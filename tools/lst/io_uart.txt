; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\io_uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\io_uart.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\lib\CMSIS\Include -I..\lib\Device\Nuvoton\NUC029xGE\Include -I..\lib\StdDriver\inc -I..\src\core\include -I..\src\driver\include -I..\src\io\include -I..\src\global -I..\src\server\include -I..\src\driver\audio -D__UVISION_VERSION=522 --omf_browse=.\obj\io_uart.crf ..\src\io\io_uart.c]
                          THUMB

                          AREA ||i.Debug_Uart_Init||, CODE, READONLY, ALIGN=2

                  Debug_Uart_Init PROC
;;;344    /*---------------------------------------------------------------------------------------------------------*/
;;;345    int32_t Debug_Uart_Init(void)
000000  b510              PUSH     {r4,lr}
;;;346    {
;;;347    	printf("debug uart init!\n");
000002  a005              ADR      r0,|L1.24|
000004  f7fffffe          BL       __2printf
;;;348        /* Init UART0 for printf and test */
;;;349        UART0_Init();
000008  f7fffffe          BL       UART0_Init
;;;350    	
;;;351        /* Enable UART RDA Interrupt */
;;;352        UART_EnableInt(UART0, UART_INTEN_RDAIEN_Msk );
00000c  2101              MOVS     r1,#1
00000e  4807              LDR      r0,|L1.44|
000010  f7fffffe          BL       UART_EnableInt
;;;353    
;;;354    
;;;355        return 0;
000014  2000              MOVS     r0,#0
;;;356    }
000016  bd10              POP      {r4,pc}
;;;357    
                          ENDP

                  |L1.24|
000018  64656275          DCB      "debug uart init!\n",0
00001c  67207561
000020  72742069
000024  6e697421
000028  0a00    
00002a  00                DCB      0
00002b  00                DCB      0
                  |L1.44|
                          DCD      0x40050000

                          AREA ||i.Hal_Uart2_Read||, CODE, READONLY, ALIGN=2

                  Hal_Uart2_Read PROC
;;;428     */
;;;429    int32_t Hal_Uart2_Read(uint8_t *dst, uint16_t len)
000000  b530              PUSH     {r4,r5,lr}
;;;430    {
;;;431     //   uint8_t  temp1, temp2;
;;;432     //   int32_t  temp3;
;;;433     	int i;
;;;434    
;;;435        if((dst == NULL) || (len == 0))
000002  2800              CMP      r0,#0
000004  d005              BEQ      |L2.18|
000006  2900              CMP      r1,#0
000008  d003              BEQ      |L2.18|
;;;436        {
;;;437            return -1;
;;;438        }
;;;439    
;;;440        //while(uart2_data.rx_ok == 0)
;;;441        //{
;;;442        //;
;;;443        //}
;;;444    #if 0
;;;445        /* wait while data in buff is less than len */
;;;446        do
;;;447        {
;;;448            temp1 = uart2_data.rx_head;
;;;449            temp2 = (temp1 <= uart2_data.rx_tail) ? (uart2_data.rx_tail - temp1) : (uart2_data.rx_tail + UART2_TX_BUFF_LEN - temp1);
;;;450        }
;;;451        while(temp2 < len);
;;;452    
;;;453        temp3 = 0;
;;;454        while(temp2)
;;;455        {
;;;456            dst[temp3] = uart2_data.rx_buff[temp1];
;;;457            temp1++;
;;;458            temp2--;
;;;459            temp3++;
;;;460    
;;;461            if(temp1 >= UART2_RX_BUFF_LEN)
;;;462            {
;;;463                temp1 = temp1 - UART2_RX_BUFF_LEN;
;;;464            }
;;;465    
;;;466            uart2_data.rx_head = temp1;
;;;467        }
;;;468    #endif
;;;469    
;;;470    	for(i = 0; i<=len; i++)
00000a  2200              MOVS     r2,#0
00000c  4613              MOV      r3,r2
;;;471    	{
;;;472    		dst[i] =uart2_get_data[i];
00000e  4c07              LDR      r4,|L2.44|
000010  e006              B        |L2.32|
                  |L2.18|
000012  2000              MOVS     r0,#0                 ;437
000014  43c0              MVNS     r0,r0                 ;437
;;;473    		uart2_get_data[i] = 0;
;;;474    	}
;;;475    	uart_counts = 0;
;;;476    /*
;;;477        for(i = 0; i<=len; i++)
;;;478        {
;;;479            dst[i] = uart2_data.rx_buff[i];
;;;480        }
;;;481    
;;;482    
;;;483        uart2_data.rx_ok = 0;
;;;484        uart2_data.rx_head = 0;
;;;485        uart2_data.rx_tail = 0;
;;;486        UART_EnableInt(UART2, (UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk));
;;;487    */
;;;488        return 0;//temp3;
;;;489    }
000016  bd30              POP      {r4,r5,pc}
                  |L2.24|
000018  5ca5              LDRB     r5,[r4,r2]            ;472
00001a  5485              STRB     r5,[r0,r2]            ;472
00001c  54a3              STRB     r3,[r4,r2]            ;473
00001e  1c52              ADDS     r2,r2,#1              ;473
                  |L2.32|
000020  428a              CMP      r2,r1                 ;470
000022  ddf9              BLE      |L2.24|
000024  4802              LDR      r0,|L2.48|
000026  7083              STRB     r3,[r0,#2]            ;475
000028  2000              MOVS     r0,#0                 ;488
00002a  bd30              POP      {r4,r5,pc}
;;;490    
                          ENDP

                  |L2.44|
                          DCD      ||.bss||+0x400
                  |L2.48|
                          DCD      ||.data||

                          AREA ||i.Hal_Uart2_Write||, CODE, READONLY, ALIGN=2

                  Hal_Uart2_Write PROC
;;;365     */
;;;366    int32_t Hal_Uart2_Write(uint8_t *src, uint16_t len)
000000  b5f8              PUSH     {r3-r7,lr}
;;;367    {
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;368    //    uint8_t  temp1, temp2;
;;;369        int32_t  temp3;
;;;370    #if 0
;;;371        if((src == NULL) || (len == 0))
;;;372        {
;;;373            return -1;
;;;374        }
;;;375    
;;;376        /* wait for the last tx */
;;;377        while(uart2_data.tx_ok == 0)
;;;378        {
;;;379            ;
;;;380        }
;;;381    
;;;382        /* write to buffer */
;;;383        temp1 = (UART2_TX_BUFF_LEN >= len) ? len : UART2_TX_BUFF_LEN;
;;;384        temp3 = 0;
;;;385    
;;;386        while(temp1)
;;;387        {
;;;388            temp2 = uart2_data.tx_tail;
;;;389            uart2_data.tx_buff[temp2] = src[temp3];
;;;390            temp2++;
;;;391            temp3++;
;;;392            temp1--;
;;;393    
;;;394            if(temp2 >= UART2_TX_BUFF_LEN)
;;;395            {
;;;396                temp2 = temp2 - UART2_TX_BUFF_LEN;
;;;397            }
;;;398    
;;;399            uart2_data.tx_tail = temp2;
;;;400        }
;;;401    
;;;402        uart2_data.tx_ok = 0;
;;;403        UART_EnableInt(UART2, UART_INTEN_THREIEN_Msk);
;;;404    
;;;405        /* wait for the finish */
;;;406        while(uart2_data.tx_ok == 0)
;;;407        {
;;;408            ;
;;;409        }
;;;410    #endif
;;;411    	for(temp3 = 0; temp3 < len; temp3++)
000006  2400              MOVS     r4,#0
;;;412    	{
;;;413    		UART_WRITE(UART2, src[temp3]);
000008  4f06              LDR      r7,|L3.36|
00000a  e007              B        |L3.28|
                  |L3.12|
00000c  5d30              LDRB     r0,[r6,r4]
00000e  6038              STR      r0,[r7,#0]
;;;414    		TIMER_Delay(TIMER0, 2000);
000010  217d              MOVS     r1,#0x7d
000012  0109              LSLS     r1,r1,#4
000014  4804              LDR      r0,|L3.40|
000016  f7fffffe          BL       TIMER_Delay
00001a  1c64              ADDS     r4,r4,#1
                  |L3.28|
00001c  42ac              CMP      r4,r5                 ;411
00001e  dbf5              BLT      |L3.12|
;;;415    		//printf("UART_WRITE: %x \n",src[temp3]);
;;;416    	}
;;;417        return temp3;
000020  4620              MOV      r0,r4
;;;418    }
000022  bdf8              POP      {r3-r7,pc}
;;;419    
                          ENDP

                  |L3.36|
                          DCD      0x40154000
                  |L3.40|
                          DCD      0x40010000

                          AREA ||i.Transfer_Uart_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  Transfer_Uart_Init PROC
;;;322    /*---------------------------------------------------------------------------------------------------------*/
;;;323    int32_t Transfer_Uart_Init(void)
000000  b510              PUSH     {r4,lr}
;;;324    {
;;;325    	printf("transfer uart init!\n");
000002  a00c              ADR      r0,|L4.52|
000004  f7fffffe          BL       __2printf
;;;326        /* Init UART0 for printf and test */
;;;327        UART1_Init();
000008  f7fffffe          BL       UART1_Init
;;;328    
;;;329        /* Init UART0 for printf and test */
;;;330        UART2_Init();
00000c  f7fffffe          BL       UART2_Init
;;;331    	
;;;332        printf("\n\nCPU @ %d Hz\n", SystemCoreClock);
000010  480e              LDR      r0,|L4.76|
000012  6801              LDR      r1,[r0,#0]  ; SystemCoreClock
000014  a00e              ADR      r0,|L4.80|
000016  f7fffffe          BL       __2printf
;;;333        printf("\nUART Sample Program\n");
00001a  a011              ADR      r0,|L4.96|
00001c  f7fffffe          BL       __2printf
;;;334    	
;;;335        /* Enable UART1 UART2 RDA Interrupt */
;;;336    	UART_EnableInt(UART2, UART_INTEN_RDAIEN_Msk );
000020  2101              MOVS     r1,#1
000022  4815              LDR      r0,|L4.120|
000024  f7fffffe          BL       UART_EnableInt
;;;337    	UART_EnableInt(UART1, UART_INTEN_RDAIEN_Msk );
000028  2101              MOVS     r1,#1
00002a  4814              LDR      r0,|L4.124|
00002c  f7fffffe          BL       UART_EnableInt
;;;338    
;;;339        return 0;
000030  2000              MOVS     r0,#0
;;;340    }
000032  bd10              POP      {r4,pc}
;;;341    
                          ENDP

                  |L4.52|
000034  7472616e          DCB      "transfer uart init!\n",0
000038  73666572
00003c  20756172
000040  7420696e
000044  6974210a
000048  00      
000049  00                DCB      0
00004a  00                DCB      0
00004b  00                DCB      0
                  |L4.76|
                          DCD      SystemCoreClock
                  |L4.80|
000050  0a0a4350          DCB      "\n\nCPU @ %d Hz\n",0
000054  55204020
000058  25642048
00005c  7a0a00  
00005f  00                DCB      0
                  |L4.96|
000060  0a554152          DCB      "\nUART Sample Program\n",0
000064  54205361
000068  6d706c65
00006c  2050726f
000070  6772616d
000074  0a00    
000076  00                DCB      0
000077  00                DCB      0
                  |L4.120|
                          DCD      0x40154000
                  |L4.124|
                          DCD      0x40150000

                          AREA ||i.UART02_IRQHandler||, CODE, READONLY, ALIGN=1

                  UART02_IRQHandler PROC
;;;304    /*---------------------------------------------------------------------------------------------------------*/
;;;305    void UART02_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;306    {
;;;307        UART_TEST_HANDLE();
000002  f7fffffe          BL       UART_TEST_HANDLE
;;;308    }
000006  bd10              POP      {r4,pc}
;;;309    
                          ENDP


                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                  UART0_Init PROC
;;;74     
;;;75     void UART0_Init()
000000  2005              MOVS     r0,#5
;;;76     {
;;;77         /* Reset UART0 */
;;;78         SYS->IPRST1 |=  SYS_IPRST1_UART0RST_Msk;
000002  0700              LSLS     r0,r0,#28
000004  68c2              LDR      r2,[r0,#0xc]
000006  2101              MOVS     r1,#1
000008  0409              LSLS     r1,r1,#16
00000a  430a              ORRS     r2,r2,r1
00000c  60c2              STR      r2,[r0,#0xc]
;;;79         SYS->IPRST1 &= ~SYS_IPRST1_UART0RST_Msk;
00000e  68c2              LDR      r2,[r0,#0xc]
000010  438a              BICS     r2,r2,r1
000012  60c2              STR      r2,[r0,#0xc]
;;;80     
;;;81         /* Configure UART0 and set UART0 baud rate */
;;;82         UART0->BAUD = UART_BAUD_MODE2 | UART_BAUD_MODE2_DIVIDER(__HXT, 115200);
000014  4803              LDR      r0,|L6.36|
000016  4902              LDR      r1,|L6.32|
000018  6241              STR      r1,[r0,#0x24]
;;;83         UART0->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
00001a  2103              MOVS     r1,#3
00001c  60c1              STR      r1,[r0,#0xc]
;;;84     }
00001e  4770              BX       lr
;;;85     
                          ENDP

                  |L6.32|
                          DCD      0x30000066
                  |L6.36|
                          DCD      0x40050000

                          AREA ||i.UART1_IRQHandler||, CODE, READONLY, ALIGN=1

                  UART1_IRQHandler PROC
;;;313    /*---------------------------------------------------------------------------------------------------------*/
;;;314    void UART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;315    {
;;;316        UART_4G_HANDLE();
000002  f7fffffe          BL       UART_4G_HANDLE
;;;317    }
000006  bd10              POP      {r4,pc}
;;;318    
                          ENDP


                          AREA ||i.UART1_Init||, CODE, READONLY, ALIGN=2

                  UART1_Init PROC
;;;85     
;;;86     void UART1_Init()
000000  2005              MOVS     r0,#5
;;;87     {
;;;88         /* Reset UART1 */
;;;89         SYS->IPRST1 |=  SYS_IPRST1_UART1RST_Msk;
000002  0700              LSLS     r0,r0,#28
000004  68c2              LDR      r2,[r0,#0xc]
000006  2101              MOVS     r1,#1
000008  0449              LSLS     r1,r1,#17
00000a  430a              ORRS     r2,r2,r1
00000c  60c2              STR      r2,[r0,#0xc]
;;;90         SYS->IPRST1 &= ~SYS_IPRST1_UART1RST_Msk;
00000e  68c2              LDR      r2,[r0,#0xc]
000010  438a              BICS     r2,r2,r1
000012  60c2              STR      r2,[r0,#0xc]
;;;91     
;;;92         /* Configure UART0 and set UART0 baud rate */
;;;93         UART1->BAUD = UART_BAUD_MODE2 | UART_BAUD_MODE2_DIVIDER(__HXT, 19200);
000014  4803              LDR      r0,|L8.36|
000016  4902              LDR      r1,|L8.32|
000018  6241              STR      r1,[r0,#0x24]
;;;94         UART1->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
00001a  2103              MOVS     r1,#3
00001c  60c1              STR      r1,[r0,#0xc]
;;;95     }
00001e  4770              BX       lr
;;;96     
                          ENDP

                  |L8.32|
                          DCD      0x3000026f
                  |L8.36|
                          DCD      0x40150000

                          AREA ||i.UART2_Init||, CODE, READONLY, ALIGN=2

                  UART2_Init PROC
;;;96     
;;;97     void UART2_Init()
000000  2005              MOVS     r0,#5
;;;98     {
;;;99         /* Reset UART0 */
;;;100        SYS->IPRST1 |=  SYS_IPRST1_UART2RST_Msk;
000002  0700              LSLS     r0,r0,#28
000004  68c2              LDR      r2,[r0,#0xc]
000006  2101              MOVS     r1,#1
000008  0489              LSLS     r1,r1,#18
00000a  430a              ORRS     r2,r2,r1
00000c  60c2              STR      r2,[r0,#0xc]
;;;101        SYS->IPRST1 &= ~SYS_IPRST1_UART2RST_Msk;
00000e  68c2              LDR      r2,[r0,#0xc]
000010  438a              BICS     r2,r2,r1
000012  60c2              STR      r2,[r0,#0xc]
;;;102    
;;;103        /* Configure UART0 and set UART0 baud rate */
;;;104        UART2->BAUD = UART_BAUD_MODE2 | UART_BAUD_MODE2_DIVIDER(__HXT, 115200);
000014  4808              LDR      r0,|L9.56|
000016  4907              LDR      r1,|L9.52|
000018  6241              STR      r1,[r0,#0x24]
;;;105        UART2->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
00001a  2103              MOVS     r1,#3
00001c  60c1              STR      r1,[r0,#0xc]
00001e  4807              LDR      r0,|L9.60|
000020  2100              MOVS     r1,#0
000022  7581              STRB     r1,[r0,#0x16]
000024  7601              STRB     r1,[r0,#0x18]
000026  7681              STRB     r1,[r0,#0x1a]
000028  75c1              STRB     r1,[r0,#0x17]
00002a  7641              STRB     r1,[r0,#0x19]
00002c  2101              MOVS     r1,#1
00002e  76c1              STRB     r1,[r0,#0x1b]
;;;106    	Hal_Uart2_Data_Init();
;;;107    }
000030  4770              BX       lr
;;;108    
                          ENDP

000032  0000              DCW      0x0000
                  |L9.52|
                          DCD      0x30000066
                  |L9.56|
                          DCD      0x40154000
                  |L9.60|
                          DCD      ||.bss||+0x556

                          AREA ||i.UART_4G_HANDLE||, CODE, READONLY, ALIGN=2

                  UART_4G_HANDLE PROC
;;;212    /*---------------------------------------------------------------------------------------------------------*/
;;;213    void UART_4G_HANDLE(void)
000000  b570              PUSH     {r4-r6,lr}
;;;214    {
;;;215        uint8_t u8InChar = 0xFF;
;;;216    	static uint8_t nRxIndex=0;
;;;217    	
;;;218    	UART_ClearIntFlag(UART1, UART_INTEN_RDAIEN_Msk);
000002  4c23              LDR      r4,|L10.144|
000004  2101              MOVS     r1,#1
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       UART_ClearIntFlag
;;;219    
;;;220    	if(UART_IS_RX_READY(UART1))
00000c  69e1              LDR      r1,[r4,#0x1c]
00000e  07c9              LSLS     r1,r1,#31
000010  d00f              BEQ      |L10.50|
;;;221        {
;;;222    	    u8InChar = UART_READ(UART1);
000012  6820              LDR      r0,[r4,#0]
;;;223    //		u8InChar = UUART_WRITE(UUART0,u8InChar);
;;;224    		switch (nRxIndex)
000014  4c1f              LDR      r4,|L10.148|
000016  b2c0              UXTB     r0,r0                 ;222
000018  78e2              LDRB     r2,[r4,#3]  ; nRxIndex
00001a  2500              MOVS     r5,#0
00001c  2101              MOVS     r1,#1                 ;218
00001e  0013              MOVS     r3,r2
000020  f7fffffe          BL       __ARM_common_switch8
000024  0805080f          DCB      0x08,0x05,0x08,0x0f
000028  161a1d20          DCB      0x16,0x1a,0x1d,0x20
00002c  2725              DCB      0x27,0x25
;;;225    		{
;;;226    			case 0: 
;;;227    				
;;;228    				if(u8InChar==0xff) nRxIndex=1;
00002e  28ff              CMP      r0,#0xff
000030  d02b              BEQ      |L10.138|
                  |L10.50|
;;;229    				break;
;;;230    				
;;;231    			case 1: 
;;;232    				if(u8InChar==0x55) nRxIndex=2;
;;;233    				else
;;;234    				{
;;;235    					if(u8InChar==0xff) nRxIndex=1;
;;;236    					else 
;;;237    						nRxIndex=0;
;;;238    				}
;;;239    				break;
;;;240    
;;;241    			case 2: 
;;;242    				if(u8InChar==0x04) nRxIndex=3;
;;;243    				else
;;;244    				{
;;;245    					if(u8InChar==0xff) nRxIndex=1;
;;;246    					else 
;;;247    						nRxIndex=0;
;;;248    				}
;;;249    				break;
;;;250    				
;;;251    			case 3: 
;;;252    				if(u8InChar==0x80) nRxIndex=4;
;;;253    				else
;;;254    				{
;;;255    					if(u8InChar==0xff) nRxIndex=1;
;;;256    					else 
;;;257    						nRxIndex=0;
;;;258    				}
;;;259    				break;
;;;260    			
;;;261    			case 4:  
;;;262    				uart1_cmd = u8InChar;
;;;263    				
;;;264    				nRxIndex=5;
;;;265    				break;	
;;;266    				
;;;267    			case 5:
;;;268    				uart1_dat = u8InChar;
;;;269    				
;;;270    				nRxIndex=6;
;;;271    				break;
;;;272    				
;;;273    			case 6:  
;;;274    				if(u8InChar==0x00) nRxIndex=7;
;;;275    				else
;;;276    				{
;;;277    					if(u8InChar==0xff) nRxIndex=1;
;;;278    					else 
;;;279    						nRxIndex=0;
;;;280    				}
;;;281    				break;	
;;;282    				
;;;283    			case 7:
;;;284    				if(u8InChar==0xff) nRxIndex=1;
;;;285    				else 
;;;286    				{
;;;287    					Core_Msg_Send(MSG_4G_SYS_STATE_IND, uart1_cmd ,uart1_dat,0);
;;;288    					uart1_cmd = 0xFF;
;;;289    					uart1_dat = 0xFF;
;;;290    					nRxIndex=0;
;;;291    				}
;;;292    				break;
;;;293    					
;;;294    			default:
;;;295    				nRxIndex=0;
;;;296    				break;
;;;297    		} 
;;;298    	}
;;;299    
;;;300    }
000032  bd70              POP      {r4-r6,pc}
000034  2855              CMP      r0,#0x55              ;232
000036  d002              BEQ      |L10.62|
000038  28ff              CMP      r0,#0xff              ;235
00003a  d0fa              BEQ      |L10.50|
00003c  e017              B        |L10.110|
                  |L10.62|
00003e  2002              MOVS     r0,#2                 ;232
000040  e013              B        |L10.106|
000042  2804              CMP      r0,#4                 ;242
000044  d101              BNE      |L10.74|
000046  2003              MOVS     r0,#3                 ;242
000048  e00f              B        |L10.106|
                  |L10.74|
00004a  28ff              CMP      r0,#0xff              ;245
00004c  d01d              BEQ      |L10.138|
00004e  e00e              B        |L10.110|
000050  2880              CMP      r0,#0x80              ;252
000052  d1fa              BNE      |L10.74|
000054  2004              MOVS     r0,#4                 ;252
000056  e008              B        |L10.106|
000058  7020              STRB     r0,[r4,#0]            ;262
00005a  2005              MOVS     r0,#5                 ;264
00005c  e005              B        |L10.106|
00005e  7060              STRB     r0,[r4,#1]            ;268
000060  2006              MOVS     r0,#6                 ;270
000062  e002              B        |L10.106|
000064  2800              CMP      r0,#0                 ;274
000066  d1f0              BNE      |L10.74|
000068  2007              MOVS     r0,#7                 ;274
                  |L10.106|
00006a  70e0              STRB     r0,[r4,#3]            ;274
00006c  bd70              POP      {r4-r6,pc}
                  |L10.110|
00006e  70e5              STRB     r5,[r4,#3]            ;279
000070  bd70              POP      {r4-r6,pc}
000072  28ff              CMP      r0,#0xff              ;284
000074  d009              BEQ      |L10.138|
000076  7862              LDRB     r2,[r4,#1]            ;287  ; uart1_dat
000078  2300              MOVS     r3,#0                 ;287
00007a  7821              LDRB     r1,[r4,#0]            ;287  ; uart1_cmd
00007c  2001              MOVS     r0,#1                 ;287
00007e  f7fffffe          BL       Core_Msg_Send
000082  20ff              MOVS     r0,#0xff              ;288
000084  7020              STRB     r0,[r4,#0]            ;288
000086  7060              STRB     r0,[r4,#1]            ;289
000088  e7f1              B        |L10.110|
                  |L10.138|
00008a  70e1              STRB     r1,[r4,#3]            ;284
00008c  bd70              POP      {r4-r6,pc}
;;;301    
                          ENDP

00008e  0000              DCW      0x0000
                  |L10.144|
                          DCD      0x40150000
                  |L10.148|
                          DCD      ||.data||

                          AREA ||i.UART_TEST_HANDLE||, CODE, READONLY, ALIGN=2

                  UART_TEST_HANDLE PROC
;;;111    /*---------------------------------------------------------------------------------------------------------*/
;;;112    void UART_TEST_HANDLE()
000000  b570              PUSH     {r4-r6,lr}
;;;113    {
;;;114        uint8_t u8InChar = 0xFF;	
;;;115    	//static uint8_t nRxIndex=0;
;;;116      //  uint8_t  temp1, temp2, cnt;
;;;117    	
;;;118        //uint32_t u32IntSts = UART0->INTSTS;
;;;119    	UART_ClearIntFlag(UART0, UART_INTEN_RDAIEN_Msk);
000002  4e1d              LDR      r6,|L11.120|
000004  2101              MOVS     r1,#1
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       UART_ClearIntFlag
;;;120    	UART_ClearIntFlag(UART2, UART_INTEN_RDAIEN_Msk);
00000c  4c1b              LDR      r4,|L11.124|
00000e  2101              MOVS     r1,#1
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       UART_ClearIntFlag
;;;121    //  printf("\nuart02_Input:");
;;;122        /* Get all the input characters */
;;;123    	 if(UART_IS_RX_READY(UART0))
000016  69f0              LDR      r0,[r6,#0x1c]
000018  2500              MOVS     r5,#0
00001a  07c0              LSLS     r0,r0,#31
;;;124        {
;;;125            /* Get the character from UART Buffer */
;;;126            u8InChar = UART_READ(UART0);
;;;127    //        printf("\nUART0_READ = %x ", u8InChar);
;;;128    //		UART_WRITE(UART2,u8InChar);
;;;129    //		UART_WRITE(UART0,u8InChar);
;;;130    
;;;131            if(u8InChar == '0')
;;;132            {
;;;133                g_bWait = FALSE;
00001c  4b18              LDR      r3,|L11.128|
00001e  2800              CMP      r0,#0                 ;123
000020  d018              BEQ      |L11.84|
000022  6830              LDR      r0,[r6,#0]            ;126
000024  b2c0              UXTB     r0,r0                 ;126
000026  2830              CMP      r0,#0x30              ;131
000028  d100              BNE      |L11.44|
00002a  60dd              STR      r5,[r3,#0xc]  ; g_bWait
                  |L11.44|
;;;134            }
;;;135    
;;;136            /* Check if buffer full */
;;;137            if(g_u32comRbytes < RXBUFSIZE)
00002c  6859              LDR      r1,[r3,#4]  ; g_u32comRbytes
00002e  2201              MOVS     r2,#1
000030  0292              LSLS     r2,r2,#10
000032  4291              CMP      r1,r2
000034  d20e              BCS      |L11.84|
;;;138            {
;;;139                /* Enqueue the character */
;;;140                g_u8RecData[g_u32comRtail] = u8InChar;
000036  4913              LDR      r1,|L11.132|
000038  689a              LDR      r2,[r3,#8]  ; g_u32comRtail
00003a  5488              STRB     r0,[r1,r2]
;;;141                g_u32comRtail = (g_u32comRtail == (RXBUFSIZE - 1)) ? 0 : (g_u32comRtail + 1);
00003c  6898              LDR      r0,[r3,#8]  ; g_u32comRtail
00003e  4912              LDR      r1,|L11.136|
000040  4288              CMP      r0,r1
000042  d101              BNE      |L11.72|
000044  2000              MOVS     r0,#0
000046  e001              B        |L11.76|
                  |L11.72|
000048  6898              LDR      r0,[r3,#8]  ; g_u32comRtail
00004a  1c40              ADDS     r0,r0,#1
                  |L11.76|
00004c  6098              STR      r0,[r3,#8]  ; g_u32comRtail
;;;142                g_u32comRbytes++;
00004e  6858              LDR      r0,[r3,#4]  ; g_u32comRbytes
000050  1c40              ADDS     r0,r0,#1
000052  6058              STR      r0,[r3,#4]  ; g_u32comRbytes
                  |L11.84|
;;;143            }
;;;144        }
;;;145    	 
;;;146    
;;;147        /* check int reg */
;;;148        if((UART2 -> INTSTS) & UART_INTSTS_RDAINT_Msk)
000054  69e0              LDR      r0,[r4,#0x1c]
000056  05c0              LSLS     r0,r0,#23
000058  d50d              BPL      |L11.118|
;;;149        {
;;;150            /* Get all the input characters */
;;;151            while(UART_IS_RX_READY(UART2))
;;;152        	{
;;;153    			uart2_get_data[uart_counts] = UART_READ(UART2);
00005a  4a0c              LDR      r2,|L11.140|
                  |L11.92|
00005c  69e0              LDR      r0,[r4,#0x1c]         ;151
00005e  07c0              LSLS     r0,r0,#31             ;151
000060  d009              BEQ      |L11.118|
000062  6820              LDR      r0,[r4,#0]
000064  7899              LDRB     r1,[r3,#2]  ; uart_counts
000066  5450              STRB     r0,[r2,r1]
000068  1c49              ADDS     r1,r1,#1
;;;154    			uart_counts++;
00006a  b2c8              UXTB     r0,r1
00006c  7098              STRB     r0,[r3,#2]
;;;155    			if (uart_counts > 140)
00006e  288c              CMP      r0,#0x8c
000070  d9f4              BLS      |L11.92|
;;;156    				uart_counts = 0;
000072  709d              STRB     r5,[r3,#2]
000074  e7f2              B        |L11.92|
                  |L11.118|
;;;157        	}
;;;158    		/*
;;;159            {
;;;160                temp1 = uart2_data.rx_tail;
;;;161                uart2_data.rx_buff[temp1] = UART_READ(UART2);
;;;162    			//printf("\nuart2_data.rx_buff[%x] = %x ",temp1, uart2_data.rx_buff[temp1]);
;;;163                temp1++;
;;;164    
;;;165                if(temp1 >= UART2_RX_BUFF_LEN)
;;;166                {
;;;167                    temp1 = temp1 - UART2_RX_BUFF_LEN;
;;;168                }
;;;169    
;;;170                uart2_data.rx_tail = temp1;
;;;171            }
;;;172            */
;;;173        }
;;;174    #if 0
;;;175        if((UART2 -> INTSTS) & UART_INTSTS_THREINT_Msk)
;;;176        {
;;;177            /* write data */
;;;178            cnt = uart2_data.tx_head;
;;;179            cnt = (uart2_data.tx_tail >= cnt) ? (uart2_data.tx_tail - cnt) : (uart2_data.tx_tail + UART2_TX_BUFF_LEN - cnt);
;;;180    
;;;181            while((!UART_IS_TX_FULL(UART2)) && cnt)
;;;182            {
;;;183                temp1 = uart2_data.tx_head;
;;;184                temp2 = uart2_data.tx_buff[temp1];
;;;185                UART_WRITE(UART2, temp2);
;;;186                temp1++;
;;;187    
;;;188                if(temp1 >= UART2_TX_BUFF_LEN)
;;;189                {
;;;190                    temp1 = temp1 - UART2_TX_BUFF_LEN;
;;;191                }
;;;192    
;;;193                uart2_data.tx_head = temp1;
;;;194                cnt --;
;;;195    
;;;196                if(cnt == 0)
;;;197                {
;;;198                    /* when all tx bytes are in buffer, tx should be ok */
;;;199                    uart2_data.tx_ok = 1;
;;;200                    UART_DisableInt(UART2, UART_INTEN_THREIEN_Msk);
;;;201                    /* now we should listen for the rx */
;;;202                    UART_EnableInt(UART2, (UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk));
;;;203                }
;;;204            }
;;;205        }    
;;;206    #endif
;;;207      //  printf("\nuart02Transmission Test:");
;;;208    }
000076  bd70              POP      {r4-r6,pc}
;;;209    
                          ENDP

                  |L11.120|
                          DCD      0x40050000
                  |L11.124|
                          DCD      0x40154000
                  |L11.128|
                          DCD      ||.data||
                  |L11.132|
                          DCD      ||.bss||
                  |L11.136|
                          DCD      0x000003ff
                  |L11.140|
                          DCD      ||.bss||+0x400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_u8RecData
                          %        1024
                  uart2_get_data
                          %        150
                  uart2_data
                          %        220

                          AREA ||.data||, DATA, ALIGN=2

                  uart1_cmd
000000  ff                DCB      0xff
                  uart1_dat
000001  ff                DCB      0xff
                  uart_counts
000002  00                DCB      0x00
                  nRxIndex
000003  00                DCB      0x00
                  g_u32comRbytes
                          DCD      0x00000000
                  g_u32comRtail
                          DCD      0x00000000
                  g_bWait
                          DCD      0x00000001

                          AREA ||area_number.16||, DATA, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.data||
                  g_u32comRhead
                          DCD      0x00000000

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L76.16|
00000e  461d              MOV      r5,r3
                  |L76.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\src\\io\\io_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_io_uart_c_a80fc96b____REV16|
#line 388 "..\\lib\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_io_uart_c_a80fc96b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_io_uart_c_a80fc96b____REVSH|
#line 402
|__asm___9_io_uart_c_a80fc96b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
