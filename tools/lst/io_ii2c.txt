; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\io_ii2c.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\io_ii2c.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\lib\CMSIS\Include -I..\lib\Device\Nuvoton\NUC029xGE\Include -I..\lib\StdDriver\inc -I..\src\core\include -I..\src\driver\include -I..\src\io\include -I..\src\global -I..\src\server\include -I..\src\driver\audio -D__UVISION_VERSION=522 --omf_browse=.\obj\io_ii2c.crf ..\src\io\io_ii2c.c]
                          THUMB

                          AREA ||i.I2CCheckACK||, CODE, READONLY, ALIGN=2

                  I2CCheckACK PROC
;;;261    
;;;262    bool I2CCheckACK(void)  
000000  b5f8              PUSH     {r3-r7,lr}
;;;263    
;;;264    {  
;;;265    	uint8_t outtime;
;;;266    //	I2C_SDA=0;
;;;267    	
;;;268    	I2C_SDA=1; // 准备接收应答信号
000002  4d14              LDR      r5,|L1.84|
000004  2601              MOVS     r6,#1
000006  616e              STR      r6,[r5,#0x14]
;;;269    	
;;;270    	GPIO_SetMode(PB, BIT5, GPIO_MODE_INPUT);
000008  4f13              LDR      r7,|L1.88|
00000a  2200              MOVS     r2,#0
00000c  2120              MOVS     r1,#0x20
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       GPIO_SetMode
;;;271    
;;;272    	I2CDelay();
000014  f7fffffe          BL       I2CDelay
;;;273    	
;;;274    	I2C_SCL=1; // 开始接受应答信号
000018  4630              MOV      r0,r6
00001a  4e0e              LDR      r6,|L1.84|
00001c  3680              ADDS     r6,r6,#0x80
00001e  62b0              STR      r0,[r6,#0x28]
;;;275    	
;;;276    	GPIO_SetMode(PB, BIT5, GPIO_MODE_INPUT);
000020  2200              MOVS     r2,#0
000022  2120              MOVS     r1,#0x20
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       GPIO_SetMode
;;;277    	
;;;278    	while ( I2C_SDA ) // 超时判断
00002a  e00a              B        |L1.66|
                  |L1.44|
;;;279    	{
;;;280    		I2CDelay();  
00002c  f7fffffe          BL       I2CDelay
;;;281    		if ( ( outtime++ )>250 ) // 不能接收到应答信号，停止IIC通讯，返回0值报错
000030  4620              MOV      r0,r4
000032  1c64              ADDS     r4,r4,#1
000034  b2e4              UXTB     r4,r4
000036  28fa              CMP      r0,#0xfa
000038  d903              BLS      |L1.66|
;;;282    		{
;;;283    			outtime=0;
;;;284    			I2CStop();
00003a  f7fffffe          BL       I2CStop
;;;285    			return 0;
00003e  2000              MOVS     r0,#0
;;;286    		}
;;;287    	}
;;;288    	
;;;289    	nop();
;;;290    	outtime=0;
;;;291    	I2C_SCL=0;
;;;292    	return  1; // 发送完毕，返回1值，通讯成功
;;;293    
;;;294    }  
000040  bdf8              POP      {r3-r7,pc}
                  |L1.66|
000042  6968              LDR      r0,[r5,#0x14]         ;278
000044  2800              CMP      r0,#0                 ;278
000046  d1f1              BNE      |L1.44|
000048  f7fffffe          BL       nop
00004c  2000              MOVS     r0,#0                 ;291
00004e  62b0              STR      r0,[r6,#0x28]         ;291
000050  2001              MOVS     r0,#1                 ;292
000052  bdf8              POP      {r3-r7,pc}
;;;295    
                          ENDP

                  |L1.84|
                          DCD      0x50004240
                  |L1.88|
                          DCD      0x50004040

                          AREA ||i.I2CDelay||, CODE, READONLY, ALIGN=2

                  I2CDelay PROC
;;;80     
;;;81     static void I2CDelay(void)  
000000  b510              PUSH     {r4,lr}
;;;82     
;;;83     {  
;;;84     
;;;85         TIMER_Delay(TIMER0, 10);	//delay 100us
000002  210a              MOVS     r1,#0xa
000004  4801              LDR      r0,|L2.12|
000006  f7fffffe          BL       TIMER_Delay
;;;86     
;;;87     }  
00000a  bd10              POP      {r4,pc}
;;;88     
                          ENDP

                  |L2.12|
                          DCD      0x40010000

                          AREA ||i.I2CFree||, CODE, READONLY, ALIGN=2

                  I2CFree PROC
;;;169    
;;;170    void I2CFree(void)  
000000  b510              PUSH     {r4,lr}
;;;171    {  
;;;172    
;;;173    
;;;174        I2C_SDA = 1;  
000002  4805              LDR      r0,|L3.24|
000004  2401              MOVS     r4,#1
000006  6144              STR      r4,[r0,#0x14]
;;;175    
;;;176        I2CDelay();  
000008  f7fffffe          BL       I2CDelay
;;;177    
;;;178        I2C_SCL = 1;  
00000c  4802              LDR      r0,|L3.24|
00000e  3080              ADDS     r0,r0,#0x80
000010  6284              STR      r4,[r0,#0x28]
;;;179    
;;;180        I2CDelay();  
000012  f7fffffe          BL       I2CDelay
;;;181    
;;;182    }  
000016  bd10              POP      {r4,pc}
;;;183    
                          ENDP

                  |L3.24|
                          DCD      0x50004240

                          AREA ||i.I2CReceiveByte||, CODE, READONLY, ALIGN=2

                  I2CReceiveByte PROC
;;;348    
;;;349    uint8_t I2CReceiveByte(void)  
000000  b5f8              PUSH     {r3-r7,lr}
;;;350    
;;;351    {     
;;;352        uint8_t serialNum = 0;  
000002  2400              MOVS     r4,#0
;;;353        uint8_t dataValue=0;  
;;;354    
;;;355        for(serialNum=0;serialNum<=7;serialNum++)  
;;;356        {  
;;;357    
;;;358            I2C_SCL=1;  
000004  4f0c              LDR      r7,|L4.56|
000006  4625              MOV      r5,r4                 ;353
000008  2601              MOVS     r6,#1
                  |L4.10|
00000a  62be              STR      r6,[r7,#0x28]
;;;359    
;;;360            I2CDelay();  
00000c  f7fffffe          BL       I2CDelay
;;;361    
;;;362            if(I2C_SDA) 
000010  4809              LDR      r0,|L4.56|
000012  3880              SUBS     r0,r0,#0x80
000014  6940              LDR      r0,[r0,#0x14]
000016  2800              CMP      r0,#0
000018  d004              BEQ      |L4.36|
;;;363            {
;;;364    			dataValue =dataValue | (1 >> (7 - serialNum)) ;
00001a  2007              MOVS     r0,#7
00001c  1b01              SUBS     r1,r0,r4
00001e  4630              MOV      r0,r6
000020  40c8              LSRS     r0,r0,r1
000022  4305              ORRS     r5,r5,r0
                  |L4.36|
;;;365            }
;;;366    
;;;367            I2C_SCL=0;  
000024  2000              MOVS     r0,#0
000026  62b8              STR      r0,[r7,#0x28]
;;;368    
;;;369            I2CDelay();  
000028  f7fffffe          BL       I2CDelay
00002c  1c64              ADDS     r4,r4,#1
00002e  b2e4              UXTB     r4,r4                 ;355
000030  2c07              CMP      r4,#7                 ;355
000032  d9ea              BLS      |L4.10|
;;;370    
;;;371        }  
;;;372    
;;;373      
;;;374    
;;;375        return dataValue;  
000034  4628              MOV      r0,r5
;;;376    
;;;377    }  
000036  bdf8              POP      {r3-r7,pc}
;;;378      
                          ENDP

                  |L4.56|
                          DCD      0x500042c0

                          AREA ||i.I2CSendACK||, CODE, READONLY, ALIGN=2

                  I2CSendACK PROC
;;;195    
;;;196    void I2CSendACK(void)  
000000  b570              PUSH     {r4-r6,lr}
;;;197    {  
;;;198    
;;;199        I2C_SCL=0;  
000002  4c09              LDR      r4,|L5.40|
000004  2500              MOVS     r5,#0
000006  62a5              STR      r5,[r4,#0x28]
;;;200    
;;;201        I2CDelay();  
000008  f7fffffe          BL       I2CDelay
;;;202    
;;;203        I2C_SDA=0;  
00000c  4806              LDR      r0,|L5.40|
00000e  3880              SUBS     r0,r0,#0x80
000010  6145              STR      r5,[r0,#0x14]
;;;204    
;;;205        I2CDelay();  
000012  f7fffffe          BL       I2CDelay
;;;206    
;;;207        I2C_SCL=1;  
000016  2001              MOVS     r0,#1
000018  62a0              STR      r0,[r4,#0x28]
;;;208    
;;;209        I2CDelay();  
00001a  f7fffffe          BL       I2CDelay
;;;210    
;;;211        I2C_SCL=0;  
00001e  62a5              STR      r5,[r4,#0x28]
;;;212    
;;;213        I2CDelay();  
000020  f7fffffe          BL       I2CDelay
;;;214    
;;;215    }  
000024  bd70              POP      {r4-r6,pc}
;;;216    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      0x500042c0

                          AREA ||i.I2CSendByte||, CODE, READONLY, ALIGN=2

                  I2CSendByte PROC
;;;307    
;;;308    void I2CSendByte(uint8_t    sendData)  
000000  b5f8              PUSH     {r3-r7,lr}
;;;309    
;;;310    {  
;;;311    
;;;312        uint8_t serialNum = 0;  
000002  2400              MOVS     r4,#0
;;;313    
;;;314        for(serialNum = 0 ;serialNum < 8; serialNum++)   //以MSB方式按位发送一个字节数据  
;;;315        {  
;;;316            I2C_SCL = 0;
000004  4d10              LDR      r5,|L6.72|
000006  4607              MOV      r7,r0                 ;310
000008  4626              MOV      r6,r4                 ;312
                  |L6.10|
00000a  62ae              STR      r6,[r5,#0x28]
;;;317    		
;;;318            I2CDelay();  
00000c  f7fffffe          BL       I2CDelay
;;;319    		
;;;320    		GPIO_SetMode(PB, BIT5, GPIO_MODE_OUTPUT);
000010  2201              MOVS     r2,#1
000012  2120              MOVS     r1,#0x20
000014  480d              LDR      r0,|L6.76|
000016  f7fffffe          BL       GPIO_SetMode
;;;321    		
;;;322            I2C_SDA = (sendData>>(7 - serialNum))&0x01;  
00001a  2007              MOVS     r0,#7
00001c  1b00              SUBS     r0,r0,r4
00001e  4639              MOV      r1,r7
000020  40c1              LSRS     r1,r1,r0
000022  4809              LDR      r0,|L6.72|
000024  07c9              LSLS     r1,r1,#31
000026  0fc9              LSRS     r1,r1,#31
000028  3880              SUBS     r0,r0,#0x80
00002a  6141              STR      r1,[r0,#0x14]
;;;323    
;;;324            I2CDelay();  
00002c  f7fffffe          BL       I2CDelay
;;;325    
;;;326            I2C_SCL = 1;  
000030  2001              MOVS     r0,#1
000032  62a8              STR      r0,[r5,#0x28]
;;;327    
;;;328            I2CDelay();  
000034  f7fffffe          BL       I2CDelay
;;;329    
;;;330            I2C_SCL = 0;  
000038  62ae              STR      r6,[r5,#0x28]
;;;331    
;;;332            I2CDelay();  
00003a  f7fffffe          BL       I2CDelay
00003e  1c64              ADDS     r4,r4,#1
000040  b2e4              UXTB     r4,r4                 ;314
000042  2c08              CMP      r4,#8                 ;314
000044  d3e1              BCC      |L6.10|
;;;333    
;;;334        }  
;;;335    }  
000046  bdf8              POP      {r3-r7,pc}
;;;336    
                          ENDP

                  |L6.72|
                          DCD      0x500042c0
                  |L6.76|
                          DCD      0x50004040

                          AREA ||i.I2CSendNoACK||, CODE, READONLY, ALIGN=2

                  I2CSendNoACK PROC
;;;228    
;;;229    void I2CSendNoACK(void)  
000000  b570              PUSH     {r4-r6,lr}
;;;230    {  
;;;231    
;;;232        I2C_SCL=0;  
000002  4c08              LDR      r4,|L7.36|
000004  2600              MOVS     r6,#0
000006  62a6              STR      r6,[r4,#0x28]
;;;233    
;;;234        I2CDelay();  
000008  f7fffffe          BL       I2CDelay
;;;235    
;;;236        I2C_SDA=1;  
00000c  4805              LDR      r0,|L7.36|
00000e  2501              MOVS     r5,#1
000010  3880              SUBS     r0,r0,#0x80
000012  6145              STR      r5,[r0,#0x14]
;;;237    
;;;238        I2CDelay();  
000014  f7fffffe          BL       I2CDelay
;;;239    
;;;240        I2C_SCL=1;  
000018  62a5              STR      r5,[r4,#0x28]
;;;241    
;;;242        I2CDelay();  
00001a  f7fffffe          BL       I2CDelay
;;;243    
;;;244        I2C_SCL=0;  
00001e  62a6              STR      r6,[r4,#0x28]
;;;245    
;;;246        //I2CDelay();  
;;;247    
;;;248    }  
000020  bd70              POP      {r4-r6,pc}
;;;249    
                          ENDP

000022  0000              DCW      0x0000
                  |L7.36|
                          DCD      0x500042c0

                          AREA ||i.I2CStart||, CODE, READONLY, ALIGN=2

                  I2CStart PROC
;;;102    
;;;103    void I2CStart(void)  
000000  b570              PUSH     {r4-r6,lr}
;;;104    {  
;;;105    
;;;106        I2C_SCL=1;  
000002  4d09              LDR      r5,|L8.40|
000004  2401              MOVS     r4,#1
000006  62ac              STR      r4,[r5,#0x28]
;;;107    
;;;108        I2CDelay();  
000008  f7fffffe          BL       I2CDelay
;;;109    
;;;110        I2C_SDA=1;  
00000c  4e06              LDR      r6,|L8.40|
00000e  3e80              SUBS     r6,r6,#0x80
000010  6174              STR      r4,[r6,#0x14]
;;;111    
;;;112        I2CDelay();  
000012  f7fffffe          BL       I2CDelay
;;;113    
;;;114        I2C_SDA=0;  
000016  2400              MOVS     r4,#0
000018  6174              STR      r4,[r6,#0x14]
;;;115    
;;;116        I2CDelay();  
00001a  f7fffffe          BL       I2CDelay
;;;117    
;;;118        I2C_SCL=0;  
00001e  62ac              STR      r4,[r5,#0x28]
;;;119    
;;;120        I2CDelay();  
000020  f7fffffe          BL       I2CDelay
;;;121    
;;;122    }  
000024  bd70              POP      {r4-r6,pc}
;;;123    
                          ENDP

000026  0000              DCW      0x0000
                  |L8.40|
                          DCD      0x500042c0

                          AREA ||i.I2CStop||, CODE, READONLY, ALIGN=2

                  I2CStop PROC
;;;135    
;;;136    void I2CStop(void)  
000000  b570              PUSH     {r4-r6,lr}
;;;137    {  
;;;138    
;;;139        I2CDelay();  
000002  f7fffffe          BL       I2CDelay
;;;140    
;;;141        I2C_SCL = 0;  
000006  4d08              LDR      r5,|L9.40|
000008  2400              MOVS     r4,#0
00000a  62ac              STR      r4,[r5,#0x28]
;;;142    
;;;143        I2CDelay();  
00000c  f7fffffe          BL       I2CDelay
;;;144    
;;;145        I2C_SDA = 0;  
000010  4e05              LDR      r6,|L9.40|
000012  3e80              SUBS     r6,r6,#0x80
000014  6174              STR      r4,[r6,#0x14]
;;;146    
;;;147        I2CDelay();  
000016  f7fffffe          BL       I2CDelay
;;;148    
;;;149        I2C_SDA = 1;  
00001a  2401              MOVS     r4,#1
00001c  6174              STR      r4,[r6,#0x14]
;;;150    
;;;151        I2CDelay();  
00001e  f7fffffe          BL       I2CDelay
;;;152    
;;;153        I2C_SCL = 1;  
000022  62ac              STR      r4,[r5,#0x28]
;;;154    
;;;155    
;;;156    }  
000024  bd70              POP      {r4-r6,pc}
;;;157    
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      0x500042c0

                          AREA ||i.Slave24C04Read||, CODE, READONLY, ALIGN=1

                  Slave24C04Read PROC
;;;443    
;;;444    void Slave24C04Read(uint8_t     tarAddress,uint8_t rdNumber,uint8_t* rdPointer)  
000000  b570              PUSH     {r4-r6,lr}
;;;445    
;;;446    {  
000002  4615              MOV      r5,r2
000004  460c              MOV      r4,r1
000006  4606              MOV      r6,r0
;;;447    
;;;448    
;;;449        I2CStart();  
000008  f7fffffe          BL       I2CStart
;;;450    
;;;451        I2CSendByte(SLAVE_ADDRESS);   //发送24C04的器件地址  
00000c  2080              MOVS     r0,#0x80
00000e  f7fffffe          BL       I2CSendByte
;;;452    
;;;453        if(!I2CCheckACK()) 
000012  f7fffffe          BL       I2CCheckACK
000016  2800              CMP      r0,#0
000018  d021              BEQ      |L10.94|
;;;454    		return;
;;;455    
;;;456        I2CSendByte(tarAddress);   //发送读取数据的起始地址  
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       I2CSendByte
;;;457    
;;;458        if(!I2CCheckACK()) 
000020  f7fffffe          BL       I2CCheckACK
000024  2800              CMP      r0,#0
000026  d01a              BEQ      |L10.94|
;;;459    		return;
;;;460    
;;;461        I2CStart();  
000028  f7fffffe          BL       I2CStart
;;;462    
;;;463        I2CSendByte(SLAVE_ADDRESS+1);  //发送24C04的器件地址，地址LSB最后一位为1代表读取  
00002c  2081              MOVS     r0,#0x81
00002e  f7fffffe          BL       I2CSendByte
;;;464    
;;;465        if(!I2CCheckACK()) 
000032  f7fffffe          BL       I2CCheckACK
000036  2800              CMP      r0,#0
000038  d011              BEQ      |L10.94|
00003a  e00c              B        |L10.86|
                  |L10.60|
;;;466    		return;
;;;467    
;;;468      
;;;469    
;;;470        for(;rdNumber!=0;rdNumber--,rdPointer++)  
;;;471    
;;;472        {  
;;;473    
;;;474            *rdPointer=I2CReceiveByte();   //按字节读取数据  
00003c  f7fffffe          BL       I2CReceiveByte
000040  7028              STRB     r0,[r5,#0]
;;;475    
;;;476      
;;;477    
;;;478            if(rdNumber!=1)  
000042  2c01              CMP      r4,#1
000044  d002              BEQ      |L10.76|
;;;479    
;;;480                I2CSendACK();  
000046  f7fffffe          BL       I2CSendACK
00004a  e001              B        |L10.80|
                  |L10.76|
;;;481    
;;;482            else  
;;;483    
;;;484                I2CSendNoACK();  
00004c  f7fffffe          BL       I2CSendNoACK
                  |L10.80|
000050  1e64              SUBS     r4,r4,#1
000052  b2e4              UXTB     r4,r4                 ;470
000054  1c6d              ADDS     r5,r5,#1              ;470
                  |L10.86|
000056  2c00              CMP      r4,#0                 ;470
000058  d1f0              BNE      |L10.60|
;;;485    
;;;486        }  
;;;487    
;;;488      
;;;489    
;;;490        I2CStop();  
00005a  f7fffffe          BL       I2CStop
                  |L10.94|
;;;491    
;;;492    }  
00005e  bd70              POP      {r4-r6,pc}
;;;493    
                          ENDP


                          AREA ||i.Slave24C04Write||, CODE, READONLY, ALIGN=1

                  Slave24C04Write PROC
;;;395    
;;;396    void Slave24C04Write(uint8_t     tarAddress, uint8_t wrdata1, uint8_t wrdata2)  
000000  b570              PUSH     {r4-r6,lr}
;;;397    
;;;398    {  
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;399    
;;;400        I2CStart();  
000008  f7fffffe          BL       I2CStart
;;;401    
;;;402        I2CSendByte(SLAVE_ADDRESS);   //发送24C04的器件地址，地址LSB最后一位为0代表写入，1代表读取  
00000c  2080              MOVS     r0,#0x80
00000e  f7fffffe          BL       I2CSendByte
;;;403    
;;;404        if(!I2CCheckACK()) 
000012  f7fffffe          BL       I2CCheckACK
000016  2800              CMP      r0,#0
000018  d012              BEQ      |L11.64|
;;;405    		goto wrfalse;
;;;406    
;;;407        I2CSendByte(tarAddress);   //发送写入数据的起始地址  
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       I2CSendByte
;;;408    
;;;409        if(!I2CCheckACK())
000020  f7fffffe          BL       I2CCheckACK
000024  2800              CMP      r0,#0
000026  d00b              BEQ      |L11.64|
;;;410    		goto wrfalse;
;;;411    
;;;412        I2CSendByte(wrdata1);   //按字节写入数据  
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       I2CSendByte
;;;413    
;;;414    	if(!I2CCheckACK())
00002e  f7fffffe          BL       I2CCheckACK
000032  2800              CMP      r0,#0
000034  d004              BEQ      |L11.64|
;;;415    		goto wrfalse;
;;;416    
;;;417        I2CSendByte(wrdata2);   //按字节写入数据  
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       I2CSendByte
;;;418    
;;;419    	if(!I2CCheckACK())
00003c  f7fffffe          BL       I2CCheckACK
                  |L11.64|
;;;420    		goto wrfalse;
;;;421    	
;;;422    wrfalse:
;;;423    
;;;424        I2CStop();  
000040  f7fffffe          BL       I2CStop
;;;425    
;;;426    }  
000044  bd70              POP      {r4-r6,pc}
;;;427    
                          ENDP


                          AREA ||i.io2w_init||, CODE, READONLY, ALIGN=2

                  io2w_init PROC
;;;495    
;;;496    void io2w_init(void)
000000  b510              PUSH     {r4,lr}
;;;497    {
;;;498    	
;;;499    //	GPIO_SetMode(PB, BIT5, GPIO_MODE_QUASI);	
;;;500    	GPIO_SetMode(PB, BIT5, GPIO_MODE_OUTPUT);	
000002  2201              MOVS     r2,#1
000004  2120              MOVS     r1,#0x20
000006  4808              LDR      r0,|L12.40|
000008  f7fffffe          BL       GPIO_SetMode
;;;501    	GPIO_SetMode(PD, BIT10, GPIO_MODE_OUTPUT);
00000c  4806              LDR      r0,|L12.40|
00000e  2201              MOVS     r2,#1
000010  0291              LSLS     r1,r2,#10
000012  3080              ADDS     r0,r0,#0x80
000014  f7fffffe          BL       GPIO_SetMode
;;;502    	
;;;503    	PB5 = 1;  //reset pin
000018  4904              LDR      r1,|L12.44|
00001a  2001              MOVS     r0,#1
00001c  6148              STR      r0,[r1,#0x14]
;;;504    	PD10 = 1;  // 1:tx, 0:rx
00001e  4903              LDR      r1,|L12.44|
000020  3180              ADDS     r1,r1,#0x80
000022  6288              STR      r0,[r1,#0x28]
;;;505    
;;;506    }
000024  bd10              POP      {r4,pc}
;;;507    
                          ENDP

000026  0000              DCW      0x0000
                  |L12.40|
                          DCD      0x50004040
                  |L12.44|
                          DCD      0x50004240

                          AREA ||i.nop||, CODE, READONLY, ALIGN=2

                  nop PROC
;;;62       
;;;63     void nop(void)
000000  b510              PUSH     {r4,lr}
;;;64     {
;;;65         TIMER_Delay(TIMER0, 10);	//delay 100us
000002  210a              MOVS     r1,#0xa
000004  4801              LDR      r0,|L13.12|
000006  f7fffffe          BL       TIMER_Delay
;;;66     }
00000a  bd10              POP      {r4,pc}
;;;67       
                          ENDP

                  |L13.12|
                          DCD      0x40010000

;*** Start embedded assembler ***

#line 1 "..\\src\\io\\io_ii2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_io_ii2c_c_nop____REV16|
#line 388 "..\\lib\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_io_ii2c_c_nop____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_io_ii2c_c_nop____REVSH|
#line 402
|__asm___9_io_ii2c_c_nop____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
