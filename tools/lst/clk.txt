; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\lib\CMSIS\Include -I..\lib\Device\Nuvoton\NUC029xGE\Include -I..\lib\StdDriver\inc -I..\src\core\include -I..\src\driver\include -I..\src\io\include -I..\src\global -I..\src\server\include -I..\src\driver\audio -D__UVISION_VERSION=522 --omf_browse=.\obj\clk.crf ..\lib\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;30       */
;;;31     void CLK_DisableCKO(void)
000000  4802              LDR      r0,|L1.12|
;;;32     {
;;;33         /* Disable CKO clock source */
;;;34         CLK->APBCLK0 &= (~CLK_APBCLK0_CLKOCKEN_Msk);
000002  6881              LDR      r1,[r0,#8]
000004  2240              MOVS     r2,#0x40
000006  4391              BICS     r1,r1,r2
000008  6081              STR      r1,[r0,#8]
;;;35     }
00000a  4770              BX       lr
;;;36     
                          ENDP

                  |L1.12|
                          DCD      0x50000200

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;527      */
;;;528    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  b50e              PUSH     {r1-r3,lr}
;;;529    {
;;;530        uint32_t u32ClkTbl[3] = {0x0, 0x4, 0x2C};
000002  4909              LDR      r1,|L2.40|
000004  c90e              LDM      r1,{r1-r3}
;;;531    
;;;532        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (u32ClkTbl[MODULE_APBCLK(u32ModuleIdx)]))  &= ~(1 << MODULE_IP_EN_Pos(u32ModuleIdx));
000006  9100              STR      r1,[sp,#0]
000008  9201              STR      r2,[sp,#4]
00000a  0f81              LSRS     r1,r0,#30
00000c  008a              LSLS     r2,r1,#2
00000e  9302              STR      r3,[sp,#8]
000010  4669              MOV      r1,sp
000012  588a              LDR      r2,[r1,r2]
000014  4905              LDR      r1,|L2.44|
000016  1851              ADDS     r1,r2,r1
000018  684a              LDR      r2,[r1,#4]
00001a  06c3              LSLS     r3,r0,#27
00001c  0edb              LSRS     r3,r3,#27
00001e  2001              MOVS     r0,#1
000020  4098              LSLS     r0,r0,r3
000022  4382              BICS     r2,r2,r0
000024  604a              STR      r2,[r1,#4]
;;;533    }
000026  bd0e              POP      {r1-r3,pc}
;;;534    
                          ENDP

                  |L2.40|
                          DCD      ||.constdata||+0x24
                  |L2.44|
                          DCD      0x50000200

                          AREA ||i.CLK_DisablePLL||, CODE, READONLY, ALIGN=2

                  CLK_DisablePLL PROC
;;;669      */
;;;670    void CLK_DisablePLL(void)
000000  4802              LDR      r0,|L3.12|
;;;671    {
;;;672        CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
000002  6a01              LDR      r1,[r0,#0x20]
000004  01c2              LSLS     r2,r0,#7
000006  4311              ORRS     r1,r1,r2
000008  6201              STR      r1,[r0,#0x20]
;;;673    }
00000a  4770              BX       lr
;;;674    
                          ENDP

                  |L3.12|
                          DCD      0x50000200

                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_DisableSysTick PROC
;;;741      */
;;;742    void CLK_DisableSysTick(void)
000000  4901              LDR      r1,|L4.8|
;;;743    {
;;;744        /* Set System Tick counter disabled */
;;;745        SysTick->CTRL = 0;
000002  2000              MOVS     r0,#0
000004  6108              STR      r0,[r1,#0x10]
;;;746    }
000006  4770              BX       lr
;;;747    
                          ENDP

                  |L4.8|
                          DCD      0xe000e000

                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_DisableXtalRC PROC
;;;439      */
;;;440    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L5.12|
;;;441    {
;;;442        CLK->PWRCTL &= ~u32ClkMask;
000002  680a              LDR      r2,[r1,#0]
000004  4382              BICS     r2,r2,r0
000006  600a              STR      r2,[r1,#0]
;;;443    }
000008  4770              BX       lr
;;;444    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;56       */
;;;57     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
000000  0152              LSLS     r2,r2,#5
;;;58     {
;;;59         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;60         CLK->CLKOCTL = CLK_CLKOCTL_CLKOEN_Msk | u32ClkDiv | (u32ClkDivBy1En << CLK_CLKOCTL_DIV1EN_Pos);
000002  430a              ORRS     r2,r2,r1
000004  2110              MOVS     r1,#0x10
000006  430a              ORRS     r2,r2,r1
000008  4905              LDR      r1,|L6.32|
00000a  624a              STR      r2,[r1,#0x24]
;;;61     
;;;62         /* Enable CKO clock source */
;;;63         CLK->APBCLK0 |= CLK_APBCLK0_CLKOCKEN_Msk;
00000c  688a              LDR      r2,[r1,#8]
00000e  2340              MOVS     r3,#0x40
000010  431a              ORRS     r2,r2,r3
000012  608a              STR      r2,[r1,#8]
;;;64     
;;;65         /* Select CKO clock source */
;;;66         CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_CLKOSEL_Msk)) | (u32ClkSrc);
000014  69ca              LDR      r2,[r1,#0x1c]
000016  231c              MOVS     r3,#0x1c
000018  439a              BICS     r2,r2,r3
00001a  4302              ORRS     r2,r2,r0
00001c  61ca              STR      r2,[r1,#0x1c]
;;;67     
;;;68     }
00001e  4770              BX       lr
;;;69     
                          ENDP

                  |L6.32|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;482      */
;;;483    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  b50e              PUSH     {r1-r3,lr}
;;;484    {
;;;485        uint32_t u32ClkTbl[3] = {0x0, 0x4, 0x2C};
000002  4909              LDR      r1,|L7.40|
000004  c90e              LDM      r1,{r1-r3}
;;;486    
;;;487        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (u32ClkTbl[MODULE_APBCLK(u32ModuleIdx)]))  |= 1 << MODULE_IP_EN_Pos(u32ModuleIdx);
000006  9100              STR      r1,[sp,#0]
000008  9201              STR      r2,[sp,#4]
00000a  0f81              LSRS     r1,r0,#30
00000c  008a              LSLS     r2,r1,#2
00000e  9302              STR      r3,[sp,#8]
000010  4669              MOV      r1,sp
000012  588a              LDR      r2,[r1,r2]
000014  4905              LDR      r1,|L7.44|
000016  1851              ADDS     r1,r2,r1
000018  684a              LDR      r2,[r1,#4]
00001a  06c3              LSLS     r3,r0,#27
00001c  0edb              LSRS     r3,r3,#27
00001e  2001              MOVS     r0,#1
000020  4098              LSLS     r0,r0,r3
000022  4302              ORRS     r2,r2,r0
000024  604a              STR      r2,[r1,#4]
;;;488    }
000026  bd0e              POP      {r1-r3,pc}
;;;489    
                          ENDP

                  |L7.40|
                          DCD      ||.constdata||+0x18
                  |L7.44|
                          DCD      0x50000200

                          AREA ||i.CLK_EnablePLL||, CODE, READONLY, ALIGN=2

                  CLK_EnablePLL PROC
;;;545      */
;;;546    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000000  b5f0              PUSH     {r4-r7,lr}
;;;547    {
000002  b085              SUB      sp,sp,#0x14
000004  460c              MOV      r4,r1
000006  4607              MOV      r7,r0
;;;548        uint32_t u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC;
;;;549        uint32_t u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR;
;;;550    
;;;551        /* Disable PLL first to avoid unstable when setting PLL */
;;;552        CLK_DisablePLL();
000008  f7fffffe          BL       CLK_DisablePLL
;;;553    
;;;554        /* PLL source clock is from HXT */
;;;555        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;556        {
;;;557            /* Enable HXT clock */
;;;558            CLK->PWRCTL |= CLK_PWRCTL_HXTEN_Msk;
;;;559    
;;;560            /* Wait for HXT clock ready */
;;;561            CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;562    
;;;563            /* Select PLL source clock from HXT */
;;;564            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HXT;
;;;565            u32PllSrcClk = __HXT;
;;;566    
;;;567            /* u32NR start from 2 */
;;;568            u32NR = 2;
;;;569        }
;;;570    
;;;571        /* PLL source clock is from HIRC */
;;;572        else
;;;573        {
;;;574            /* Enable HIRC clock */
;;;575            CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00000c  4855              LDR      r0,|L8.356|
00000e  4e54              LDR      r6,|L8.352|
000010  6801              LDR      r1,[r0,#0]
000012  2f00              CMP      r7,#0                 ;555
000014  d013              BEQ      |L8.62|
000016  2204              MOVS     r2,#4
000018  4311              ORRS     r1,r1,r2
00001a  6001              STR      r1,[r0,#0]
;;;576    
;;;577            /* Wait for HIRC clock ready */
;;;578            CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;579    
;;;580            /* Select PLL source clock from HIRC */
;;;581            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HIRC;
000022  2001              MOVS     r0,#1
000024  04c0              LSLS     r0,r0,#19
;;;582            u32PllSrcClk = __HIRC;
000026  9002              STR      r0,[sp,#8]
000028  484f              LDR      r0,|L8.360|
;;;583    
;;;584            /* u32NR start from 4 when FIN = 22.1184MHz to avoid calculation overflow */
;;;585            u32NR = 4;
00002a  2504              MOVS     r5,#4
00002c  9003              STR      r0,[sp,#0xc]
                  |L8.46|
;;;586        }
;;;587    
;;;588        /* Select "NO" according to request frequency */
;;;589        if((u32PllFreq <= FREQ_200MHZ) && (u32PllFreq > FREQ_100MHZ))
00002e  484f              LDR      r0,|L8.364|
000030  494f              LDR      r1,|L8.368|
000032  1820              ADDS     r0,r4,r0
000034  4288              CMP      r0,r1
000036  d80d              BHI      |L8.84|
;;;590        {
;;;591            u32NO = 0;
000038  2000              MOVS     r0,#0
00003a  9004              STR      r0,[sp,#0x10]
00003c  e01c              B        |L8.120|
                  |L8.62|
00003e  2201              MOVS     r2,#1                 ;558
000040  4311              ORRS     r1,r1,r2              ;558
000042  6001              STR      r1,[r0,#0]            ;558
000044  4610              MOV      r0,r2                 ;561
000046  f7fffffe          BL       CLK_WaitClockReady
00004a  2000              MOVS     r0,#0                 ;564
00004c  2502              MOVS     r5,#2                 ;568
00004e  9603              STR      r6,[sp,#0xc]          ;568
000050  9002              STR      r0,[sp,#8]            ;568
000052  e7ec              B        |L8.46|
                  |L8.84|
;;;592        }
;;;593        else if((u32PllFreq <= FREQ_100MHZ) && (u32PllFreq > FREQ_50MHZ))
000054  4847              LDR      r0,|L8.372|
000056  4948              LDR      r1,|L8.376|
000058  1820              ADDS     r0,r4,r0
00005a  4288              CMP      r0,r1
00005c  d803              BHI      |L8.102|
;;;594        {
;;;595            u32NO = 1;
00005e  2001              MOVS     r0,#1
;;;596            u32PllFreq = u32PllFreq << 1;
000060  0064              LSLS     r4,r4,#1
000062  9004              STR      r0,[sp,#0x10]
000064  e008              B        |L8.120|
                  |L8.102|
;;;597        }
;;;598        else if((u32PllFreq <= FREQ_50MHZ) && (u32PllFreq >= FREQ_25MHZ))
000066  4845              LDR      r0,|L8.380|
000068  4944              LDR      r1,|L8.380|
00006a  1820              ADDS     r0,r4,r0
00006c  4249              RSBS     r1,r1,#0
00006e  4288              CMP      r0,r1
000070  d849              BHI      |L8.262|
;;;599        {
;;;600            u32NO = 3;
000072  2003              MOVS     r0,#3
;;;601            u32PllFreq = u32PllFreq << 2;
000074  00a4              LSLS     r4,r4,#2
000076  9004              STR      r0,[sp,#0x10]
                  |L8.120|
;;;602        }
;;;603        else
;;;604        {
;;;605            /* Wrong frequency request. Just return default setting. */
;;;606            goto lexit;
;;;607        }
;;;608    
;;;609        /* Find best solution */
;;;610        u32Min = (uint32_t) - 1;
000078  2600              MOVS     r6,#0
00007a  43f6              MVNS     r6,r6
;;;611        u32MinNR = 0;
00007c  2000              MOVS     r0,#0
;;;612        u32MinNF = 0;
00007e  9000              STR      r0,[sp,#0]
;;;613        for(; u32NR <= 33; u32NR++)
000080  9001              STR      r0,[sp,#4]
000082  e021              B        |L8.200|
                  |L8.132|
;;;614        {
;;;615            u32Tmp = u32PllSrcClk / u32NR;
000084  4629              MOV      r1,r5
000086  9803              LDR      r0,[sp,#0xc]
000088  f7fffffe          BL       __aeabi_uidivmod
;;;616            if((u32Tmp > 1600000) && (u32Tmp < 16000000))
00008c  493c              LDR      r1,|L8.384|
00008e  4a3d              LDR      r2,|L8.388|
000090  1841              ADDS     r1,r0,r1
000092  4291              CMP      r1,r2
000094  d217              BCS      |L8.198|
;;;617            {
;;;618                for(u32NF = 2; u32NF <= 513; u32NF++)
000096  2202              MOVS     r2,#2
                  |L8.152|
;;;619                {
;;;620                    u32Tmp2 = u32Tmp * u32NF;
;;;621                    if((u32Tmp2 >= 100000000) && (u32Tmp2 <= 200000000))
000098  4b34              LDR      r3,|L8.364|
00009a  4601              MOV      r1,r0                 ;618
00009c  4351              MULS     r1,r2,r1              ;620
00009e  1c5b              ADDS     r3,r3,#1
0000a0  18cf              ADDS     r7,r1,r3
0000a2  425b              RSBS     r3,r3,#0
0000a4  429f              CMP      r7,r3
0000a6  d80a              BHI      |L8.190|
;;;622                    {
;;;623                        u32Tmp3 = (u32Tmp2 > u32PllFreq) ? u32Tmp2 - u32PllFreq : u32PllFreq - u32Tmp2;
0000a8  42a1              CMP      r1,r4
0000aa  d901              BLS      |L8.176|
0000ac  1b0b              SUBS     r3,r1,r4
0000ae  e000              B        |L8.178|
                  |L8.176|
0000b0  1a63              SUBS     r3,r4,r1
                  |L8.178|
;;;624                        if(u32Tmp3 < u32Min)
0000b2  42b3              CMP      r3,r6
0000b4  d203              BCS      |L8.190|
;;;625                        {
;;;626                            u32Min = u32Tmp3;
0000b6  001e              MOVS     r6,r3
;;;627                            u32MinNR = u32NR;
;;;628                            u32MinNF = u32NF;
;;;629    
;;;630                            /* Break when get good results */
;;;631                            if(u32Min == 0)
0000b8  9500              STR      r5,[sp,#0]
0000ba  9201              STR      r2,[sp,#4]
0000bc  d003              BEQ      |L8.198|
                  |L8.190|
0000be  4932              LDR      r1,|L8.392|
0000c0  1c52              ADDS     r2,r2,#1              ;618
0000c2  428a              CMP      r2,r1                 ;618
0000c4  d9e8              BLS      |L8.152|
                  |L8.198|
0000c6  1c6d              ADDS     r5,r5,#1              ;618
                  |L8.200|
0000c8  2d21              CMP      r5,#0x21              ;613
0000ca  d9db              BLS      |L8.132|
;;;632                                break;
;;;633                        }
;;;634                    }
;;;635                }
;;;636            }
;;;637        }
;;;638    
;;;639        /* Enable and apply new PLL setting. */
;;;640        CLK->PLLCTL = u32CLK_SRC | (u32NO << 14) | ((u32MinNR - 2) << 9) | (u32MinNF - 2);
0000cc  9804              LDR      r0,[sp,#0x10]
0000ce  9902              LDR      r1,[sp,#8]
0000d0  0380              LSLS     r0,r0,#14
0000d2  4308              ORRS     r0,r0,r1
0000d4  9900              LDR      r1,[sp,#0]
0000d6  2201              MOVS     r2,#1
0000d8  0249              LSLS     r1,r1,#9
0000da  0292              LSLS     r2,r2,#10
0000dc  1a89              SUBS     r1,r1,r2
0000de  4308              ORRS     r0,r0,r1
0000e0  9901              LDR      r1,[sp,#4]
0000e2  1e89              SUBS     r1,r1,#2
0000e4  4308              ORRS     r0,r0,r1
0000e6  491f              LDR      r1,|L8.356|
0000e8  6208              STR      r0,[r1,#0x20]
;;;641    
;;;642        /* Wait for PLL clock stable */
;;;643        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
0000ea  2004              MOVS     r0,#4
0000ec  f7fffffe          BL       CLK_WaitClockReady
;;;644    
;;;645        /* Return actual PLL output clock frequency */
;;;646        return u32PllSrcClk / ((u32NO + 1) * u32MinNR) * u32MinNF;
0000f0  9904              LDR      r1,[sp,#0x10]
0000f2  9800              LDR      r0,[sp,#0]
0000f4  1c49              ADDS     r1,r1,#1
0000f6  4341              MULS     r1,r0,r1
0000f8  9803              LDR      r0,[sp,#0xc]
0000fa  f7fffffe          BL       __aeabi_uidivmod
0000fe  9901              LDR      r1,[sp,#4]
000100  4348              MULS     r0,r1,r0
                  |L8.258|
;;;647    
;;;648    lexit:
;;;649    
;;;650        /* Apply default PLL setting and return */
;;;651        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;652            CLK->PLLCTL = CLK_PLLCTL_72MHz_HXT; /* 72MHz */
;;;653        else
;;;654            CLK->PLLCTL = CLK_PLLCTL_72MHz_HIRC; /* 71.8848MHz */
;;;655    
;;;656        /* Wait for PLL clock stable */
;;;657        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;658    
;;;659        return CLK_GetPLLClockFreq();
;;;660    
;;;661    }
000102  b005              ADD      sp,sp,#0x14
000104  bdf0              POP      {r4-r7,pc}
                  |L8.262|
000106  2f00              CMP      r7,#0                 ;651
000108  d00f              BEQ      |L8.298|
00010a  4920              LDR      r1,|L8.396|
                  |L8.268|
00010c  4815              LDR      r0,|L8.356|
00010e  6201              STR      r1,[r0,#0x20]         ;654
000110  2004              MOVS     r0,#4                 ;657
000112  f7fffffe          BL       CLK_WaitClockReady
000116  a01e              ADR      r0,|L8.400|
000118  6800              LDR      r0,[r0,#0]            ;657
00011a  9000              STR      r0,[sp,#0]            ;657
00011c  4811              LDR      r0,|L8.356|
00011e  6a01              LDR      r1,[r0,#0x20]         ;657
000120  1300              ASRS     r0,r0,#12             ;657
000122  4201              TST      r1,r0                 ;657
000124  d003              BEQ      |L8.302|
000126  2000              MOVS     r0,#0                 ;657
000128  e7eb              B        |L8.258|
                  |L8.298|
00012a  491a              LDR      r1,|L8.404|
00012c  e7ee              B        |L8.268|
                  |L8.302|
00012e  0308              LSLS     r0,r1,#12             ;652
000130  d500              BPL      |L8.308|
000132  4e0d              LDR      r6,|L8.360|
                  |L8.308|
000134  0388              LSLS     r0,r1,#14             ;652
000136  d501              BPL      |L8.316|
000138  4630              MOV      r0,r6                 ;652
00013a  e7e2              B        |L8.258|
                  |L8.316|
00013c  0408              LSLS     r0,r1,#16
00013e  0f80              LSRS     r0,r0,#30
000140  466a              MOV      r2,sp
000142  5c10              LDRB     r0,[r2,r0]
000144  05ca              LSLS     r2,r1,#23
000146  0489              LSLS     r1,r1,#18
000148  0ec9              LSRS     r1,r1,#27
00014a  1c89              ADDS     r1,r1,#2
00014c  0dd2              LSRS     r2,r2,#23
00014e  4341              MULS     r1,r0,r1
000150  08b0              LSRS     r0,r6,#2
000152  1c92              ADDS     r2,r2,#2
000154  4350              MULS     r0,r2,r0
000156  f7fffffe          BL       __aeabi_uidivmod
00015a  0080              LSLS     r0,r0,#2
00015c  e7d1              B        |L8.258|
;;;662    
                          ENDP

00015e  0000              DCW      0x0000
                  |L8.352|
                          DCD      0x00b71b00
                  |L8.356|
                          DCD      0x50000200
                  |L8.360|
                          DCD      0x01518000
                  |L8.364|
                          DCD      0xfa0a1eff
                  |L8.368|
                          DCD      0x05f5e0ff
                  |L8.372|
                          DCD      0xfd050f7f
                  |L8.376|
                          DCD      0x02faf07f
                  |L8.380|
                          DCD      0xfe8287c0
                  |L8.384|
                          DCD      0xffe795ff
                  |L8.388|
                          DCD      0x00dbb9ff
                  |L8.392|
                          DCD      0x00000201
                  |L8.396|
                          DCD      0x00084c32
                  |L8.400|
000190  01020204          DCB      1,2,2,4
                  |L8.404|
                          DCD      0x0000442e

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_EnableSysTick PROC
;;;714      */
;;;715    void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count)
000000  b570              PUSH     {r4-r6,lr}
;;;716    {
;;;717        /* Set System Tick counter disabled */
;;;718        SysTick->CTRL = 0;
000002  4a0b              LDR      r2,|L9.48|
000004  2400              MOVS     r4,#0
000006  6114              STR      r4,[r2,#0x10]
;;;719    
;;;720        /* Set System Tick clock source */
;;;721        if(u32ClkSrc == CLK_CLKSEL0_STCLKSEL_HCLK)
000008  2804              CMP      r0,#4
00000a  d00c              BEQ      |L9.38|
;;;722            SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
;;;723        else
;;;724            CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
00000c  4d09              LDR      r5,|L9.52|
00000e  692b              LDR      r3,[r5,#0x10]
000010  2638              MOVS     r6,#0x38
000012  43b3              BICS     r3,r3,r6
000014  4303              ORRS     r3,r3,r0
000016  612b              STR      r3,[r5,#0x10]
                  |L9.24|
;;;725    
;;;726        /* Set System Tick reload value */
;;;727        SysTick->LOAD = u32Count;
000018  6151              STR      r1,[r2,#0x14]
;;;728    
;;;729        /* Clear System Tick current value and counter flag */
;;;730        SysTick->VAL = 0;
00001a  6194              STR      r4,[r2,#0x18]
;;;731    
;;;732        /* Set System Tick interrupt enabled and counter enabled */
;;;733        SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;
00001c  6910              LDR      r0,[r2,#0x10]
00001e  2103              MOVS     r1,#3
000020  4308              ORRS     r0,r0,r1
000022  6110              STR      r0,[r2,#0x10]
;;;734    }
000024  bd70              POP      {r4-r6,pc}
                  |L9.38|
000026  6910              LDR      r0,[r2,#0x10]         ;722
000028  2304              MOVS     r3,#4                 ;722
00002a  4318              ORRS     r0,r0,r3              ;722
00002c  6110              STR      r0,[r2,#0x10]         ;722
00002e  e7f3              B        |L9.24|
;;;735    
                          ENDP

                  |L9.48|
                          DCD      0xe000e000
                  |L9.52|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_EnableXtalRC PROC
;;;422      */
;;;423    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L10.12|
;;;424    {
;;;425        CLK->PWRCTL |= u32ClkMask;
000002  680a              LDR      r2,[r1,#0]
000004  4302              ORRS     r2,r2,r0
000006  600a              STR      r2,[r1,#0]
;;;426    }
000008  4770              BX       lr
;;;427    
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      0x50000200

                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;183      */
;;;184    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;185    {
;;;186        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;187        return SystemCoreClock;
000006  4801              LDR      r0,|L11.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;188    }
00000a  bd10              POP      {r4,pc}
;;;189    
                          ENDP

                  |L11.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;141      */
;;;142    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;143    {
;;;144        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;145        return SystemCoreClock;
000006  4801              LDR      r0,|L12.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;146    }
00000a  bd10              POP      {r4,pc}
;;;147    
                          ENDP

                  |L12.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;113      */
;;;114    uint32_t CLK_GetHXTFreq(void)
000000  4802              LDR      r0,|L13.12|
;;;115    {
;;;116        if(CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk)
000002  6800              LDR      r0,[r0,#0]
000004  07c0              LSLS     r0,r0,#31
000006  d000              BEQ      |L13.10|
;;;117            return __HXT;
000008  4801              LDR      r0,|L13.16|
                  |L13.10|
;;;118        else
;;;119            return 0;
;;;120    }
00000a  4770              BX       lr
;;;121    
                          ENDP

                  |L13.12|
                          DCD      0x50000200
                  |L13.16|
                          DCD      0x00b71b00

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetLXTFreq PROC
;;;127      */
;;;128    uint32_t CLK_GetLXTFreq(void)
000000  4804              LDR      r0,|L14.20|
;;;129    {
;;;130        if(CLK->PWRCTL & CLK_PWRCTL_LXTEN_Msk)
000002  6800              LDR      r0,[r0,#0]
000004  0780              LSLS     r0,r0,#30
000006  d502              BPL      |L14.14|
;;;131            return __LXT;
000008  2001              MOVS     r0,#1
00000a  03c0              LSLS     r0,r0,#15
;;;132        else
;;;133            return 0;
;;;134    }
00000c  4770              BX       lr
                  |L14.14|
00000e  2000              MOVS     r0,#0                 ;133
000010  4770              BX       lr
;;;135    
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x50000200

                          AREA ||i.CLK_GetPCLK0Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK0Freq PROC
;;;153      */
;;;154    uint32_t CLK_GetPCLK0Freq(void)
000000  b510              PUSH     {r4,lr}
;;;155    {
;;;156        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;157        if(CLK->CLKSEL0 & CLK_CLKSEL0_PCLK0SEL_Msk)
000006  4804              LDR      r0,|L15.24|
000008  6900              LDR      r0,[r0,#0x10]
00000a  0641              LSLS     r1,r0,#25
;;;158            return SystemCoreClock >> 1;
00000c  4803              LDR      r0,|L15.28|
;;;159        else
;;;160            return SystemCoreClock;
00000e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000010  d500              BPL      |L15.20|
000012  0840              LSRS     r0,r0,#1              ;158
                  |L15.20|
;;;161    }
000014  bd10              POP      {r4,pc}
;;;162    
                          ENDP

000016  0000              DCW      0x0000
                  |L15.24|
                          DCD      0x50000200
                  |L15.28|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK1Freq PROC
;;;168      */
;;;169    uint32_t CLK_GetPCLK1Freq(void)
000000  b510              PUSH     {r4,lr}
;;;170    {
;;;171        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;172        if(CLK->CLKSEL0 & CLK_CLKSEL0_PCLK1SEL_Msk)
000006  4804              LDR      r0,|L16.24|
000008  6900              LDR      r0,[r0,#0x10]
00000a  0601              LSLS     r1,r0,#24
;;;173            return SystemCoreClock >> 1;
00000c  4803              LDR      r0,|L16.28|
;;;174        else
;;;175            return SystemCoreClock;
00000e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000010  d500              BPL      |L16.20|
000012  0840              LSRS     r0,r0,#1              ;173
                  |L16.20|
;;;176    }
000014  bd10              POP      {r4,pc}
;;;177    
                          ENDP

000016  0000              DCW      0x0000
                  |L16.24|
                          DCD      0x50000200
                  |L16.28|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;95       */
;;;96     void CLK_Idle(void)
000000  4805              LDR      r0,|L17.24|
;;;97     {
;;;98         /* Set the processor uses sleep as its low power mode */
;;;99         SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
000002  6901              LDR      r1,[r0,#0x10]
000004  2204              MOVS     r2,#4
000006  4391              BICS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;100    
;;;101        /* Set chip in idle mode because of WFI command */
;;;102        CLK->PWRCTL &= ~CLK_PWRCTL_PDEN_Msk;
00000a  4804              LDR      r0,|L17.28|
00000c  6801              LDR      r1,[r0,#0]
00000e  2280              MOVS     r2,#0x80
000010  4391              BICS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;103    
;;;104        /* Chip enter idle mode after CPU run WFI instruction */
;;;105        __WFI();
000014  bf30              WFI      
;;;106    }
000016  4770              BX       lr
;;;107    
                          ENDP

                  |L17.24|
                          DCD      0xe000ed00
                  |L17.28|
                          DCD      0x50000200

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;76       */
;;;77     void CLK_PowerDown(void)
000000  4805              LDR      r0,|L18.24|
;;;78     {
;;;79         /* Set the processor uses deep sleep as its low power mode */
;;;80         SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000002  6901              LDR      r1,[r0,#0x10]
000004  2204              MOVS     r2,#4
000006  4311              ORRS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;81     
;;;82         /* Set system Power-down enabled*/
;;;83         CLK->PWRCTL |= CLK_PWRCTL_PDEN_Msk;
00000a  4804              LDR      r0,|L18.28|
00000c  6801              LDR      r1,[r0,#0]
00000e  2280              MOVS     r2,#0x80
000010  4311              ORRS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;84     
;;;85         /* Chip enter Power-down mode after CPU run WFI instruction */
;;;86         __WFI();
000014  bf30              WFI      
;;;87     }
000016  4770              BX       lr
;;;88     
                          ENDP

                  |L18.24|
                          DCD      0xe000ed00
                  |L18.28|
                          DCD      0x50000200

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;198      */
;;;199    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  b5f8              PUSH     {r3-r7,lr}
;;;200    {
;;;201        uint32_t u32HIRCSTB;
;;;202    
;;;203        /* Read HIRC clock source stable flag */
;;;204        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000002  4d1c              LDR      r5,|L19.116|
000004  4604              MOV      r4,r0                 ;200
000006  68ee              LDR      r6,[r5,#0xc]
000008  2010              MOVS     r0,#0x10
00000a  4006              ANDS     r6,r6,r0
;;;205    
;;;206        /* The range of u32Hclk is 25 MHz ~ 72 MHz */
;;;207        if(u32Hclk > FREQ_72MHZ)
00000c  481a              LDR      r0,|L19.120|
00000e  4284              CMP      r4,r0
000010  d802              BHI      |L19.24|
;;;208            u32Hclk = FREQ_72MHZ;
;;;209        if(u32Hclk < FREQ_25MHZ)
000012  481a              LDR      r0,|L19.124|
000014  4284              CMP      r4,r0
000016  d200              BCS      |L19.26|
                  |L19.24|
000018  4604              MOV      r4,r0                 ;208
                  |L19.26|
;;;210            u32Hclk = FREQ_25MHZ;
;;;211    
;;;212        /* Switch HCLK clock source to HIRC clock for safe */
;;;213        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00001a  6828              LDR      r0,[r5,#0]
00001c  2704              MOVS     r7,#4
00001e  4338              ORRS     r0,r0,r7
000020  6028              STR      r0,[r5,#0]
;;;214        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000022  2010              MOVS     r0,#0x10
000024  f7fffffe          BL       CLK_WaitClockReady
;;;215        CLK->CLKSEL0 |= CLK_CLKSEL0_HCLKSEL_Msk;
000028  6928              LDR      r0,[r5,#0x10]
00002a  2107              MOVS     r1,#7
00002c  4308              ORRS     r0,r0,r1
00002e  6128              STR      r0,[r5,#0x10]
;;;216        CLK->CLKDIV0 &= (~CLK_CLKDIV0_HCLKDIV_Msk);
000030  69a8              LDR      r0,[r5,#0x18]
000032  0900              LSRS     r0,r0,#4
000034  0100              LSLS     r0,r0,#4
000036  61a8              STR      r0,[r5,#0x18]
;;;217    
;;;218        /* Configure PLL setting if HXT clock is stable */
;;;219        if(CLK->STATUS & CLK_STATUS_HXTSTB_Msk)
000038  68e8              LDR      r0,[r5,#0xc]
00003a  07c0              LSLS     r0,r0,#31
00003c  d005              BEQ      |L19.74|
;;;220            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HXT, (u32Hclk << 1));
00003e  0061              LSLS     r1,r4,#1
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       CLK_EnablePLL
000046  4604              MOV      r4,r0
000048  e008              B        |L19.92|
                  |L19.74|
;;;221    
;;;222        /* Configure PLL setting if HXT clock is not stable */
;;;223        else
;;;224        {
;;;225            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HIRC, (u32Hclk << 1));
00004a  2001              MOVS     r0,#1
00004c  0061              LSLS     r1,r4,#1
00004e  04c0              LSLS     r0,r0,#19
000050  f7fffffe          BL       CLK_EnablePLL
;;;226    
;;;227            /* Read HIRC clock source stable flag */
;;;228            u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000054  68ee              LDR      r6,[r5,#0xc]
000056  4604              MOV      r4,r0                 ;225
000058  2010              MOVS     r0,#0x10
00005a  4006              ANDS     r6,r6,r0
                  |L19.92|
;;;229        }
;;;230    
;;;231        /* Select HCLK clock source to PLL,
;;;232           Select HCLK clock source divider as 2
;;;233           and update system core clock
;;;234        */
;;;235        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(2));
00005c  2101              MOVS     r1,#1
00005e  2002              MOVS     r0,#2
000060  f7fffffe          BL       CLK_SetHCLK
;;;236    
;;;237        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;238        if(u32HIRCSTB == 0)
000064  2e00              CMP      r6,#0
000066  d102              BNE      |L19.110|
;;;239            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000068  6828              LDR      r0,[r5,#0]
00006a  43b8              BICS     r0,r0,r7
00006c  6028              STR      r0,[r5,#0]
                  |L19.110|
;;;240    
;;;241        /* Return actually HCLK frequency is PLL frequency divide 2 */
;;;242        return u32Hclk >> 1;
00006e  0860              LSRS     r0,r4,#1
;;;243    }
000070  bdf8              POP      {r3-r7,pc}
;;;244    
                          ENDP

000072  0000              DCW      0x0000
                  |L19.116|
                          DCD      0x50000200
                  |L19.120|
                          DCD      0x044aa200
                  |L19.124|
                          DCD      0x017d7840

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=2

                  CLK_SetHCLK PROC
;;;259      */
;;;260    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;261    {
;;;262        uint32_t u32HIRCSTB;
;;;263    
;;;264        /* Read HIRC clock source stable flag */
;;;265        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000002  4c11              LDR      r4,|L20.72|
000004  b081              SUB      sp,sp,#4              ;261
000006  68e5              LDR      r5,[r4,#0xc]
000008  460f              MOV      r7,r1                 ;261
00000a  2010              MOVS     r0,#0x10
00000c  4005              ANDS     r5,r5,r0
;;;266    
;;;267        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;268        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00000e  6820              LDR      r0,[r4,#0]
000010  2604              MOVS     r6,#4
000012  4330              ORRS     r0,r0,r6
000014  6020              STR      r0,[r4,#0]
;;;269        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000016  2010              MOVS     r0,#0x10
000018  f7fffffe          BL       CLK_WaitClockReady
;;;270        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
00001c  6920              LDR      r0,[r4,#0x10]
00001e  2107              MOVS     r1,#7
000020  4308              ORRS     r0,r0,r1
000022  6120              STR      r0,[r4,#0x10]
;;;271    
;;;272        /* Apply new Divider */
;;;273        CLK->CLKDIV0 = (CLK->CLKDIV0 & (~CLK_CLKDIV0_HCLKDIV_Msk)) | u32ClkDiv;
000024  69a0              LDR      r0,[r4,#0x18]
000026  0900              LSRS     r0,r0,#4
000028  0100              LSLS     r0,r0,#4
00002a  4338              ORRS     r0,r0,r7
00002c  61a0              STR      r0,[r4,#0x18]
;;;274    
;;;275        /* Switch HCLK to new HCLK source */
;;;276        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | u32ClkSrc;
00002e  6920              LDR      r0,[r4,#0x10]
000030  4388              BICS     r0,r0,r1
000032  9901              LDR      r1,[sp,#4]
000034  4308              ORRS     r0,r0,r1
000036  6120              STR      r0,[r4,#0x10]
;;;277    
;;;278        /* Update System Core Clock */
;;;279        SystemCoreClockUpdate();
000038  f7fffffe          BL       SystemCoreClockUpdate
;;;280    
;;;281        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;282        if(u32HIRCSTB == 0)
00003c  2d00              CMP      r5,#0
00003e  d102              BNE      |L20.70|
;;;283            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000040  6820              LDR      r0,[r4,#0]
000042  43b0              BICS     r0,r0,r6
000044  6020              STR      r0,[r4,#0]
                  |L20.70|
;;;284    }
000046  bdfe              POP      {r1-r7,pc}
;;;285    /**
                          ENDP

                  |L20.72|
                          DCD      0x50000200

                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;370      */
;;;371    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b5f0              PUSH     {r4-r7,lr}
;;;372    {
;;;373        uint32_t u32sel = 0, u32div = 0;
;;;374        uint32_t u32SelTbl[4] = {0x0, 0x4, 0xC, 0x24};
000002  4b1a              LDR      r3,|L21.108|
000004  b086              SUB      sp,sp,#0x18           ;372
000006  461c              MOV      r4,r3
000008  3408              ADDS     r4,r4,#8
00000a  ccf0              LDM      r4,{r4-r7}
00000c  9400              STR      r4,[sp,#0]
00000e  ac01              ADD      r4,sp,#4
000010  c4e0              STM      r4!,{r5-r7}
000012  cb18              LDM      r3,{r3,r4}
;;;375        uint32_t u32DivTbl[2] = {0x0, 0x20};
;;;376    
;;;377        if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000014  9405              STR      r4,[sp,#0x14]
000016  9304              STR      r3,[sp,#0x10]
000018  0a84              LSRS     r4,r0,#10
00001a  0623              LSLS     r3,r4,#24
00001c  0e1b              LSRS     r3,r3,#24
00001e  d00e              BEQ      |L21.62|
;;;378        {
;;;379            /* Get clock divider control register address */
;;;380            u32div = (uint32_t)&CLK->CLKDIV0 + (u32DivTbl[MODULE_CLKDIV(u32ModuleIdx)]);
000020  0303              LSLS     r3,r0,#12
000022  0f9b              LSRS     r3,r3,#30
000024  009b              LSLS     r3,r3,#2
000026  ad04              ADD      r5,sp,#0x10
000028  58eb              LDR      r3,[r5,r3]
00002a  4d11              LDR      r5,|L21.112|
00002c  195b              ADDS     r3,r3,r5
;;;381            /* Apply new divider */
;;;382            M32(u32div) = (M32(u32div) & (~(MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;
00002e  b2e5              UXTB     r5,r4
000030  0584              LSLS     r4,r0,#22
000032  0ee4              LSRS     r4,r4,#27
000034  40a5              LSLS     r5,r5,r4
000036  681c              LDR      r4,[r3,#0]
000038  43ac              BICS     r4,r4,r5
00003a  4314              ORRS     r4,r4,r2
00003c  601c              STR      r4,[r3,#0]
                  |L21.62|
;;;383        }
;;;384    
;;;385        if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
00003e  0e42              LSRS     r2,r0,#25
000040  0752              LSLS     r2,r2,#29
000042  d010              BEQ      |L21.102|
;;;386        {
;;;387            /* Get clock select control register address */
;;;388            u32sel = (uint32_t)&CLK->CLKSEL0 + (u32SelTbl[MODULE_CLKSEL(u32ModuleIdx)]);
000044  0082              LSLS     r2,r0,#2
000046  0f92              LSRS     r2,r2,#30
000048  0092              LSLS     r2,r2,#2
00004a  466b              MOV      r3,sp
00004c  589a              LDR      r2,[r3,r2]
00004e  4b08              LDR      r3,|L21.112|
000050  3b08              SUBS     r3,r3,#8
000052  18d2              ADDS     r2,r2,r3
;;;389            /* Set new clock selection setting */
;;;390            M32(u32sel) = (M32(u32sel) & (~(MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;
000054  0103              LSLS     r3,r0,#4
000056  0f5b              LSRS     r3,r3,#29
000058  01c0              LSLS     r0,r0,#7
00005a  0ec0              LSRS     r0,r0,#27
00005c  4083              LSLS     r3,r3,r0
00005e  6810              LDR      r0,[r2,#0]
000060  4398              BICS     r0,r0,r3
000062  4308              ORRS     r0,r0,r1
000064  6010              STR      r0,[r2,#0]
                  |L21.102|
;;;391        }
;;;392    }
000066  b006              ADD      sp,sp,#0x18
000068  bdf0              POP      {r4-r7,pc}
;;;393    
                          ENDP

00006a  0000              DCW      0x0000
                  |L21.108|
                          DCD      ||.constdata||
                  |L21.112|
                          DCD      0x50000218

                          AREA ||i.CLK_SetSysTickClockSrc||, CODE, READONLY, ALIGN=2

                  CLK_SetSysTickClockSrc PROC
;;;405      */
;;;406    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
000000  4a03              LDR      r2,|L22.16|
;;;407    {
;;;408        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000002  6911              LDR      r1,[r2,#0x10]
000004  2338              MOVS     r3,#0x38
000006  4399              BICS     r1,r1,r3
000008  4301              ORRS     r1,r1,r0
00000a  6111              STR      r1,[r2,#0x10]
;;;409    }
00000c  4770              BX       lr
;;;410    
                          ENDP

00000e  0000              DCW      0x0000
                  |L22.16|
                          DCD      0x50000200

                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;687      */
;;;688    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  b510              PUSH     {r4,lr}
;;;689    {
000002  4604              MOV      r4,r0
;;;690        int32_t i32TimeOutCnt = 2160000;
000004  4907              LDR      r1,|L23.36|
;;;691    
;;;692        while((CLK->STATUS & u32ClkMask) != u32ClkMask)
000006  4b08              LDR      r3,|L23.40|
000008  e005              B        |L23.22|
                  |L23.10|
;;;693        {
;;;694            if(i32TimeOutCnt-- <= 0)
00000a  460a              MOV      r2,r1
00000c  1e49              SUBS     r1,r1,#1
00000e  2a00              CMP      r2,#0
000010  dc01              BGT      |L23.22|
;;;695                return 0;
000012  2000              MOVS     r0,#0
;;;696        }
;;;697    
;;;698        return 1;
;;;699    }
000014  bd10              POP      {r4,pc}
                  |L23.22|
000016  68da              LDR      r2,[r3,#0xc]          ;692
000018  4620              MOV      r0,r4                 ;692
00001a  4390              BICS     r0,r0,r2              ;692
00001c  d1f5              BNE      |L23.10|
00001e  2001              MOVS     r0,#1                 ;698
000020  bd10              POP      {r4,pc}
;;;700    
                          ENDP

000022  0000              DCW      0x0000
                  |L23.36|
                          DCD      0x0020f580
                  |L23.40|
                          DCD      0x50000200

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000000
                          DCD      0x00000020
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000000c
                          DCD      0x00000024
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000002c
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000002c

;*** Start embedded assembler ***

#line 1 "..\\lib\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 388 "..\\lib\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 402
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
