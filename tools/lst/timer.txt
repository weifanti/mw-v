; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\timer.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\timer.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\lib\CMSIS\Include -I..\lib\Device\Nuvoton\NUC029xGE\Include -I..\lib\StdDriver\inc -I..\src\core\include -I..\src\driver\include -I..\src\io\include -I..\src\global -I..\src\server\include -I..\src\driver\audio -D__UVISION_VERSION=522 --omf_browse=.\obj\timer.crf ..\lib\StdDriver\src\timer.c]
                          THUMB

                          AREA ||i.TIMER_Close||, CODE, READONLY, ALIGN=1

                  TIMER_Close PROC
;;;89       */
;;;90     void TIMER_Close(TIMER_T *timer)
000000  2100              MOVS     r1,#0
;;;91     {
;;;92         timer->CTL = 0;
000002  6001              STR      r1,[r0,#0]
;;;93         timer->EXTCTL = 0;
000004  6141              STR      r1,[r0,#0x14]
;;;94     }
000006  4770              BX       lr
;;;95     
                          ENDP


                          AREA ||i.TIMER_Delay||, CODE, READONLY, ALIGN=2

                  TIMER_Delay PROC
;;;107      */
;;;108    void TIMER_Delay(TIMER_T *timer, uint32_t u32Usec)
000000  b5f8              PUSH     {r3-r7,lr}
;;;109    {
000002  460c              MOV      r4,r1
000004  4607              MOV      r7,r0
;;;110        uint32_t u32Clk = TIMER_GetModuleClock(timer);
000006  f7fffffe          BL       TIMER_GetModuleClock
00000a  4605              MOV      r5,r0
;;;111        uint32_t u32Prescale = 0, delay = (SystemCoreClock / u32Clk) + 1;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
000010  4826              LDR      r0,|L2.172|
000012  4629              MOV      r1,r5
000014  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000016  f7fffffe          BL       __aeabi_uidivmod
00001a  1c46              ADDS     r6,r0,#1
;;;112        uint32_t u32Cmpr, u32NsecPerTick;
;;;113    
;;;114        // Clear current timer configuration/
;;;115        timer->CTL = 0;
00001c  2000              MOVS     r0,#0
00001e  6038              STR      r0,[r7,#0]
;;;116        timer->EXTCTL = 0;
000020  6178              STR      r0,[r7,#0x14]
;;;117    
;;;118        if(u32Clk <= 1000000)   // min delay is 1000 us if timer clock source is <= 1 MHz
000022  4923              LDR      r1,|L2.176|
000024  428d              CMP      r5,r1
000026  d805              BHI      |L2.52|
;;;119        {
;;;120            if(u32Usec < 1000)
000028  207d              MOVS     r0,#0x7d
00002a  00c0              LSLS     r0,r0,#3
00002c  4284              CMP      r4,r0
00002e  d205              BCS      |L2.60|
;;;121                u32Usec = 1000;
000030  4604              MOV      r4,r0
000032  e006              B        |L2.66|
                  |L2.52|
;;;122            if(u32Usec > 1000000)
;;;123                u32Usec = 1000000;
;;;124        }
;;;125        else
;;;126        {
;;;127            if(u32Usec < 100)
000034  2c64              CMP      r4,#0x64
000036  d201              BCS      |L2.60|
;;;128                u32Usec = 100;
000038  2464              MOVS     r4,#0x64
00003a  e002              B        |L2.66|
                  |L2.60|
;;;129            if(u32Usec > 1000000)
00003c  428c              CMP      r4,r1
00003e  d900              BLS      |L2.66|
;;;130                u32Usec = 1000000;
000040  460c              MOV      r4,r1
                  |L2.66|
;;;131        }
;;;132    
;;;133        if(u32Clk <= 1000000)
;;;134        {
;;;135            u32Prescale = 0;
;;;136            u32NsecPerTick = 1000000000 / u32Clk;
000042  481c              LDR      r0,|L2.180|
000044  428d              CMP      r5,r1                 ;133
000046  d807              BHI      |L2.88|
                  |L2.72|
000048  4629              MOV      r1,r5
00004a  f7fffffe          BL       __aeabi_uidivmod
00004e  4601              MOV      r1,r0
;;;137            u32Cmpr = (u32Usec * 1000) / u32NsecPerTick;
000050  207d              MOVS     r0,#0x7d
000052  00c0              LSLS     r0,r0,#3
000054  4360              MULS     r0,r4,r0
000056  e017              B        |L2.136|
                  |L2.88|
;;;138        }
;;;139        else
;;;140        {
;;;141            if(u32Clk > 64000000)
000058  4a17              LDR      r2,|L2.184|
00005a  4295              CMP      r5,r2
00005c  d903              BLS      |L2.102|
;;;142            {
;;;143                u32Prescale = 7;    // real prescaler value is 8
00005e  2207              MOVS     r2,#7
;;;144                u32Clk >>= 3;
000060  08ed              LSRS     r5,r5,#3
000062  9200              STR      r2,[sp,#0]
000064  e00c              B        |L2.128|
                  |L2.102|
;;;145            }
;;;146            else if(u32Clk > 32000000)
000066  4a15              LDR      r2,|L2.188|
000068  4295              CMP      r5,r2
00006a  d903              BLS      |L2.116|
;;;147            {
;;;148                u32Prescale = 3;    // real prescaler value is 4
00006c  2203              MOVS     r2,#3
;;;149                u32Clk >>= 2;
00006e  08ad              LSRS     r5,r5,#2
000070  9200              STR      r2,[sp,#0]
000072  e005              B        |L2.128|
                  |L2.116|
;;;150            }
;;;151            else if(u32Clk > 16000000)
000074  4a12              LDR      r2,|L2.192|
000076  4295              CMP      r5,r2
000078  d902              BLS      |L2.128|
;;;152            {
;;;153                u32Prescale = 1;    // real prescaler value is 2
00007a  2201              MOVS     r2,#1
;;;154                u32Clk >>= 1;
00007c  086d              LSRS     r5,r5,#1
00007e  9200              STR      r2,[sp,#0]
                  |L2.128|
;;;155            }
;;;156    
;;;157            if(u32Usec < 250)
000080  2cfa              CMP      r4,#0xfa
000082  d2e1              BCS      |L2.72|
000084  4620              MOV      r0,r4
;;;158            {
;;;159                u32Cmpr = (u32Usec * u32Clk) / 1000000;
000086  4368              MULS     r0,r5,r0
                  |L2.136|
000088  f7fffffe          BL       __aeabi_uidivmod
;;;160            }
;;;161            else
;;;162            {
;;;163                u32NsecPerTick = 1000000000 / u32Clk;
;;;164                u32Cmpr = (u32Usec * 1000) / u32NsecPerTick;
;;;165            }
;;;166        }
;;;167    
;;;168        timer->CMP = u32Cmpr;
00008c  6078              STR      r0,[r7,#4]
;;;169        timer->CTL = TIMER_CTL_CNTEN_Msk | TIMER_ONESHOT_MODE | u32Prescale;
00008e  2101              MOVS     r1,#1
000090  9800              LDR      r0,[sp,#0]
000092  0789              LSLS     r1,r1,#30
000094  4308              ORRS     r0,r0,r1
000096  6038              STR      r0,[r7,#0]
;;;170    
;;;171        // When system clock is faster than timer clock, it is possible timer active bit cannot set in time while we check it.
;;;172        // And the while loop below return immediately, so put a tiny delay here allowing timer start counting and raise active flag.
;;;173        for(; delay > 0; delay--)
000098  2e00              CMP      r6,#0
00009a  d002              BEQ      |L2.162|
                  |L2.156|
;;;174        {
;;;175            __NOP();
00009c  bf00              NOP      
00009e  1e76              SUBS     r6,r6,#1
0000a0  d1fc              BNE      |L2.156|
                  |L2.162|
;;;176        }
;;;177    
;;;178        while(timer->CTL & TIMER_CTL_ACTSTS_Msk);
0000a2  6838              LDR      r0,[r7,#0]
0000a4  0180              LSLS     r0,r0,#6
0000a6  d4fc              BMI      |L2.162|
;;;179    }
0000a8  bdf8              POP      {r3-r7,pc}
;;;180    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L2.172|
                          DCD      SystemCoreClock
                  |L2.176|
                          DCD      0x000f4240
                  |L2.180|
                          DCD      0x3b9aca00
                  |L2.184|
                          DCD      0x03d09000
                  |L2.188|
                          DCD      0x01e84800
                  |L2.192|
                          DCD      0x00f42400

                          AREA ||i.TIMER_DisableCapture||, CODE, READONLY, ALIGN=1

                  TIMER_DisableCapture PROC
;;;216      */
;;;217    void TIMER_DisableCapture(TIMER_T *timer)
000000  6941              LDR      r1,[r0,#0x14]
;;;218    {
;;;219        timer->EXTCTL &= ~TIMER_EXTCTL_CAPEN_Msk;
000002  2208              MOVS     r2,#8
000004  4391              BICS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;220    }
000008  4770              BX       lr
;;;221    
                          ENDP


                          AREA ||i.TIMER_DisableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_DisableEventCounter PROC
;;;250      */
;;;251    void TIMER_DisableEventCounter(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;252    {
;;;253        timer->CTL &= ~TIMER_CTL_EXTCNTEN_Msk;
000002  2201              MOVS     r2,#1
000004  0612              LSLS     r2,r2,#24
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;254    }
00000a  4770              BX       lr
;;;255    
                          ENDP


                          AREA ||i.TIMER_DisableFreqCounter||, CODE, READONLY, ALIGN=1

                  TIMER_DisableFreqCounter PROC
;;;323      */
;;;324    void TIMER_DisableFreqCounter(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;325    {
;;;326        timer->CTL &= ~TIMER_CTL_INTRGEN_Msk;
000002  2201              MOVS     r2,#1
000004  04d2              LSLS     r2,r2,#19
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;327    }
00000a  4770              BX       lr
;;;328    
                          ENDP


                          AREA ||i.TIMER_EnableCapture||, CODE, READONLY, ALIGN=2

                  TIMER_EnableCapture PROC
;;;201      */
;;;202    void TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge)
000000  b510              PUSH     {r4,lr}
;;;203    {
;;;204        timer->EXTCTL = (timer->EXTCTL & ~(TIMER_EXTCTL_CAPFUNCS_Msk | TIMER_EXTCTL_CAPEDGE_Msk)) |
000002  6943              LDR      r3,[r0,#0x14]
000004  4c03              LDR      r4,|L6.20|
000006  4023              ANDS     r3,r3,r4
000008  430b              ORRS     r3,r3,r1
00000a  4313              ORRS     r3,r3,r2
00000c  2108              MOVS     r1,#8
00000e  430b              ORRS     r3,r3,r1
000010  6143              STR      r3,[r0,#0x14]
;;;205                        u32CapMode | u32Edge | TIMER_EXTCTL_CAPEN_Msk;
;;;206    }
000012  bd10              POP      {r4,pc}
;;;207    
                          ENDP

                  |L6.20|
                          DCD      0xffff8fef

                          AREA ||i.TIMER_EnableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_EnableEventCounter PROC
;;;235      */
;;;236    void TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge)
000000  6942              LDR      r2,[r0,#0x14]
;;;237    {
;;;238        timer->EXTCTL = (timer->EXTCTL & ~TIMER_EXTCTL_CNTPHASE_Msk) | u32Edge;
000002  0852              LSRS     r2,r2,#1
000004  0052              LSLS     r2,r2,#1
000006  430a              ORRS     r2,r2,r1
000008  6142              STR      r2,[r0,#0x14]
;;;239        timer->CTL |= TIMER_CTL_EXTCNTEN_Msk;
00000a  6801              LDR      r1,[r0,#0]
00000c  2201              MOVS     r2,#1
00000e  0612              LSLS     r2,r2,#24
000010  4311              ORRS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;240    }
000014  4770              BX       lr
;;;241    
                          ENDP


                          AREA ||i.TIMER_EnableFreqCounter||, CODE, READONLY, ALIGN=2

                  TIMER_EnableFreqCounter PROC
;;;303      */
;;;304    void TIMER_EnableFreqCounter(TIMER_T *timer, uint32_t u32DropCount, uint32_t u32Timeout, uint32_t u32EnableInt)
000000  4908              LDR      r1,|L8.36|
;;;305    {
;;;306        TIMER_T *t;    // store the timer base to configure compare value
;;;307    
;;;308        t = (timer == TIMER0) ? TIMER1 : TIMER3;
000002  4288              CMP      r0,r1
000004  d101              BNE      |L8.10|
000006  4908              LDR      r1,|L8.40|
000008  e000              B        |L8.12|
                  |L8.10|
00000a  4908              LDR      r1,|L8.44|
                  |L8.12|
;;;309    
;;;310        t->CMP = 0xFFFFFF;
00000c  4a08              LDR      r2,|L8.48|
00000e  604a              STR      r2,[r1,#4]
;;;311        t->EXTCTL = u32EnableInt ? TIMER_EXTCTL_CAPIEN_Msk : 0;
000010  2b00              CMP      r3,#0
000012  d001              BEQ      |L8.24|
000014  2220              MOVS     r2,#0x20
000016  e000              B        |L8.26|
                  |L8.24|
000018  2200              MOVS     r2,#0
                  |L8.26|
00001a  614a              STR      r2,[r1,#0x14]
;;;312        timer->CTL = TIMER_CTL_INTRGEN_Msk | TIMER_CTL_CNTEN_Msk;
00001c  4905              LDR      r1,|L8.52|
00001e  6001              STR      r1,[r0,#0]
;;;313    
;;;314        return;
;;;315    }
000020  4770              BX       lr
;;;316    
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      0x40010000
                  |L8.40|
                          DCD      0x40010100
                  |L8.44|
                          DCD      0x40110100
                  |L8.48|
                          DCD      0x00ffffff
                  |L8.52|
                          DCD      0x40080000

                          AREA ||i.TIMER_GetModuleClock||, CODE, READONLY, ALIGN=2

                  TIMER_GetModuleClock PROC
;;;265      */
;;;266    uint32_t TIMER_GetModuleClock(TIMER_T *timer)
000000  b510              PUSH     {r4,lr}
;;;267    {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;268        uint32_t u32Src;
;;;269        const uint32_t au32Clk[] = {__HXT, __LXT, 0, 0, 0, __LIRC, 0, __HIRC};
000006  2220              MOVS     r2,#0x20
000008  4911              LDR      r1,|L9.80|
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       __aeabi_memcpy4
;;;270    
;;;271        if(timer == TIMER0)
000010  4910              LDR      r1,|L9.84|
;;;272            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR0SEL_Msk) >> CLK_CLKSEL1_TMR0SEL_Pos;
000012  4811              LDR      r0,|L9.88|
000014  428c              CMP      r4,r1                 ;271
000016  d102              BNE      |L9.30|
000018  6940              LDR      r0,[r0,#0x14]
;;;273        else if(timer == TIMER1)
;;;274            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR1SEL_Msk) >> CLK_CLKSEL1_TMR1SEL_Pos;
;;;275        else if(timer == TIMER2)
;;;276            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR2SEL_Msk) >> CLK_CLKSEL1_TMR2SEL_Pos;
;;;277        else  // Timer 3
;;;278            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR3SEL_Msk) >> CLK_CLKSEL1_TMR3SEL_Pos;
;;;279    
;;;280        if(u32Src == 2)
;;;281        {
;;;282            return (SystemCoreClock);
;;;283        }
;;;284    
;;;285        return (au32Clk[u32Src]);
;;;286    }
00001a  0a00              LSRS     r0,r0,#8
00001c  e00c              B        |L9.56|
                  |L9.30|
00001e  490f              LDR      r1,|L9.92|
000020  428c              CMP      r4,r1                 ;273
000022  d102              BNE      |L9.42|
000024  6940              LDR      r0,[r0,#0x14]         ;274
000026  0b00              LSRS     r0,r0,#12
000028  e006              B        |L9.56|
                  |L9.42|
00002a  490d              LDR      r1,|L9.96|
00002c  6940              LDR      r0,[r0,#0x14]         ;278
00002e  428c              CMP      r4,r1                 ;275
000030  d101              BNE      |L9.54|
000032  0c00              LSRS     r0,r0,#16
000034  e000              B        |L9.56|
                  |L9.54|
000036  0d00              LSRS     r0,r0,#20
                  |L9.56|
000038  0740              LSLS     r0,r0,#29
00003a  0f40              LSRS     r0,r0,#29
00003c  2802              CMP      r0,#2                 ;280
00003e  d004              BEQ      |L9.74|
000040  0080              LSLS     r0,r0,#2              ;285
000042  4669              MOV      r1,sp                 ;285
000044  5808              LDR      r0,[r1,r0]            ;285
                  |L9.70|
000046  b008              ADD      sp,sp,#0x20
000048  bd10              POP      {r4,pc}
                  |L9.74|
00004a  4806              LDR      r0,|L9.100|
00004c  6800              LDR      r0,[r0,#0]            ;282  ; SystemCoreClock
00004e  e7fa              B        |L9.70|
;;;287    
                          ENDP

                  |L9.80|
                          DCD      ||.constdata||
                  |L9.84|
                          DCD      0x40010000
                  |L9.88|
                          DCD      0x50000200
                  |L9.92|
                          DCD      0x40010100
                  |L9.96|
                          DCD      0x40110000
                  |L9.100|
                          DCD      SystemCoreClock

                          AREA ||i.TIMER_Open||, CODE, READONLY, ALIGN=2

                  TIMER_Open PROC
;;;43       */
;;;44     uint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;45     {
000002  4617              MOV      r7,r2
000004  4606              MOV      r6,r0
;;;46         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000006  f7fffffe          BL       TIMER_GetModuleClock
00000a  4604              MOV      r4,r0
;;;47         uint32_t u32Cmpr = 0, u32Prescale = 0;
00000c  2500              MOVS     r5,#0
;;;48     
;;;49         // Fastest possible timer working freq is (u32Clk / 2). While cmpr = 2, pre-scale = 0.
;;;50         if(u32Freq > (u32Clk / 2))
00000e  0840              LSRS     r0,r0,#1
000010  42b8              CMP      r0,r7
000012  d201              BCS      |L10.24|
;;;51         {
;;;52             u32Cmpr = 2;
000014  2002              MOVS     r0,#2
000016  e014              B        |L10.66|
                  |L10.24|
;;;53         }
;;;54         else
;;;55         {
;;;56             if(u32Clk > 64000000)
000018  490f              LDR      r1,|L10.88|
00001a  428c              CMP      r4,r1
00001c  d902              BLS      |L10.36|
;;;57             {
;;;58                 u32Prescale = 7;    // real prescaler value is 8
00001e  2507              MOVS     r5,#7
;;;59                 u32Clk >>= 3;
000020  08e4              LSRS     r4,r4,#3
000022  e00a              B        |L10.58|
                  |L10.36|
;;;60             }
;;;61             else if(u32Clk > 32000000)
000024  490d              LDR      r1,|L10.92|
000026  428c              CMP      r4,r1
000028  d902              BLS      |L10.48|
;;;62             {
;;;63                 u32Prescale = 3;    // real prescaler value is 4
00002a  2503              MOVS     r5,#3
;;;64                 u32Clk >>= 2;
00002c  08a4              LSRS     r4,r4,#2
00002e  e004              B        |L10.58|
                  |L10.48|
;;;65             }
;;;66             else if(u32Clk > 16000000)
000030  490b              LDR      r1,|L10.96|
000032  428c              CMP      r4,r1
000034  d901              BLS      |L10.58|
;;;67             {
;;;68                 u32Prescale = 1;    // real prescaler value is 2
000036  2501              MOVS     r5,#1
;;;69                 u32Clk >>= 1;
000038  4604              MOV      r4,r0
                  |L10.58|
;;;70             }
;;;71     
;;;72             u32Cmpr = u32Clk / u32Freq;
00003a  4639              MOV      r1,r7
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       __aeabi_uidivmod
                  |L10.66|
;;;73         }
;;;74     
;;;75         timer->CTL = u32Mode | u32Prescale;
000042  9901              LDR      r1,[sp,#4]
000044  4329              ORRS     r1,r1,r5
000046  6031              STR      r1,[r6,#0]
;;;76         timer->CMP = u32Cmpr;
000048  6070              STR      r0,[r6,#4]
00004a  1c6d              ADDS     r5,r5,#1
;;;77     
;;;78         return(u32Clk / (u32Cmpr * (u32Prescale + 1)));
00004c  4368              MULS     r0,r5,r0
00004e  4601              MOV      r1,r0
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       __aeabi_uidivmod
;;;79     }
000056  bdfe              POP      {r1-r7,pc}
;;;80     
                          ENDP

                  |L10.88|
                          DCD      0x03d09000
                  |L10.92|
                          DCD      0x01e84800
                  |L10.96|
                          DCD      0x00f42400

                          AREA ||i.TIMER_SetTriggerSource||, CODE, READONLY, ALIGN=1

                  TIMER_SetTriggerSource PROC
;;;338      */
;;;339    void TIMER_SetTriggerSource(TIMER_T *timer, uint32_t u32Src)
000000  69c2              LDR      r2,[r0,#0x1c]
;;;340    {
;;;341        timer->TRGCTL = (timer->TRGCTL & ~TIMER_TRGCTL_TRGSSEL_Msk) | u32Src;
000002  0852              LSRS     r2,r2,#1
000004  0052              LSLS     r2,r2,#1
000006  430a              ORRS     r2,r2,r1
000008  61c2              STR      r2,[r0,#0x1c]
;;;342    }
00000a  4770              BX       lr
;;;343    
                          ENDP


                          AREA ||i.TIMER_SetTriggerTarget||, CODE, READONLY, ALIGN=1

                  TIMER_SetTriggerTarget PROC
;;;354      */
;;;355    void TIMER_SetTriggerTarget(TIMER_T *timer, uint32_t u32Mask)
000000  69c2              LDR      r2,[r0,#0x1c]
;;;356    {
;;;357        timer->TRGCTL = (timer->TRGCTL & ~(TIMER_TRGCTL_TRGPWM_Msk | TIMER_TRGCTL_TRGADC_Msk | TIMER_TRGCTL_TRGPDMA_Msk)) | (u32Mask);
000002  2316              MOVS     r3,#0x16
000004  439a              BICS     r2,r2,r3
000006  430a              ORRS     r2,r2,r1
000008  61c2              STR      r2,[r0,#0x1c]
;;;358    }
00000a  4770              BX       lr
;;;359    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00008000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00002710
                          DCD      0x00000000
                          DCD      0x01518000

;*** Start embedded assembler ***

#line 1 "..\\lib\\StdDriver\\src\\timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REV16|
#line 388 "..\\lib\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_timer_c_5bec749a____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REVSH|
#line 402
|__asm___7_timer_c_5bec749a____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
