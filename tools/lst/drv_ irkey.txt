; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o".\obj\drv_ irkey.o" --asm_dir=.\lst\ --list_dir=.\lst\ --depend=".\obj\drv_ irkey.d" --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\lib\CMSIS\Include -I..\lib\Device\Nuvoton\NUC029xGE\Include -I..\lib\StdDriver\inc -I..\src\core\include -I..\src\driver\include -I..\src\io\include -I..\src\global -I..\src\server\include -I..\src\driver\audio -D__UVISION_VERSION=522 --omf_browse=".\obj\drv_ irkey.crf" "..\src\driver\drv_ irkey.c"]
                          THUMB

                          AREA ||i.Drv_IrKey_init||, CODE, READONLY, ALIGN=2

                  Drv_IrKey_init PROC
;;;85     
;;;86     void Drv_IrKey_init(void)
000000  b510              PUSH     {r4,lr}
;;;87     {
;;;88     
;;;89     	GPIO_SetMode(PD, BIT0,  GPIO_MODE_INPUT);
000002  4c09              LDR      r4,|L1.40|
000004  2200              MOVS     r2,#0
000006  2101              MOVS     r1,#1
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;90     	GPIO_EnableInt(PD, 0, GPIO_INT_FALLING);
00000e  2201              MOVS     r2,#1
000010  2100              MOVS     r1,#0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_EnableInt
000018  2201              MOVS     r2,#1
00001a  4904              LDR      r1,|L1.44|
00001c  2020              MOVS     r0,#0x20
00001e  6008              STR      r0,[r1,#0]
;;;91     	
;;;92     	NVIC_EnableIRQ(GPCDEF_IRQn);  
;;;93         GPIO_ENABLE_DEBOUNCE(PD, BIT0);
000020  6961              LDR      r1,[r4,#0x14]
000022  4311              ORRS     r1,r1,r2
000024  6161              STR      r1,[r4,#0x14]
;;;94     }
000026  bd10              POP      {r4,pc}
;;;95     
                          ENDP

                  |L1.40|
                          DCD      0x500040c0
                  |L1.44|
                          DCD      0xe000e100

                          AREA ||i.GPCDEF_IRQHandler||, CODE, READONLY, ALIGN=2

                  GPCDEF_IRQHandler PROC
;;;27     
;;;28     void GPCDEF_IRQHandler(void)
000000  b530              PUSH     {r4,r5,lr}
;;;29     {
;;;30         volatile uint32_t temp;
;;;31     	static uint8_t i = 0;
;;;32     	static uint32_t repeat_time = 0;	
;;;33     
;;;34     	    if(GPIO_GET_INT_FLAG(PD,BIT0)) // IR KEY
000002  4818              LDR      r0,|L2.100|
000004  6a01              LDR      r1,[r0,#0x20]
000006  07c9              LSLS     r1,r1,#31
000008  d00d              BEQ      |L2.38|
;;;35     		{
;;;36     	        GPIO_CLR_INT_FLAG(PD, BIT0);
00000a  2401              MOVS     r4,#1
00000c  6204              STR      r4,[r0,#0x20]
;;;37     
;;;38     			if((IrTimerCount > 120) && (IrTimerCount < 145))// start code  14ms
00000e  4816              LDR      r0,|L2.104|
000010  2300              MOVS     r3,#0
000012  6881              LDR      r1,[r0,#8]  ; IrTimerCount
000014  460a              MOV      r2,r1
000016  3a79              SUBS     r2,r2,#0x79
000018  2a18              CMP      r2,#0x18
00001a  d205              BCS      |L2.40|
;;;39     			{
;;;40     				//	printf("IR KEY:%d\n",IrTimerCount);
;;;41     					DecodeStartFlag = 1;
00001c  7004              STRB     r4,[r0,#0]
;;;42     					IrTimerCount = 0;
;;;43     					i = 0;
00001e  6083              STR      r3,[r0,#8]  ; IrTimerCount
000020  7103              STRB     r3,[r0,#4]
;;;44     					repeat_time = 0;
;;;45     					LongKeyPress = 0;
000022  6103              STR      r3,[r0,#0x10]  ; repeat_time
000024  70c3              STRB     r3,[r0,#3]
                  |L2.38|
;;;46     			}
;;;47     			else if((IrTimerCount > 23) && (IrTimerCount < 120))
;;;48     			{
;;;49     				IrTimerCount = 0;
;;;50     				//printf("REPPPPPPPPPPPPPPP\n");
;;;51     
;;;52     				repeat_time++;
;;;53     			    if(repeat_time >10)
;;;54     				{
;;;55     					LongKeyPress = 1;
;;;56     					repeat_time = 0;
;;;57     				}
;;;58     
;;;59     			}
;;;60     			else 
;;;61     			{
;;;62     			   
;;;63     				if(DecodeStartFlag)
;;;64     				{
;;;65     					ir_data[i] = IrTimerCount;
;;;66     				//	printf("IR KEY %d:%d\n",i,ir_data[i]);
;;;67     					i++;
;;;68     					if(i >= 32)
;;;69     					{
;;;70     						i=0;
;;;71     						ir_data_rx_ok = 1;
;;;72     						DecodeStartFlag = 0;
;;;73     					}
;;;74     				}
;;;75     				IrTimerCount = 0;
;;;76     			}	
;;;77     	    }
;;;78     		
;;;79     }
000026  bd30              POP      {r4,r5,pc}
                  |L2.40|
000028  460a              MOV      r2,r1                 ;47
00002a  3a18              SUBS     r2,r2,#0x18           ;47
00002c  2a60              CMP      r2,#0x60              ;47
00002e  d208              BCS      |L2.66|
000030  6083              STR      r3,[r0,#8]            ;52  ; IrTimerCount
000032  6901              LDR      r1,[r0,#0x10]         ;52  ; repeat_time
000034  1c49              ADDS     r1,r1,#1              ;52
000036  6101              STR      r1,[r0,#0x10]         ;53  ; repeat_time
000038  290a              CMP      r1,#0xa               ;53
00003a  d9f4              BLS      |L2.38|
00003c  70c4              STRB     r4,[r0,#3]            ;55
00003e  6103              STR      r3,[r0,#0x10]         ;56  ; repeat_time
000040  bd30              POP      {r4,r5,pc}
                  |L2.66|
000042  7802              LDRB     r2,[r0,#0]            ;63  ; DecodeStartFlag
000044  2a00              CMP      r2,#0                 ;63
000046  d00a              BEQ      |L2.94|
000048  4d08              LDR      r5,|L2.108|
00004a  7902              LDRB     r2,[r0,#4]            ;65  ; i
00004c  54a9              STRB     r1,[r5,r2]            ;65
00004e  1c52              ADDS     r2,r2,#1              ;65
000050  b2d1              UXTB     r1,r2                 ;67
000052  7101              STRB     r1,[r0,#4]            ;67
000054  2920              CMP      r1,#0x20              ;68
000056  d302              BCC      |L2.94|
000058  7103              STRB     r3,[r0,#4]            ;70
00005a  7084              STRB     r4,[r0,#2]            ;71
00005c  7003              STRB     r3,[r0,#0]            ;72
                  |L2.94|
00005e  6083              STR      r3,[r0,#8]            ;75  ; IrTimerCount
000060  bd30              POP      {r4,r5,pc}
;;;80     		
                          ENDP

000062  0000              DCW      0x0000
                  |L2.100|
                          DCD      0x500040c0
                  |L2.104|
                          DCD      ||.data||
                  |L2.108|
                          DCD      ||.bss||

                          AREA ||i.GetIrKey||, CODE, READONLY, ALIGN=2

                  GetIrKey PROC
;;;164    
;;;165    uint8_t GetIrKey(void)
000000  b570              PUSH     {r4-r6,lr}
;;;166    {
;;;167    	uint8_t ir_key_value;
;;;168    
;;;169    	if(ir_data_rx_ok)
000002  4c10              LDR      r4,|L3.68|
000004  2500              MOVS     r5,#0
000006  78a0              LDRB     r0,[r4,#2]  ; ir_data_rx_ok
000008  2800              CMP      r0,#0
00000a  d012              BEQ      |L3.50|
;;;170    	{
;;;171    		printf("ir_data_rx_ok = 1\n");
00000c  a00e              ADR      r0,|L3.72|
00000e  f7fffffe          BL       __2printf
;;;172    		ir_key_value = Ircordpro();
000012  f7fffffe          BL       Ircordpro
;;;173    		ir_data_rx_ok = 0;
;;;174    
;;;175    
;;;176    		// shoutting down cann't respond any key. idle state only respond power key
;;;177    		if((((Global_datas.g_mode_status == POWER_IDLE_MODE) || (Global_datas.g_mode_status == POWER_ON_MODE)) && (ir_key_value != IR_KEY_POWER)) || (Global_datas.shoutting_down)) 
000016  4911              LDR      r1,|L3.92|
000018  70a5              STRB     r5,[r4,#2]            ;173
00001a  794a              LDRB     r2,[r1,#5]  ; Global_datas
00001c  2a0e              CMP      r2,#0xe
00001e  d001              BEQ      |L3.36|
000020  2a00              CMP      r2,#0
000022  d101              BNE      |L3.40|
                  |L3.36|
000024  2801              CMP      r0,#1
000026  d102              BNE      |L3.46|
                  |L3.40|
000028  7b49              LDRB     r1,[r1,#0xd]  ; Global_datas
00002a  2900              CMP      r1,#0
00002c  d000              BEQ      |L3.48|
                  |L3.46|
;;;178    		{
;;;179    			ir_key_value = IR_KEY_NONE;
00002e  2000              MOVS     r0,#0
                  |L3.48|
;;;180    		}
;;;181    		return ir_key_value;
;;;182    	}
;;;183    
;;;184    	if(LongKeyPress)
;;;185    	{
;;;186    		LongKeyPress = 0;
;;;187    		printf("LongPress\n");
;;;188    	}
;;;189    	
;;;190    	return IR_KEY_NONE;
;;;191    }
000030  bd70              POP      {r4-r6,pc}
                  |L3.50|
000032  78e0              LDRB     r0,[r4,#3]            ;184  ; LongKeyPress
000034  2800              CMP      r0,#0                 ;184
000036  d0fa              BEQ      |L3.46|
000038  70e5              STRB     r5,[r4,#3]            ;186
00003a  a009              ADR      r0,|L3.96|
00003c  f7fffffe          BL       __2printf
000040  e7f5              B        |L3.46|
;;;192    
                          ENDP

000042  0000              DCW      0x0000
                  |L3.68|
                          DCD      ||.data||
                  |L3.72|
000048  69725f64          DCB      "ir_data_rx_ok = 1\n",0
00004c  6174615f
000050  72785f6f
000054  6b203d20
000058  310a00  
00005b  00                DCB      0
                  |L3.92|
                          DCD      Global_datas+0x20
                  |L3.96|
000060  4c6f6e67          DCB      "LongPress\n",0
000064  50726573
000068  730a00  
00006b  00                DCB      0

                          AREA ||i.Ircordpro||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  Ircordpro PROC
;;;97     
;;;98     uint8_t Ircordpro(void)//红外码值处理函数
000000  b5f8              PUSH     {r3-r7,lr}
;;;99     { 
;;;100      unsigned char i, j, k,temp;
;;;101      unsigned char cord,value = 0;
000002  2000              MOVS     r0,#0
;;;102      uint8_t ir_key =0;
;;;103      uint8_t key_value=0;
;;;104    
;;;105      k=0;
;;;106      for(i=0;i<4;i++)      //处理4个字节
;;;107         {
;;;108          for(j=1;j<=8;j++) //处理1个字节8位
;;;109             {
;;;110              cord=ir_data[k];
000004  4d26              LDR      r5,|L4.160|
;;;111              if(cord>15)//大于某值为1，这个和晶振有绝对关系，这里使用12M计算，此值可以有一定误差
;;;112                 value|=0x80;
;;;113              if(j<8)
;;;114                {
;;;115                 value>>=1;
;;;116                }
;;;117               k++;
;;;118             }
;;;119          ir_code[i]=value & 0xff;
000006  4f27              LDR      r7,|L4.164|
000008  4602              MOV      r2,r0                 ;105
00000a  4603              MOV      r3,r0                 ;106
00000c  2680              MOVS     r6,#0x80              ;112
                  |L4.14|
00000e  2101              MOVS     r1,#1                 ;108
                  |L4.16|
000010  5cac              LDRB     r4,[r5,r2]            ;110
000012  2c0f              CMP      r4,#0xf               ;111
000014  d900              BLS      |L4.24|
000016  4330              ORRS     r0,r0,r6              ;112
                  |L4.24|
000018  2908              CMP      r1,#8                 ;113
00001a  d200              BCS      |L4.30|
00001c  0840              LSRS     r0,r0,#1              ;115
                  |L4.30|
00001e  1c52              ADDS     r2,r2,#1              ;115
000020  1c49              ADDS     r1,r1,#1              ;117
000022  b2c9              UXTB     r1,r1                 ;108
000024  b2d2              UXTB     r2,r2                 ;117
000026  2908              CMP      r1,#8                 ;108
000028  d9f2              BLS      |L4.16|
00002a  54f8              STRB     r0,[r7,r3]
;;;120    	  value = 0;
00002c  1c5b              ADDS     r3,r3,#1
00002e  2000              MOVS     r0,#0
000030  b2db              UXTB     r3,r3                 ;106
000032  2b04              CMP      r3,#4                 ;106
000034  d3eb              BCC      |L4.14|
;;;121    	  
;;;122    	  //printf("KeyData %d:%x\n", i, ir_code[i]);
;;;123          //value=0;     
;;;124         } 
;;;125      
;;;126         DecodeFinishFlag =1;//处理完毕标志位置1
000036  491b              LDR      r1,|L4.164|
000038  2001              MOVS     r0,#1
00003a  390c              SUBS     r1,r1,#0xc
00003c  7048              STRB     r0,[r1,#1]
;;;127    
;;;128    
;;;129    	 ///////////////////////////////////////////////////////////////////////////
;;;130    
;;;131    	 //if((ir_code[0] == 0x40) && (ir_code[1] == 0xbf))// cs code is ok  0x40bf
;;;132    	 if((ir_code[0] == 0x12) && (ir_code[1] == 0x34))// cs code is ok  0x1234
00003e  7838              LDRB     r0,[r7,#0]  ; ir_code
000040  2812              CMP      r0,#0x12
000042  d002              BEQ      |L4.74|
;;;133    	 {
;;;134    		key_value = ir_code[2];
;;;135    	  //  printf("keyvalue:%x\n", key_value);
;;;136    
;;;137    		for(temp=0;temp<11;temp++)
;;;138    		{
;;;139    			if(IrKeyMap[temp][1] == key_value)
;;;140    			{
;;;141    				ir_key = IrKeyMap[temp][0];
;;;142    				printf("ir_key_num:%d\n", temp);
;;;143    				return ir_key;
;;;144    			}
;;;145    		}
;;;146    	 }
;;;147    	 else if((ir_code[0] == 0x0c) && (ir_code[1] == 0xf3))// cs code is ok  0x1234
000044  280c              CMP      r0,#0xc
000046  d011              BEQ      |L4.108|
000048  e027              B        |L4.154|
                  |L4.74|
00004a  7878              LDRB     r0,[r7,#1]            ;132  ; ir_code
00004c  2834              CMP      r0,#0x34              ;132
00004e  d124              BNE      |L4.154|
000050  4814              LDR      r0,|L4.164|
000052  78ba              LDRB     r2,[r7,#2]            ;134  ; ir_code
000054  2100              MOVS     r1,#0                 ;137
000056  3008              ADDS     r0,r0,#8              ;139
                  |L4.88|
000058  004b              LSLS     r3,r1,#1              ;139
00005a  181b              ADDS     r3,r3,r0              ;139
00005c  785b              LDRB     r3,[r3,#1]            ;139
00005e  4293              CMP      r3,r2                 ;139
000060  d010              BEQ      |L4.132|
000062  1c49              ADDS     r1,r1,#1              ;139
000064  b2c9              UXTB     r1,r1                 ;137
000066  290b              CMP      r1,#0xb               ;137
000068  d3f6              BCC      |L4.88|
00006a  e016              B        |L4.154|
                  |L4.108|
00006c  7878              LDRB     r0,[r7,#1]  ; ir_code
00006e  28f3              CMP      r0,#0xf3
000070  d113              BNE      |L4.154|
;;;148    	 {
;;;149    		key_value = ir_code[2];
;;;150    	  //  printf("keyvalue:%x\n", key_value);
;;;151    
;;;152    		for(temp=0;temp<11;temp++)
;;;153    		{
;;;154    			if(IrKeyMap_B[temp][1] == key_value)
000072  480c              LDR      r0,|L4.164|
000074  78ba              LDRB     r2,[r7,#2]            ;149  ; ir_code
000076  2100              MOVS     r1,#0                 ;152
000078  3020              ADDS     r0,r0,#0x20
                  |L4.122|
00007a  004b              LSLS     r3,r1,#1
00007c  181b              ADDS     r3,r3,r0
00007e  785b              LDRB     r3,[r3,#1]
000080  4293              CMP      r3,r2
000082  d106              BNE      |L4.146|
                  |L4.132|
;;;155    			{
;;;156    				ir_key = IrKeyMap_B[temp][0];
000084  004a              LSLS     r2,r1,#1
000086  5c84              LDRB     r4,[r0,r2]
;;;157    				printf("ir_key_num:%d\n", temp);
000088  a007              ADR      r0,|L4.168|
00008a  f7fffffe          BL       __2printf
;;;158    				return ir_key;
00008e  4620              MOV      r0,r4
;;;159    			}
;;;160    		}
;;;161    	 }
;;;162    	 return IR_KEY_NONE;
;;;163    }
000090  bdf8              POP      {r3-r7,pc}
                  |L4.146|
000092  1c49              ADDS     r1,r1,#1
000094  b2c9              UXTB     r1,r1                 ;152
000096  290b              CMP      r1,#0xb               ;152
000098  d3ef              BCC      |L4.122|
                  |L4.154|
00009a  2000              MOVS     r0,#0                 ;162
00009c  bdf8              POP      {r3-r7,pc}
;;;164    
                          ENDP

00009e  0000              DCW      0x0000
                  |L4.160|
                          DCD      ||.bss||
                  |L4.164|
                          DCD      ||.data||+0xc
                  |L4.168|
0000a8  69725f6b          DCB      "ir_key_num:%d\n",0
0000ac  65795f6e
0000b0  756d3a25
0000b4  640a00  
0000b7  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ir_data
                          %        33

                          AREA ||.data||, DATA, ALIGN=2

                  DecodeStartFlag
000000  00                DCB      0x00
                  DecodeFinishFlag
000001  00                DCB      0x00
                  ir_data_rx_ok
000002  00                DCB      0x00
                  LongKeyPress
000003  00                DCB      0x00
                  i
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  IrTimerCount
                          DCD      0x00000000
                  ir_code
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  repeat_time
                          DCD      0x00000000
                  IrKeyMap
000014  01200224          DCB      0x01,0x20,0x02,0x24
000018  03220421          DCB      0x03,0x22,0x04,0x21
00001c  06280727          DCB      0x06,0x28,0x07,0x27
000020  05260823          DCB      0x05,0x26,0x08,0x23
000024  09250b29          DCB      0x09,0x25,0x0b,0x29
000028  0c2a00aa          DCB      0x0c,0x2a,0x00,0xaa
                  IrKeyMap_B
00002c  01d002d4          DCB      0x01,0xd0,0x02,0xd4
000030  03d204d1          DCB      0x03,0xd2,0x04,0xd1
000034  06d807d7          DCB      0x06,0xd8,0x07,0xd7
000038  05d608d3          DCB      0x05,0xd6,0x08,0xd3
00003c  09d50bd9          DCB      0x09,0xd5,0x0b,0xd9
000040  0cda00aa          DCB      0x0c,0xda,0x00,0xaa

;*** Start embedded assembler ***

#line 1 "..\\src\\driver\\drv_ irkey.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_drv__irkey_c_66de5768____REV16|
#line 388 "..\\lib\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_drv__irkey_c_66de5768____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_drv__irkey_c_66de5768____REVSH|
#line 402
|__asm___12_drv__irkey_c_66de5768____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
