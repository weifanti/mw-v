; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o".\obj\drv_ irkey.o" --asm_dir=.\lst\ --list_dir=.\lst\ --depend=".\obj\drv_ irkey.d" --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\lib\CMSIS\Include -I..\lib\Device\Nuvoton\NUC029xGE\Include -I..\lib\StdDriver\inc -I..\src\core\include -I..\src\driver\include -I..\src\io\include -I..\src\global -I..\src\server\include -I..\src\driver\audio -D__UVISION_VERSION=522 --omf_browse=".\obj\drv_ irkey.crf" "..\src\driver\drv_ irkey.c"]
                          THUMB

                          AREA ||i.Drv_IrKey_init||, CODE, READONLY, ALIGN=2

                  Drv_IrKey_init PROC
;;;110    
;;;111    void Drv_IrKey_init(void)
000000  b510              PUSH     {r4,lr}
;;;112    {
;;;113    
;;;114    	GPIO_SetMode(PD, BIT0,  GPIO_MODE_INPUT);
000002  4c09              LDR      r4,|L1.40|
000004  2200              MOVS     r2,#0
000006  2101              MOVS     r1,#1
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;115    	GPIO_EnableInt(PD, 0, GPIO_INT_FALLING);
00000e  2201              MOVS     r2,#1
000010  2100              MOVS     r1,#0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_EnableInt
000018  2201              MOVS     r2,#1
00001a  4904              LDR      r1,|L1.44|
00001c  2020              MOVS     r0,#0x20
00001e  6008              STR      r0,[r1,#0]
;;;116    	
;;;117    	NVIC_EnableIRQ(GPCDEF_IRQn);  
;;;118        GPIO_ENABLE_DEBOUNCE(PD, BIT0);
000020  6961              LDR      r1,[r4,#0x14]
000022  4311              ORRS     r1,r1,r2
000024  6161              STR      r1,[r4,#0x14]
;;;119    }
000026  bd10              POP      {r4,pc}
;;;120    
                          ENDP

                  |L1.40|
                          DCD      0x500040c0
                  |L1.44|
                          DCD      0xe000e100

                          AREA ||i.GPCDEF_IRQHandler||, CODE, READONLY, ALIGN=2

                  GPCDEF_IRQHandler PROC
;;;28     
;;;29     void GPCDEF_IRQHandler(void)
000000  b530              PUSH     {r4,r5,lr}
;;;30     {
;;;31         volatile uint32_t temp;
;;;32     	static uint8_t i = 0;
;;;33     	static uint32_t repeat_time = 0;	
;;;34     
;;;35     	    if(GPIO_GET_INT_FLAG(PD,BIT0)) // IR KEY
000002  481f              LDR      r0,|L2.128|
000004  6a01              LDR      r1,[r0,#0x20]
000006  07c9              LSLS     r1,r1,#31
000008  d00e              BEQ      |L2.40|
;;;36     		{
;;;37     	        GPIO_CLR_INT_FLAG(PD, BIT0);
00000a  2201              MOVS     r2,#1
00000c  6202              STR      r2,[r0,#0x20]
;;;38     
;;;39     			if((IrTimerCount > 120) && (IrTimerCount < 145))// start code  14ms
00000e  491d              LDR      r1,|L2.132|
000010  2000              MOVS     r0,#0
000012  688b              LDR      r3,[r1,#8]  ; IrTimerCount
000014  461c              MOV      r4,r3
000016  3c79              SUBS     r4,r4,#0x79
000018  2c18              CMP      r4,#0x18
00001a  d206              BCS      |L2.42|
;;;40     			{
;;;41     				//	printf("IR KEY:%d\n",IrTimerCount);
;;;42     					DecodeStartFlag = 1;
00001c  700a              STRB     r2,[r1,#0]
;;;43     					IrTimerCount = 0;
;;;44     					i = 0;
00001e  6088              STR      r0,[r1,#8]  ; IrTimerCount
000020  7148              STRB     r0,[r1,#5]
;;;45     					repeat_time = 0;
;;;46     					LongKeyPress = 0;
000022  6108              STR      r0,[r1,#0x10]  ; repeat_time
000024  70c8              STRB     r0,[r1,#3]
;;;47     					key_value_bak = 0;
000026  7108              STRB     r0,[r1,#4]
                  |L2.40|
;;;48     			}
;;;49     			else if((IrTimerCount > 23) && (IrTimerCount < 120))
;;;50     			{
;;;51     				IrTimerCount = 0;
;;;52     				//printf("REPPPPPPPPPPPPPPP\n");
;;;53     
;;;54     				if((key_value_bak == IR_KEY_PLAY_PAUSE) || (key_value_bak == IR_KEY_POWER))
;;;55     				{
;;;56     					if(repeat_time < 15)
;;;57     					{
;;;58     						repeat_time++;
;;;59     						if(repeat_time == 15)
;;;60     						{
;;;61     							LongKeyPress = 1;
;;;62     						}
;;;63     					}
;;;64     				}
;;;65     				else
;;;66     				{
;;;67     					repeat_time++;
;;;68     					if(repeat_time <10)
;;;69     					{
;;;70     						;
;;;71     					}
;;;72     					else
;;;73     					{
;;;74     						if(repeat_time%2)
;;;75     						{
;;;76     							LongKeyPress = 1;
;;;77     						}
;;;78     					}
;;;79     
;;;80     
;;;81     				}
;;;82     
;;;83     
;;;84     			}
;;;85     			else 
;;;86     			{
;;;87     			   
;;;88     				if(DecodeStartFlag)
;;;89     				{
;;;90     					ir_data[i] = IrTimerCount;
;;;91     				//	printf("IR KEY %d:%d\n",i,ir_data[i]);
;;;92     					i++;
;;;93     					if(i >= 32)
;;;94     					{
;;;95     						i=0;
;;;96     						ir_data_rx_ok = 1;
;;;97     						DecodeStartFlag = 0;
;;;98     					}
;;;99     				}
;;;100    				IrTimerCount = 0;
;;;101    			}	
;;;102    	    }
;;;103    		
;;;104    }
000028  bd30              POP      {r4,r5,pc}
                  |L2.42|
00002a  461c              MOV      r4,r3                 ;49
00002c  3c18              SUBS     r4,r4,#0x18           ;49
00002e  2c60              CMP      r4,#0x60              ;49
000030  d215              BCS      |L2.94|
000032  6088              STR      r0,[r1,#8]            ;54  ; IrTimerCount
000034  4813              LDR      r0,|L2.132|
000036  790b              LDRB     r3,[r1,#4]            ;54  ; key_value_bak
000038  6904              LDR      r4,[r0,#0x10]         ;58
00003a  1c60              ADDS     r0,r4,#1              ;58
00003c  2b28              CMP      r3,#0x28              ;54
00003e  d008              BEQ      |L2.82|
000040  2b1d              CMP      r3,#0x1d              ;54
000042  d006              BEQ      |L2.82|
000044  6108              STR      r0,[r1,#0x10]         ;68  ; repeat_time
000046  280a              CMP      r0,#0xa               ;68
000048  d3ee              BCC      |L2.40|
00004a  07c0              LSLS     r0,r0,#31             ;74
00004c  d0ec              BEQ      |L2.40|
                  |L2.78|
00004e  70ca              STRB     r2,[r1,#3]            ;76
                  |L2.80|
000050  bd30              POP      {r4,r5,pc}
                  |L2.82|
000052  2c0f              CMP      r4,#0xf               ;56
000054  d2fc              BCS      |L2.80|
000056  6108              STR      r0,[r1,#0x10]         ;59  ; repeat_time
000058  280f              CMP      r0,#0xf               ;59
00005a  d0f8              BEQ      |L2.78|
00005c  bd30              POP      {r4,r5,pc}
                  |L2.94|
00005e  780c              LDRB     r4,[r1,#0]            ;88  ; DecodeStartFlag
000060  2c00              CMP      r4,#0                 ;88
000062  d00a              BEQ      |L2.122|
000064  4d08              LDR      r5,|L2.136|
000066  794c              LDRB     r4,[r1,#5]            ;90  ; i
000068  552b              STRB     r3,[r5,r4]            ;90
00006a  1c64              ADDS     r4,r4,#1              ;90
00006c  b2e3              UXTB     r3,r4                 ;92
00006e  714b              STRB     r3,[r1,#5]            ;92
000070  2b20              CMP      r3,#0x20              ;93
000072  d302              BCC      |L2.122|
000074  7148              STRB     r0,[r1,#5]            ;95
000076  708a              STRB     r2,[r1,#2]            ;96
000078  7008              STRB     r0,[r1,#0]            ;97
                  |L2.122|
00007a  6088              STR      r0,[r1,#8]            ;100  ; IrTimerCount
00007c  bd30              POP      {r4,r5,pc}
;;;105    		
                          ENDP

00007e  0000              DCW      0x0000
                  |L2.128|
                          DCD      0x500040c0
                  |L2.132|
                          DCD      ||.data||
                  |L2.136|
                          DCD      ||.bss||

                          AREA ||i.GetIrKey||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  GetIrKey PROC
;;;191    
;;;192    uint8_t GetIrKey(void)
000000  b570              PUSH     {r4-r6,lr}
;;;193    {
;;;194    	uint8_t ir_key_value = 0;
;;;195    	
;;;196    	uint8_t ir_key_hold = 0;
;;;197    
;;;198    	if(ir_data_rx_ok)
000002  4d1e              LDR      r5,|L3.124|
000004  2400              MOVS     r4,#0                 ;196
000006  78a8              LDRB     r0,[r5,#2]  ; ir_data_rx_ok
000008  2800              CMP      r0,#0
00000a  d012              BEQ      |L3.50|
;;;199    	{
;;;200    		printf("ir_data_rx_ok = 1\n");
00000c  a01c              ADR      r0,|L3.128|
00000e  f7fffffe          BL       __2printf
;;;201    		ir_key_value = Ircordpro();
000012  f7fffffe          BL       Ircordpro
;;;202    		ir_data_rx_ok = 0;
000016  2100              MOVS     r1,#0
000018  70a9              STRB     r1,[r5,#2]
;;;203    
;;;204            		
;;;205    		// shoutting down cann't respond any key. idle state only respond power key
;;;206    		if((((Global_datas.state == SYS_PLAY_STATE_IDLE) || (Global_datas.state == SYS_PLAY_STATE_POWERUP)) && (ir_key_value != IR_KEY_POWER)) || (Global_datas.state == SYS_PLAY_STATE_SHUTTING_DOWN)) 
00001a  491e              LDR      r1,|L3.148|
00001c  7e49              LDRB     r1,[r1,#0x19]  ; Global_datas
00001e  2901              CMP      r1,#1
000020  d001              BEQ      |L3.38|
000022  2902              CMP      r1,#2
000024  d101              BNE      |L3.42|
                  |L3.38|
000026  281d              CMP      r0,#0x1d
000028  d101              BNE      |L3.46|
                  |L3.42|
00002a  2904              CMP      r1,#4
00002c  d100              BNE      |L3.48|
                  |L3.46|
;;;207    		{
;;;208    			ir_key_value = IR_KEY_NONE;
00002e  2000              MOVS     r0,#0
                  |L3.48|
;;;209    		}
;;;210    		return ir_key_value;
;;;211    	}
;;;212    
;;;213    	if(LongKeyPress)
;;;214    	{
;;;215    		printf("longpress:%d\n", LongKeyPress);
;;;216    		LongKeyPress--;
;;;217    		switch(key_value_bak)
;;;218    		{
;;;219    			case IR_KEY_PLAY_PAUSE:
;;;220    				ir_key_hold = IR_KEY_PLAY_PAUSE_CP;
;;;221    				break;
;;;222    			
;;;223    			case IR_KEY_POWER:
;;;224    				ir_key_hold = IR_KEY_POWER_CP;
;;;225    				break;
;;;226    			case IR_KEY_VOLUME_DOWN:
;;;227    				ir_key_hold = IR_KEY_VOLUME_DOWN_CP;
;;;228    				break;
;;;229    			case IR_KEY_VOLUME_UP:
;;;230    				ir_key_hold = IR_KEY_VOLUME_UP_CP;
;;;231    				break;
;;;232    			case IR_KEY_PREV_SONG:
;;;233    				ir_key_hold = IR_KEY_PREV_SONG_CP;
;;;234    				break;	
;;;235    			case IR_KEY_NEXT_SONG:
;;;236    				ir_key_hold = IR_KEY_NEXT_SONG_CP;
;;;237    				break;
;;;238    			default:ir_key_hold = IR_KEY_NONE;
;;;239    			break;
;;;240    
;;;241    				
;;;242    		}
;;;243    		return ir_key_hold;
;;;244    		
;;;245    	}
;;;246    	
;;;247    	return IR_KEY_NONE;
;;;248    }
000030  bd70              POP      {r4-r6,pc}
                  |L3.50|
000032  78e9              LDRB     r1,[r5,#3]            ;213  ; LongKeyPress
000034  2900              CMP      r1,#0                 ;213
000036  d0fa              BEQ      |L3.46|
000038  a017              ADR      r0,|L3.152|
00003a  f7fffffe          BL       __2printf
00003e  78e8              LDRB     r0,[r5,#3]            ;216  ; LongKeyPress
000040  1e40              SUBS     r0,r0,#1              ;216
000042  70e8              STRB     r0,[r5,#3]            ;216
000044  7928              LDRB     r0,[r5,#4]            ;217  ; key_value_bak
000046  2824              CMP      r0,#0x24              ;217
000048  d013              BEQ      |L3.114|
00004a  dc06              BGT      |L3.90|
00004c  281d              CMP      r0,#0x1d              ;217
00004e  d00a              BEQ      |L3.102|
000050  2820              CMP      r0,#0x20              ;217
000052  d00c              BEQ      |L3.110|
000054  2822              CMP      r0,#0x22              ;217
000056  d10f              BNE      |L3.120|
000058  e007              B        |L3.106|
                  |L3.90|
00005a  2826              CMP      r0,#0x26              ;217
00005c  d00b              BEQ      |L3.118|
00005e  2828              CMP      r0,#0x28              ;217
000060  d10a              BNE      |L3.120|
000062  2429              MOVS     r4,#0x29              ;220
000064  e008              B        |L3.120|
                  |L3.102|
000066  241e              MOVS     r4,#0x1e              ;224
000068  e006              B        |L3.120|
                  |L3.106|
00006a  2423              MOVS     r4,#0x23              ;227
00006c  e004              B        |L3.120|
                  |L3.110|
00006e  2421              MOVS     r4,#0x21              ;230
000070  e002              B        |L3.120|
                  |L3.114|
000072  2425              MOVS     r4,#0x25              ;233
000074  e000              B        |L3.120|
                  |L3.118|
000076  2427              MOVS     r4,#0x27              ;236
                  |L3.120|
000078  4620              MOV      r0,r4                 ;243
00007a  bd70              POP      {r4-r6,pc}
;;;249    
                          ENDP

                  |L3.124|
                          DCD      ||.data||
                  |L3.128|
000080  69725f64          DCB      "ir_data_rx_ok = 1\n",0
000084  6174615f
000088  72785f6f
00008c  6b203d20
000090  310a00  
000093  00                DCB      0
                  |L3.148|
                          DCD      Global_datas+0x20
                  |L3.152|
000098  6c6f6e67          DCB      "longpress:%d\n",0
00009c  70726573
0000a0  733a2564
0000a4  0a00    
0000a6  00                DCB      0
0000a7  00                DCB      0

                          AREA ||i.Ircordpro||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  Ircordpro PROC
;;;122    
;;;123    uint8_t Ircordpro(void)//红外码值处理函数
000000  b5f8              PUSH     {r3-r7,lr}
;;;124    { 
;;;125      unsigned char i, j, k,temp;
;;;126      unsigned char cord,value = 0;
000002  2000              MOVS     r0,#0
;;;127      uint8_t ir_key =0;
;;;128      uint8_t key_value=0;
;;;129    
;;;130      k=0;
;;;131      for(i=0;i<4;i++)      //处理4个字节
;;;132         {
;;;133          for(j=1;j<=8;j++) //处理1个字节8位
;;;134             {
;;;135              cord=ir_data[k];
000004  4d28              LDR      r5,|L4.168|
;;;136              if(cord>15)//大于某值为1，这个和晶振有绝对关系，这里使用12M计算，此值可以有一定误差
;;;137                 value|=0x80;
;;;138              if(j<8)
;;;139                {
;;;140                 value>>=1;
;;;141                }
;;;142               k++;
;;;143             }
;;;144          ir_code[i]=value & 0xff;
000006  4f29              LDR      r7,|L4.172|
000008  4602              MOV      r2,r0                 ;130
00000a  4603              MOV      r3,r0                 ;131
00000c  2680              MOVS     r6,#0x80              ;137
                  |L4.14|
00000e  2101              MOVS     r1,#1                 ;133
                  |L4.16|
000010  5cac              LDRB     r4,[r5,r2]            ;135
000012  2c0f              CMP      r4,#0xf               ;136
000014  d900              BLS      |L4.24|
000016  4330              ORRS     r0,r0,r6              ;137
                  |L4.24|
000018  2908              CMP      r1,#8                 ;138
00001a  d200              BCS      |L4.30|
00001c  0840              LSRS     r0,r0,#1              ;140
                  |L4.30|
00001e  1c52              ADDS     r2,r2,#1              ;140
000020  1c49              ADDS     r1,r1,#1              ;142
000022  b2c9              UXTB     r1,r1                 ;133
000024  b2d2              UXTB     r2,r2                 ;142
000026  2908              CMP      r1,#8                 ;133
000028  d9f2              BLS      |L4.16|
00002a  54f8              STRB     r0,[r7,r3]
;;;145    	  value = 0;
00002c  1c5b              ADDS     r3,r3,#1
00002e  2000              MOVS     r0,#0
000030  b2db              UXTB     r3,r3                 ;131
000032  2b04              CMP      r3,#4                 ;131
000034  d3eb              BCC      |L4.14|
;;;146    	  
;;;147    	  //printf("KeyData %d:%x\n", i, ir_code[i]);
;;;148          //value=0;     
;;;149         } 
;;;150      
;;;151         DecodeFinishFlag =1;//处理完毕标志位置1
000036  4c1d              LDR      r4,|L4.172|
000038  2001              MOVS     r0,#1
00003a  3c0c              SUBS     r4,r4,#0xc
00003c  7060              STRB     r0,[r4,#1]
;;;152    
;;;153    
;;;154    	 ///////////////////////////////////////////////////////////////////////////
;;;155    
;;;156    	 //if((ir_code[0] == 0x40) && (ir_code[1] == 0xbf))// cs code is ok  0x40bf
;;;157    	 if((ir_code[0] == 0x12) && (ir_code[1] == 0x34))// cs code is ok  0x1234
00003e  7838              LDRB     r0,[r7,#0]  ; ir_code
000040  2812              CMP      r0,#0x12
000042  d002              BEQ      |L4.74|
;;;158    	 {
;;;159    		key_value = ir_code[2];
;;;160    	  //  printf("keyvalue:%x\n", key_value);
;;;161    
;;;162    		for(temp=0;temp<11;temp++)
;;;163    		{
;;;164    			if(IrKeyMap[temp][1] == key_value)
;;;165    			{
;;;166    				ir_key = IrKeyMap[temp][0];
;;;167    				printf("ir_key_num:%d\n", temp);
;;;168    				key_value_bak = ir_key;
;;;169    				return ir_key;
;;;170    			}
;;;171    		}
;;;172    	 }
;;;173    	 else if((ir_code[0] == 0x0c) && (ir_code[1] == 0xf3))// cs code is ok  0x1234
000044  280c              CMP      r0,#0xc
000046  d012              BEQ      |L4.110|
000048  e02b              B        |L4.162|
                  |L4.74|
00004a  7878              LDRB     r0,[r7,#1]            ;157  ; ir_code
00004c  2834              CMP      r0,#0x34              ;157
00004e  d128              BNE      |L4.162|
000050  4816              LDR      r0,|L4.172|
000052  78ba              LDRB     r2,[r7,#2]            ;159  ; ir_code
000054  2100              MOVS     r1,#0                 ;162
000056  3008              ADDS     r0,r0,#8              ;164
                  |L4.88|
000058  004b              LSLS     r3,r1,#1              ;164
00005a  18cb              ADDS     r3,r1,r3              ;164
00005c  181b              ADDS     r3,r3,r0              ;164
00005e  785b              LDRB     r3,[r3,#1]            ;164
000060  4293              CMP      r3,r2                 ;164
000062  d011              BEQ      |L4.136|
000064  1c49              ADDS     r1,r1,#1              ;164
000066  b2c9              UXTB     r1,r1                 ;162
000068  290b              CMP      r1,#0xb               ;162
00006a  d3f5              BCC      |L4.88|
00006c  e019              B        |L4.162|
                  |L4.110|
00006e  7878              LDRB     r0,[r7,#1]  ; ir_code
000070  28f3              CMP      r0,#0xf3
000072  d116              BNE      |L4.162|
;;;174    	 {
;;;175    		key_value = ir_code[2];
;;;176    	  //  printf("keyvalue:%x\n", key_value);
;;;177    
;;;178    		for(temp=0;temp<11;temp++)
;;;179    		{
;;;180    			if(IrKeyMap_B[temp][1] == key_value)
000074  480d              LDR      r0,|L4.172|
000076  78ba              LDRB     r2,[r7,#2]            ;175  ; ir_code
000078  2100              MOVS     r1,#0                 ;178
00007a  302c              ADDS     r0,r0,#0x2c
                  |L4.124|
00007c  004b              LSLS     r3,r1,#1
00007e  18cb              ADDS     r3,r1,r3
000080  181b              ADDS     r3,r3,r0
000082  785b              LDRB     r3,[r3,#1]
000084  4293              CMP      r3,r2
000086  d108              BNE      |L4.154|
                  |L4.136|
;;;181    			{
;;;182    				ir_key = IrKeyMap_B[temp][0];
000088  004a              LSLS     r2,r1,#1
00008a  188a              ADDS     r2,r1,r2
00008c  5c85              LDRB     r5,[r0,r2]
;;;183    				printf("ir_key_num:%d\n", temp);
00008e  a008              ADR      r0,|L4.176|
000090  f7fffffe          BL       __2printf
;;;184    				key_value_bak = ir_key;
000094  7125              STRB     r5,[r4,#4]
;;;185    				return ir_key;
000096  4628              MOV      r0,r5
;;;186    			}
;;;187    		}
;;;188    	 }
;;;189    	 return IR_KEY_NONE;
;;;190    }
000098  bdf8              POP      {r3-r7,pc}
                  |L4.154|
00009a  1c49              ADDS     r1,r1,#1
00009c  b2c9              UXTB     r1,r1                 ;178
00009e  290b              CMP      r1,#0xb               ;178
0000a0  d3ec              BCC      |L4.124|
                  |L4.162|
0000a2  2000              MOVS     r0,#0                 ;189
0000a4  bdf8              POP      {r3-r7,pc}
;;;191    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L4.168|
                          DCD      ||.bss||
                  |L4.172|
                          DCD      ||.data||+0xc
                  |L4.176|
0000b0  69725f6b          DCB      "ir_key_num:%d\n",0
0000b4  65795f6e
0000b8  756d3a25
0000bc  640a00  
0000bf  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ir_data
                          %        33

                          AREA ||.data||, DATA, ALIGN=2

                  DecodeStartFlag
000000  00                DCB      0x00
                  DecodeFinishFlag
000001  00                DCB      0x00
                  ir_data_rx_ok
000002  00                DCB      0x00
                  LongKeyPress
000003  00                DCB      0x00
                  key_value_bak
000004  00                DCB      0x00
                  i
000005  000000            DCB      0x00,0x00,0x00
                  IrTimerCount
                          DCD      0x00000000
                  ir_code
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  repeat_time
                          DCD      0x00000000
                  IrKeyMap
000014  1d201e1f          DCB      0x1d,0x20,0x1e,0x1f
000018  24002022          DCB      0x24,0x00,0x20,0x22
00001c  21222123          DCB      0x21,0x22,0x21,0x23
000020  26282728          DCB      0x26,0x28,0x27,0x28
000024  27292426          DCB      0x27,0x29,0x24,0x26
000028  252a2300          DCB      0x25,0x2a,0x23,0x00
00002c  2b25002c          DCB      0x2b,0x25,0x00,0x2c
000030  29002d2a          DCB      0x29,0x00,0x2d,0x2a
000034  0000aa00          DCB      0x00,0x00,0xaa,0x00
                  IrKeyMap_B
000038  1dd0001f          DCB      0x1d,0xd0,0x00,0x1f
00003c  d40020d2          DCB      0xd4,0x00,0x20,0xd2
000040  2122d123          DCB      0x21,0x22,0xd1,0x23
000044  26d82728          DCB      0x26,0xd8,0x27,0x28
000048  d72924d6          DCB      0xd7,0x29,0x24,0xd6
00004c  252ad300          DCB      0x25,0x2a,0xd3,0x00
000050  2bd5002c          DCB      0x2b,0xd5,0x00,0x2c
000054  d9002dda          DCB      0xd9,0x00,0x2d,0xda
000058  0000aa00          DCB      0x00,0x00,0xaa,0x00

;*** Start embedded assembler ***

#line 1 "..\\src\\driver\\drv_ irkey.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_drv__irkey_c_66de5768____REV16|
#line 388 "..\\lib\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_drv__irkey_c_66de5768____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_drv__irkey_c_66de5768____REVSH|
#line 402
|__asm___12_drv__irkey_c_66de5768____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
