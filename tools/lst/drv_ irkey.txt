; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o".\obj\drv_ irkey.o" --asm_dir=.\lst\ --list_dir=.\lst\ --depend=".\obj\drv_ irkey.d" --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\lib\CMSIS\Include -I..\lib\Device\Nuvoton\NUC029xGE\Include -I..\lib\StdDriver\inc -I..\src\core\include -I..\src\driver\include -I..\src\io\include -I..\src\global -I..\src\server\include -I..\src\driver\audio -D__UVISION_VERSION=522 --omf_browse=".\obj\drv_ irkey.crf" "..\src\driver\drv_ irkey.c"]
                          THUMB

                          AREA ||i.Drv_IrKey_init||, CODE, READONLY, ALIGN=2

                  Drv_IrKey_init PROC
;;;115    
;;;116    void Drv_IrKey_init(void)
000000  b510              PUSH     {r4,lr}
;;;117    {
;;;118    
;;;119    	GPIO_SetMode(PD, BIT0,  GPIO_MODE_INPUT);
000002  4c09              LDR      r4,|L1.40|
000004  2200              MOVS     r2,#0
000006  2101              MOVS     r1,#1
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;120    	GPIO_EnableInt(PD, 0, GPIO_INT_FALLING);
00000e  2201              MOVS     r2,#1
000010  2100              MOVS     r1,#0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_EnableInt
000018  2201              MOVS     r2,#1
00001a  4904              LDR      r1,|L1.44|
00001c  2020              MOVS     r0,#0x20
00001e  6008              STR      r0,[r1,#0]
;;;121    	
;;;122    	NVIC_EnableIRQ(GPCDEF_IRQn);  
;;;123        GPIO_ENABLE_DEBOUNCE(PD, BIT0);
000020  6961              LDR      r1,[r4,#0x14]
000022  4311              ORRS     r1,r1,r2
000024  6161              STR      r1,[r4,#0x14]
;;;124    }
000026  bd10              POP      {r4,pc}
;;;125    
                          ENDP

                  |L1.40|
                          DCD      0x500040c0
                  |L1.44|
                          DCD      0xe000e100

                          AREA ||i.GPCDEF_IRQHandler||, CODE, READONLY, ALIGN=2

                  GPCDEF_IRQHandler PROC
;;;30     
;;;31     void GPCDEF_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;32     {
;;;33         volatile uint32_t temp;
;;;34     	static uint8_t i = 0;
;;;35     	static uint32_t repeat_time = 0;	
;;;36     
;;;37     	    if(GPIO_GET_INT_FLAG(PD,BIT0)) // IR KEY
000002  4822              LDR      r0,|L2.140|
000004  6a01              LDR      r1,[r0,#0x20]
000006  07c9              LSLS     r1,r1,#31
000008  d00f              BEQ      |L2.42|
;;;38     		{
;;;39     	        GPIO_CLR_INT_FLAG(PD, BIT0);
00000a  2501              MOVS     r5,#1
00000c  6205              STR      r5,[r0,#0x20]
;;;40     
;;;41     			if((IrTimerCount > 120) && (IrTimerCount < 145))// start code  14ms
00000e  4c20              LDR      r4,|L2.144|
;;;42     			{
;;;43     				//	printf("IR KEY:%d\n",IrTimerCount);
;;;44     					DecodeStartFlag = 1;
;;;45     					IrTimerCount = 0;
;;;46     					i = 0;
;;;47     					repeat_time = 0;
;;;48     					LongKeyPress = 0;
;;;49     					//key_value_bak = 0;
;;;50     					Global_datas.ir_bak_key = IN_KEY_NONE;
000010  4e20              LDR      r6,|L2.148|
000012  68a1              LDR      r1,[r4,#8]            ;41  ; IrTimerCount
000014  2000              MOVS     r0,#0
000016  460a              MOV      r2,r1                 ;41
000018  3a79              SUBS     r2,r2,#0x79           ;41
00001a  2a18              CMP      r2,#0x18              ;41
00001c  d206              BCS      |L2.44|
00001e  7025              STRB     r5,[r4,#0]            ;44
000020  60a0              STR      r0,[r4,#8]            ;46  ; IrTimerCount
000022  7120              STRB     r0,[r4,#4]            ;46
000024  6120              STR      r0,[r4,#0x10]         ;48  ; repeat_time
000026  70e0              STRB     r0,[r4,#3]            ;48
000028  7630              STRB     r0,[r6,#0x18]
                  |L2.42|
;;;51     			}
;;;52     			else if((IrTimerCount > 23) && (IrTimerCount < 120))
;;;53     			{
;;;54     				IrTimerCount = 0;
;;;55     				//printf("REPPPPPPPPPPPPPPP\n");
;;;56     
;;;57     				TimeOutSet(&IrLongPressTimer, 300);
;;;58     
;;;59     				if((Global_datas.ir_bak_key  == IR_KEY_PLAY_PAUSE) || (Global_datas.ir_bak_key == IR_KEY_POWER))
;;;60     				{
;;;61     					if(repeat_time < 15)
;;;62     					{
;;;63     						repeat_time++;
;;;64     						if(repeat_time == 15)
;;;65     						{
;;;66     							LongKeyPress = 1;
;;;67     						}
;;;68     					}
;;;69     				}
;;;70     				else
;;;71     				{
;;;72     					repeat_time++;
;;;73     					if(repeat_time <10)
;;;74     					{
;;;75     						;
;;;76     					}
;;;77     					else
;;;78     					{
;;;79     						if(repeat_time%2)
;;;80     						{
;;;81     							LongKeyPress = 1;
;;;82     						}
;;;83     					}
;;;84     
;;;85     
;;;86     				}
;;;87     
;;;88     
;;;89     			}
;;;90     			else 
;;;91     			{
;;;92     			   
;;;93     				if(DecodeStartFlag)
;;;94     				{
;;;95     					ir_data[i] = IrTimerCount;
;;;96     				//	printf("IR KEY %d:%d\n",i,ir_data[i]);
;;;97     					i++;
;;;98     					if(i >= 32)
;;;99     					{
;;;100    						i=0;
;;;101    						ir_data_rx_ok = 1;
;;;102    						DecodeStartFlag = 0;
;;;103    					}
;;;104    				}
;;;105    				IrTimerCount = 0;
;;;106    			}	
;;;107    	    }
;;;108    		
;;;109    }
00002a  bd70              POP      {r4-r6,pc}
                  |L2.44|
00002c  460a              MOV      r2,r1                 ;52
00002e  3a18              SUBS     r2,r2,#0x18           ;52
000030  2a60              CMP      r2,#0x60              ;52
000032  d21b              BCS      |L2.108|
000034  21ff              MOVS     r1,#0xff              ;57
000036  60a0              STR      r0,[r4,#8]            ;57  ; IrTimerCount
000038  312d              ADDS     r1,r1,#0x2d           ;57
00003a  4817              LDR      r0,|L2.152|
00003c  f7fffffe          BL       TimeOutSet
000040  7e30              LDRB     r0,[r6,#0x18]         ;59  ; Global_datas
000042  2870              CMP      r0,#0x70              ;59
000044  d00a              BEQ      |L2.92|
000046  2865              CMP      r0,#0x65              ;59
000048  d008              BEQ      |L2.92|
00004a  6920              LDR      r0,[r4,#0x10]         ;72  ; repeat_time
00004c  1c40              ADDS     r0,r0,#1              ;72
00004e  6120              STR      r0,[r4,#0x10]         ;73  ; repeat_time
000050  280a              CMP      r0,#0xa               ;73
000052  d3ea              BCC      |L2.42|
000054  07c0              LSLS     r0,r0,#31             ;79
000056  d0e8              BEQ      |L2.42|
                  |L2.88|
000058  70e5              STRB     r5,[r4,#3]            ;81
                  |L2.90|
00005a  bd70              POP      {r4-r6,pc}
                  |L2.92|
00005c  6920              LDR      r0,[r4,#0x10]         ;61  ; repeat_time
00005e  280f              CMP      r0,#0xf               ;61
000060  d2fb              BCS      |L2.90|
000062  1c40              ADDS     r0,r0,#1              ;61
000064  6120              STR      r0,[r4,#0x10]         ;64  ; repeat_time
000066  280f              CMP      r0,#0xf               ;64
000068  d0f6              BEQ      |L2.88|
00006a  bd70              POP      {r4-r6,pc}
                  |L2.108|
00006c  7822              LDRB     r2,[r4,#0]            ;93  ; DecodeStartFlag
00006e  2a00              CMP      r2,#0                 ;93
000070  d00a              BEQ      |L2.136|
000072  4b0a              LDR      r3,|L2.156|
000074  7922              LDRB     r2,[r4,#4]            ;95  ; i
000076  5499              STRB     r1,[r3,r2]            ;95
000078  1c52              ADDS     r2,r2,#1              ;95
00007a  b2d1              UXTB     r1,r2                 ;97
00007c  7121              STRB     r1,[r4,#4]            ;97
00007e  2920              CMP      r1,#0x20              ;98
000080  d302              BCC      |L2.136|
000082  7120              STRB     r0,[r4,#4]            ;100
000084  70a5              STRB     r5,[r4,#2]            ;101
000086  7020              STRB     r0,[r4,#0]            ;102
                  |L2.136|
000088  60a0              STR      r0,[r4,#8]            ;105  ; IrTimerCount
00008a  bd70              POP      {r4-r6,pc}
;;;110    		
                          ENDP

                  |L2.140|
                          DCD      0x500040c0
                  |L2.144|
                          DCD      ||.data||
                  |L2.148|
                          DCD      Global_datas+0x80
                  |L2.152|
                          DCD      IrLongPressTimer
                  |L2.156|
                          DCD      ||.bss||

                          AREA ||i.GetIrKey||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  GetIrKey PROC
;;;199    
;;;200    uint8_t GetIrKey(void)
000000  b570              PUSH     {r4-r6,lr}
;;;201    {
;;;202    	uint8_t ir_key_value = 0;
;;;203    	
;;;204    	uint8_t ir_key_hold = 0;
;;;205    
;;;206    	if(ir_data_rx_ok)
000002  4d1f              LDR      r5,|L3.128|
000004  2400              MOVS     r4,#0                 ;204
000006  78a8              LDRB     r0,[r5,#2]  ; ir_data_rx_ok
000008  2800              CMP      r0,#0
00000a  d012              BEQ      |L3.50|
;;;207    	{
;;;208    		printf("ir_data_rx_ok = 1\n");
00000c  a01d              ADR      r0,|L3.132|
00000e  f7fffffe          BL       __2printf
;;;209    		ir_key_value = Ircordpro();
000012  f7fffffe          BL       Ircordpro
;;;210    		ir_data_rx_ok = 0;
000016  2100              MOVS     r1,#0
000018  70a9              STRB     r1,[r5,#2]
;;;211    
;;;212            		
;;;213    		// shoutting down cann't respond any key. idle state only respond power key
;;;214    		if((((Global_datas.state == SYS_PLAY_STATE_IDLE) || (Global_datas.state == SYS_PLAY_STATE_POWERUP)) && (ir_key_value != IR_KEY_POWER)) || (Global_datas.state == SYS_PLAY_STATE_SHUTTING_DOWN)) 
00001a  491f              LDR      r1,|L3.152|
00001c  7e49              LDRB     r1,[r1,#0x19]  ; Global_datas
00001e  2901              CMP      r1,#1
000020  d001              BEQ      |L3.38|
000022  2902              CMP      r1,#2
000024  d101              BNE      |L3.42|
                  |L3.38|
000026  2865              CMP      r0,#0x65
000028  d101              BNE      |L3.46|
                  |L3.42|
00002a  2904              CMP      r1,#4
00002c  d100              BNE      |L3.48|
                  |L3.46|
;;;215    		{
;;;216    			ir_key_value = IR_KEY_NONE;
00002e  2000              MOVS     r0,#0
                  |L3.48|
;;;217    		}
;;;218    		return ir_key_value;
;;;219    	}
;;;220    
;;;221    	if(LongKeyPress)
;;;222    	{
;;;223    		printf("longpress:%d\n", LongKeyPress);
;;;224    		LongKeyPress--;
;;;225    		switch(Global_datas.ir_bak_key)
;;;226    		{
;;;227    			case IR_KEY_PLAY_PAUSE:
;;;228    				ir_key_hold = IR_KEY_PLAY_PAUSE_CP;
;;;229    				break;
;;;230    			
;;;231    			case IR_KEY_POWER:
;;;232    				ir_key_hold = IR_KEY_POWER_CP;
;;;233    				break;
;;;234    			case IR_KEY_VOLUME_DOWN:
;;;235    				ir_key_hold = IR_KEY_VOLUME_DOWN_CP;
;;;236    				break;
;;;237    			case IR_KEY_VOLUME_UP:
;;;238    				ir_key_hold = IR_KEY_VOLUME_UP_CP;
;;;239    				break;
;;;240    			case IR_KEY_PREV_SONG:
;;;241    				ir_key_hold = IR_KEY_PREV_SONG_CP;
;;;242    				break;	
;;;243    			case IR_KEY_NEXT_SONG:
;;;244    				ir_key_hold = IR_KEY_NEXT_SONG_CP;
;;;245    				break;
;;;246    			default:ir_key_hold = IR_KEY_NONE;
;;;247    			break;
;;;248    
;;;249    				
;;;250    		}
;;;251    		return ir_key_hold;
;;;252    		
;;;253    	}
;;;254    	
;;;255    	return IR_KEY_NONE;
;;;256    }
000030  bd70              POP      {r4-r6,pc}
                  |L3.50|
000032  78e9              LDRB     r1,[r5,#3]            ;221  ; LongKeyPress
000034  2900              CMP      r1,#0                 ;221
000036  d0fa              BEQ      |L3.46|
000038  a018              ADR      r0,|L3.156|
00003a  f7fffffe          BL       __2printf
00003e  78e8              LDRB     r0,[r5,#3]            ;224  ; LongKeyPress
000040  1e40              SUBS     r0,r0,#1              ;224
000042  70e8              STRB     r0,[r5,#3]            ;224
000044  4814              LDR      r0,|L3.152|
000046  3060              ADDS     r0,r0,#0x60           ;225
000048  7e00              LDRB     r0,[r0,#0x18]         ;225  ; Global_datas
00004a  286c              CMP      r0,#0x6c              ;225
00004c  d013              BEQ      |L3.118|
00004e  dc06              BGT      |L3.94|
000050  2865              CMP      r0,#0x65              ;225
000052  d00a              BEQ      |L3.106|
000054  2868              CMP      r0,#0x68              ;225
000056  d00c              BEQ      |L3.114|
000058  286a              CMP      r0,#0x6a              ;225
00005a  d10f              BNE      |L3.124|
00005c  e007              B        |L3.110|
                  |L3.94|
00005e  286e              CMP      r0,#0x6e              ;225
000060  d00b              BEQ      |L3.122|
000062  2870              CMP      r0,#0x70              ;225
000064  d10a              BNE      |L3.124|
000066  2471              MOVS     r4,#0x71              ;228
000068  e008              B        |L3.124|
                  |L3.106|
00006a  2466              MOVS     r4,#0x66              ;232
00006c  e006              B        |L3.124|
                  |L3.110|
00006e  246b              MOVS     r4,#0x6b              ;235
000070  e004              B        |L3.124|
                  |L3.114|
000072  2469              MOVS     r4,#0x69              ;238
000074  e002              B        |L3.124|
                  |L3.118|
000076  246d              MOVS     r4,#0x6d              ;241
000078  e000              B        |L3.124|
                  |L3.122|
00007a  246f              MOVS     r4,#0x6f              ;244
                  |L3.124|
00007c  4620              MOV      r0,r4                 ;251
00007e  bd70              POP      {r4-r6,pc}
;;;257    
                          ENDP

                  |L3.128|
                          DCD      ||.data||
                  |L3.132|
000084  69725f64          DCB      "ir_data_rx_ok = 1\n",0
000088  6174615f
00008c  72785f6f
000090  6b203d20
000094  310a00  
000097  00                DCB      0
                  |L3.152|
                          DCD      Global_datas+0x20
                  |L3.156|
00009c  6c6f6e67          DCB      "longpress:%d\n",0
0000a0  70726573
0000a4  733a2564
0000a8  0a00    
0000aa  00                DCB      0
0000ab  00                DCB      0

                          AREA ||i.Ircordpro||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  Ircordpro PROC
;;;127    
;;;128    uint8_t Ircordpro(void)//红外码值处理函数
000000  b5f8              PUSH     {r3-r7,lr}
;;;129    { 
;;;130      unsigned char i, j, k,temp;
;;;131      unsigned char cord,value = 0;
000002  2000              MOVS     r0,#0
;;;132      uint8_t ir_key =0;
;;;133      uint8_t key_value=0;
;;;134    
;;;135      k=0;
;;;136      for(i=0;i<4;i++)      //处理4个字节
;;;137         {
;;;138          for(j=1;j<=8;j++) //处理1个字节8位
;;;139             {
;;;140              cord=ir_data[k];
000004  4d2b              LDR      r5,|L4.180|
;;;141              if(cord>15)//大于某值为1，这个和晶振有绝对关系，这里使用12M计算，此值可以有一定误差
;;;142                 value|=0x80;
;;;143              if(j<8)
;;;144                {
;;;145                 value>>=1;
;;;146                }
;;;147               k++;
;;;148             }
;;;149          ir_code[i]=value & 0xff;
000006  4f2c              LDR      r7,|L4.184|
000008  4602              MOV      r2,r0                 ;135
00000a  4603              MOV      r3,r0                 ;136
00000c  2680              MOVS     r6,#0x80              ;142
                  |L4.14|
00000e  2101              MOVS     r1,#1                 ;138
                  |L4.16|
000010  5cac              LDRB     r4,[r5,r2]            ;140
000012  2c0f              CMP      r4,#0xf               ;141
000014  d900              BLS      |L4.24|
000016  4330              ORRS     r0,r0,r6              ;142
                  |L4.24|
000018  2908              CMP      r1,#8                 ;143
00001a  d200              BCS      |L4.30|
00001c  0840              LSRS     r0,r0,#1              ;145
                  |L4.30|
00001e  1c52              ADDS     r2,r2,#1              ;145
000020  1c49              ADDS     r1,r1,#1              ;147
000022  b2c9              UXTB     r1,r1                 ;138
000024  b2d2              UXTB     r2,r2                 ;147
000026  2908              CMP      r1,#8                 ;138
000028  d9f2              BLS      |L4.16|
00002a  54f8              STRB     r0,[r7,r3]
;;;150    	  value = 0;
00002c  1c5b              ADDS     r3,r3,#1
00002e  2000              MOVS     r0,#0
000030  b2db              UXTB     r3,r3                 ;136
000032  2b04              CMP      r3,#4                 ;136
000034  d3eb              BCC      |L4.14|
;;;151    	  
;;;152    	  //printf("KeyData %d:%x\n", i, ir_code[i]);
;;;153          //value=0;     
;;;154         } 
;;;155      
;;;156         DecodeFinishFlag =1;//处理完毕标志位置1
000036  4920              LDR      r1,|L4.184|
000038  2001              MOVS     r0,#1
00003a  390c              SUBS     r1,r1,#0xc
00003c  7048              STRB     r0,[r1,#1]
;;;157    
;;;158    
;;;159    	 ///////////////////////////////////////////////////////////////////////////
;;;160    
;;;161    	 //if((ir_code[0] == 0x40) && (ir_code[1] == 0xbf))// cs code is ok  0x40bf
;;;162    	 if((ir_code[0] == 0x12) && (ir_code[1] == 0x34))// cs code is ok  0x1234
00003e  7838              LDRB     r0,[r7,#0]  ; ir_code
;;;163    	 {
;;;164    		key_value = ir_code[2];
;;;165    	  //  printf("keyvalue:%x\n", key_value);
;;;166    
;;;167    		for(temp=0;temp<11;temp++)
;;;168    		{
;;;169    			if(IrKeyMap[temp][1] == key_value)
;;;170    			{
;;;171    				ir_key = IrKeyMap[temp][0];
;;;172    				printf("ir_key_num:%d\n", temp);
;;;173    				Global_datas.ir_bak_key = ir_key;
;;;174    				TimeOutSet(&IrLongPressTimer, 500);
000040  25ff              MOVS     r5,#0xff
000042  4c1e              LDR      r4,|L4.188|
000044  35f5              ADDS     r5,r5,#0xf5
000046  2812              CMP      r0,#0x12              ;162
000048  d002              BEQ      |L4.80|
;;;175    				return ir_key;
;;;176    			}
;;;177    		}
;;;178    	 }
;;;179    	 else if((ir_code[0] == 0x0c) && (ir_code[1] == 0xf3))// cs code is ok  0x1234
00004a  280c              CMP      r0,#0xc
00004c  d012              BEQ      |L4.116|
00004e  e02f              B        |L4.176|
                  |L4.80|
000050  7878              LDRB     r0,[r7,#1]            ;162  ; ir_code
000052  2834              CMP      r0,#0x34              ;162
000054  d12c              BNE      |L4.176|
000056  4818              LDR      r0,|L4.184|
000058  78ba              LDRB     r2,[r7,#2]            ;164  ; ir_code
00005a  2100              MOVS     r1,#0                 ;167
00005c  3008              ADDS     r0,r0,#8              ;169
                  |L4.94|
00005e  004b              LSLS     r3,r1,#1              ;169
000060  18cb              ADDS     r3,r1,r3              ;169
000062  181b              ADDS     r3,r3,r0              ;169
000064  785b              LDRB     r3,[r3,#1]            ;169
000066  4293              CMP      r3,r2                 ;169
000068  d011              BEQ      |L4.142|
00006a  1c49              ADDS     r1,r1,#1              ;169
00006c  b2c9              UXTB     r1,r1                 ;167
00006e  290b              CMP      r1,#0xb               ;167
000070  d3f5              BCC      |L4.94|
000072  e01d              B        |L4.176|
                  |L4.116|
000074  7878              LDRB     r0,[r7,#1]  ; ir_code
000076  28f3              CMP      r0,#0xf3
000078  d11a              BNE      |L4.176|
;;;180    	 {
;;;181    		key_value = ir_code[2];
;;;182    	  //  printf("keyvalue:%x\n", key_value);
;;;183    
;;;184    		for(temp=0;temp<11;temp++)
;;;185    		{
;;;186    			if(IrKeyMap_B[temp][1] == key_value)
00007a  480f              LDR      r0,|L4.184|
00007c  78ba              LDRB     r2,[r7,#2]            ;181  ; ir_code
00007e  2100              MOVS     r1,#0                 ;184
000080  302c              ADDS     r0,r0,#0x2c
                  |L4.130|
000082  004b              LSLS     r3,r1,#1
000084  18cb              ADDS     r3,r1,r3
000086  181b              ADDS     r3,r3,r0
000088  785b              LDRB     r3,[r3,#1]
00008a  4293              CMP      r3,r2
00008c  d10c              BNE      |L4.168|
                  |L4.142|
;;;187    			{
;;;188    				ir_key = IrKeyMap_B[temp][0];
00008e  004a              LSLS     r2,r1,#1
000090  188a              ADDS     r2,r1,r2
000092  5c86              LDRB     r6,[r0,r2]
;;;189    				printf("ir_key_num:%d\n", temp);
000094  a00a              ADR      r0,|L4.192|
000096  f7fffffe          BL       __2printf
;;;190    				Global_datas.ir_bak_key = ir_key;
00009a  7626              STRB     r6,[r4,#0x18]
;;;191    				
;;;192    				TimeOutSet(&IrLongPressTimer, 500);
00009c  4629              MOV      r1,r5
00009e  480c              LDR      r0,|L4.208|
0000a0  f7fffffe          BL       TimeOutSet
;;;193    				return ir_key;
0000a4  4630              MOV      r0,r6
;;;194    			}
;;;195    		}
;;;196    	 }
;;;197    	 return IR_KEY_NONE;
;;;198    }
0000a6  bdf8              POP      {r3-r7,pc}
                  |L4.168|
0000a8  1c49              ADDS     r1,r1,#1
0000aa  b2c9              UXTB     r1,r1                 ;184
0000ac  290b              CMP      r1,#0xb               ;184
0000ae  d3e8              BCC      |L4.130|
                  |L4.176|
0000b0  2000              MOVS     r0,#0                 ;197
0000b2  bdf8              POP      {r3-r7,pc}
;;;199    
                          ENDP

                  |L4.180|
                          DCD      ||.bss||
                  |L4.184|
                          DCD      ||.data||+0xc
                  |L4.188|
                          DCD      Global_datas+0x80
                  |L4.192|
0000c0  69725f6b          DCB      "ir_key_num:%d\n",0
0000c4  65795f6e
0000c8  756d3a25
0000cc  640a00  
0000cf  00                DCB      0
                  |L4.208|
                          DCD      IrLongPressTimer

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ir_data
                          %        33

                          AREA ||.data||, DATA, ALIGN=2

                  DecodeStartFlag
000000  00                DCB      0x00
                  DecodeFinishFlag
000001  00                DCB      0x00
                  ir_data_rx_ok
000002  00                DCB      0x00
                  LongKeyPress
000003  00                DCB      0x00
                  i
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  IrTimerCount
                          DCD      0x00000000
                  ir_code
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  repeat_time
                          DCD      0x00000000
                  IrKeyMap
000014  65206667          DCB      0x65,0x20,0x66,0x67
000018  24006822          DCB      0x24,0x00,0x68,0x22
00001c  696a216b          DCB      0x69,0x6a,0x21,0x6b
000020  6e286f70          DCB      0x6e,0x28,0x6f,0x70
000024  27716c26          DCB      0x27,0x71,0x6c,0x26
000028  6d722300          DCB      0x6d,0x72,0x23,0x00
00002c  73250074          DCB      0x73,0x25,0x00,0x74
000030  2900752a          DCB      0x29,0x00,0x75,0x2a
000034  0000aa00          DCB      0x00,0x00,0xaa,0x00
                  IrKeyMap_B
000038  65d00067          DCB      0x65,0xd0,0x00,0x67
00003c  d40068d2          DCB      0xd4,0x00,0x68,0xd2
000040  696ad16b          DCB      0x69,0x6a,0xd1,0x6b
000044  6ed86f70          DCB      0x6e,0xd8,0x6f,0x70
000048  d7716cd6          DCB      0xd7,0x71,0x6c,0xd6
00004c  6d72d300          DCB      0x6d,0x72,0xd3,0x00
000050  73d50074          DCB      0x73,0xd5,0x00,0x74
000054  d90075da          DCB      0xd9,0x00,0x75,0xda
000058  0000aa00          DCB      0x00,0x00,0xaa,0x00

;*** Start embedded assembler ***

#line 1 "..\\src\\driver\\drv_ irkey.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_drv__irkey_c_66de5768____REV16|
#line 388 "..\\lib\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_drv__irkey_c_66de5768____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_drv__irkey_c_66de5768____REVSH|
#line 402
|__asm___12_drv__irkey_c_66de5768____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
