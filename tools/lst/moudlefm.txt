; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\moudlefm.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\moudlefm.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\lib\CMSIS\Include -I..\lib\Device\Nuvoton\NUC029xGE\Include -I..\lib\StdDriver\inc -I..\src\core\include -I..\src\driver\include -I..\src\io\include -I..\src\global -I..\src\server\include -I..\src\driver\audio -D__UVISION_VERSION=522 --omf_browse=.\obj\moudlefm.crf ..\src\driver\MoudleFm.c]
                          THUMB

                          AREA ||i.FmIoConfig||, CODE, READONLY, ALIGN=2

                  FmIoConfig PROC
;;;74     
;;;75     void FmIoConfig(void)
000000  b510              PUSH     {r4,lr}
;;;76     {
;;;77     	GPIO_SetMode(PA, BIT11, GPIO_MODE_OUTPUT);
000002  4c06              LDR      r4,|L1.28|
000004  2201              MOVS     r2,#1
000006  02d1              LSLS     r1,r2,#11
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;78     	GPIO_SetMode(PA, BIT10, GPIO_MODE_QUASI);
00000e  2101              MOVS     r1,#1
000010  2203              MOVS     r2,#3
000012  0289              LSLS     r1,r1,#10
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       GPIO_SetMode
;;;79     }
00001a  bd10              POP      {r4,pc}
;;;80     
                          ENDP

                  |L1.28|
                          DCD      0x50004000

                          AREA ||i.Fm_Rest||, CODE, READONLY, ALIGN=2

                  Fm_Rest PROC
;;;85     /*---------------------------------------------------------------------------------------------------------*/
;;;86     void Fm_Rest(void)
000000  b510              PUSH     {r4,lr}
;;;87     {
;;;88     	int i;
;;;89     
;;;90     	// FM reset
;;;91     	GPIO_SetMode(PE, BIT11, GPIO_MODE_OUTPUT); //high en, low dis
000002  2201              MOVS     r2,#1
000004  02d1              LSLS     r1,r2,#11
000006  480a              LDR      r0,|L2.48|
000008  f7fffffe          BL       GPIO_SetMode
;;;92     
;;;93     	PE11 = 1;
00000c  4a09              LDR      r2,|L2.52|
00000e  2301              MOVS     r3,#1
000010  62d3              STR      r3,[r2,#0x2c]
;;;94     	for(i = 0UL; i < 200000 ; ++i)
000012  4909              LDR      r1,|L2.56|
000014  2000              MOVS     r0,#0
                  |L2.22|
;;;95     	{
;;;96     	   __NOP();
000016  bf00              NOP      
000018  1c40              ADDS     r0,r0,#1
00001a  4288              CMP      r0,r1                 ;94
00001c  dbfb              BLT      |L2.22|
;;;97     	}
;;;98     	PE11 = 0;
00001e  2000              MOVS     r0,#0
000020  62d0              STR      r0,[r2,#0x2c]
                  |L2.34|
;;;99     	for(i = 0UL; i < 200000 ; ++i)
;;;100    	{
;;;101    	   __NOP();
000022  bf00              NOP      
000024  1c40              ADDS     r0,r0,#1
000026  4288              CMP      r0,r1                 ;99
000028  dbfb              BLT      |L2.34|
;;;102    	}
;;;103    	PE11 = 1;
00002a  62d3              STR      r3,[r2,#0x2c]
;;;104    }
00002c  bd10              POP      {r4,pc}
;;;105    
                          ENDP

00002e  0000              DCW      0x0000
                  |L2.48|
                          DCD      0x50004100
                  |L2.52|
                          DCD      0x50004300
                  |L2.56|
                          DCD      0x00030d40

                          AREA ||i.IsCurrentStationNunValid||, CODE, READONLY, ALIGN=2

                  IsCurrentStationNunValid PROC
;;;1259   
;;;1260   uint8_t IsCurrentStationNunValid(void)
000000  4905              LDR      r1,|L3.24|
;;;1261   {
;;;1262   	if((Global_datas.FmData.current_station <= FM_MAX_STATION_NUM) && (Global_datas.FmData.current_station <= Global_datas.FmData.station_num))
000002  7988              LDRB     r0,[r1,#6]  ; Global_datas
000004  280f              CMP      r0,#0xf
000006  d804              BHI      |L3.18|
000008  7909              LDRB     r1,[r1,#4]  ; Global_datas
00000a  4288              CMP      r0,r1
00000c  d801              BHI      |L3.18|
;;;1263   		return 1;
00000e  2001              MOVS     r0,#1
;;;1264   	else return 0;
;;;1265   }
000010  4770              BX       lr
                  |L3.18|
000012  2000              MOVS     r0,#0                 ;1264
000014  4770              BX       lr
;;;1266   
                          ENDP

000016  0000              DCW      0x0000
                  |L3.24|
                          DCD      Global_datas+0x80

                          AREA ||i.IsFreqValid||, CODE, READONLY, ALIGN=2

                  IsFreqValid PROC
;;;1243   
;;;1244   uint8_t IsFreqValid(void)
000000  4805              LDR      r0,|L4.24|
;;;1245   {
;;;1246   	if(Global_datas.FmData.Frequency >= 8750 && Global_datas.FmData.Frequency <= 10800)
000002  4906              LDR      r1,|L4.28|
000004  6c00              LDR      r0,[r0,#0x40]  ; Global_datas
000006  1840              ADDS     r0,r0,r1
000008  4905              LDR      r1,|L4.32|
00000a  4288              CMP      r0,r1
00000c  d801              BHI      |L4.18|
;;;1247   		return 1;
00000e  2001              MOVS     r0,#1
;;;1248   	else
;;;1249   		return 0;
;;;1250   }
000010  4770              BX       lr
                  |L4.18|
000012  2000              MOVS     r0,#0                 ;1249
000014  4770              BX       lr
;;;1251   
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      Global_datas
                  |L4.28|
                          DCD      0xffffddd2
                  |L4.32|
                          DCD      0x00000802

                          AREA ||i.IsStationNumValid||, CODE, READONLY, ALIGN=2

                  IsStationNumValid PROC
;;;1251   
;;;1252   uint8_t IsStationNumValid(void)
000000  4803              LDR      r0,|L5.16|
;;;1253   {
;;;1254   	if(Global_datas.FmData.station_num <= FM_MAX_STATION_NUM)
000002  7900              LDRB     r0,[r0,#4]  ; Global_datas
000004  280f              CMP      r0,#0xf
000006  d801              BHI      |L5.12|
;;;1255   		return 1;
000008  2001              MOVS     r0,#1
;;;1256   	else return 0;
;;;1257   }
00000a  4770              BX       lr
                  |L5.12|
00000c  2000              MOVS     r0,#0                 ;1256
00000e  4770              BX       lr
;;;1258   
                          ENDP

                  |L5.16|
                          DCD      Global_datas+0x80

                          AREA ||i.WaitMs||, CODE, READONLY, ALIGN=2

                  WaitMs PROC
;;;128    
;;;129    void WaitMs(uint32_t time)
000000  2200              MOVS     r2,#0
;;;130    {
;;;131    	uint32_t i,j;
;;;132    	for(i=0;i<time;i++)
;;;133    	{
;;;134    		for(j=0;j<10000;j++);
000002  4b05              LDR      r3,|L6.24|
000004  e004              B        |L6.16|
                  |L6.6|
000006  2100              MOVS     r1,#0
                  |L6.8|
000008  1c49              ADDS     r1,r1,#1
00000a  4299              CMP      r1,r3
00000c  d3fc              BCC      |L6.8|
00000e  1c52              ADDS     r2,r2,#1
                  |L6.16|
000010  4282              CMP      r2,r0                 ;132
000012  d3f8              BCC      |L6.6|
;;;135    	}
;;;136    }
000014  4770              BX       lr
;;;137    
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      0x00002710

                          AREA ||i.die||, CODE, READONLY, ALIGN=1

                  ||die|| PROC
;;;148    //-----------------------------------------------------------------------------
;;;149    void die(void)
000000  2000              MOVS     r0,#0
                  |L7.2|
;;;150    {
;;;151    	uint8_t i;
;;;152    	for(i=0;i<5;i++);
000002  1c40              ADDS     r0,r0,#1
000004  b2c0              UXTB     r0,r0
000006  2805              CMP      r0,#5
000008  d3fb              BCC      |L7.2|
;;;153      // ;; _nop_(); // put breakpoint here during debug.
;;;154    }
00000a  4770              BX       lr
;;;155    
                          ENDP


                          AREA ||i.fmRsqStatus||, CODE, READONLY, ALIGN=2

                  fmRsqStatus PROC
;;;1153   //-----------------------------------------------------------------------------
;;;1154   void fmRsqStatus(uint8_t intack)
000000  b510              PUSH     {r4,lr}
;;;1155   {
;;;1156       // Put the ID for the command in the first byte.
;;;1157       cmd[0] = FM_RSQ_STATUS;
000002  4916              LDR      r1,|L8.92|
000004  2223              MOVS     r2,#0x23
000006  700a              STRB     r2,[r1,#0]
;;;1158   
;;;1159   	// Put the flags if the bit was set for the input parameters.
;;;1160   	cmd[1] = 0;
000008  2200              MOVS     r2,#0
00000a  704a              STRB     r2,[r1,#1]
;;;1161   	if(intack) cmd[1] |= FM_RSQ_STATUS_IN_INTACK;
00000c  2800              CMP      r0,#0
00000e  d001              BEQ      |L8.20|
000010  2001              MOVS     r0,#1
000012  7048              STRB     r0,[r1,#1]
                  |L8.20|
;;;1162   
;;;1163       // Invoke the command
;;;1164   	si47xx_command(2, cmd, 8, rsp);
000014  4b12              LDR      r3,|L8.96|
000016  2208              MOVS     r2,#8
000018  4910              LDR      r1,|L8.92|
00001a  2002              MOVS     r0,#2
00001c  f7fffffe          BL       si47xx_command
;;;1165   
;;;1166       // Parse the results
;;;1167   	Status  = rsp[0];
000020  490f              LDR      r1,|L8.96|
000022  480e              LDR      r0,|L8.92|
000024  780a              LDRB     r2,[r1,#0]  ; rsp
000026  3818              SUBS     r0,r0,#0x18
000028  70c2              STRB     r2,[r0,#3]
;;;1168       RsqInts = rsp[1];
00002a  784a              LDRB     r2,[r1,#1]  ; rsp
00002c  7102              STRB     r2,[r0,#4]
;;;1169       SMUTE   = !!(rsp[2] & FM_RSQ_STATUS_OUT_SMUTE);
00002e  788a              LDRB     r2,[r1,#2]  ; rsp
000030  0713              LSLS     r3,r2,#28
000032  0fdb              LSRS     r3,r3,#31
000034  7183              STRB     r3,[r0,#6]
;;;1170       AFCRL   = !!(rsp[2] & FM_RSQ_STATUS_OUT_AFCRL);
000036  0793              LSLS     r3,r2,#30
000038  0fdb              LSRS     r3,r3,#31
;;;1171       Valid   = !!(rsp[2] & FM_RSQ_STATUS_OUT_VALID);
00003a  07d2              LSLS     r2,r2,#31
00003c  7203              STRB     r3,[r0,#8]            ;1170
00003e  0fd2              LSRS     r2,r2,#31
000040  7242              STRB     r2,[r0,#9]
;;;1172       Pilot   = !!(rsp[3] & FM_RSQ_STATUS_OUT_PILOT);
000042  78ca              LDRB     r2,[r1,#3]  ; rsp
000044  09d3              LSRS     r3,r2,#7
;;;1173       Blend   = rsp[3] & FM_RSQ_STATUS_OUT_STBLEND;
000046  0652              LSLS     r2,r2,#25
000048  7283              STRB     r3,[r0,#0xa]          ;1172
00004a  0e52              LSRS     r2,r2,#25
00004c  72c2              STRB     r2,[r0,#0xb]
;;;1174       RSSI    = rsp[4];
00004e  790a              LDRB     r2,[r1,#4]  ; rsp
000050  7302              STRB     r2,[r0,#0xc]
;;;1175       ASNR    = rsp[5];
000052  794a              LDRB     r2,[r1,#5]  ; rsp
000054  7342              STRB     r2,[r0,#0xd]
;;;1176       FreqOff = rsp[7];   
000056  79c9              LDRB     r1,[r1,#7]  ; rsp
000058  7381              STRB     r1,[r0,#0xe]
;;;1177   }
00005a  bd10              POP      {r4,pc}
;;;1178   
                          ENDP

                  |L8.92|
                          DCD      ||.data||+0x18
                  |L8.96|
                          DCD      ||.bss||

                          AREA ||i.fmSeekStart||, CODE, READONLY, ALIGN=2

                  fmSeekStart PROC
;;;1071   //-----------------------------------------------------------------------------
;;;1072   void fmSeekStart(uint8_t seekUp, uint8_t wrap)
000000  b510              PUSH     {r4,lr}
;;;1073   {
;;;1074       // Put the ID for the command in the first byte.
;;;1075       cmd[0] = FM_SEEK_START;
000002  4a0b              LDR      r2,|L9.48|
000004  2321              MOVS     r3,#0x21
000006  7013              STRB     r3,[r2,#0]
;;;1076   
;;;1077   	// Put the flags if the bit was set for the input parameters.
;;;1078   	cmd[1] = 0;
000008  2300              MOVS     r3,#0
00000a  7053              STRB     r3,[r2,#1]
;;;1079       if(seekUp) cmd[1] |= FM_SEEK_START_IN_SEEKUP;
00000c  2800              CMP      r0,#0
00000e  d001              BEQ      |L9.20|
000010  2008              MOVS     r0,#8
000012  7050              STRB     r0,[r2,#1]
                  |L9.20|
;;;1080   	if(wrap)   cmd[1] |= FM_SEEK_START_IN_WRAP;
000014  2900              CMP      r1,#0
000016  d003              BEQ      |L9.32|
000018  7850              LDRB     r0,[r2,#1]  ; cmd
00001a  2104              MOVS     r1,#4
00001c  4308              ORRS     r0,r0,r1
00001e  7050              STRB     r0,[r2,#1]
                  |L9.32|
;;;1081   
;;;1082       // Invoke the command
;;;1083   	si47xx_command(2, cmd, 1, rsp);
000020  4b04              LDR      r3,|L9.52|
000022  2201              MOVS     r2,#1
000024  4902              LDR      r1,|L9.48|
000026  2002              MOVS     r0,#2
000028  f7fffffe          BL       si47xx_command
;;;1084   }
00002c  bd10              POP      {r4,pc}
;;;1085   
                          ENDP

00002e  0000              DCW      0x0000
                  |L9.48|
                          DCD      ||.data||+0x18
                  |L9.52|
                          DCD      ||.bss||

                          AREA ||i.fmTuneFreq||, CODE, READONLY, ALIGN=2

                  fmTuneFreq PROC
;;;1044   //-----------------------------------------------------------------------------
;;;1045   void fmTuneFreq(uint32_t frequency)
000000  b510              PUSH     {r4,lr}
;;;1046   {
;;;1047       // Put the ID for the command in the first byte.
;;;1048       cmd[0] = FM_TUNE_FREQ;
000002  4907              LDR      r1,|L10.32|
000004  2220              MOVS     r2,#0x20
000006  700a              STRB     r2,[r1,#0]
;;;1049   
;;;1050   	// Initialize the reserved section to 0
;;;1051       cmd[1] = 0;
000008  2200              MOVS     r2,#0
00000a  704a              STRB     r2,[r1,#1]
;;;1052   
;;;1053   	// Put the frequency in the second and third bytes.
;;;1054       cmd[2] = (uint8_t)(frequency >> 8);
00000c  0a03              LSRS     r3,r0,#8
00000e  708b              STRB     r3,[r1,#2]
;;;1055   	cmd[3] = (uint8_t)(frequency & 0x00FF);
000010  70c8              STRB     r0,[r1,#3]
;;;1056   
;;;1057   	// Set the antenna calibration value.
;;;1058       cmd[4] = (uint8_t)0;  // Auto
000012  710a              STRB     r2,[r1,#4]
;;;1059   
;;;1060       // Invoke the command
;;;1061   	si47xx_command(5, cmd, 1, rsp);
000014  4b03              LDR      r3,|L10.36|
000016  2201              MOVS     r2,#1
000018  2005              MOVS     r0,#5
00001a  f7fffffe          BL       si47xx_command
;;;1062   }
00001e  bd10              POP      {r4,pc}
;;;1063   
                          ENDP

                  |L10.32|
                          DCD      ||.data||+0x18
                  |L10.36|
                          DCD      ||.bss||

                          AREA ||i.fmTuneStatus||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  fmTuneStatus PROC
;;;1102   //-----------------------------------------------------------------------------
;;;1103   void fmTuneStatus(uint8_t cancel, uint8_t intack)
000000  b510              PUSH     {r4,lr}
;;;1104   {
;;;1105   
;;;1106   
;;;1107       // Put the ID for the command in the first byte.
;;;1108       cmd[0] = FM_TUNE_STATUS;
000002  4a1e              LDR      r2,|L11.124|
000004  2322              MOVS     r3,#0x22
000006  7013              STRB     r3,[r2,#0]
;;;1109   
;;;1110   	// Put the flags if the bit was set for the input parameters.
;;;1111   	cmd[1] = 0;
000008  2300              MOVS     r3,#0
00000a  7053              STRB     r3,[r2,#1]
;;;1112       if(cancel) cmd[1] |= FM_TUNE_STATUS_IN_CANCEL;
00000c  2800              CMP      r0,#0
00000e  d001              BEQ      |L11.20|
000010  2002              MOVS     r0,#2
000012  7050              STRB     r0,[r2,#1]
                  |L11.20|
;;;1113   	if(intack) cmd[1] |= FM_TUNE_STATUS_IN_INTACK;
000014  2900              CMP      r1,#0
000016  d003              BEQ      |L11.32|
000018  7850              LDRB     r0,[r2,#1]  ; cmd
00001a  2101              MOVS     r1,#1
00001c  4308              ORRS     r0,r0,r1
00001e  7050              STRB     r0,[r2,#1]
                  |L11.32|
;;;1114   
;;;1115       // Invoke the command
;;;1116   	si47xx_command(2, cmd, 8, rsp);
000020  4b17              LDR      r3,|L11.128|
000022  2208              MOVS     r2,#8
000024  4915              LDR      r1,|L11.124|
000026  2002              MOVS     r0,#2
000028  f7fffffe          BL       si47xx_command
;;;1117   
;;;1118       // Parse the results
;;;1119       STC    = !!(rsp[0] & STCINT);
00002c  4814              LDR      r0,|L11.128|
00002e  4c13              LDR      r4,|L11.124|
000030  7801              LDRB     r1,[r0,#0]  ; rsp
000032  3c18              SUBS     r4,r4,#0x18
000034  07c9              LSLS     r1,r1,#31
000036  0fc9              LSRS     r1,r1,#31
000038  7161              STRB     r1,[r4,#5]
;;;1120       BLTF   = !!(rsp[1] & FM_TUNE_STATUS_OUT_BTLF);
00003a  7841              LDRB     r1,[r0,#1]  ; rsp
00003c  09ca              LSRS     r2,r1,#7
00003e  71e2              STRB     r2,[r4,#7]
;;;1121       AFCRL  = !!(rsp[1] & FM_TUNE_STATUS_OUT_AFCRL);
000040  078a              LSLS     r2,r1,#30
000042  0fd2              LSRS     r2,r2,#31
;;;1122       Valid  = !!(rsp[1] & FM_TUNE_STATUS_OUT_VALID);
000044  07c9              LSLS     r1,r1,#31
000046  7222              STRB     r2,[r4,#8]            ;1121
000048  0fc9              LSRS     r1,r1,#31
00004a  7261              STRB     r1,[r4,#9]
;;;1123       Freq   = ((uint32_t)rsp[2] << 8) | (uint32_t)rsp[3];
00004c  78c1              LDRB     r1,[r0,#3]  ; rsp
00004e  7882              LDRB     r2,[r0,#2]  ; rsp
000050  0209              LSLS     r1,r1,#8
000052  4311              ORRS     r1,r1,r2
000054  ba49              REV16    r1,r1
;;;1124       RSSI   = rsp[4];
000056  6121              STR      r1,[r4,#0x10]  ; Freq
000058  7902              LDRB     r2,[r0,#4]  ; rsp
00005a  7322              STRB     r2,[r4,#0xc]
;;;1125       ASNR   = rsp[5];
00005c  7942              LDRB     r2,[r0,#5]  ; rsp
00005e  7362              STRB     r2,[r4,#0xd]
;;;1126       AntCap = rsp[7];   
000060  79c0              LDRB     r0,[r0,#7]  ; rsp
;;;1127   
;;;1128   	printf("read freq: %d\n", Freq);
000062  6160              STR      r0,[r4,#0x14]  ; AntCap
000064  a007              ADR      r0,|L11.132|
000066  f7fffffe          BL       __2printf
;;;1129   	printf("Is valid: %d\n", Valid);
00006a  7a61              LDRB     r1,[r4,#9]  ; Valid
00006c  a009              ADR      r0,|L11.148|
00006e  f7fffffe          BL       __2printf
;;;1130   	printf("RSSI: %d\n", RSSI);
000072  7b21              LDRB     r1,[r4,#0xc]  ; RSSI
000074  a00b              ADR      r0,|L11.164|
000076  f7fffffe          BL       __2printf
;;;1131   
;;;1132   	
;;;1133   }
00007a  bd10              POP      {r4,pc}
;;;1134   
                          ENDP

                  |L11.124|
                          DCD      ||.data||+0x18
                  |L11.128|
                          DCD      ||.bss||
                  |L11.132|
000084  72656164          DCB      "read freq: %d\n",0
000088  20667265
00008c  713a2025
000090  640a00  
000093  00                DCB      0
                  |L11.148|
000094  49732076          DCB      "Is valid: %d\n",0
000098  616c6964
00009c  3a202564
0000a0  0a00    
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L11.164|
0000a4  52535349          DCB      "RSSI: %d\n",0
0000a8  3a202564
0000ac  0a00    
0000ae  00                DCB      0
0000af  00                DCB      0

                          AREA ||i.getIntStatus||, CODE, READONLY, ALIGN=1

                  getIntStatus PROC
;;;527    //-----------------------------------------------------------------------------
;;;528    uint8_t getIntStatus(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;529    {
;;;530        uint8_t  cmd[1] = {0};
000002  2000              MOVS     r0,#0
;;;531        uint8_t  rsp[1] = {0};
000004  9000              STR      r0,[sp,#0]
;;;532    
;;;533        // Put the ID for the command in the first byte.
;;;534        cmd[0] = GET_INT_STATUS;
000006  9001              STR      r0,[sp,#4]
000008  2014              MOVS     r0,#0x14
00000a  4669              MOV      r1,sp
00000c  7008              STRB     r0,[r1,#0]
;;;535    
;;;536        // Invoke the command
;;;537    	si47xx_command(1, cmd, 1, rsp);
00000e  2201              MOVS     r2,#1
000010  ab01              ADD      r3,sp,#4
000012  4610              MOV      r0,r2
000014  f7fffffe          BL       si47xx_command
;;;538    
;;;539    	// Return the status
;;;540    	return rsp[0];
000018  4669              MOV      r1,sp
00001a  7908              LDRB     r0,[r1,#4]
;;;541    }
00001c  bd1c              POP      {r2-r4,pc}
;;;542    
                          ENDP


                          AREA ||i.io2w_read||, CODE, READONLY, ALIGN=1

                  io2w_read PROC
;;;402    //-----------------------------------------------------------------------------
;;;403    void io2w_read(int number_bytes, uint8_t *data_in)
000000  b570              PUSH     {r4-r6,lr}
;;;404    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;405        uint8_t addr;
;;;406    
;;;407    	
;;;408    
;;;409        // issue the START condition with address lsb set for reads
;;;410        io2w_start(SI4730_ADDRESS, READ);
000006  2101              MOVS     r1,#1
000008  2022              MOVS     r0,#0x22
00000a  f7fffffe          BL       io2w_start
;;;411    
;;;412    
;;;413    
;;;414        // loop until the specified number of bytes have been read
;;;415        while(number_bytes--)
00000e  e004              B        |L13.26|
                  |L13.16|
;;;416        {
;;;417            *data_in++ = io2w_read_byte(number_bytes);
000010  b2e8              UXTB     r0,r5
000012  f7fffffe          BL       io2w_read_byte
000016  7020              STRB     r0,[r4,#0]
000018  1c64              ADDS     r4,r4,#1
                  |L13.26|
00001a  1e6d              SUBS     r5,r5,#1
00001c  d2f8              BCS      |L13.16|
;;;418        }
;;;419    
;;;420        // issue the STOP condition
;;;421        io2w_stop();
00001e  f7fffffe          BL       io2w_stop
;;;422    }
000022  bd70              POP      {r4-r6,pc}
;;;423    
                          ENDP


                          AREA ||i.io2w_read_byte||, CODE, READONLY, ALIGN=2

                  io2w_read_byte PROC
;;;315    //-----------------------------------------------------------------------------
;;;316    static uint8_t io2w_read_byte(uint8_t remaining_bytes)
000000  b5f0              PUSH     {r4-r7,lr}
;;;317    {
;;;318        uint8_t i;
;;;319        uint8_t rddata = 0;
000002  2400              MOVS     r4,#0
;;;320    
;;;321       // SDIO_OUT &= ~(SDIO_HEX);  // Configure SDIO as open-drain
;;;322        for( i = 0; i < 8; i++ )
;;;323        {
;;;324            SCLK = 0;
000004  4b13              LDR      r3,|L14.84|
000006  4607              MOV      r7,r0                 ;317
000008  4622              MOV      r2,r4                 ;322
00000a  4626              MOV      r6,r4                 ;322
;;;325            SDIO = 1;                        // Configure P0^7(SDIO) as a digital input
00000c  2501              MOVS     r5,#1
                  |L14.14|
00000e  62de              STR      r6,[r3,#0x2c]         ;324
000010  629d              STR      r5,[r3,#0x28]
;;;326            wait_us(1);                      // tf:IN
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       wait_us
;;;327            wait_us(2);                      // tLOW
000018  2002              MOVS     r0,#2
00001a  f7fffffe          BL       wait_us
;;;328            SCLK = 1;
00001e  62dd              STR      r5,[r3,#0x2c]
;;;329            wait_us(1);                      // tf:IN + tHIGH
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       wait_us
;;;330            rddata = ((rddata << 1) | SDIO);
000026  6a99              LDR      r1,[r3,#0x28]
000028  0060              LSLS     r0,r4,#1
00002a  4308              ORRS     r0,r0,r1
00002c  1c52              ADDS     r2,r2,#1
00002e  b2d2              UXTB     r2,r2                 ;322
000030  b2c4              UXTB     r4,r0
000032  2a08              CMP      r2,#8                 ;322
000034  d3eb              BCC      |L14.14|
;;;331    
;;;332    		
;;;333        }
;;;334        // set the acknowledge
;;;335        SCLK = 0;
000036  62de              STR      r6,[r3,#0x2c]
;;;336    
;;;337       // SDIO_OUT |= SDIO_HEX;   // Configure SDIO as push-pull
;;;338    
;;;339        if (remaining_bytes == 0)
000038  2f00              CMP      r7,#0
00003a  d009              BEQ      |L14.80|
;;;340            SDIO = 1;
;;;341        else
;;;342            SDIO = 0;
00003c  629e              STR      r6,[r3,#0x28]
                  |L14.62|
;;;343    
;;;344        wait_us(2); // tf:IN + tLOW
00003e  2002              MOVS     r0,#2
000040  f7fffffe          BL       wait_us
;;;345        SCLK = 1;
000044  62dd              STR      r5,[r3,#0x2c]
;;;346        wait_us(1); // tf:IN + tHIGH
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       wait_us
;;;347    
;;;348        return rddata;
00004c  4620              MOV      r0,r4
;;;349    }
00004e  bdf0              POP      {r4-r7,pc}
                  |L14.80|
000050  629d              STR      r5,[r3,#0x28]         ;340
000052  e7f4              B        |L14.62|
;;;350    
                          ENDP

                  |L14.84|
                          DCD      0x50004200

                          AREA ||i.io2w_start||, CODE, READONLY, ALIGN=2

                  io2w_start PROC
;;;170    //-----------------------------------------------------------------------------
;;;171    void io2w_start(uint8_t io2w_address, uint8_t operation)
000000  b570              PUSH     {r4-r6,lr}
;;;172    {
;;;173        int i;
;;;174    	int j = 0;
;;;175    
;;;176    	SCLK = 1;
000002  4b1b              LDR      r3,|L15.112|
000004  2601              MOVS     r6,#1
000006  460a              MOV      r2,r1                 ;172
000008  4604              MOV      r4,r0                 ;172
00000a  62de              STR      r6,[r3,#0x2c]
;;;177    	//FM_SDA_OUTPUT_SET;
;;;178    
;;;179        // issue the START condition
;;;180        wait_us(1); // tSU:STA
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       wait_us
;;;181        SDIO = 0;
000012  2500              MOVS     r5,#0
000014  629d              STR      r5,[r3,#0x28]
;;;182        wait_us(1); // tHD:STA
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       wait_us
;;;183        SCLK = 0;
00001c  62dd              STR      r5,[r3,#0x2c]
;;;184    
;;;185        // Set the least significant bit to indicate read or write
;;;186        io2w_address = (io2w_address & 0xFE) | (operation & 0x01);
00001e  07d0              LSLS     r0,r2,#31
000020  43b4              BICS     r4,r4,r6
000022  0fc0              LSRS     r0,r0,#31
000024  4304              ORRS     r4,r4,r0
;;;187    
;;;188    	
;;;189    
;;;190        // issue the control word (7 bit chip address + R/W* bit)
;;;191        // Note that tr:IN + tLOW + tf:IN + tHIGH = 2500 ns = 400 kHz
;;;192        for ( i = 7; i >= 0; i-- )
000026  2207              MOVS     r2,#7
                  |L15.40|
;;;193        {
;;;194            SCLK = 0;
000028  62dd              STR      r5,[r3,#0x2c]
;;;195            wait_us(1); // tf:IN
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       wait_us
000030  4620              MOV      r0,r4
;;;196            SDIO = ((io2w_address >> i) & 0x01);
000032  40d0              LSRS     r0,r0,r2
000034  07c0              LSLS     r0,r0,#31
000036  0fc0              LSRS     r0,r0,#31
000038  6298              STR      r0,[r3,#0x28]
;;;197            wait_us(1); // tLOW
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       wait_us
;;;198            SCLK = 1;
000040  62de              STR      r6,[r3,#0x2c]
;;;199            wait_us(1); // tf:IN + tHIGH
000042  2001              MOVS     r0,#1
000044  f7fffffe          BL       wait_us
000048  1e52              SUBS     r2,r2,#1
00004a  d5ed              BPL      |L15.40|
;;;200    
;;;201        }
;;;202    
;;;203    
;;;204    
;;;205        // check the acknowledge
;;;206    	//SDIO_OUT &= ~(SDIO_HEX);   // Configure SDIO as open-drain
;;;207    
;;;208        SCLK = 0;
00004c  62dd              STR      r5,[r3,#0x2c]
;;;209        SDIO = 1;
00004e  629e              STR      r6,[r3,#0x28]
;;;210        wait_us(2); // tf:IN + tLOW
000050  2002              MOVS     r0,#2
000052  f7fffffe          BL       wait_us
;;;211        SCLK = 1;
000056  62de              STR      r6,[r3,#0x2c]
;;;212        wait_us(1); // tf:IN + tHIGH
000058  2001              MOVS     r0,#1
00005a  f7fffffe          BL       wait_us
;;;213    
;;;214    
;;;215    	//while(SDIO);
;;;216    	
;;;217    /*	while(SDIO)
;;;218    	{
;;;219    	
;;;220    	for(j=0;j<100;j++)
;;;221    	{
;;;222    		wait_us(10);
;;;223    	}
;;;224    
;;;225    	if(j>50) break;
;;;226    
;;;227    	}
;;;228    */
;;;229    
;;;230    	
;;;231        if (SDIO != 0)
00005e  6a98              LDR      r0,[r3,#0x28]
000060  2800              CMP      r0,#0
000062  d004              BEQ      |L15.110|
;;;232        {
;;;233    		die();	// ack not received.  This should never happen. Device isn't responding.
000064  f7fffffe          BL       ||die||
;;;234    		
;;;235    		printf(" die in start function \n");
000068  a002              ADR      r0,|L15.116|
00006a  f7fffffe          BL       __2printf
                  |L15.110|
;;;236    	}
;;;237    }
00006e  bd70              POP      {r4-r6,pc}
;;;238    
                          ENDP

                  |L15.112|
                          DCD      0x50004200
                  |L15.116|
000074  20646965          DCB      " die in start function \n",0
000078  20696e20
00007c  73746172
000080  74206675
000084  6e637469
000088  6f6e200a
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0

                          AREA ||i.io2w_stop||, CODE, READONLY, ALIGN=2

                  io2w_stop PROC
;;;246    //-----------------------------------------------------------------------------
;;;247    static void io2w_stop(void)
000000  b500              PUSH     {lr}
;;;248    {
;;;249       // SDIO_OUT |= SDIO_HEX;  // Configure SDIO as push-pull
;;;250    	SCLK = 0;
000002  4a08              LDR      r2,|L16.36|
000004  2300              MOVS     r3,#0
000006  62d3              STR      r3,[r2,#0x2c]
;;;251        wait_us(2); // tf:IN + tLOW
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       wait_us
;;;252        SDIO = 0;
00000e  6293              STR      r3,[r2,#0x28]
;;;253        wait_us(1);
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       wait_us
;;;254        SCLK = 1;
000016  2301              MOVS     r3,#1
000018  62d3              STR      r3,[r2,#0x2c]
;;;255        wait_us(1); // tf:IN + tSU:STO
00001a  4618              MOV      r0,r3
00001c  f7fffffe          BL       wait_us
;;;256        SDIO = 1;
000020  6293              STR      r3,[r2,#0x28]
;;;257    }
000022  bd00              POP      {pc}
;;;258    
                          ENDP

                  |L16.36|
                          DCD      0x50004200

                          AREA ||i.io2w_write||, CODE, READONLY, ALIGN=1

                  io2w_write PROC
;;;378    //-----------------------------------------------------------------------------
;;;379    void io2w_write(int number_bytes, uint8_t *data_out)
000000  b570              PUSH     {r4-r6,lr}
;;;380    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;381    
;;;382        // issue the START condition with address lsb cleared for writes
;;;383        io2w_start(SI4730_ADDRESS, WRITE);
000006  2100              MOVS     r1,#0
000008  2022              MOVS     r0,#0x22
00000a  f7fffffe          BL       io2w_start
;;;384    
;;;385        // loop writing all bytes in the data_out array
;;;386        while(number_bytes--)
00000e  e003              B        |L17.24|
                  |L17.16|
;;;387        {
;;;388            io2w_write_byte(*data_out++);
000010  7820              LDRB     r0,[r4,#0]
000012  1c64              ADDS     r4,r4,#1
000014  f7fffffe          BL       io2w_write_byte
                  |L17.24|
000018  1e6d              SUBS     r5,r5,#1
00001a  d2f9              BCS      |L17.16|
;;;389        }
;;;390    
;;;391        // issue the STOP condition
;;;392        io2w_stop();
00001c  f7fffffe          BL       io2w_stop
;;;393    }
000020  bd70              POP      {r4-r6,pc}
;;;394    
                          ENDP


                          AREA ||i.io2w_write_byte||, CODE, READONLY, ALIGN=2

                  io2w_write_byte PROC
;;;268    //-----------------------------------------------------------------------------
;;;269    static void io2w_write_byte(uint8_t wrdata)
000000  b570              PUSH     {r4-r6,lr}
;;;270    {
;;;271        int i;
;;;272    
;;;273        //SDIO_OUT |= SDIO_HEX;  // Configure SDIO as push-pull
;;;274        for ( i = 7; i >= 0; i-- )
000002  2207              MOVS     r2,#7
000004  2600              MOVS     r6,#0
;;;275        {
;;;276            SCLK = 0;
000006  4b13              LDR      r3,|L18.84|
000008  4604              MOV      r4,r0                 ;270
;;;277            wait_us(1); // tf:IN
00000a  2501              MOVS     r5,#1
                  |L18.12|
00000c  62de              STR      r6,[r3,#0x2c]         ;276
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       wait_us
000014  4620              MOV      r0,r4
;;;278            SDIO = ((wrdata >> i) & 0x01);
000016  40d0              LSRS     r0,r0,r2
000018  07c0              LSLS     r0,r0,#31
00001a  0fc0              LSRS     r0,r0,#31
00001c  6298              STR      r0,[r3,#0x28]
;;;279            wait_us(2); // tLOW
00001e  2002              MOVS     r0,#2
000020  f7fffffe          BL       wait_us
;;;280            SCLK = 1;
000024  62dd              STR      r5,[r3,#0x2c]
;;;281            wait_us(1); // tf:IN + tHIGH
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       wait_us
00002c  1e52              SUBS     r2,r2,#1
00002e  d5ed              BPL      |L18.12|
;;;282        }
;;;283        // check the acknowledge
;;;284    	//SDIO_OUT &= ~(SDIO_HEX);  // Configure SDIO as open-drain
;;;285        SCLK = 0;
000030  62de              STR      r6,[r3,#0x2c]
;;;286        SDIO = 1;   // Configure P0^7(SDIO) as a digital input
000032  629d              STR      r5,[r3,#0x28]
;;;287        wait_us(2); // tf:IN + tLOW
000034  2002              MOVS     r0,#2
000036  f7fffffe          BL       wait_us
;;;288        SCLK = 1;
00003a  62dd              STR      r5,[r3,#0x2c]
;;;289        wait_us(1); // tf:IN + tHIGH
00003c  2001              MOVS     r0,#1
00003e  f7fffffe          BL       wait_us
;;;290    
;;;291     //   if (SDIO != 0)
;;;292     //       die();  // ack not received.  This should never happen. Device isn't responding.
;;;293    
;;;294        if (SDIO != 0)
000042  6a98              LDR      r0,[r3,#0x28]
000044  2800              CMP      r0,#0
000046  d004              BEQ      |L18.82|
;;;295        {
;;;296    		die();	// ack not received.  This should never happen. Device isn't responding.
000048  f7fffffe          BL       ||die||
;;;297    		
;;;298    		printf(" die in write byte function \n");
00004c  a002              ADR      r0,|L18.88|
00004e  f7fffffe          BL       __2printf
                  |L18.82|
;;;299    	}	
;;;300    }
000052  bd70              POP      {r4-r6,pc}
;;;301    
                          ENDP

                  |L18.84|
                          DCD      0x50004200
                  |L18.88|
000058  20646965          DCB      " die in write byte function \n",0
00005c  20696e20
000060  77726974
000064  65206279
000068  74652066
00006c  756e6374
000070  696f6e20
000074  0a00    
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||i.quickAFTune||, CODE, READONLY, ALIGN=2

                  quickAFTune PROC
;;;1020   //-----------------------------------------------------------------------------
;;;1021   uint8_t quickAFTune(uint32_t freq)
000000  b570              PUSH     {r4-r6,lr}
;;;1022   {
000002  4605              MOV      r5,r0
;;;1023   	uint32_t current_freq = 0;
;;;1024   	uint8_t  current_rssi = 0;
;;;1025   
;;;1026   	// Get the current frequency from the part
;;;1027       fmTuneStatus(0, 0);
000004  2100              MOVS     r1,#0
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       fmTuneStatus
;;;1028   	current_freq = Freq;
00000c  4805              LDR      r0,|L19.36|
;;;1029   
;;;1030       // Tune to the AF frequency, check the RSSI, tune back
;;;1031       current_rssi = si47xxFMRX_tune(freq);
00000e  6904              LDR      r4,[r0,#0x10]  ; Freq
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       si47xxFMRX_tune
000016  4605              MOV      r5,r0
;;;1032   
;;;1033       // Return to the original channel
;;;1034       si47xxFMRX_tune(current_freq);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       si47xxFMRX_tune
;;;1035       return current_rssi;
00001e  4628              MOV      r0,r5
;;;1036   }
000020  bd70              POP      {r4-r6,pc}
;;;1037   
                          ENDP

000022  0000              DCW      0x0000
                  |L19.36|
                          DCD      ||.data||

                          AREA ||i.si47xxFMRX_configure||, CODE, READONLY, ALIGN=2

                  si47xxFMRX_configure PROC
;;;817    //-----------------------------------------------------------------------------
;;;818    void si47xxFMRX_configure(void)
000000  b510              PUSH     {r4,lr}
000002  2105              MOVS     r1,#5
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       si47xx_set_property
00000a  211f              MOVS     r1,#0x1f
00000c  480a              LDR      r0,|L20.56|
00000e  f7fffffe          BL       si47xx_set_property
000012  4809              LDR      r0,|L20.56|
000014  2109              MOVS     r1,#9
000016  1c40              ADDS     r0,r0,#1
000018  f7fffffe          BL       si47xx_set_property
00001c  2103              MOVS     r1,#3
00001e  4807              LDR      r0,|L20.60|
000020  f7fffffe          BL       si47xx_set_property
000024  4805              LDR      r0,|L20.60|
000026  2110              MOVS     r1,#0x10
000028  1c40              ADDS     r0,r0,#1
00002a  f7fffffe          BL       si47xx_set_property
;;;819    {
;;;820        // Configure all other registers
;;;821        si47xxFMRX_hardware_cfg();
;;;822        si47xxFMRX_general_cfg();
;;;823        si47xxFMRX_regional_cfg(USA);
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       si47xxFMRX_regional_cfg
;;;824    
;;;825    }
000034  bd10              POP      {r4,pc}
;;;826    
                          ENDP

000036  0000              DCW      0x0000
                  |L20.56|
                          DCD      0x00001302
                  |L20.60|
                          DCD      0x00001403

                          AREA ||i.si47xxFMRX_digtal_cfg||, CODE, READONLY, ALIGN=2

                  si47xxFMRX_digtal_cfg PROC
;;;806    
;;;807    void si47xxFMRX_digtal_cfg(void)
000000  b510              PUSH     {r4,lr}
;;;808    {
;;;809    
;;;810    	si47xx_set_property(0x0104, 0xbb80);
000002  20ff              MOVS     r0,#0xff
000004  4902              LDR      r1,|L21.16|
000006  3005              ADDS     r0,#5
000008  f7fffffe          BL       si47xx_set_property
;;;811    
;;;812    }
00000c  bd10              POP      {r4,pc}
;;;813    
                          ENDP

00000e  0000              DCW      0x0000
                  |L21.16|
                          DCD      0x0000bb80

                          AREA ||i.si47xxFMRX_get_frequency||, CODE, READONLY, ALIGN=2

                  si47xxFMRX_get_frequency PROC
;;;986    //-----------------------------------------------------------------------------
;;;987    uint32_t si47xxFMRX_get_frequency()
000000  b510              PUSH     {r4,lr}
;;;988    {
;;;989    	// Get the tune status which contains the current frequency
;;;990        fmTuneStatus(0, 0);
000002  2100              MOVS     r1,#0
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       fmTuneStatus
;;;991    
;;;992        // Return the frequency
;;;993        return Freq;
00000a  4801              LDR      r0,|L22.16|
00000c  6900              LDR      r0,[r0,#0x10]  ; Freq
;;;994    }
00000e  bd10              POP      {r4,pc}
;;;995    
                          ENDP

                  |L22.16|
                          DCD      ||.data||

                          AREA ||i.si47xxFMRX_get_rssi||, CODE, READONLY, ALIGN=2

                  si47xxFMRX_get_rssi PROC
;;;1001   //-----------------------------------------------------------------------------
;;;1002   uint8_t si47xxFMRX_get_rssi()
000000  b510              PUSH     {r4,lr}
;;;1003   {
;;;1004   	// Get the tune status which contains the current frequency
;;;1005   	fmRsqStatus(0);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       fmRsqStatus
;;;1006   
;;;1007       // Return the RSSI level
;;;1008       return RSSI;
000008  4801              LDR      r0,|L23.16|
00000a  7b00              LDRB     r0,[r0,#0xc]  ; RSSI
;;;1009   }
00000c  bd10              POP      {r4,pc}
;;;1010   
                          ENDP

00000e  0000              DCW      0x0000
                  |L23.16|
                          DCD      ||.data||

                          AREA ||i.si47xxFMRX_initialize||, CODE, READONLY, ALIGN=2

                  si47xxFMRX_initialize PROC
;;;835    //-----------------------------------------------------------------------------
;;;836    void si47xxFMRX_initialize(void)
000000  b510              PUSH     {r4,lr}
;;;837    {
;;;838        // Zero status registers.
;;;839    	PowerUp = 0;
000002  4905              LDR      r1,|L24.24|
000004  2000              MOVS     r0,#0
000006  7008              STRB     r0,[r1,#0]
;;;840    
;;;841        // Perform a hardware reset, power up the device, and then perform the
;;;842        // initial configuration.
;;;843        si47xx_reset();
;;;844        si47xxFMRX_powerup();
000008  f7fffffe          BL       si47xxFMRX_powerup
;;;845    	printf("POWER UP\n");
00000c  a003              ADR      r0,|L24.28|
00000e  f7fffffe          BL       __2printf
;;;846        
;;;847       // si47xxFMRX_digtal_cfg();
;;;848    	si47xxFMRX_configure();
000012  f7fffffe          BL       si47xxFMRX_configure
;;;849    }
000016  bd10              POP      {r4,pc}
;;;850    
                          ENDP

                  |L24.24|
                          DCD      ||.data||
                  |L24.28|
00001c  504f5745          DCB      "POWER UP\n",0
000020  52205550
000024  0a00    
000026  00                DCB      0
000027  00                DCB      0

                          AREA ||i.si47xxFMRX_mute||, CODE, READONLY, ALIGN=2

                  si47xxFMRX_mute PROC
;;;875    //-----------------------------------------------------------------------------
;;;876    void si47xxFMRX_mute(uint8_t mute)
000000  b510              PUSH     {r4,lr}
;;;877    {
;;;878        if(mute)
;;;879        	si47xx_set_property(RX_HARD_MUTE, 
000002  4a05              LDR      r2,|L25.24|
000004  2800              CMP      r0,#0                 ;878
000006  d001              BEQ      |L25.12|
000008  2103              MOVS     r1,#3
00000a  e000              B        |L25.14|
                  |L25.12|
;;;880                                    RX_HARD_MUTE_RMUTE_MASK | RX_HARD_MUTE_LMUTE_MASK);
;;;881        else
;;;882        	si47xx_set_property(RX_HARD_MUTE, 0);
00000c  2100              MOVS     r1,#0
                  |L25.14|
00000e  4610              MOV      r0,r2                 ;879
000010  f7fffffe          BL       si47xx_set_property
;;;883    }
000014  bd10              POP      {r4,pc}
;;;884    
                          ENDP

000016  0000              DCW      0x0000
                  |L25.24|
                          DCD      0x00004001

                          AREA ||i.si47xxFMRX_powerdown||, CODE, READONLY, ALIGN=2

                  si47xxFMRX_powerdown PROC
;;;668    //-----------------------------------------------------------------------------
;;;669    void si47xxFMRX_powerdown(void)
000000  b510              PUSH     {r4,lr}
;;;670    {
;;;671    
;;;672    	// Check to see if the device is powered up.  If not do not do anything.
;;;673        if(PowerUp)
000002  4808              LDR      r0,|L26.36|
000004  7801              LDRB     r1,[r0,#0]  ; PowerUp
000006  2900              CMP      r1,#0
000008  d00a              BEQ      |L26.32|
;;;674        {   
;;;675            // Set the powered up variable to 0
;;;676            PowerUp = 0;
00000a  2100              MOVS     r1,#0
00000c  7001              STRB     r1,[r0,#0]
;;;677    
;;;678    	    // Put the ID for the command in the first byte.
;;;679    	    cmd[0] = POWER_DOWN;
00000e  4905              LDR      r1,|L26.36|
000010  2011              MOVS     r0,#0x11
000012  3118              ADDS     r1,r1,#0x18
000014  7008              STRB     r0,[r1,#0]
;;;680    
;;;681    	    // Invoke the command
;;;682    		si47xx_command(1, cmd, 1, rsp);
000016  2201              MOVS     r2,#1
000018  4b03              LDR      r3,|L26.40|
00001a  4610              MOV      r0,r2
00001c  f7fffffe          BL       si47xx_command
                  |L26.32|
;;;683        }
;;;684    }
000020  bd10              POP      {r4,pc}
;;;685    
                          ENDP

000022  0000              DCW      0x0000
                  |L26.36|
                          DCD      ||.data||
                  |L26.40|
                          DCD      ||.bss||

                          AREA ||i.si47xxFMRX_powerup||, CODE, READONLY, ALIGN=2

                  si47xxFMRX_powerup PROC
;;;619    //-----------------------------------------------------------------------------
;;;620    void si47xxFMRX_powerup(void)
000000  b570              PUSH     {r4-r6,lr}
;;;621    {
;;;622    
;;;623        // Check if the device is already powered up.
;;;624        if (PowerUp) 
000002  4d0c              LDR      r5,|L27.52|
000004  7828              LDRB     r0,[r5,#0]  ; PowerUp
000006  2800              CMP      r0,#0
000008  d112              BNE      |L27.48|
;;;625    	{
;;;626    	
;;;627        }
;;;628    	else 
;;;629    	{
;;;630            // Put the ID for the command in the first byte.
;;;631            cmd[0] = POWER_UP;
00000a  4628              MOV      r0,r5
00000c  2401              MOVS     r4,#1
00000e  3018              ADDS     r0,r0,#0x18
000010  7004              STRB     r4,[r0,#0]
;;;632    
;;;633    		// Enable the GPO2OEN on the part because it will be used to determine
;;;634            // RDS Sync timing.
;;;635            cmd[1] = POWER_UP_IN_GPO2OEN;
;;;636    
;;;637    		// The device is being powered up in FM RX mode.
;;;638            cmd[1] |= POWER_UP_IN_FUNC_FMRX;
;;;639    
;;;640    		// The opmode needs to be set to analog mode
;;;641            cmd[2] = POWER_UP_IN_OPMODE_RX_DIGITAL;
;;;642    
;;;643    
;;;644    #if 1
;;;645    		cmd[0] = POWER_UP;
;;;646    		cmd[1] = 0xc0;
000012  21c0              MOVS     r1,#0xc0
000014  7041              STRB     r1,[r0,#1]
;;;647    		cmd[2] = 0x05;	
000016  2105              MOVS     r1,#5
000018  7081              STRB     r1,[r0,#2]
;;;648    
;;;649    #else
;;;650    
;;;651    		cmd[0] = POWER_UP;
;;;652    		cmd[1] = 0xc0;
;;;653    		cmd[2] = 0xb0;
;;;654    #endif		
;;;655            // Powerup the device
;;;656    		si47xx_command(3, cmd, 8, rsp);
00001a  4601              MOV      r1,r0
00001c  4b06              LDR      r3,|L27.56|
00001e  2208              MOVS     r2,#8
000020  2003              MOVS     r0,#3
000022  f7fffffe          BL       si47xx_command
;;;657            WaitMs(500);               // wait for si47xx to powerup
000026  20ff              MOVS     r0,#0xff
000028  30f5              ADDS     r0,r0,#0xf5
00002a  f7fffffe          BL       WaitMs
;;;658    
;;;659            // Since we did not boot the part in query mode the result will not
;;;660            // contain the part information.
;;;661    
;;;662    		PowerUp = 1;
00002e  702c              STRB     r4,[r5,#0]
                  |L27.48|
;;;663        }
;;;664    }
000030  bd70              POP      {r4-r6,pc}
;;;665    
                          ENDP

000032  0000              DCW      0x0000
                  |L27.52|
                          DCD      ||.data||
                  |L27.56|
                          DCD      ||.bss||

                          AREA ||i.si47xxFMRX_regional_cfg||, CODE, READONLY, ALIGN=2

                  si47xxFMRX_regional_cfg PROC
;;;747    //-----------------------------------------------------------------------------
;;;748    void si47xxFMRX_regional_cfg(country_enum country)
000000  b5f8              PUSH     {r3-r7,lr}
;;;749    {
;;;750        // Typically the settings used for stereo blend are determined by the 
;;;751        // designer and not exposed to the end user. They should be adjusted here.
;;;752        // If the user wishes to force mono set both of these values to 127.
;;;753        // si47xx_set_property(FM_BLEND_MONO_THRESHOLD, 30);
;;;754        // si47xx_set_property(FM_BLEND_STEREO_THRESHOLD, 49);
;;;755    
;;;756        // Depending on the country, set the de-emphasis, band, and space settings
;;;757        // Also optionally enable RDS for countries that support it
;;;758        switch (country) {
;;;759        case USA :
;;;760            // This interrupt will be used to determine when RDS is available.
;;;761            si47xx_set_property(FM_RDS_INTERRUPT_SOURCE, 
000002  2215              MOVS     r2,#0x15
000004  0212              LSLS     r2,r2,#8
;;;762    					FM_RDS_INTERRUPT_SOURCE_SYNCFOUND_MASK); // RDS Interrupt
;;;763    
;;;764    		// Enable the RDS and allow all blocks so we can compute the error
;;;765            // rate later.
;;;766            si47xx_set_property(FM_RDS_CONFIG, FM_RDS_CONFIG_RDSEN_MASK |
;;;767    			(3 << FM_RDS_CONFIG_BLETHA_SHFT) |
;;;768    			(3 << FM_RDS_CONFIG_BLETHB_SHFT) |
;;;769    			(3 << FM_RDS_CONFIG_BLETHC_SHFT) |
;;;770    			(3 << FM_RDS_CONFIG_BLETHD_SHFT));
;;;771    
;;;772            si47xx_set_property(FM_DEEMPHASIS, FM_DEEMPH_75US); // Deemphasis
000006  2611              MOVS     r6,#0x11
000008  4c1a              LDR      r4,|L28.116|
00000a  1c95              ADDS     r5,r2,#2              ;766
00000c  0236              LSLS     r6,r6,#8
00000e  2800              CMP      r0,#0                 ;758
000010  d00d              BEQ      |L28.46|
;;;773            // Band is already set to 87.5-107.9MHz (US)
;;;774            // Space is already set to 200kHz (US)
;;;775            break;
;;;776        case JAPAN :
;;;777            si47xx_set_property(FM_RDS_CONFIG, 0);              // Disable RDS
;;;778            si47xx_set_property(FM_DEEMPHASIS, FM_DEEMPH_50US); // Deemphasis
;;;779            si47xx_set_property(FM_SEEK_BAND_BOTTOM, 7600);     // 76 MHz Bottom
;;;780            si47xx_set_property(FM_SEEK_BAND_TOP, 9000);        // 90 MHz Top
;;;781            si47xx_set_property(FM_SEEK_FREQ_SPACING, 10);      // 100 kHz Spacing
000012  4f19              LDR      r7,|L28.120|
000014  2802              CMP      r0,#2                 ;758
000016  d015              BEQ      |L28.68|
;;;782            break;
;;;783        case EUROPE :
;;;784        default:
;;;785            // This interrupt will be used to determine when RDS is available.
;;;786            si47xx_set_property(FM_RDS_INTERRUPT_SOURCE, 
000018  2104              MOVS     r1,#4
00001a  4610              MOV      r0,r2
00001c  f7fffffe          BL       si47xx_set_property
;;;787    			FM_RDS_INTERRUPT_SOURCE_SYNCFOUND_MASK); // RDS Interrupt
;;;788    
;;;789    	    // Enable the RDS and allow all blocks so we can compute the error
;;;790            // rate later.
;;;791            si47xx_set_property(FM_RDS_CONFIG, FM_RDS_CONFIG_RDSEN_MASK |
000020  4621              MOV      r1,r4
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       si47xx_set_property
;;;792    		    (3 << FM_RDS_CONFIG_BLETHA_SHFT) |
;;;793    			(3 << FM_RDS_CONFIG_BLETHB_SHFT) |
;;;794    			(3 << FM_RDS_CONFIG_BLETHC_SHFT) |
;;;795    			(3 << FM_RDS_CONFIG_BLETHD_SHFT));
;;;796    
;;;797            si47xx_set_property(FM_DEEMPHASIS, FM_DEEMPH_50US); // Deemphasis
000028  2101              MOVS     r1,#1
00002a  4630              MOV      r0,r6
;;;798            // Band is already set to 87.5-107.9MHz (Europe)
;;;799            si47xx_set_property(FM_SEEK_FREQ_SPACING, 10);      // 100 kHz Spacing
;;;800            break;
00002c  e01a              B        |L28.100|
                  |L28.46|
00002e  2104              MOVS     r1,#4                 ;761
000030  4610              MOV      r0,r2                 ;761
000032  f7fffffe          BL       si47xx_set_property
000036  4621              MOV      r1,r4                 ;766
000038  4628              MOV      r0,r5                 ;766
00003a  f7fffffe          BL       si47xx_set_property
00003e  2102              MOVS     r1,#2                 ;772
000040  4630              MOV      r0,r6                 ;772
000042  e013              B        |L28.108|
                  |L28.68|
000044  2100              MOVS     r1,#0                 ;777
000046  4628              MOV      r0,r5                 ;777
000048  f7fffffe          BL       si47xx_set_property
00004c  2101              MOVS     r1,#1                 ;778
00004e  4630              MOV      r0,r6                 ;778
000050  f7fffffe          BL       si47xx_set_property
000054  2005              MOVS     r0,#5                 ;779
000056  4909              LDR      r1,|L28.124|
000058  0280              LSLS     r0,r0,#10             ;779
00005a  f7fffffe          BL       si47xx_set_property
00005e  4806              LDR      r0,|L28.120|
000060  4907              LDR      r1,|L28.128|
000062  1e40              SUBS     r0,r0,#1              ;780
                  |L28.100|
000064  f7fffffe          BL       si47xx_set_property
000068  210a              MOVS     r1,#0xa               ;799
00006a  4638              MOV      r0,r7                 ;799
                  |L28.108|
00006c  f7fffffe          BL       si47xx_set_property
;;;801        }
;;;802    }
000070  bdf8              POP      {r3-r7,pc}
;;;803    
                          ENDP

000072  0000              DCW      0x0000
                  |L28.116|
                          DCD      0x0000ff01
                  |L28.120|
                          DCD      0x00001402
                  |L28.124|
                          DCD      0x00001db0
                  |L28.128|
                          DCD      0x00002328

                          AREA ||i.si47xxFMRX_seek||, CODE, READONLY, ALIGN=2

                  si47xxFMRX_seek PROC
;;;949    //-----------------------------------------------------------------------------
;;;950    uint8_t si47xxFMRX_seek(uint8_t seekup, uint8_t seekmode)
000000  b510              PUSH     {r4,lr}
;;;951    {
;;;952    	// Enable the bit used for the interrupt of STC.
;;;953    	SeekTuneInProc = 1;
000002  2201              MOVS     r2,#1
000004  4c0c              LDR      r4,|L29.56|
;;;954    
;;;955    	// Call the tune command to start the seek.
;;;956     	WaitSTCInterrupt = 1;
;;;957        fmSeekStart(seekup, !seekmode);
000006  2900              CMP      r1,#0
000008  70a2              STRB     r2,[r4,#2]            ;953
00000a  7062              STRB     r2,[r4,#1]            ;956
00000c  d011              BEQ      |L29.50|
00000e  2100              MOVS     r1,#0
                  |L29.16|
000010  f7fffffe          BL       fmSeekStart
000014  7860              LDRB     r0,[r4,#1]            ;953
                  |L29.22|
;;;958    
;;;959        // wait for the interrupt before continuing
;;;960        // If you do not wish to use interrupts but wish to poll the part
;;;961        // then comment out these two lines.
;;;962        while (WaitSTCInterrupt); // Wait for interrupt to clear the bit
000016  2800              CMP      r0,#0
000018  d1fd              BNE      |L29.22|
                  |L29.26|
;;;963    
;;;964        // Wait for stc bit to be set
;;;965        // If there is a display to update seek progress, then you could
;;;966        // call fmTuneStatus in this loop to get the current frequency.
;;;967        // When calling fmTuneStatus here make sure intack is zero.
;;;968        while (!(getIntStatus() & STCINT));
00001a  f7fffffe          BL       getIntStatus
00001e  07c0              LSLS     r0,r0,#31
000020  d0fb              BEQ      |L29.26|
;;;969    
;;;970    	// Clear the STC bit and get the results of the tune.
;;;971        fmTuneStatus(0, 1);
000022  2101              MOVS     r1,#1
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       fmTuneStatus
;;;972    
;;;973    	// Disable the bit used for the interrupt of STC.
;;;974    	SeekTuneInProc = 0;
00002a  2000              MOVS     r0,#0
00002c  70a0              STRB     r0,[r4,#2]
;;;975    
;;;976        // The tuner is now set to the newly found channel if one was available
;;;977        // as indicated by the seek-fail bit.
;;;978        return BLTF; //return seek fail indicator
00002e  79e0              LDRB     r0,[r4,#7]  ; BLTF
;;;979    }
000030  bd10              POP      {r4,pc}
                  |L29.50|
000032  2101              MOVS     r1,#1                 ;957
000034  e7ec              B        |L29.16|
;;;980    
                          ENDP

000036  0000              DCW      0x0000
                  |L29.56|
                          DCD      ||.data||

                          AREA ||i.si47xxFMRX_set_volume||, CODE, READONLY, ALIGN=2

                  si47xxFMRX_set_volume PROC
;;;859    //-----------------------------------------------------------------------------
;;;860    void si47xxFMRX_set_volume(uint8_t volume)
000000  b510              PUSH     {r4,lr}
;;;861    {
000002  4604              MOV      r4,r0
;;;862        // Turn off the mute
;;;863        si47xx_set_property(RX_HARD_MUTE, 0);
000004  2100              MOVS     r1,#0
000006  4805              LDR      r0,|L30.28|
000008  f7fffffe          BL       si47xx_set_property
;;;864    
;;;865        // Set the volume to the passed value
;;;866        si47xx_set_property(RX_VOLUME, (uint32_t)volume & RX_VOLUME_MASK);
00000c  06a1              LSLS     r1,r4,#26
00000e  2001              MOVS     r0,#1
000010  0e89              LSRS     r1,r1,#26
000012  0380              LSLS     r0,r0,#14
000014  f7fffffe          BL       si47xx_set_property
;;;867    }
000018  bd10              POP      {r4,pc}
;;;868    
                          ENDP

00001a  0000              DCW      0x0000
                  |L30.28|
                          DCD      0x00004001

                          AREA ||i.si47xxFMRX_tune||, CODE, READONLY, ALIGN=2

                  si47xxFMRX_tune PROC
;;;893    //-----------------------------------------------------------------------------
;;;894    uint8_t si47xxFMRX_tune(uint32_t frequency)
000000  b5f8              PUSH     {r3-r7,lr}
;;;895    {
;;;896    	int temp = 300;
;;;897    	// Enable the bit used for the interrupt of STC.
;;;898    	SeekTuneInProc = 1;
000002  4e12              LDR      r6,|L31.76|
000004  2501              MOVS     r5,#1
000006  24ff              MOVS     r4,#0xff              ;896
000008  70b5              STRB     r5,[r6,#2]
00000a  342d              ADDS     r4,r4,#0x2d           ;896
;;;899    
;;;900    	// Call the tune command to start the tune.
;;;901     	WaitSTCInterrupt = 1;
00000c  7075              STRB     r5,[r6,#1]
;;;902        fmTuneFreq(frequency);
00000e  f7fffffe          BL       fmTuneFreq
;;;903    
;;;904        // wait for the interrupt before continuing
;;;905        // If you do not wish to use interrupts but wish to poll the part
;;;906        // then comment out this line.
;;;907        
;;;908        WaitMs(100);
000012  2064              MOVS     r0,#0x64
000014  f7fffffe          BL       WaitMs
000018  2700              MOVS     r7,#0
;;;909    	
;;;910       // while (WaitSTCInterrupt); // Wait for interrupt to clear the bit
;;;911    
;;;912        // Wait for stc bit to be set
;;;913        
;;;914       // while (!(getIntStatus() & STCINT));
;;;915        
;;;916        // Loop until CTS is found or stop due to the counter running out.
;;;917        while ((temp--) && !(getIntStatus() & STCINT))
;;;918        {
;;;919            wait_us(500);
;;;920    		if(temp < 2) 
;;;921    		{
;;;922    			Global_datas.FmData.FmError = 1;
00001a  4d0d              LDR      r5,|L31.80|
00001c  e008              B        |L31.48|
                  |L31.30|
00001e  20ff              MOVS     r0,#0xff              ;919
000020  30f5              ADDS     r0,r0,#0xf5           ;919
000022  f7fffffe          BL       wait_us
000026  2c02              CMP      r4,#2                 ;920
000028  da02              BGE      |L31.48|
00002a  2001              MOVS     r0,#1
00002c  7128              STRB     r0,[r5,#4]
;;;923    			PowerUp = 0;
00002e  7037              STRB     r7,[r6,#0]
                  |L31.48|
000030  1e64              SUBS     r4,r4,#1
000032  d303              BCC      |L31.60|
000034  f7fffffe          BL       getIntStatus
000038  07c0              LSLS     r0,r0,#31             ;917
00003a  d0f0              BEQ      |L31.30|
                  |L31.60|
;;;924    		}
;;;925        }
;;;926    
;;;927    	
;;;928    
;;;929    	// Clear the STC bit and get the results of the tune.
;;;930        fmTuneStatus(0, 1);
00003c  2101              MOVS     r1,#1
00003e  2000              MOVS     r0,#0
000040  f7fffffe          BL       fmTuneStatus
;;;931    
;;;932    	// Disable the bit used for the interrupt of STC.
;;;933    	SeekTuneInProc = 0;
000044  70b7              STRB     r7,[r6,#2]
;;;934    
;;;935        // Return the RSSI level
;;;936      //  return RSSI;
;;;937      return Valid;
000046  7a70              LDRB     r0,[r6,#9]  ; Valid
;;;938    }
000048  bdf8              POP      {r3-r7,pc}
;;;939    
                          ENDP

00004a  0000              DCW      0x0000
                  |L31.76|
                          DCD      ||.data||
                  |L31.80|
                          DCD      Global_datas+0x40

                          AREA ||i.si47xx_command||, CODE, READONLY, ALIGN=1

                  si47xx_command PROC
;;;483    //-----------------------------------------------------------------------------
;;;484    void si47xx_command(uint8_t cmd_size, uint8_t *cmd, uint8_t reply_size, uint8_t  *reply)
000000  b5f8              PUSH     {r3-r7,lr}
;;;485    {
000002  461e              MOV      r6,r3
000004  4614              MOV      r4,r2
000006  460d              MOV      r5,r1
000008  4607              MOV      r7,r0
;;;486        // It is always a good idea to check for cts prior to sending a command to
;;;487        // the part.
;;;488        si47xx_waitForCTS();
00000a  f7fffffe          BL       si47xx_waitForCTS
;;;489    
;;;490    	
;;;491    
;;;492        // Write the command to the part
;;;493        si47xx_lowWrite(cmd_size, cmd);
00000e  4629              MOV      r1,r5
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       si47xx_lowWrite
;;;494    
;;;495        // Wait for CTS after sending the command
;;;496        si47xx_waitForCTS();
000016  f7fffffe          BL       si47xx_waitForCTS
;;;497    
;;;498        // If the calling function would like to have results then read them.
;;;499        if(reply_size)
00001a  2c00              CMP      r4,#0
00001c  d003              BEQ      |L32.38|
;;;500        {
;;;501            si47xx_lowRead(reply_size, reply);
00001e  4631              MOV      r1,r6
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       si47xx_lowRead
                  |L32.38|
;;;502        }
;;;503    }
000026  bdf8              POP      {r3-r7,pc}
;;;504    
                          ENDP


                          AREA ||i.si47xx_getPartInformation||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  si47xx_getPartInformation PROC
;;;573    //-----------------------------------------------------------------------------
;;;574    void si47xx_getPartInformation(void)
000000  b510              PUSH     {r4,lr}
;;;575    {
;;;576    	uint8_t partNumber;
;;;577    	char fwMajor;
;;;578    	char fwMinor;
;;;579    	uint32_t  patchID;
;;;580    	char cmpMajor;
;;;581    	char cmpMinor;
;;;582    	char chipRev;
;;;583    
;;;584    	// NOTE:  This routine should only be called when the part is powered up.
;;;585    	// If you wish to retrieve some of the part information without fully
;;;586    	// powering up the part call the POWER_UP command on the part with the
;;;587    	// FUNC_DEBUG flag.
;;;588    
;;;589    	// Put the ID for the command in the first byte.
;;;590    	cmd[0] = GET_REV;
000002  490b              LDR      r1,|L33.48|
000004  2010              MOVS     r0,#0x10
000006  7008              STRB     r0,[r1,#0]
;;;591    
;;;592    	// Invoke the command
;;;593    	si47xx_command(1, cmd, 9, rsp);
000008  4b0a              LDR      r3,|L33.52|
00000a  2209              MOVS     r2,#9
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       si47xx_command
;;;594    
;;;595    	// Now take the result and put in the variables we have declared
;;;596    	// Status is in the first element of the array so skip that.
;;;597    	partNumber = rsp[1];
000012  4c08              LDR      r4,|L33.52|
;;;598    	fwMajor  = (char)rsp[2];
;;;599    	fwMinor  = (char)rsp[3];
;;;600    	patchID  = (uint32_t)(rsp[4] << 8) | (uint32_t)rsp[5];
;;;601    	cmpMajor = (char)rsp[6];
;;;602    	cmpMinor = (char)rsp[7];
;;;603    	chipRev  = (char)rsp[8]; 
;;;604    
;;;605    	printf("partNumber: %d\n", partNumber);
000014  a008              ADR      r0,|L33.56|
000016  7861              LDRB     r1,[r4,#1]            ;597  ; rsp
000018  f7fffffe          BL       __2printf
;;;606    
;;;607    	printf("patchID_H: %d\n", rsp[4]);
00001c  7921              LDRB     r1,[r4,#4]  ; rsp
00001e  a00a              ADR      r0,|L33.72|
000020  f7fffffe          BL       __2printf
;;;608    	printf("patchID_L: %d\n", rsp[5]);
000024  7961              LDRB     r1,[r4,#5]  ; rsp
000026  a00c              ADR      r0,|L33.88|
000028  f7fffffe          BL       __2printf
;;;609    
;;;610    	
;;;611    }
00002c  bd10              POP      {r4,pc}
;;;612    
                          ENDP

00002e  0000              DCW      0x0000
                  |L33.48|
                          DCD      ||.data||+0x18
                  |L33.52|
                          DCD      ||.bss||
                  |L33.56|
000038  70617274          DCB      "partNumber: %d\n",0
00003c  4e756d62
000040  65723a20
000044  25640a00
                  |L33.72|
000048  70617463          DCB      "patchID_H: %d\n",0
00004c  6849445f
000050  483a2025
000054  640a00  
000057  00                DCB      0
                  |L33.88|
000058  70617463          DCB      "patchID_L: %d\n",0
00005c  6849445f
000060  4c3a2025
000064  640a00  
000067  00                DCB      0

                          AREA ||i.si47xx_lowRead||, CODE, READONLY, ALIGN=1

                  si47xx_lowRead PROC
;;;516    //-----------------------------------------------------------------------------
;;;517    void si47xx_lowRead(uint8_t number_bytes, uint8_t *data_in)
000000  b510              PUSH     {r4,lr}
;;;518    {
;;;519        io2w_read(number_bytes, data_in);
000002  f7fffffe          BL       io2w_read
;;;520    }
000006  bd10              POP      {r4,pc}
;;;521    
                          ENDP


                          AREA ||i.si47xx_lowWrite||, CODE, READONLY, ALIGN=1

                  si47xx_lowWrite PROC
;;;508    //-----------------------------------------------------------------------------
;;;509    void si47xx_lowWrite(uint8_t number_bytes, uint8_t *data_out)
000000  b510              PUSH     {r4,lr}
;;;510    {
;;;511            io2w_write(number_bytes, data_out);}
000002  f7fffffe          BL       io2w_write
000006  bd10              POP      {r4,pc}
;;;512    
                          ENDP


                          AREA ||i.si47xx_readStatus||, CODE, READONLY, ALIGN=1

                  si47xx_readStatus PROC
;;;444    //-----------------------------------------------------------------------------
;;;445    uint8_t si47xx_readStatus()
000000  b508              PUSH     {r3,lr}
;;;446    {
;;;447        uint8_t status;
;;;448       
;;;449        si47xx_lowRead(1, &status);
000002  4669              MOV      r1,sp
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       si47xx_lowRead
;;;450    
;;;451    
;;;452        return status;
00000a  4668              MOV      r0,sp
00000c  7800              LDRB     r0,[r0,#0]
;;;453    }
00000e  bd08              POP      {r3,pc}
;;;454    
                          ENDP


                          AREA ||i.si47xx_reset||, CODE, READONLY, ALIGN=1

                  si47xx_reset PROC
;;;435    //-----------------------------------------------------------------------------
;;;436    void si47xx_reset(void)
000000  4770              BX       lr
;;;437    {
;;;438    
;;;439    
;;;440    }
;;;441    
                          ENDP


                          AREA ||i.si47xx_set_property||, CODE, READONLY, ALIGN=2

                  si47xx_set_property PROC
;;;549    //-----------------------------------------------------------------------------
;;;550    void si47xx_set_property(uint32_t propNumber, uint32_t propValue)
000000  b510              PUSH     {r4,lr}
;;;551    {
;;;552        // Put the ID for the command in the first byte.
;;;553        cmd[0] = SET_PROPERTY;
000002  4a09              LDR      r2,|L38.40|
000004  2312              MOVS     r3,#0x12
000006  7013              STRB     r3,[r2,#0]
;;;554    
;;;555    	// Initialize the reserved section to 0
;;;556        cmd[1] = 0;
000008  2300              MOVS     r3,#0
00000a  7053              STRB     r3,[r2,#1]
;;;557    
;;;558    	// Put the property number in the third and fourth bytes.
;;;559        cmd[2] = (uint8_t)(propNumber >> 8);
00000c  0a03              LSRS     r3,r0,#8
00000e  7093              STRB     r3,[r2,#2]
;;;560    	cmd[3] = (uint8_t)(propNumber & 0x00FF);
000010  70d0              STRB     r0,[r2,#3]
;;;561    
;;;562    	// Put the property value in the fifth and sixth bytes.
;;;563        cmd[4] = (uint8_t)(propValue >> 8);
000012  0a08              LSRS     r0,r1,#8
000014  7110              STRB     r0,[r2,#4]
;;;564        cmd[5] = (uint8_t)(propValue & 0x00FF);
000016  7151              STRB     r1,[r2,#5]
;;;565    
;;;566        // Invoke the command
;;;567    	si47xx_command(6, cmd, 0, NULL);
000018  2300              MOVS     r3,#0
00001a  461a              MOV      r2,r3
00001c  4902              LDR      r1,|L38.40|
00001e  2006              MOVS     r0,#6
000020  f7fffffe          BL       si47xx_command
;;;568    }
000024  bd10              POP      {r4,pc}
;;;569    
                          ENDP

000026  0000              DCW      0x0000
                  |L38.40|
                          DCD      ||.data||+0x18

                          AREA ||i.si47xx_waitForCTS||, CODE, READONLY, ALIGN=1

                  si47xx_waitForCTS PROC
;;;457    //-----------------------------------------------------------------------------
;;;458    void si47xx_waitForCTS()
000000  b570              PUSH     {r4-r6,lr}
;;;459    {
;;;460        char i=250;
000002  24fa              MOVS     r4,#0xfa
;;;461    
;;;462    	
;;;463        // Loop until CTS is found or stop due to the counter running out.
;;;464        while ((i--) && !(si47xx_readStatus() & CTS))
;;;465        {
;;;466            wait_us(500);
000004  0065              LSLS     r5,r4,#1
000006  e002              B        |L39.14|
                  |L39.8|
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       wait_us
                  |L39.14|
00000e  4621              MOV      r1,r4                 ;464
000010  1e64              SUBS     r4,r4,#1              ;464
000012  b2e4              UXTB     r4,r4                 ;464
000014  2900              CMP      r1,#0                 ;464
000016  d003              BEQ      |L39.32|
000018  f7fffffe          BL       si47xx_readStatus
00001c  0600              LSLS     r0,r0,#24             ;464
00001e  d5f3              BPL      |L39.8|
                  |L39.32|
;;;467        }
;;;468    
;;;469     //   while (!(si47xx_readStatus() & CTS))
;;;470     //   {
;;;471     //      wait_us(500);
;;;472     //   }
;;;473    
;;;474    	
;;;475    
;;;476        // If the i is equal to 0 then something must have happened.
;;;477        // It is recommended that the controller do some type of error
;;;478        // handling in this case.
;;;479    }
000020  bd70              POP      {r4-r6,pc}
;;;480    
                          ENDP


                          AREA ||i.test_FMRXtune||, CODE, READONLY, ALIGN=2

                  test_FMRXtune PROC
;;;1234   
;;;1235   void test_FMRXtune(void)
000000  b510              PUSH     {r4,lr}
;;;1236   {
;;;1237       si47xxFMRX_initialize();
000002  f7fffffe          BL       si47xxFMRX_initialize
;;;1238       si47xxFMRX_set_volume(63);     // full volume, turn off mute
000006  203f              MOVS     r0,#0x3f
000008  f7fffffe          BL       si47xxFMRX_set_volume
;;;1239       si47xxFMRX_tune(Global_datas.FmData.Frequency);        // tune to a station
00000c  4804              LDR      r0,|L40.32|
00000e  6c00              LDR      r0,[r0,#0x40]  ; Global_datas
000010  f7fffffe          BL       si47xxFMRX_tune
;;;1240       WaitMs(300);
000014  20ff              MOVS     r0,#0xff
000016  302d              ADDS     r0,r0,#0x2d
000018  f7fffffe          BL       WaitMs
;;;1241   }
00001c  bd10              POP      {r4,pc}
;;;1242   
                          ENDP

00001e  0000              DCW      0x0000
                  |L40.32|
                          DCD      Global_datas

                          AREA ||i.wait_us||, CODE, READONLY, ALIGN=1

                  wait_us PROC
;;;120    
;;;121    void wait_us(uint32_t  us)
000000  2100              MOVS     r1,#0
;;;122    {
000002  e000              B        |L41.6|
                  |L41.4|
000004  1c49              ADDS     r1,r1,#1
                  |L41.6|
;;;123    	uint32_t i = 0;
;;;124    
;;;125    	for(i=0;i< us; i++);
000006  4281              CMP      r1,r0
000008  d3fc              BCC      |L41.4|
;;;126    }
00000a  4770              BX       lr
;;;127    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ||rsp||
                          %        15

                          AREA ||.data||, DATA, ALIGN=2

                  PowerUp
000000  00                DCB      0x00
                  WaitSTCInterrupt
000001  00                DCB      0x00
                  SeekTuneInProc
000002  00                DCB      0x00
                  Status
000003  00                DCB      0x00
                  RsqInts
000004  00                DCB      0x00
                  ||STC||
000005  00                DCB      0x00
                  SMUTE
000006  00                DCB      0x00
                  BLTF
000007  00                DCB      0x00
                  AFCRL
000008  00                DCB      0x00
                  Valid
000009  00                DCB      0x00
                  Pilot
00000a  00                DCB      0x00
                  Blend
00000b  00                DCB      0x00
                  RSSI
00000c  00                DCB      0x00
                  ASNR
00000d  00                DCB      0x00
                  FreqOff
00000e  0000              DCB      0x00,0x00
                  Freq
                          DCD      0x00000000
                  AntCap
                          DCD      0x00000000
                  ||cmd||
                          %        8

                          AREA ||area_number.46||, DATA, ALIGN=0

                          EXPORTAS ||area_number.46||, ||.data||
                  RdsAvailable
000000  00                DCB      0x00

                          AREA ||area_number.47||, DATA, ALIGN=0

                          EXPORTAS ||area_number.47||, ||.data||
                  ProcessSame
000000  00                DCB      0x00

                          AREA ||area_number.48||, DATA, ALIGN=0

                          EXPORTAS ||area_number.48||, ||.data||
                  RdsTestInProc
000000  00                DCB      0x00

                          AREA ||area_number.49||, DATA, ALIGN=0

                          EXPORTAS ||area_number.49||, ||.data||
                  SameTestInProc
000000  00                DCB      0x00

                          AREA ||area_number.50||, DATA, ALIGN=0

                          EXPORTAS ||area_number.50||, ||.data||
                  chipFunction
000000  00                DCB      0x00

                          AREA ||area_number.51||, DATA, ALIGN=0

                          EXPORTAS ||area_number.51||, ||.data||
                  AsqInts
000000  00                DCB      0x00

                          AREA ||area_number.52||, DATA, ALIGN=0

                          EXPORTAS ||area_number.52||, ||.data||
                  Alert
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\src\\driver\\MoudleFm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_MoudleFm_c_PowerUp____REV16|
#line 388 "..\\lib\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_MoudleFm_c_PowerUp____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_MoudleFm_c_PowerUp____REVSH|
#line 402
|__asm___10_MoudleFm_c_PowerUp____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
