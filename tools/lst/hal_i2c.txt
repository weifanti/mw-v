; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\hal_i2c.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\hal_i2c.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\lib\CMSIS\Include -I..\lib\Device\Nuvoton\NUC029xGE\Include -I..\lib\StdDriver\inc -I..\src\core\include -I..\src\driver\include -I..\src\io\include -D__UVISION_VERSION=522 --omf_browse=.\obj\hal_i2c.crf ..\src\io\hal_i2c.c]
                          THUMB

                          AREA ||i.Hal_I2c0_Stop||, CODE, READONLY, ALIGN=2

                  Hal_I2c0_Stop PROC
;;;67      */
;;;68     static void Hal_I2c0_Stop(void)
000000  b538              PUSH     {r3-r5,lr}
;;;69     {
;;;70     	/*--I2C0--*/
;;;71         I2C_ClearTimeoutFlag(I2C0);
000002  4d09              LDR      r5,|L1.40|
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       I2C_ClearTimeoutFlag
;;;72         I2C_DisableInt(I2C0);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       I2C_DisableInt
;;;73         I2C_Trigger(I2C0, 0, 1, 1, 0);
000010  2400              MOVS     r4,#0
000012  2301              MOVS     r3,#1
000014  461a              MOV      r2,r3
000016  4621              MOV      r1,r4
000018  4628              MOV      r0,r5
00001a  9400              STR      r4,[sp,#0]
00001c  f7fffffe          BL       I2C_Trigger
;;;74         i2c_trans_data.wait_cnt    = 0;
000020  4802              LDR      r0,|L1.44|
000022  8204              STRH     r4,[r0,#0x10]
;;;75         i2c_trans_data.is_in_trans = FALSE;
000024  7504              STRB     r4,[r0,#0x14]
;;;76     }
000026  bd38              POP      {r3-r5,pc}
;;;77     
                          ENDP

                  |L1.40|
                          DCD      0x40020000
                  |L1.44|
                          DCD      ||.bss||

                          AREA ||i.Hal_I2c1_Stop||, CODE, READONLY, ALIGN=2

                  Hal_I2c1_Stop PROC
;;;83      */
;;;84     static void Hal_I2c1_Stop(void)
000000  b538              PUSH     {r3-r5,lr}
;;;85     {
;;;86     	/*--I2C1--*/
;;;87     
;;;88     	I2C_ClearTimeoutFlag(I2C1);
000002  4d09              LDR      r5,|L2.40|
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       I2C_ClearTimeoutFlag
;;;89         I2C_DisableInt(I2C1);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       I2C_DisableInt
;;;90         I2C_Trigger(I2C1, 0, 1, 1, 0);
000010  2400              MOVS     r4,#0
000012  2301              MOVS     r3,#1
000014  461a              MOV      r2,r3
000016  4621              MOV      r1,r4
000018  4628              MOV      r0,r5
00001a  9400              STR      r4,[sp,#0]
00001c  f7fffffe          BL       I2C_Trigger
;;;91         i2c_trans_data.wait_cnt    = 0;
000020  4802              LDR      r0,|L2.44|
000022  8204              STRH     r4,[r0,#0x10]
;;;92         i2c_trans_data.is_in_trans = FALSE;
000024  7504              STRB     r4,[r0,#0x14]
;;;93     }
000026  bd38              POP      {r3-r5,pc}
;;;94     
                          ENDP

                  |L2.40|
                          DCD      0x40120000
                  |L2.44|
                          DCD      ||.bss||

                          AREA ||i.Hal_I2c1_Transfer||, CODE, READONLY, ALIGN=2

                  Hal_I2c1_Transfer PROC
;;;149    
;;;150    void Hal_I2c1_Transfer(uint8_t addr, uint8_t* tx_arr, uint32_t tx_len, uint8_t* rx_arr, uint32_t rx_len)
000000  b5ff              PUSH     {r0-r7,lr}
;;;151    {
;;;152        /* first check bus and wait */
;;;153        while(i2c_trans_data.is_in_trans)
000002  4c1c              LDR      r4,|L3.116|
000004  b081              SUB      sp,sp,#4              ;151
000006  4616              MOV      r6,r2                 ;151
000008  4607              MOV      r7,r0                 ;151
                  |L3.10|
00000a  7d20              LDRB     r0,[r4,#0x14]  ; i2c_trans_data
00000c  2800              CMP      r0,#0
00000e  d1fc              BNE      |L3.10|
;;;154        {
;;;155            ; /* wait */
;;;156        }
;;;157    
;;;158        /* leave when error */
;;;159        if(I2C_GetStatus(I2C1) == I2C_STATUS_ERROR)
000010  4d19              LDR      r5,|L3.120|
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       I2C_GetStatus
000018  2800              CMP      r0,#0
00001a  d109              BNE      |L3.48|
;;;160        {
;;;161     //   printf("I2C_STATUS_ERROR\n");
;;;162            if((sys_err & SYS_ERR_I2C1) == 0)
00001c  4817              LDR      r0,|L3.124|
00001e  7801              LDRB     r1,[r0,#0]  ; sys_err
000020  0749              LSLS     r1,r1,#29
000022  d405              BMI      |L3.48|
;;;163            {
;;;164                sys_err |= SYS_ERR_I2C1;
000024  7801              LDRB     r1,[r0,#0]  ; sys_err
000026  2204              MOVS     r2,#4
000028  4311              ORRS     r1,r1,r2
00002a  7001              STRB     r1,[r0,#0]
                  |L3.44|
;;;165                return;
;;;166            }
;;;167        }
;;;168    
;;;169        /* set data */
;;;170        i2c_trans_data.slave_addr  = addr;
;;;171        i2c_trans_data.p_tx_buff   = tx_arr;
;;;172        i2c_trans_data.p_rx_buff   = rx_arr;
;;;173        i2c_trans_data.tx_buff_len = tx_len;
;;;174        i2c_trans_data.rx_buff_len = rx_len;
;;;175        i2c_trans_data.curr_tx_pos = 0;
;;;176        i2c_trans_data.curr_rx_pos = 0;
;;;177        i2c_trans_data.next_status = I2C_STATUS_START_OK;
;;;178        i2c_trans_data.wait_cnt    = 0;
;;;179        i2c_trans_data.is_in_trans = TRUE;
;;;180    
;;;181        /* start */
;;;182        I2C_ClearTimeoutFlag(I2C1);
;;;183        I2C_Trigger(I2C1, 1, 0, 1, 0);
;;;184        I2C_EnableInt(I2C1);
;;;185    //	printf("last check bus and wait\n");
;;;186    
;;;187        /* last check bus and wait */
;;;188    #if 1
;;;189        while(i2c_trans_data.is_in_trans)
;;;190        {
;;;191            ; /* wait */
;;;192        }
;;;193    #endif
;;;194    }
00002c  b005              ADD      sp,sp,#0x14
00002e  bdf0              POP      {r4-r7,pc}
                  |L3.48|
000030  74a7              STRB     r7,[r4,#0x12]         ;170
000032  9802              LDR      r0,[sp,#8]            ;171
000034  6020              STR      r0,[r4,#0]            ;171  ; i2c_trans_data
000036  9804              LDR      r0,[sp,#0x10]         ;172
000038  6060              STR      r0,[r4,#4]            ;172  ; i2c_trans_data
00003a  8126              STRH     r6,[r4,#8]            ;173
00003c  980a              LDR      r0,[sp,#0x28]         ;174
00003e  8160              STRH     r0,[r4,#0xa]          ;174
000040  2600              MOVS     r6,#0                 ;175
000042  81a6              STRH     r6,[r4,#0xc]          ;175
000044  81e6              STRH     r6,[r4,#0xe]          ;176
000046  2008              MOVS     r0,#8                 ;177
000048  74e0              STRB     r0,[r4,#0x13]         ;177
00004a  8226              STRH     r6,[r4,#0x10]         ;178
00004c  2001              MOVS     r0,#1                 ;179
00004e  7520              STRB     r0,[r4,#0x14]         ;179
000050  4628              MOV      r0,r5                 ;182
000052  f7fffffe          BL       I2C_ClearTimeoutFlag
000056  2301              MOVS     r3,#1                 ;183
000058  2200              MOVS     r2,#0                 ;183
00005a  4619              MOV      r1,r3                 ;183
00005c  4628              MOV      r0,r5                 ;183
00005e  9600              STR      r6,[sp,#0]            ;183
000060  f7fffffe          BL       I2C_Trigger
000064  4628              MOV      r0,r5                 ;184
000066  f7fffffe          BL       I2C_EnableInt
                  |L3.106|
00006a  7d20              LDRB     r0,[r4,#0x14]         ;189  ; i2c_trans_data
00006c  2800              CMP      r0,#0                 ;189
00006e  d1fc              BNE      |L3.106|
000070  e7dc              B        |L3.44|
;;;195    
                          ENDP

000072  0000              DCW      0x0000
                  |L3.116|
                          DCD      ||.bss||
                  |L3.120|
                          DCD      0x40120000
                  |L3.124|
                          DCD      sys_err

                          AREA ||i.Hal_I2c_Init||, CODE, READONLY, ALIGN=2

                  Hal_I2c_Init PROC
;;;42      */
;;;43     void Hal_I2c_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;44     {
;;;45     	/*--I2C0--*/
;;;46         CLK_EnableModuleClock(I2C0_MODULE);
000002  4818              LDR      r0,|L4.100|
000004  f7fffffe          BL       CLK_EnableModuleClock
;;;47         SYS_ResetModule(I2C0_RST);
000008  4817              LDR      r0,|L4.104|
00000a  f7fffffe          BL       SYS_ResetModule
;;;48         I2C_EnableTimeout(I2C0, 1);
00000e  4c17              LDR      r4,|L4.108|
000010  2101              MOVS     r1,#1
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       I2C_EnableTimeout
;;;49         I2C_Open(I2C0, I2C_BAUDRATE);
000018  4d15              LDR      r5,|L4.112|
00001a  4620              MOV      r0,r4
00001c  4629              MOV      r1,r5
00001e  f7fffffe          BL       I2C_Open
000022  2001              MOVS     r0,#1
000024  4c13              LDR      r4,|L4.116|
000026  0480              LSLS     r0,r0,#18
000028  6020              STR      r0,[r4,#0]
;;;50         NVIC_EnableIRQ(I2C0_IRQn);
;;;51         NVIC_SetPriority(I2C0_IRQn, 2UL);
00002a  2102              MOVS     r1,#2
00002c  2012              MOVS     r0,#0x12
00002e  f7fffffe          BL       NVIC_SetPriority
;;;52     	/*--I2C1--*/
;;;53     	CLK_EnableModuleClock(I2C1_MODULE);
000032  480c              LDR      r0,|L4.100|
000034  1c40              ADDS     r0,r0,#1
000036  f7fffffe          BL       CLK_EnableModuleClock
;;;54         SYS_ResetModule(I2C1_RST);
00003a  480b              LDR      r0,|L4.104|
00003c  1c40              ADDS     r0,r0,#1
00003e  f7fffffe          BL       SYS_ResetModule
;;;55         I2C_EnableTimeout(I2C1, 1);
000042  4e0d              LDR      r6,|L4.120|
000044  2101              MOVS     r1,#1
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       I2C_EnableTimeout
;;;56         I2C_Open(I2C1, I2C_BAUDRATE);
00004c  4629              MOV      r1,r5
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       I2C_Open
000054  2001              MOVS     r0,#1
000056  04c0              LSLS     r0,r0,#19
000058  6020              STR      r0,[r4,#0]
;;;57         NVIC_EnableIRQ(I2C1_IRQn);
;;;58         NVIC_SetPriority(I2C1_IRQn, 2UL);
00005a  2102              MOVS     r1,#2
00005c  2013              MOVS     r0,#0x13
00005e  f7fffffe          BL       NVIC_SetPriority
;;;59     
;;;60     }
000062  bd70              POP      {r4-r6,pc}
;;;61     
                          ENDP

                  |L4.100|
                          DCD      0x40000008
                  |L4.104|
                          DCD      0x04000008
                  |L4.108|
                          DCD      0x40020000
                  |L4.112|
                          DCD      0x000186a0
                  |L4.116|
                          DCD      0xe000e100
                  |L4.120|
                          DCD      0x40120000

                          AREA ||i.Hal_I2c_Transfer||, CODE, READONLY, ALIGN=2

                  Hal_I2c_Transfer PROC
;;;104     */
;;;105    void Hal_I2c_Transfer(uint8_t addr, uint8_t* tx_arr, uint32_t tx_len, uint8_t* rx_arr, uint32_t rx_len)
000000  b5ff              PUSH     {r0-r7,lr}
;;;106    {
;;;107        /* first check bus and wait */
;;;108        while(i2c_trans_data.is_in_trans)
000002  4c1c              LDR      r4,|L5.116|
000004  b081              SUB      sp,sp,#4              ;106
000006  4616              MOV      r6,r2                 ;106
000008  4607              MOV      r7,r0                 ;106
                  |L5.10|
00000a  7d20              LDRB     r0,[r4,#0x14]  ; i2c_trans_data
00000c  2800              CMP      r0,#0
00000e  d1fc              BNE      |L5.10|
;;;109        {
;;;110            ; /* wait */
;;;111        }
;;;112    
;;;113        /* leave when error */
;;;114        if(I2C_GetStatus(I2C0) == I2C_STATUS_ERROR)
000010  4d19              LDR      r5,|L5.120|
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       I2C_GetStatus
000018  2800              CMP      r0,#0
00001a  d109              BNE      |L5.48|
;;;115        {
;;;116       // 	printf("I2C_STATUS_ERROR\n");
;;;117            if((sys_err & SYS_ERR_I2C0) == 0)
00001c  4817              LDR      r0,|L5.124|
00001e  7801              LDRB     r1,[r0,#0]  ; sys_err
000020  0789              LSLS     r1,r1,#30
000022  d405              BMI      |L5.48|
;;;118            {
;;;119                sys_err |= SYS_ERR_I2C0;
000024  7801              LDRB     r1,[r0,#0]  ; sys_err
000026  2202              MOVS     r2,#2
000028  4311              ORRS     r1,r1,r2
00002a  7001              STRB     r1,[r0,#0]
                  |L5.44|
;;;120                return;
;;;121            }
;;;122        }
;;;123    
;;;124        /* set data */
;;;125        i2c_trans_data.slave_addr  = addr;
;;;126        i2c_trans_data.p_tx_buff   = tx_arr;
;;;127        i2c_trans_data.p_rx_buff   = rx_arr;
;;;128        i2c_trans_data.tx_buff_len = tx_len;
;;;129        i2c_trans_data.rx_buff_len = rx_len;
;;;130        i2c_trans_data.curr_tx_pos = 0;
;;;131        i2c_trans_data.curr_rx_pos = 0;
;;;132        i2c_trans_data.next_status = I2C_STATUS_START_OK;
;;;133        i2c_trans_data.wait_cnt    = 0;
;;;134        i2c_trans_data.is_in_trans = TRUE;
;;;135    
;;;136        /* start */
;;;137        I2C_ClearTimeoutFlag(I2C0);
;;;138        I2C_Trigger(I2C0, 1, 0, 1, 0);
;;;139        I2C_EnableInt(I2C0);
;;;140    //	printf("last check bus and wait\n");
;;;141        /* last check bus and wait */
;;;142    #if 1
;;;143        while(i2c_trans_data.is_in_trans)
;;;144        {
;;;145            ; /* wait */
;;;146        }
;;;147    #endif
;;;148    }
00002c  b005              ADD      sp,sp,#0x14
00002e  bdf0              POP      {r4-r7,pc}
                  |L5.48|
000030  74a7              STRB     r7,[r4,#0x12]         ;125
000032  9802              LDR      r0,[sp,#8]            ;126
000034  6020              STR      r0,[r4,#0]            ;126  ; i2c_trans_data
000036  9804              LDR      r0,[sp,#0x10]         ;127
000038  6060              STR      r0,[r4,#4]            ;127  ; i2c_trans_data
00003a  8126              STRH     r6,[r4,#8]            ;128
00003c  980a              LDR      r0,[sp,#0x28]         ;129
00003e  8160              STRH     r0,[r4,#0xa]          ;129
000040  2600              MOVS     r6,#0                 ;130
000042  81a6              STRH     r6,[r4,#0xc]          ;130
000044  81e6              STRH     r6,[r4,#0xe]          ;131
000046  2008              MOVS     r0,#8                 ;132
000048  74e0              STRB     r0,[r4,#0x13]         ;132
00004a  8226              STRH     r6,[r4,#0x10]         ;133
00004c  2001              MOVS     r0,#1                 ;134
00004e  7520              STRB     r0,[r4,#0x14]         ;134
000050  4628              MOV      r0,r5                 ;137
000052  f7fffffe          BL       I2C_ClearTimeoutFlag
000056  2301              MOVS     r3,#1                 ;138
000058  2200              MOVS     r2,#0                 ;138
00005a  4619              MOV      r1,r3                 ;138
00005c  4628              MOV      r0,r5                 ;138
00005e  9600              STR      r6,[sp,#0]            ;138
000060  f7fffffe          BL       I2C_Trigger
000064  4628              MOV      r0,r5                 ;139
000066  f7fffffe          BL       I2C_EnableInt
                  |L5.106|
00006a  7d20              LDRB     r0,[r4,#0x14]         ;143  ; i2c_trans_data
00006c  2800              CMP      r0,#0                 ;143
00006e  d1fc              BNE      |L5.106|
000070  e7dc              B        |L5.44|
;;;149    
                          ENDP

000072  0000              DCW      0x0000
                  |L5.116|
                          DCD      ||.bss||
                  |L5.120|
                          DCD      0x40020000
                  |L5.124|
                          DCD      sys_err

                          AREA ||i.I2C0_IRQHandler||, CODE, READONLY, ALIGN=2

                  I2C0_IRQHandler PROC
;;;201     */
;;;202    void I2C0_IRQHandler(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;203    {
;;;204        uint16_t tmp;
;;;205        uint8_t*  tp;
;;;206        volatile uint32_t status;
;;;207    
;;;208    	status = I2C_GET_STATUS(I2C0);
000002  4d59              LDR      r5,|L6.360|
000004  68e8              LDR      r0,[r5,#0xc]
000006  2601              MOVS     r6,#1
000008  9000              STR      r0,[sp,#0]
00000a  4958              LDR      r1,|L6.364|
00000c  04b0              LSLS     r0,r6,#18
00000e  6008              STR      r0,[r1,#0]
;;;209    
;;;210        NVIC_ClearPendingIRQ(I2C0_IRQn);
;;;211    
;;;212        if(I2C_GET_TIMEOUT_FLAG(I2C0))
000010  6968              LDR      r0,[r5,#0x14]
000012  43c0              MVNS     r0,r0
000014  07c0              LSLS     r0,r0,#31
000016  d027              BEQ      |L6.104|
;;;213        {
;;;214            I2C_ClearTimeoutFlag(I2C0);
;;;215            Hal_I2c0_Stop();
;;;216            return;
;;;217        }
;;;218    
;;;219        if(i2c_trans_data.next_status != status)
000018  4c55              LDR      r4,|L6.368|
00001a  7ce1              LDRB     r1,[r4,#0x13]  ; i2c_trans_data
00001c  9800              LDR      r0,[sp,#0]
;;;220        {
;;;221            i2c_trans_data.wait_cnt++;
;;;222    
;;;223            if(i2c_trans_data.wait_cnt > I2C_WAIT_CYCLE)
;;;224            {
;;;225                if((sys_err & SYS_ERR_I2C0) == 0)
00001e  4f55              LDR      r7,|L6.372|
000020  4281              CMP      r1,r0                 ;219
000022  d010              BEQ      |L6.70|
000024  8a20              LDRH     r0,[r4,#0x10]         ;221  ; i2c_trans_data
000026  1c40              ADDS     r0,r0,#1              ;221
000028  8220              STRH     r0,[r4,#0x10]         ;221
00002a  8a20              LDRH     r0,[r4,#0x10]         ;223  ; i2c_trans_data
00002c  21ff              MOVS     r1,#0xff              ;223
00002e  31f5              ADDS     r1,r1,#0xf5           ;223
000030  4288              CMP      r0,r1                 ;223
000032  d908              BLS      |L6.70|
000034  7838              LDRB     r0,[r7,#0]  ; sys_err
000036  0780              LSLS     r0,r0,#30
000038  d403              BMI      |L6.66|
;;;226                {
;;;227                    sys_err |= SYS_ERR_I2C0;
00003a  7838              LDRB     r0,[r7,#0]  ; sys_err
00003c  2102              MOVS     r1,#2
00003e  4308              ORRS     r0,r0,r1
000040  7038              STRB     r0,[r7,#0]
                  |L6.66|
;;;228                }
;;;229    
;;;230                Hal_I2c0_Stop();
000042  f7fffffe          BL       Hal_I2c0_Stop
                  |L6.70|
;;;231            }
;;;232        }
;;;233    //	printf("i2c*****status0= 0x%x\n",status);
;;;234        switch (status)
000046  9800              LDR      r0,[sp,#0]
000048  0741              LSLS     r1,r0,#29
00004a  0f49              LSRS     r1,r1,#29
00004c  d131              BNE      |L6.178|
00004e  10c2              ASRS     r2,r0,#3
;;;235        {
;;;236            case I2C_STATUS_ERROR:
;;;237            case I2C_STATUS_TRANS_ADDR_NAK:
;;;238            case I2C_STATUS_TRANS_DATA_NAK:
;;;239            case I2C_STATUS_REC_ADDR_NAK:
;;;240                if((sys_err & SYS_ERR_I2C0) == 0)
;;;241                {
;;;242                    sys_err |= SYS_ERR_I2C0;
;;;243                }
;;;244    
;;;245                Hal_I2c0_Stop();
;;;246    
;;;247                break;
;;;248    
;;;249            /* 1st start */
;;;250            case I2C_STATUS_START_OK:
;;;251                i2c_trans_data.next_status = I2C_STATUS_TRANS_ADDR_ACK;
;;;252                i2c_trans_data.wait_cnt = 0;
;;;253                I2C_SetData(I2C0, i2c_trans_data.slave_addr | I2C_DIR_WRITE);
;;;254                I2C_Trigger(I2C0, 0, 0, 1, 0);
;;;255                break;
;;;256    
;;;257            /* tx transfer */
;;;258            case I2C_STATUS_TRANS_ADDR_ACK:
;;;259                if(i2c_trans_data.tx_buff_len)
;;;260                {
;;;261                    i2c_trans_data.next_status = I2C_STATUS_TRANS_DATA_ACK;
000050  2128              MOVS     r1,#0x28
000052  2000              MOVS     r0,#0
000054  0013              MOVS     r3,r2                 ;234
000056  f7fffffe          BL       __ARM_common_switch8
00005a  0c0b              DCB      0x0c,0x0b
00005c  13491c0b          DCB      0x13,0x49,0x1c,0x0b
000060  2d0b2c57          DCB      0x2d,0x0b,0x2c,0x57
000064  0b65842c          DCB      0x0b,0x65,0x84,0x2c
                  |L6.104|
000068  4628              MOV      r0,r5                 ;214
00006a  f7fffffe          BL       I2C_ClearTimeoutFlag
00006e  e078              B        |L6.354|
000070  7838              LDRB     r0,[r7,#0]            ;240  ; sys_err
000072  0780              LSLS     r0,r0,#30             ;240
000074  d475              BMI      |L6.354|
000076  7838              LDRB     r0,[r7,#0]            ;242  ; sys_err
000078  2102              MOVS     r1,#2                 ;242
00007a  4308              ORRS     r0,r0,r1              ;242
00007c  7038              STRB     r0,[r7,#0]            ;242
00007e  e070              B        |L6.354|
000080  2118              MOVS     r1,#0x18              ;251
000082  74e1              STRB     r1,[r4,#0x13]         ;251
000084  4606              MOV      r6,r0                 ;252
000086  8220              STRH     r0,[r4,#0x10]         ;252
000088  7ca1              LDRB     r1,[r4,#0x12]         ;253  ; i2c_trans_data
00008a  4628              MOV      r0,r5                 ;253
00008c  f7fffffe          BL       I2C_SetData
000090  e01f              B        |L6.210|
000092  8922              LDRH     r2,[r4,#8]            ;259  ; i2c_trans_data
000094  2a00              CMP      r2,#0                 ;259
000096  d064              BEQ      |L6.354|
000098  74e1              STRB     r1,[r4,#0x13]
;;;262                    i2c_trans_data.wait_cnt = 0;
00009a  4607              MOV      r7,r0
00009c  8220              STRH     r0,[r4,#0x10]
;;;263                    I2C_SetData(I2C0, i2c_trans_data.p_tx_buff[0]);
00009e  6820              LDR      r0,[r4,#0]  ; i2c_trans_data
0000a0  7801              LDRB     r1,[r0,#0]
0000a2  4628              MOV      r0,r5
0000a4  f7fffffe          BL       I2C_SetData
;;;264                    i2c_trans_data.curr_tx_pos = 1;
0000a8  81a6              STRH     r6,[r4,#0xc]
;;;265                    I2C_Trigger(I2C0, 0, 0, 1, 0);
0000aa  e02b              B        |L6.260|
                  |L6.172|
0000ac  4628              MOV      r0,r5                 ;254
0000ae  f7fffffe          BL       I2C_Trigger
                  |L6.178|
;;;266                }
;;;267                else
;;;268                {
;;;269                    Hal_I2c0_Stop();
;;;270                }
;;;271                break;
;;;272    
;;;273            /* tx transfer */
;;;274            case I2C_STATUS_TRANS_DATA_ACK:
;;;275                tmp = i2c_trans_data.curr_tx_pos;
;;;276    
;;;277                if(tmp < i2c_trans_data.tx_buff_len)
;;;278                {
;;;279                    i2c_trans_data.next_status = I2C_STATUS_TRANS_DATA_ACK;
;;;280                    i2c_trans_data.wait_cnt = 0;
;;;281                    I2C_SetData(I2C0, i2c_trans_data.p_tx_buff[tmp]);
;;;282                    i2c_trans_data.curr_tx_pos++;
;;;283                    I2C_Trigger(I2C0, 0, 0, 1, 0);
;;;284                }
;;;285                else if(i2c_trans_data.rx_buff_len)
;;;286                {
;;;287                    /* repeat start */
;;;288                    i2c_trans_data.next_status = I2C_STATUS_REPEAT_START_OK;
;;;289                    i2c_trans_data.wait_cnt = 0;
;;;290                    I2C_Trigger(I2C0, 1, 0, 1, 0);
;;;291                }
;;;292                else
;;;293                {
;;;294                    /* stop */
;;;295                    Hal_I2c0_Stop();
;;;296                }
;;;297                break;
;;;298    
;;;299            case I2C_STATUS_REPEAT_START_OK:
;;;300                if(i2c_trans_data.rx_buff_len)
;;;301                {
;;;302                    i2c_trans_data.next_status = I2C_STATUS_REC_ADDR_ACK;
;;;303                    i2c_trans_data.wait_cnt = 0;
;;;304                    I2C_SetData(I2C0, i2c_trans_data.slave_addr | I2C_DIR_READ);
;;;305                    I2C_Trigger(I2C0, 0, 0, 1, 0);
;;;306                }
;;;307                else
;;;308                {
;;;309                    Hal_I2c0_Stop();
;;;310                }
;;;311                break;
;;;312    
;;;313            case I2C_STATUS_REC_ADDR_ACK:
;;;314                if(i2c_trans_data.rx_buff_len)
;;;315                {
;;;316                    i2c_trans_data.next_status = I2C_STATUS_REC_DATA_ACK;
;;;317                    i2c_trans_data.wait_cnt = 0;
;;;318                    /* this is the ack for the 1st rx byte */
;;;319                    if(i2c_trans_data.rx_buff_len == 1)
;;;320                    {
;;;321                        I2C_Trigger(I2C0, 0, 0, 1, 0);
;;;322                    }
;;;323                    else
;;;324                    {
;;;325                        I2C_Trigger(I2C0, 0, 0, 1, 1);
;;;326                    }
;;;327                }
;;;328                else
;;;329                {
;;;330                    Hal_I2c0_Stop();
;;;331                }
;;;332                break;
;;;333    
;;;334            case I2C_STATUS_REC_DATA_ACK:
;;;335                tmp = i2c_trans_data.curr_rx_pos;
;;;336                tp  = i2c_trans_data.p_rx_buff;
;;;337    
;;;338                if(tmp < i2c_trans_data.rx_buff_len)
;;;339                {
;;;340                    if(i2c_trans_data.rx_buff_len - tmp == 2)
;;;341                    {
;;;342                        /* should send nak for the last byte */
;;;343                        i2c_trans_data.next_status = I2C_STATUS_REC_DATA_NAK;
;;;344                    }
;;;345                    else
;;;346                    {
;;;347                        i2c_trans_data.next_status = I2C_STATUS_REC_DATA_ACK;
;;;348                    }
;;;349    
;;;350                    i2c_trans_data.wait_cnt = 0;
;;;351                    tp[tmp] = (uint8_t)(I2C_GetData(I2C0) & 0xFF);
;;;352                    i2c_trans_data.curr_rx_pos++;
;;;353    
;;;354                    if(i2c_trans_data.rx_buff_len - tmp == 2)
;;;355                    {
;;;356                        I2C_Trigger(I2C0, 0, 0, 1, 0);
;;;357                    }
;;;358                    else
;;;359                    {
;;;360                        I2C_Trigger(I2C0, 0, 0, 1, 1);
;;;361                    }
;;;362                }
;;;363                else
;;;364                {
;;;365                    Hal_I2c0_Stop();
;;;366                }
;;;367                break;
;;;368    
;;;369            case I2C_STATUS_REC_DATA_NAK:
;;;370                /* stop */
;;;371                Hal_I2c0_Stop();
;;;372                break;
;;;373    
;;;374            default:
;;;375                break;
;;;376        }
;;;377    }
0000b2  bdf8              POP      {r3-r7,pc}
0000b4  89a2              LDRH     r2,[r4,#0xc]          ;275  ; i2c_trans_data
0000b6  8923              LDRH     r3,[r4,#8]            ;277  ; i2c_trans_data
0000b8  4293              CMP      r3,r2                 ;277
0000ba  d90c              BLS      |L6.214|
0000bc  74e1              STRB     r1,[r4,#0x13]         ;279
0000be  4606              MOV      r6,r0                 ;280
0000c0  8220              STRH     r0,[r4,#0x10]         ;280
0000c2  6820              LDR      r0,[r4,#0]            ;281  ; i2c_trans_data
0000c4  5c81              LDRB     r1,[r0,r2]            ;281
0000c6  4628              MOV      r0,r5                 ;281
0000c8  f7fffffe          BL       I2C_SetData
0000cc  89a1              LDRH     r1,[r4,#0xc]          ;282  ; i2c_trans_data
0000ce  1c49              ADDS     r1,r1,#1              ;282
0000d0  81a1              STRH     r1,[r4,#0xc]          ;282
                  |L6.210|
0000d2  9600              STR      r6,[sp,#0]            ;283
0000d4  e022              B        |L6.284|
                  |L6.214|
0000d6  8961              LDRH     r1,[r4,#0xa]          ;285  ; i2c_trans_data
0000d8  2900              CMP      r1,#0                 ;285
0000da  d042              BEQ      |L6.354|
0000dc  2110              MOVS     r1,#0x10              ;288
0000de  74e1              STRB     r1,[r4,#0x13]         ;288
0000e0  8220              STRH     r0,[r4,#0x10]         ;289
0000e2  2301              MOVS     r3,#1                 ;290
0000e4  2200              MOVS     r2,#0                 ;290
0000e6  4619              MOV      r1,r3                 ;290
0000e8  9000              STR      r0,[sp,#0]            ;290
0000ea  e7df              B        |L6.172|
0000ec  8961              LDRH     r1,[r4,#0xa]          ;300  ; i2c_trans_data
0000ee  2900              CMP      r1,#0                 ;300
0000f0  d037              BEQ      |L6.354|
0000f2  2140              MOVS     r1,#0x40              ;302
0000f4  74e1              STRB     r1,[r4,#0x13]         ;302
0000f6  4607              MOV      r7,r0                 ;303
0000f8  8220              STRH     r0,[r4,#0x10]         ;303
0000fa  7ca1              LDRB     r1,[r4,#0x12]         ;304  ; i2c_trans_data
0000fc  4628              MOV      r0,r5                 ;304
0000fe  4331              ORRS     r1,r1,r6              ;304
000100  f7fffffe          BL       I2C_SetData
                  |L6.260|
000104  9700              STR      r7,[sp,#0]            ;265
000106  e009              B        |L6.284|
000108  8961              LDRH     r1,[r4,#0xa]          ;314  ; i2c_trans_data
00010a  2900              CMP      r1,#0                 ;314
00010c  d029              BEQ      |L6.354|
00010e  2150              MOVS     r1,#0x50              ;316
000110  74e1              STRB     r1,[r4,#0x13]         ;316
000112  8220              STRH     r0,[r4,#0x10]         ;317
000114  8961              LDRH     r1,[r4,#0xa]          ;319  ; i2c_trans_data
000116  2901              CMP      r1,#1                 ;319
000118  d1db              BNE      |L6.210|
                  |L6.282|
00011a  9000              STR      r0,[sp,#0]            ;321
                  |L6.284|
00011c  2301              MOVS     r3,#1                 ;360
00011e  2200              MOVS     r2,#0                 ;360
000120  4611              MOV      r1,r2                 ;360
000122  e7c3              B        |L6.172|
000124  89e7              LDRH     r7,[r4,#0xe]          ;335  ; i2c_trans_data
000126  6861              LDR      r1,[r4,#4]            ;336  ; i2c_trans_data
000128  9100              STR      r1,[sp,#0]            ;338
00012a  8961              LDRH     r1,[r4,#0xa]          ;338  ; i2c_trans_data
00012c  42b9              CMP      r1,r7                 ;338
00012e  d918              BLS      |L6.354|
000130  8961              LDRH     r1,[r4,#0xa]          ;340  ; i2c_trans_data
000132  1bc9              SUBS     r1,r1,r7              ;340
000134  2902              CMP      r1,#2                 ;340
000136  d012              BEQ      |L6.350|
000138  2150              MOVS     r1,#0x50              ;347
                  |L6.314|
00013a  74e1              STRB     r1,[r4,#0x13]         ;347
00013c  2000              MOVS     r0,#0                 ;350
00013e  8220              STRH     r0,[r4,#0x10]         ;350
000140  4628              MOV      r0,r5                 ;351
000142  f7fffffe          BL       I2C_GetData
000146  4601              MOV      r1,r0                 ;351
000148  9800              LDR      r0,[sp,#0]            ;351
00014a  55c1              STRB     r1,[r0,r7]            ;351
00014c  89e0              LDRH     r0,[r4,#0xe]          ;352  ; i2c_trans_data
00014e  1c40              ADDS     r0,r0,#1              ;352
000150  81e0              STRH     r0,[r4,#0xe]          ;352
000152  8960              LDRH     r0,[r4,#0xa]          ;354  ; i2c_trans_data
000154  1bc0              SUBS     r0,r0,r7              ;354
000156  2802              CMP      r0,#2                 ;354
000158  d1bb              BNE      |L6.210|
00015a  2000              MOVS     r0,#0                 ;356
00015c  e7dd              B        |L6.282|
                  |L6.350|
00015e  2158              MOVS     r1,#0x58              ;343
000160  e7eb              B        |L6.314|
                  |L6.354|
000162  f7fffffe          BL       Hal_I2c0_Stop
000166  bdf8              POP      {r3-r7,pc}
;;;378    
                          ENDP

                  |L6.360|
                          DCD      0x40020000
                  |L6.364|
                          DCD      0xe000e280
                  |L6.368|
                          DCD      ||.bss||
                  |L6.372|
                          DCD      sys_err

                          AREA ||i.I2C1_IRQHandler||, CODE, READONLY, ALIGN=2

                  I2C1_IRQHandler PROC
;;;384     */
;;;385    void I2C1_IRQHandler(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;386    {
;;;387        uint16_t tmp;
;;;388        uint8_t*  tp;
;;;389        volatile uint32_t status;
;;;390    
;;;391        status = I2C_GET_STATUS(I2C1);
000002  4d59              LDR      r5,|L7.360|
000004  68e8              LDR      r0,[r5,#0xc]
000006  2601              MOVS     r6,#1
000008  9000              STR      r0,[sp,#0]
00000a  4958              LDR      r1,|L7.364|
00000c  04f0              LSLS     r0,r6,#19
00000e  6008              STR      r0,[r1,#0]
;;;392    
;;;393        NVIC_ClearPendingIRQ(I2C1_IRQn);
;;;394    
;;;395        if(I2C_GET_TIMEOUT_FLAG(I2C1))
000010  6968              LDR      r0,[r5,#0x14]
000012  43c0              MVNS     r0,r0
000014  07c0              LSLS     r0,r0,#31
000016  d027              BEQ      |L7.104|
;;;396        {
;;;397            I2C_ClearTimeoutFlag(I2C1);
;;;398            Hal_I2c1_Stop();
;;;399            return;
;;;400        }
;;;401    
;;;402        if(i2c_trans_data.next_status != status)
000018  4c55              LDR      r4,|L7.368|
00001a  7ce1              LDRB     r1,[r4,#0x13]  ; i2c_trans_data
00001c  9800              LDR      r0,[sp,#0]
;;;403        {
;;;404            i2c_trans_data.wait_cnt++;
;;;405    
;;;406            if(i2c_trans_data.wait_cnt > I2C_WAIT_CYCLE)
;;;407            {
;;;408                if((sys_err & SYS_ERR_I2C1) == 0)
00001e  4f55              LDR      r7,|L7.372|
000020  4281              CMP      r1,r0                 ;402
000022  d010              BEQ      |L7.70|
000024  8a20              LDRH     r0,[r4,#0x10]         ;404  ; i2c_trans_data
000026  1c40              ADDS     r0,r0,#1              ;404
000028  8220              STRH     r0,[r4,#0x10]         ;404
00002a  8a20              LDRH     r0,[r4,#0x10]         ;406  ; i2c_trans_data
00002c  21ff              MOVS     r1,#0xff              ;406
00002e  31f5              ADDS     r1,r1,#0xf5           ;406
000030  4288              CMP      r0,r1                 ;406
000032  d908              BLS      |L7.70|
000034  7838              LDRB     r0,[r7,#0]  ; sys_err
000036  0740              LSLS     r0,r0,#29
000038  d403              BMI      |L7.66|
;;;409                {
;;;410                    sys_err |= SYS_ERR_I2C1;
00003a  7838              LDRB     r0,[r7,#0]  ; sys_err
00003c  2104              MOVS     r1,#4
00003e  4308              ORRS     r0,r0,r1
000040  7038              STRB     r0,[r7,#0]
                  |L7.66|
;;;411                }
;;;412    
;;;413                Hal_I2c1_Stop();
000042  f7fffffe          BL       Hal_I2c1_Stop
                  |L7.70|
;;;414            }
;;;415        }
;;;416    //	printf("i2c1*****status= 0x%x\n",status);
;;;417    
;;;418        switch (status)
000046  9800              LDR      r0,[sp,#0]
000048  0741              LSLS     r1,r0,#29
00004a  0f49              LSRS     r1,r1,#29
00004c  d131              BNE      |L7.178|
00004e  10c2              ASRS     r2,r0,#3
;;;419        {
;;;420            case I2C_STATUS_ERROR:
;;;421            case I2C_STATUS_TRANS_ADDR_NAK:
;;;422            case I2C_STATUS_TRANS_DATA_NAK:
;;;423            case I2C_STATUS_REC_ADDR_NAK:
;;;424                if((sys_err & SYS_ERR_I2C1) == 0)
;;;425                {
;;;426                    sys_err |= SYS_ERR_I2C1;
;;;427                }
;;;428    
;;;429                Hal_I2c1_Stop();
;;;430    
;;;431                break;
;;;432    
;;;433            /* 1st start */
;;;434            case I2C_STATUS_START_OK:
;;;435                i2c_trans_data.next_status = I2C_STATUS_TRANS_ADDR_ACK;
;;;436                i2c_trans_data.wait_cnt = 0;
;;;437                I2C_SetData(I2C1, i2c_trans_data.slave_addr | I2C_DIR_WRITE);
;;;438                I2C_Trigger(I2C1, 0, 0, 1, 0);
;;;439                break;
;;;440    
;;;441            /* tx transfer */
;;;442            case I2C_STATUS_TRANS_ADDR_ACK:
;;;443                if(i2c_trans_data.tx_buff_len)
;;;444                {
;;;445                    i2c_trans_data.next_status = I2C_STATUS_TRANS_DATA_ACK;
000050  2128              MOVS     r1,#0x28
000052  2000              MOVS     r0,#0
000054  0013              MOVS     r3,r2                 ;418
000056  f7fffffe          BL       __ARM_common_switch8
00005a  0c0b              DCB      0x0c,0x0b
00005c  13491c0b          DCB      0x13,0x49,0x1c,0x0b
000060  2d0b2c57          DCB      0x2d,0x0b,0x2c,0x57
000064  0b65842c          DCB      0x0b,0x65,0x84,0x2c
                  |L7.104|
000068  4628              MOV      r0,r5                 ;397
00006a  f7fffffe          BL       I2C_ClearTimeoutFlag
00006e  e078              B        |L7.354|
000070  7838              LDRB     r0,[r7,#0]            ;424  ; sys_err
000072  0740              LSLS     r0,r0,#29             ;424
000074  d475              BMI      |L7.354|
000076  7838              LDRB     r0,[r7,#0]            ;426  ; sys_err
000078  2104              MOVS     r1,#4                 ;426
00007a  4308              ORRS     r0,r0,r1              ;426
00007c  7038              STRB     r0,[r7,#0]            ;426
00007e  e070              B        |L7.354|
000080  2118              MOVS     r1,#0x18              ;435
000082  74e1              STRB     r1,[r4,#0x13]         ;435
000084  4606              MOV      r6,r0                 ;436
000086  8220              STRH     r0,[r4,#0x10]         ;436
000088  7ca1              LDRB     r1,[r4,#0x12]         ;437  ; i2c_trans_data
00008a  4628              MOV      r0,r5                 ;437
00008c  f7fffffe          BL       I2C_SetData
000090  e01f              B        |L7.210|
000092  8922              LDRH     r2,[r4,#8]            ;443  ; i2c_trans_data
000094  2a00              CMP      r2,#0                 ;443
000096  d064              BEQ      |L7.354|
000098  74e1              STRB     r1,[r4,#0x13]
;;;446                    i2c_trans_data.wait_cnt = 0;
00009a  4607              MOV      r7,r0
00009c  8220              STRH     r0,[r4,#0x10]
;;;447                    I2C_SetData(I2C1, i2c_trans_data.p_tx_buff[0]);
00009e  6820              LDR      r0,[r4,#0]  ; i2c_trans_data
0000a0  7801              LDRB     r1,[r0,#0]
0000a2  4628              MOV      r0,r5
0000a4  f7fffffe          BL       I2C_SetData
;;;448                    i2c_trans_data.curr_tx_pos = 1;
0000a8  81a6              STRH     r6,[r4,#0xc]
;;;449                    I2C_Trigger(I2C1, 0, 0, 1, 0);
0000aa  e02b              B        |L7.260|
                  |L7.172|
0000ac  4628              MOV      r0,r5                 ;438
0000ae  f7fffffe          BL       I2C_Trigger
                  |L7.178|
;;;450                }
;;;451                else
;;;452                {
;;;453                    Hal_I2c1_Stop();
;;;454                }
;;;455                break;
;;;456    
;;;457            /* tx transfer */
;;;458            case I2C_STATUS_TRANS_DATA_ACK:
;;;459                tmp = i2c_trans_data.curr_tx_pos;
;;;460    
;;;461                if(tmp < i2c_trans_data.tx_buff_len)
;;;462                {
;;;463                    i2c_trans_data.next_status = I2C_STATUS_TRANS_DATA_ACK;
;;;464                    i2c_trans_data.wait_cnt = 0;
;;;465                    I2C_SetData(I2C1, i2c_trans_data.p_tx_buff[tmp]);
;;;466                    i2c_trans_data.curr_tx_pos++;
;;;467                    I2C_Trigger(I2C1, 0, 0, 1, 0);
;;;468                }
;;;469                else if(i2c_trans_data.rx_buff_len)
;;;470                {
;;;471                    /* repeat start */
;;;472                    i2c_trans_data.next_status = I2C_STATUS_REPEAT_START_OK;
;;;473                    i2c_trans_data.wait_cnt = 0;
;;;474                    I2C_Trigger(I2C1, 1, 0, 1, 0);
;;;475                }
;;;476                else
;;;477                {
;;;478                    /* stop */
;;;479                    Hal_I2c1_Stop();
;;;480                }
;;;481                break;
;;;482    
;;;483            case I2C_STATUS_REPEAT_START_OK:
;;;484                if(i2c_trans_data.rx_buff_len)
;;;485                {
;;;486                    i2c_trans_data.next_status = I2C_STATUS_REC_ADDR_ACK;
;;;487                    i2c_trans_data.wait_cnt = 0;
;;;488                    I2C_SetData(I2C1, i2c_trans_data.slave_addr | I2C_DIR_READ);
;;;489                    I2C_Trigger(I2C1, 0, 0, 1, 0);
;;;490                }
;;;491                else
;;;492                {
;;;493                    Hal_I2c1_Stop();
;;;494                }
;;;495                break;
;;;496    
;;;497            case I2C_STATUS_REC_ADDR_ACK:
;;;498                if(i2c_trans_data.rx_buff_len)
;;;499                {
;;;500                    i2c_trans_data.next_status = I2C_STATUS_REC_DATA_ACK;
;;;501                    i2c_trans_data.wait_cnt = 0;
;;;502                    /* this is the ack for the 1st rx byte */
;;;503                    if(i2c_trans_data.rx_buff_len == 1)
;;;504                    {
;;;505                        I2C_Trigger(I2C1, 0, 0, 1, 0);
;;;506                    }
;;;507                    else
;;;508                    {
;;;509                        I2C_Trigger(I2C1, 0, 0, 1, 1);
;;;510                    }
;;;511                }
;;;512                else
;;;513                {
;;;514                    Hal_I2c1_Stop();
;;;515                }
;;;516                break;
;;;517    
;;;518            case I2C_STATUS_REC_DATA_ACK:
;;;519                tmp = i2c_trans_data.curr_rx_pos;
;;;520                tp  = i2c_trans_data.p_rx_buff;
;;;521    
;;;522                if(tmp < i2c_trans_data.rx_buff_len)
;;;523                {
;;;524                    if(i2c_trans_data.rx_buff_len - tmp == 2)
;;;525                    {
;;;526                        /* should send nak for the last byte */
;;;527                        i2c_trans_data.next_status = I2C_STATUS_REC_DATA_NAK;
;;;528                    }
;;;529                    else
;;;530                    {
;;;531                        i2c_trans_data.next_status = I2C_STATUS_REC_DATA_ACK;
;;;532                    }
;;;533    
;;;534                    i2c_trans_data.wait_cnt = 0;
;;;535                    tp[tmp] = (uint8_t)(I2C_GetData(I2C1) & 0xFF);
;;;536                    i2c_trans_data.curr_rx_pos++;
;;;537    
;;;538                    if(i2c_trans_data.rx_buff_len - tmp == 2)
;;;539                    {
;;;540                        I2C_Trigger(I2C1, 0, 0, 1, 0);
;;;541                    }
;;;542                    else
;;;543                    {
;;;544                        I2C_Trigger(I2C1, 0, 0, 1, 1);
;;;545                    }
;;;546                }
;;;547                else
;;;548                {
;;;549                    Hal_I2c1_Stop();
;;;550                }
;;;551                break;
;;;552    
;;;553            case I2C_STATUS_REC_DATA_NAK:
;;;554                /* stop */
;;;555                Hal_I2c1_Stop();
;;;556                break;
;;;557    
;;;558            default:
;;;559                break;
;;;560        }
;;;561    }
0000b2  bdf8              POP      {r3-r7,pc}
0000b4  89a2              LDRH     r2,[r4,#0xc]          ;459  ; i2c_trans_data
0000b6  8923              LDRH     r3,[r4,#8]            ;461  ; i2c_trans_data
0000b8  4293              CMP      r3,r2                 ;461
0000ba  d90c              BLS      |L7.214|
0000bc  74e1              STRB     r1,[r4,#0x13]         ;463
0000be  4606              MOV      r6,r0                 ;464
0000c0  8220              STRH     r0,[r4,#0x10]         ;464
0000c2  6820              LDR      r0,[r4,#0]            ;465  ; i2c_trans_data
0000c4  5c81              LDRB     r1,[r0,r2]            ;465
0000c6  4628              MOV      r0,r5                 ;465
0000c8  f7fffffe          BL       I2C_SetData
0000cc  89a1              LDRH     r1,[r4,#0xc]          ;466  ; i2c_trans_data
0000ce  1c49              ADDS     r1,r1,#1              ;466
0000d0  81a1              STRH     r1,[r4,#0xc]          ;466
                  |L7.210|
0000d2  9600              STR      r6,[sp,#0]            ;467
0000d4  e022              B        |L7.284|
                  |L7.214|
0000d6  8961              LDRH     r1,[r4,#0xa]          ;469  ; i2c_trans_data
0000d8  2900              CMP      r1,#0                 ;469
0000da  d042              BEQ      |L7.354|
0000dc  2110              MOVS     r1,#0x10              ;472
0000de  74e1              STRB     r1,[r4,#0x13]         ;472
0000e0  8220              STRH     r0,[r4,#0x10]         ;473
0000e2  2301              MOVS     r3,#1                 ;474
0000e4  2200              MOVS     r2,#0                 ;474
0000e6  4619              MOV      r1,r3                 ;474
0000e8  9000              STR      r0,[sp,#0]            ;474
0000ea  e7df              B        |L7.172|
0000ec  8961              LDRH     r1,[r4,#0xa]          ;484  ; i2c_trans_data
0000ee  2900              CMP      r1,#0                 ;484
0000f0  d037              BEQ      |L7.354|
0000f2  2140              MOVS     r1,#0x40              ;486
0000f4  74e1              STRB     r1,[r4,#0x13]         ;486
0000f6  4607              MOV      r7,r0                 ;487
0000f8  8220              STRH     r0,[r4,#0x10]         ;487
0000fa  7ca1              LDRB     r1,[r4,#0x12]         ;488  ; i2c_trans_data
0000fc  4628              MOV      r0,r5                 ;488
0000fe  4331              ORRS     r1,r1,r6              ;488
000100  f7fffffe          BL       I2C_SetData
                  |L7.260|
000104  9700              STR      r7,[sp,#0]            ;449
000106  e009              B        |L7.284|
000108  8961              LDRH     r1,[r4,#0xa]          ;498  ; i2c_trans_data
00010a  2900              CMP      r1,#0                 ;498
00010c  d029              BEQ      |L7.354|
00010e  2150              MOVS     r1,#0x50              ;500
000110  74e1              STRB     r1,[r4,#0x13]         ;500
000112  8220              STRH     r0,[r4,#0x10]         ;501
000114  8961              LDRH     r1,[r4,#0xa]          ;503  ; i2c_trans_data
000116  2901              CMP      r1,#1                 ;503
000118  d1db              BNE      |L7.210|
                  |L7.282|
00011a  9000              STR      r0,[sp,#0]            ;505
                  |L7.284|
00011c  2301              MOVS     r3,#1                 ;544
00011e  2200              MOVS     r2,#0                 ;544
000120  4611              MOV      r1,r2                 ;544
000122  e7c3              B        |L7.172|
000124  89e7              LDRH     r7,[r4,#0xe]          ;519  ; i2c_trans_data
000126  6861              LDR      r1,[r4,#4]            ;520  ; i2c_trans_data
000128  9100              STR      r1,[sp,#0]            ;522
00012a  8961              LDRH     r1,[r4,#0xa]          ;522  ; i2c_trans_data
00012c  42b9              CMP      r1,r7                 ;522
00012e  d918              BLS      |L7.354|
000130  8961              LDRH     r1,[r4,#0xa]          ;524  ; i2c_trans_data
000132  1bc9              SUBS     r1,r1,r7              ;524
000134  2902              CMP      r1,#2                 ;524
000136  d012              BEQ      |L7.350|
000138  2150              MOVS     r1,#0x50              ;531
                  |L7.314|
00013a  74e1              STRB     r1,[r4,#0x13]         ;531
00013c  2000              MOVS     r0,#0                 ;534
00013e  8220              STRH     r0,[r4,#0x10]         ;534
000140  4628              MOV      r0,r5                 ;535
000142  f7fffffe          BL       I2C_GetData
000146  4601              MOV      r1,r0                 ;535
000148  9800              LDR      r0,[sp,#0]            ;535
00014a  55c1              STRB     r1,[r0,r7]            ;535
00014c  89e0              LDRH     r0,[r4,#0xe]          ;536  ; i2c_trans_data
00014e  1c40              ADDS     r0,r0,#1              ;536
000150  81e0              STRH     r0,[r4,#0xe]          ;536
000152  8960              LDRH     r0,[r4,#0xa]          ;538  ; i2c_trans_data
000154  1bc0              SUBS     r0,r0,r7              ;538
000156  2802              CMP      r0,#2                 ;538
000158  d1bb              BNE      |L7.210|
00015a  2000              MOVS     r0,#0                 ;540
00015c  e7dd              B        |L7.282|
                  |L7.350|
00015e  2158              MOVS     r1,#0x58              ;527
000160  e7eb              B        |L7.314|
                  |L7.354|
000162  f7fffffe          BL       Hal_I2c1_Stop
000166  bdf8              POP      {r3-r7,pc}
;;;562    
                          ENDP

                  |L7.360|
                          DCD      0x40120000
                  |L7.364|
                          DCD      0xe000e280
                  |L7.368|
                          DCD      ||.bss||
                  |L7.372|
                          DCD      sys_err

                          AREA ||i.NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;687     */
;;;688    __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  0783              LSLS     r3,r0,#30
;;;689    {
;;;690        if((int32_t)(IRQn) < 0)
;;;691        {
;;;692            SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
000002  22ff              MOVS     r2,#0xff
000004  0edb              LSRS     r3,r3,#27
000006  409a              LSLS     r2,r2,r3
000008  0789              LSLS     r1,r1,#30
00000a  0e09              LSRS     r1,r1,#24
00000c  4099              LSLS     r1,r1,r3
00000e  2800              CMP      r0,#0                 ;690
000010  da0b              BGE      |L8.42|
000012  0700              LSLS     r0,r0,#28
000014  0f00              LSRS     r0,r0,#28
000016  3808              SUBS     r0,r0,#8
000018  0883              LSRS     r3,r0,#2
00001a  4808              LDR      r0,|L8.60|
00001c  009b              LSLS     r3,r3,#2
00001e  1818              ADDS     r0,r3,r0
000020  69c3              LDR      r3,[r0,#0x1c]
000022  4393              BICS     r3,r3,r2
000024  430b              ORRS     r3,r3,r1
000026  61c3              STR      r3,[r0,#0x1c]
;;;693                                        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
;;;694        }
;;;695        else
;;;696        {
;;;697            NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
;;;698                                        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
;;;699        }
;;;700    }
000028  4770              BX       lr
                  |L8.42|
00002a  0883              LSRS     r3,r0,#2              ;697
00002c  4804              LDR      r0,|L8.64|
00002e  009b              LSLS     r3,r3,#2              ;697
000030  1818              ADDS     r0,r3,r0              ;697
000032  6803              LDR      r3,[r0,#0]            ;697
000034  4393              BICS     r3,r3,r2              ;697
000036  430b              ORRS     r3,r3,r1              ;697
000038  6003              STR      r3,[r0,#0]            ;697
00003a  4770              BX       lr
;;;701    
                          ENDP

                  |L8.60|
                          DCD      0xe000ed00
                  |L8.64|
                          DCD      0xe000e400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  i2c_trans_data
                          %        24

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L54.16|
00000e  461d              MOV      r5,r3
                  |L54.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\src\\io\\hal_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_hal_i2c_c_c0dff8c5____REV16|
#line 388 "..\\lib\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_hal_i2c_c_c0dff8c5____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_hal_i2c_c_c0dff8c5____REVSH|
#line 402
|__asm___9_hal_i2c_c_c0dff8c5____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
