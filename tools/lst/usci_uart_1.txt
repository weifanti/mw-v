; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\usci_uart_1.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\usci_uart_1.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\lib\CMSIS\Include -I..\lib\Device\Nuvoton\NUC029xGE\Include -I..\lib\StdDriver\inc -I..\src\core\include -I..\src\driver\include -I..\src\io\include -I..\src\global -I..\src\server\include -I..\src\driver\audio -D__UVISION_VERSION=522 --omf_browse=.\obj\usci_uart_1.crf ..\lib\StdDriver\src\usci_uart.c]
                          THUMB

                          AREA ||i.UUART_ClearIntFlag||, CODE, READONLY, ALIGN=1

                  UUART_ClearIntFlag PROC
;;;46     
;;;47     void UUART_ClearIntFlag(UUART_T* uuart, uint32_t u32Mask)
000000  078a              LSLS     r2,r1,#30
;;;48     {
000002  d502              BPL      |L1.10|
;;;49     
;;;50         if(u32Mask & UUART_ABR_INT_MASK)  /* Clear Auto-baud Rate Interrupt */
;;;51             uuart->PROTSTS = UUART_PROTSTS_ABRDETIF_Msk;
000004  2201              MOVS     r2,#1
000006  0252              LSLS     r2,r2,#9
000008  6642              STR      r2,[r0,#0x64]
                  |L1.10|
;;;52     
;;;53         if(u32Mask & UUART_RLS_INT_MASK)   /* Clear Receive Line Status Interrupt */
00000a  074a              LSLS     r2,r1,#29
00000c  d501              BPL      |L1.18|
;;;54             uuart->PROTSTS = (UUART_PROTSTS_BREAK_Msk | UUART_PROTSTS_FRMERR_Msk | UUART_PROTSTS_PARITYERR_Msk);
00000e  22e0              MOVS     r2,#0xe0
000010  6642              STR      r2,[r0,#0x64]
                  |L1.18|
;;;55     
;;;56         if(u32Mask & UUART_BUF_RXOV_INT_MASK)   /* Clear Receive Buffer Over-run Error Interrupt */
000012  070b              LSLS     r3,r1,#28
;;;57             uuart->BUFSTS = UUART_BUFSTS_RXOVIF_Msk;
000014  2208              MOVS     r2,#8
000016  2b00              CMP      r3,#0                 ;56
000018  da00              BGE      |L1.28|
00001a  63c2              STR      r2,[r0,#0x3c]
                  |L1.28|
;;;58     
;;;59         if(u32Mask & UUART_TXST_INT_MASK)   /* Clear Transmit Start Interrupt */
00001c  06cb              LSLS     r3,r1,#27
00001e  d501              BPL      |L1.36|
;;;60             uuart->PROTSTS = UUART_PROTSTS_TXSTIF_Msk;
000020  2302              MOVS     r3,#2
000022  6643              STR      r3,[r0,#0x64]
                  |L1.36|
;;;61     
;;;62         if(u32Mask & UUART_TXEND_INT_MASK)   /* Clear Transmit End Interrupt */
000024  068b              LSLS     r3,r1,#26
000026  d501              BPL      |L1.44|
;;;63             uuart->PROTSTS = UUART_PROTSTS_TXENDIF_Msk;
000028  2304              MOVS     r3,#4
00002a  6643              STR      r3,[r0,#0x64]
                  |L1.44|
;;;64     
;;;65         if(u32Mask & UUART_RXST_INT_MASK)   /* Clear Receive Start Interrupt */
00002c  064b              LSLS     r3,r1,#25
00002e  d500              BPL      |L1.50|
;;;66             uuart->PROTSTS = UUART_PROTSTS_RXSTIF_Msk;
000030  6642              STR      r2,[r0,#0x64]
                  |L1.50|
;;;67     
;;;68         if(u32Mask & UUART_RXEND_INT_MASK)   /* Clear Receive End Interrupt */
000032  0609              LSLS     r1,r1,#24
000034  d501              BPL      |L1.58|
;;;69             uuart->PROTSTS = UUART_PROTSTS_RXENDIF_Msk;
000036  2110              MOVS     r1,#0x10
000038  6641              STR      r1,[r0,#0x64]
                  |L1.58|
;;;70     
;;;71     }
00003a  4770              BX       lr
;;;72     
                          ENDP


                          AREA ||i.UUART_Close||, CODE, READONLY, ALIGN=1

                  UUART_Close PROC
;;;139     */
;;;140    void UUART_Close(UUART_T* uuart)
000000  2100              MOVS     r1,#0
;;;141    {
;;;142        uuart->CTL = 0;
000002  6001              STR      r1,[r0,#0]
;;;143    }
000004  4770              BX       lr
;;;144    
                          ENDP


                          AREA ||i.UUART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UUART_DisableFlowCtrl PROC
;;;633     */
;;;634    void UUART_DisableFlowCtrl(UUART_T* uuart)
000000  6dc1              LDR      r1,[r0,#0x5c]
;;;635    {
;;;636        /* Disable CTS and RTS auto flow control function */
;;;637        uuart->PROTCTL &= ~(UUART_PROTCTL_RTSAUTOEN_Msk | UUART_PROTCTL_CTSAUTOEN_Msk);
000002  2218              MOVS     r2,#0x18
000004  4391              BICS     r1,r1,r2
000006  65c1              STR      r1,[r0,#0x5c]
;;;638    }
000008  4770              BX       lr
;;;639    
                          ENDP


                          AREA ||i.UUART_DisableInt||, CODE, READONLY, ALIGN=1

                  UUART_DisableInt PROC
;;;164     */
;;;165    void UUART_DisableInt(UUART_T* uuart, uint32_t u32Mask)
000000  b530              PUSH     {r4,r5,lr}
;;;166    {
;;;167    
;;;168        /* Disable Auto-baud rate interrupt flag */
;;;169        if((u32Mask & UUART_ABR_INT_MASK) == UUART_ABR_INT_MASK)
000002  078a              LSLS     r2,r1,#30
;;;170            uuart->PROTIEN &= ~UUART_PROTIEN_ABRIEN_Msk;
000004  2302              MOVS     r3,#2
000006  2a00              CMP      r2,#0                 ;169
000008  da02              BGE      |L4.16|
00000a  6e02              LDR      r2,[r0,#0x60]
00000c  439a              BICS     r2,r2,r3
00000e  6602              STR      r2,[r0,#0x60]
                  |L4.16|
;;;171    
;;;172        /* Disable receive line status interrupt flag */
;;;173        if((u32Mask & UUART_RLS_INT_MASK) == UUART_RLS_INT_MASK)
000010  074a              LSLS     r2,r1,#29
;;;174            uuart->PROTIEN &= ~UUART_PROTIEN_RLSIEN_Msk;
000012  2404              MOVS     r4,#4
000014  2a00              CMP      r2,#0                 ;173
000016  da02              BGE      |L4.30|
000018  6e02              LDR      r2,[r0,#0x60]
00001a  43a2              BICS     r2,r2,r4
00001c  6602              STR      r2,[r0,#0x60]
                  |L4.30|
;;;175    
;;;176        /* Disable RX overrun interrupt flag */
;;;177        if((u32Mask & UUART_BUF_RXOV_INT_MASK) == UUART_BUF_RXOV_INT_MASK)
00001e  070a              LSLS     r2,r1,#28
000020  d504              BPL      |L4.44|
;;;178            uuart->BUFCTL &= ~UUART_BUFCTL_RXOVIEN_Msk;
000022  6b82              LDR      r2,[r0,#0x38]
000024  2501              MOVS     r5,#1
000026  03ad              LSLS     r5,r5,#14
000028  43aa              BICS     r2,r2,r5
00002a  6382              STR      r2,[r0,#0x38]
                  |L4.44|
;;;179    
;;;180        /* Disable TX start interrupt flag */
;;;181        if((u32Mask & UUART_TXST_INT_MASK) == UUART_TXST_INT_MASK)
00002c  06ca              LSLS     r2,r1,#27
00002e  d502              BPL      |L4.54|
;;;182            uuart->INTEN &= ~UUART_INTEN_TXSTIEN_Msk;
000030  6842              LDR      r2,[r0,#4]
000032  439a              BICS     r2,r2,r3
000034  6042              STR      r2,[r0,#4]
                  |L4.54|
;;;183    
;;;184        /* Disable TX end interrupt flag */
;;;185        if((u32Mask & UUART_TXEND_INT_MASK) == UUART_TXEND_INT_MASK)
000036  068a              LSLS     r2,r1,#26
000038  d502              BPL      |L4.64|
;;;186            uuart->INTEN &= ~UUART_INTEN_TXENDIEN_Msk;
00003a  6842              LDR      r2,[r0,#4]
00003c  43a2              BICS     r2,r2,r4
00003e  6042              STR      r2,[r0,#4]
                  |L4.64|
;;;187    
;;;188        /* Disable RX start interrupt flag */
;;;189        if((u32Mask & UUART_RXST_INT_MASK) == UUART_RXST_INT_MASK)
000040  064a              LSLS     r2,r1,#25
000042  d503              BPL      |L4.76|
;;;190            uuart->INTEN &= ~UUART_INTEN_RXSTIEN_Msk;
000044  6842              LDR      r2,[r0,#4]
000046  2308              MOVS     r3,#8
000048  439a              BICS     r2,r2,r3
00004a  6042              STR      r2,[r0,#4]
                  |L4.76|
;;;191    
;;;192        /* Disable RX end interrupt flag */
;;;193        if((u32Mask & UUART_RXEND_INT_MASK) == UUART_RXEND_INT_MASK)
00004c  0609              LSLS     r1,r1,#24
00004e  d503              BPL      |L4.88|
;;;194            uuart->INTEN &= ~UUART_INTEN_RXENDIEN_Msk;
000050  6841              LDR      r1,[r0,#4]
000052  2210              MOVS     r2,#0x10
000054  4391              BICS     r1,r1,r2
000056  6041              STR      r1,[r0,#4]
                  |L4.88|
;;;195    }
000058  bd30              POP      {r4,r5,pc}
;;;196    
                          ENDP


                          AREA ||i.UUART_DisableWakeup||, CODE, READONLY, ALIGN=1

                  UUART_DisableWakeup PROC
;;;597     */
;;;598    void UUART_DisableWakeup(UUART_T* uuart)
000000  6dc1              LDR      r1,[r0,#0x5c]
;;;599    {
;;;600        uuart->PROTCTL &= ~(UUART_PROTCTL_DATWKEN_Msk | UUART_PROTCTL_CTSWKEN_Msk);
000002  2203              MOVS     r2,#3
000004  0252              LSLS     r2,r2,#9
000006  4391              BICS     r1,r1,r2
000008  65c1              STR      r1,[r0,#0x5c]
;;;601        uuart->WKCTL &= ~UUART_WKCTL_WKEN_Msk;
00000a  6d41              LDR      r1,[r0,#0x54]
00000c  0849              LSRS     r1,r1,#1
00000e  0049              LSLS     r1,r1,#1
000010  6541              STR      r1,[r0,#0x54]
;;;602    }
000012  4770              BX       lr
;;;603    
                          ENDP


                          AREA ||i.UUART_EnableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UUART_EnableFlowCtrl PROC
;;;612     */
;;;613    void UUART_EnableFlowCtrl(UUART_T* uuart)
000000  6ac1              LDR      r1,[r0,#0x2c]
;;;614    {
;;;615        /* Set RTS signal is low level active */
;;;616        uuart->LINECTL &= ~UUART_LINECTL_CTLOINV_Msk;
000002  2280              MOVS     r2,#0x80
000004  4391              BICS     r1,r1,r2
000006  62c1              STR      r1,[r0,#0x2c]
;;;617    
;;;618        /* Set CTS signal is low level active */
;;;619        uuart->CTLIN0 &= ~UUART_CTLIN0_ININV_Msk;
000008  6a01              LDR      r1,[r0,#0x20]
00000a  2204              MOVS     r2,#4
00000c  4391              BICS     r1,r1,r2
00000e  6201              STR      r1,[r0,#0x20]
;;;620    
;;;621        /* Enable CTS and RTS auto flow control function */
;;;622        uuart->PROTCTL |= UUART_PROTCTL_RTSAUTOEN_Msk | UUART_PROTCTL_CTSAUTOEN_Msk;
000010  6dc1              LDR      r1,[r0,#0x5c]
000012  2218              MOVS     r2,#0x18
000014  4311              ORRS     r1,r1,r2
000016  65c1              STR      r1,[r0,#0x5c]
;;;623    }
000018  4770              BX       lr
;;;624    
                          ENDP


                          AREA ||i.UUART_EnableInt||, CODE, READONLY, ALIGN=1

                  UUART_EnableInt PROC
;;;216     */
;;;217    void UUART_EnableInt(UUART_T*  uuart, uint32_t u32Mask)
000000  b530              PUSH     {r4,r5,lr}
;;;218    {
;;;219        /* Enable Auto-baud rate interrupt flag */
;;;220        if((u32Mask & UUART_ABR_INT_MASK) == UUART_ABR_INT_MASK)
000002  078a              LSLS     r2,r1,#30
;;;221            uuart->PROTIEN |= UUART_PROTIEN_ABRIEN_Msk;
000004  2402              MOVS     r4,#2
000006  2a00              CMP      r2,#0                 ;220
000008  da02              BGE      |L7.16|
00000a  6e02              LDR      r2,[r0,#0x60]
00000c  4322              ORRS     r2,r2,r4
00000e  6602              STR      r2,[r0,#0x60]
                  |L7.16|
;;;222    
;;;223        /* Enable receive line status interrupt flag */
;;;224        if((u32Mask & UUART_RLS_INT_MASK) == UUART_RLS_INT_MASK)
000010  074a              LSLS     r2,r1,#29
;;;225            uuart->PROTIEN |= UUART_PROTIEN_RLSIEN_Msk;
000012  2304              MOVS     r3,#4
000014  2a00              CMP      r2,#0                 ;224
000016  da02              BGE      |L7.30|
000018  6e02              LDR      r2,[r0,#0x60]
00001a  431a              ORRS     r2,r2,r3
00001c  6602              STR      r2,[r0,#0x60]
                  |L7.30|
;;;226    
;;;227        /* Enable RX overrun interrupt flag */
;;;228        if((u32Mask & UUART_BUF_RXOV_INT_MASK) == UUART_BUF_RXOV_INT_MASK)
00001e  070a              LSLS     r2,r1,#28
000020  d504              BPL      |L7.44|
;;;229            uuart->BUFCTL |= UUART_BUFCTL_RXOVIEN_Msk;
000022  6b82              LDR      r2,[r0,#0x38]
000024  2501              MOVS     r5,#1
000026  03ad              LSLS     r5,r5,#14
000028  432a              ORRS     r2,r2,r5
00002a  6382              STR      r2,[r0,#0x38]
                  |L7.44|
;;;230    
;;;231        /* Enable TX start interrupt flag */
;;;232        if((u32Mask & UUART_TXST_INT_MASK) == UUART_TXST_INT_MASK)
00002c  06ca              LSLS     r2,r1,#27
00002e  d502              BPL      |L7.54|
;;;233            uuart->INTEN |= UUART_INTEN_TXSTIEN_Msk;
000030  6842              LDR      r2,[r0,#4]
000032  4322              ORRS     r2,r2,r4
000034  6042              STR      r2,[r0,#4]
                  |L7.54|
;;;234    
;;;235        /* Enable TX end interrupt flag */
;;;236        if((u32Mask & UUART_TXEND_INT_MASK) == UUART_TXEND_INT_MASK)
000036  068a              LSLS     r2,r1,#26
000038  d502              BPL      |L7.64|
;;;237            uuart->INTEN |= UUART_INTEN_TXENDIEN_Msk;
00003a  6842              LDR      r2,[r0,#4]
00003c  431a              ORRS     r2,r2,r3
00003e  6042              STR      r2,[r0,#4]
                  |L7.64|
;;;238    
;;;239        /* Enable RX start interrupt flag */
;;;240        if((u32Mask & UUART_RXST_INT_MASK) == UUART_RXST_INT_MASK)
000040  064a              LSLS     r2,r1,#25
000042  d503              BPL      |L7.76|
;;;241            uuart->INTEN |= UUART_INTEN_RXSTIEN_Msk;
000044  6842              LDR      r2,[r0,#4]
000046  2308              MOVS     r3,#8
000048  431a              ORRS     r2,r2,r3
00004a  6042              STR      r2,[r0,#4]
                  |L7.76|
;;;242    
;;;243        /* Enable RX end interrupt flag */
;;;244        if((u32Mask & UUART_RXEND_INT_MASK) == UUART_RXEND_INT_MASK)
00004c  0609              LSLS     r1,r1,#24
00004e  d503              BPL      |L7.88|
;;;245            uuart->INTEN |= UUART_INTEN_RXENDIEN_Msk;
000050  6841              LDR      r1,[r0,#4]
000052  2210              MOVS     r2,#0x10
000054  4311              ORRS     r1,r1,r2
000056  6041              STR      r1,[r0,#4]
                  |L7.88|
;;;246    }
000058  bd30              POP      {r4,r5,pc}
;;;247    
                          ENDP


                          AREA ||i.UUART_EnableWakeup||, CODE, READONLY, ALIGN=1

                  UUART_EnableWakeup PROC
;;;581     */
;;;582    void UUART_EnableWakeup(UUART_T* uuart, uint32_t u32WakeupMode)
000000  6dc2              LDR      r2,[r0,#0x5c]
;;;583    {
;;;584        uuart->PROTCTL |= u32WakeupMode;
000002  430a              ORRS     r2,r2,r1
000004  65c2              STR      r2,[r0,#0x5c]
;;;585        uuart->WKCTL |= UUART_WKCTL_WKEN_Msk;
000006  6d41              LDR      r1,[r0,#0x54]
000008  2201              MOVS     r2,#1
00000a  4311              ORRS     r1,r1,r2
00000c  6541              STR      r1,[r0,#0x54]
;;;586    }
00000e  4770              BX       lr
;;;587    
                          ENDP


                          AREA ||i.UUART_GetIntFlag||, CODE, READONLY, ALIGN=1

                  UUART_GetIntFlag PROC
;;;93     
;;;94     uint32_t UUART_GetIntFlag(UUART_T* uuart, uint32_t u32Mask)
000000  4602              MOV      r2,r0
;;;95     {
;;;96         uint32_t u32IntFlag = 0;
000002  2000              MOVS     r0,#0
;;;97     
;;;98         /* Check Auto-baud Rate Interrupt Flag */
;;;99         if((u32Mask & UUART_ABR_INT_MASK) && (uuart->PROTSTS & UUART_PROTSTS_ABRDETIF_Msk))
000004  078b              LSLS     r3,r1,#30
000006  d503              BPL      |L9.16|
000008  6e53              LDR      r3,[r2,#0x64]
00000a  059b              LSLS     r3,r3,#22
00000c  d500              BPL      |L9.16|
;;;100            u32IntFlag |= UUART_ABR_INT_MASK;
00000e  2002              MOVS     r0,#2
                  |L9.16|
;;;101    
;;;102        /* Check Receive Line Status Interrupt Flag */
;;;103        if((u32Mask & UUART_RLS_INT_MASK) && (uuart->PROTSTS & (UUART_PROTSTS_BREAK_Msk | UUART_PROTSTS_FRMERR_Msk | UUART_PROTSTS_PARITYERR_Msk)))
000010  074b              LSLS     r3,r1,#29
000012  d505              BPL      |L9.32|
000014  6e53              LDR      r3,[r2,#0x64]
000016  061b              LSLS     r3,r3,#24
000018  0f5b              LSRS     r3,r3,#29
00001a  d001              BEQ      |L9.32|
;;;104            u32IntFlag |= UUART_RLS_INT_MASK;
00001c  2304              MOVS     r3,#4
00001e  4318              ORRS     r0,r0,r3
                  |L9.32|
;;;105    
;;;106        /* Check Receive Buffer Over-run Error Interrupt Flag */
;;;107        if((u32Mask & UUART_BUF_RXOV_INT_MASK) && (uuart->BUFSTS & UUART_BUFSTS_RXOVIF_Msk))
000020  070b              LSLS     r3,r1,#28
000022  d504              BPL      |L9.46|
000024  6bd3              LDR      r3,[r2,#0x3c]
000026  071b              LSLS     r3,r3,#28
000028  d501              BPL      |L9.46|
;;;108            u32IntFlag |= UUART_BUF_RXOV_INT_MASK;
00002a  2308              MOVS     r3,#8
00002c  4318              ORRS     r0,r0,r3
                  |L9.46|
;;;109    
;;;110        /* Check Transmit Start Interrupt Flag */
;;;111        if((u32Mask & UUART_TXST_INT_MASK) && (uuart->PROTSTS & UUART_PROTSTS_TXSTIF_Msk))
00002e  06cb              LSLS     r3,r1,#27
000030  d504              BPL      |L9.60|
000032  6e53              LDR      r3,[r2,#0x64]
000034  079b              LSLS     r3,r3,#30
000036  d501              BPL      |L9.60|
;;;112            u32IntFlag |= UUART_TXST_INT_MASK;
000038  2310              MOVS     r3,#0x10
00003a  4318              ORRS     r0,r0,r3
                  |L9.60|
;;;113    
;;;114        /* Check Transmit End Interrupt Flag */
;;;115        if((u32Mask & UUART_TXEND_INT_MASK) && (uuart->PROTSTS & UUART_PROTSTS_TXENDIF_Msk))
00003c  068b              LSLS     r3,r1,#26
00003e  d504              BPL      |L9.74|
000040  6e53              LDR      r3,[r2,#0x64]
000042  075b              LSLS     r3,r3,#29
000044  d501              BPL      |L9.74|
;;;116            u32IntFlag |= UUART_TXEND_INT_MASK;
000046  2320              MOVS     r3,#0x20
000048  4318              ORRS     r0,r0,r3
                  |L9.74|
;;;117    
;;;118        /* Check Receive Start Interrupt Flag */
;;;119        if((u32Mask & UUART_RXST_INT_MASK) && (uuart->PROTSTS & UUART_PROTSTS_RXSTIF_Msk))
00004a  064b              LSLS     r3,r1,#25
00004c  d504              BPL      |L9.88|
00004e  6e53              LDR      r3,[r2,#0x64]
000050  071b              LSLS     r3,r3,#28
000052  d501              BPL      |L9.88|
;;;120            u32IntFlag |= UUART_RXST_INT_MASK;
000054  2340              MOVS     r3,#0x40
000056  4318              ORRS     r0,r0,r3
                  |L9.88|
;;;121    
;;;122        /* Check Receive End Interrupt Flag */
;;;123        if((u32Mask & UUART_RXEND_INT_MASK) && (uuart->PROTSTS & UUART_PROTSTS_RXENDIF_Msk))
000058  0609              LSLS     r1,r1,#24
00005a  d504              BPL      |L9.102|
00005c  6e51              LDR      r1,[r2,#0x64]
00005e  06c9              LSLS     r1,r1,#27
000060  d501              BPL      |L9.102|
;;;124            u32IntFlag |= UUART_RXEND_INT_MASK;
000062  2180              MOVS     r1,#0x80
000064  4308              ORRS     r0,r0,r1
                  |L9.102|
;;;125    
;;;126        return u32IntFlag;
;;;127    
;;;128    }
000066  4770              BX       lr
;;;129    
                          ENDP


                          AREA ||i.UUART_Open||, CODE, READONLY, ALIGN=2

                  UUART_Open PROC
;;;258     */
;;;259    uint32_t UUART_Open(UUART_T* uuart, uint32_t u32baudrate)
000000  b5f0              PUSH     {r4-r7,lr}
;;;260    {
000002  4606              MOV      r6,r0
;;;261        uint32_t u32PCLKFreq, u32PDSCnt, u32DSCnt, u32ClkDiv;
;;;262        uint32_t u32Tmp, u32Tmp2, u32Min, u32MinClkDiv, u32MinDSCnt;
;;;263        uint32_t u32Div;
;;;264    
;;;265        /* Get PCLK frequency */
;;;266        if((uuart == UUART0) || (uuart == UUART2))
000004  4847              LDR      r0,|L10.292|
000006  b085              SUB      sp,sp,#0x14           ;260
000008  460d              MOV      r5,r1                 ;260
00000a  4286              CMP      r6,r0
00000c  d002              BEQ      |L10.20|
00000e  4846              LDR      r0,|L10.296|
000010  4286              CMP      r6,r0
000012  d102              BNE      |L10.26|
                  |L10.20|
;;;267        {
;;;268            u32PCLKFreq = CLK_GetPCLK0Freq();
000014  f7fffffe          BL       CLK_GetPCLK0Freq
000018  e001              B        |L10.30|
                  |L10.26|
;;;269        }
;;;270        else
;;;271        {
;;;272            u32PCLKFreq = CLK_GetPCLK1Freq();
00001a  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L10.30|
;;;273        }
;;;274    
;;;275        /* Calculate baud rate divider */
;;;276        u32Div = u32PCLKFreq / u32baudrate;
00001e  4629              MOV      r1,r5
000020  9002              STR      r0,[sp,#8]
000022  f7fffffe          BL       __aeabi_uidivmod
000026  4604              MOV      r4,r0
;;;277        u32Tmp = (u32PCLKFreq / u32Div) - u32baudrate;
000028  4601              MOV      r1,r0
00002a  9802              LDR      r0,[sp,#8]
00002c  f7fffffe          BL       __aeabi_uidivmod
000030  1b47              SUBS     r7,r0,r5
;;;278        u32Tmp2 = u32baudrate - (u32PCLKFreq / (u32Div + 1ul));
000032  1c61              ADDS     r1,r4,#1
000034  9802              LDR      r0,[sp,#8]
000036  f7fffffe          BL       __aeabi_uidivmod
00003a  1a28              SUBS     r0,r5,r0
;;;279    
;;;280        if(u32Tmp >= u32Tmp2) u32Div = u32Div + 1ul;
00003c  4287              CMP      r7,r0
00003e  d300              BCC      |L10.66|
000040  1c64              ADDS     r4,r4,#1
                  |L10.66|
;;;281    
;;;282        if(u32Div >= 65536ul)
000042  2001              MOVS     r0,#1
000044  0400              LSLS     r0,r0,#16
000046  4284              CMP      r4,r0
000048  d305              BCC      |L10.86|
;;;283        {
;;;284    
;;;285            /* Set the smallest baud rate that USCI_UART can generate */
;;;286            u32PDSCnt = 0x4ul;
;;;287            u32MinDSCnt = 0x10ul;
00004a  2010              MOVS     r0,#0x10
00004c  2504              MOVS     r5,#4                 ;286
;;;288            u32MinClkDiv = 0x400ul;
00004e  9000              STR      r0,[sp,#0]
000050  0180              LSLS     r0,r0,#6
000052  9001              STR      r0,[sp,#4]
000054  e03c              B        |L10.208|
                  |L10.86|
;;;289    
;;;290        }
;;;291        else
;;;292        {
;;;293    
;;;294            u32Tmp = 0x400ul * 0x10ul;
000056  2101              MOVS     r1,#1
000058  0389              LSLS     r1,r1,#14
;;;295            for(u32PDSCnt = 1ul; u32PDSCnt <= 0x04ul; u32PDSCnt++)
00005a  2501              MOVS     r5,#1
                  |L10.92|
;;;296            {
;;;297                if(u32Div <= (u32Tmp * u32PDSCnt)) break;
00005c  4608              MOV      r0,r1
00005e  4368              MULS     r0,r5,r0
000060  42a0              CMP      r0,r4
000062  d203              BCS      |L10.108|
000064  1c6d              ADDS     r5,r5,#1
000066  2d04              CMP      r5,#4                 ;295
000068  d9f8              BLS      |L10.92|
00006a  e001              B        |L10.112|
                  |L10.108|
;;;298            }
;;;299    
;;;300            if(u32PDSCnt > 0x4ul) u32PDSCnt = 0x4ul;
00006c  2d04              CMP      r5,#4
00006e  d900              BLS      |L10.114|
                  |L10.112|
000070  2504              MOVS     r5,#4
                  |L10.114|
;;;301    
;;;302            u32Div = u32Div / u32PDSCnt;
000072  4629              MOV      r1,r5
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       __aeabi_uidivmod
;;;303    
;;;304            /* Find best solution */
;;;305            u32Min = (uint32_t) - 1;
;;;306            u32MinDSCnt = 0ul;
00007a  9003              STR      r0,[sp,#0xc]
00007c  2000              MOVS     r0,#0
00007e  2700              MOVS     r7,#0                 ;305
000080  43ff              MVNS     r7,r7                 ;305
;;;307            u32MinClkDiv = 0ul;
000082  9000              STR      r0,[sp,#0]
;;;308            u32Tmp = 0ul;
;;;309    
;;;310            for(u32DSCnt = 6ul; u32DSCnt <= 0x10ul; u32DSCnt++)   /* DSCNT could be 0x5~0xF */
000084  2406              MOVS     r4,#6
000086  9001              STR      r0,[sp,#4]
                  |L10.136|
;;;311            {
;;;312    
;;;313                u32ClkDiv = u32Div / u32DSCnt;
000088  4621              MOV      r1,r4
00008a  9803              LDR      r0,[sp,#0xc]
00008c  f7fffffe          BL       __aeabi_uidivmod
;;;314    
;;;315                if(u32ClkDiv > 0x400ul)
000090  2101              MOVS     r1,#1
000092  0289              LSLS     r1,r1,#10
000094  4288              CMP      r0,r1
000096  d905              BLS      |L10.164|
;;;316                {
;;;317                    u32ClkDiv = 0x400ul;
000098  4608              MOV      r0,r1
;;;318                    u32Tmp = u32Div - (u32ClkDiv * u32DSCnt);
00009a  9903              LDR      r1,[sp,#0xc]
00009c  02a2              LSLS     r2,r4,#10
00009e  1a8a              SUBS     r2,r1,r2
;;;319                    u32Tmp2 = u32Tmp + 1ul;
0000a0  1c51              ADDS     r1,r2,#1
0000a2  e007              B        |L10.180|
                  |L10.164|
0000a4  4601              MOV      r1,r0
;;;320                }
;;;321                else
;;;322                {
;;;323                    u32Tmp = u32Div - (u32ClkDiv * u32DSCnt);
0000a6  9a03              LDR      r2,[sp,#0xc]
0000a8  4361              MULS     r1,r4,r1
0000aa  1a52              SUBS     r2,r2,r1
;;;324                    u32Tmp2 = ((u32ClkDiv + 1ul) * u32DSCnt) - u32Div;
0000ac  1c41              ADDS     r1,r0,#1
0000ae  9b03              LDR      r3,[sp,#0xc]
0000b0  4361              MULS     r1,r4,r1
0000b2  1ac9              SUBS     r1,r1,r3
                  |L10.180|
;;;325                }
;;;326    
;;;327                if(u32Tmp >= u32Tmp2)
0000b4  428a              CMP      r2,r1
0000b6  d301              BCC      |L10.188|
0000b8  1c40              ADDS     r0,r0,#1
;;;328                {
;;;329                    u32ClkDiv = u32ClkDiv + 1ul;
0000ba  e000              B        |L10.190|
                  |L10.188|
;;;330                }
;;;331                else u32Tmp2 = u32Tmp;
0000bc  4611              MOV      r1,r2
                  |L10.190|
;;;332    
;;;333                if(u32Tmp2 < u32Min)
0000be  42b9              CMP      r1,r7
0000c0  d203              BCS      |L10.202|
;;;334                {
;;;335                    u32Min = u32Tmp2;
0000c2  000f              MOVS     r7,r1
;;;336                    u32MinDSCnt = u32DSCnt;
;;;337                    u32MinClkDiv = u32ClkDiv;
;;;338    
;;;339                    /* Break when get good results */
;;;340                    if(u32Min == 0ul)
0000c4  9400              STR      r4,[sp,#0]
0000c6  9001              STR      r0,[sp,#4]
0000c8  d002              BEQ      |L10.208|
                  |L10.202|
0000ca  1c64              ADDS     r4,r4,#1
0000cc  2c10              CMP      r4,#0x10              ;310
0000ce  d9db              BLS      |L10.136|
                  |L10.208|
;;;341                    {
;;;342                        break;
;;;343                    }
;;;344                }
;;;345            }
;;;346    
;;;347        }
;;;348    
;;;349        /* Enable USCI_UART protocol */
;;;350        uuart->CTL &= ~UUART_CTL_FUNMODE_Msk;
0000d0  6830              LDR      r0,[r6,#0]
0000d2  08c0              LSRS     r0,r0,#3
0000d4  00c0              LSLS     r0,r0,#3
0000d6  6030              STR      r0,[r6,#0]
;;;351        uuart->CTL = 2ul << UUART_CTL_FUNMODE_Pos;
0000d8  2002              MOVS     r0,#2
0000da  6030              STR      r0,[r6,#0]
;;;352    
;;;353        /* Set USCI_UART line configuration */
;;;354        uuart->LINECTL = UUART_WORD_LEN_8 | UUART_LINECTL_LSB_Msk;
0000dc  4813              LDR      r0,|L10.300|
0000de  62f0              STR      r0,[r6,#0x2c]
;;;355        uuart->DATIN0 = (2ul << UUART_DATIN0_EDGEDET_Pos);  /* Set falling edge detection */
0000e0  2010              MOVS     r0,#0x10
0000e2  6130              STR      r0,[r6,#0x10]
;;;356    
;;;357        /* Set USCI_UART baud rate */
;;;358        uuart->BRGEN = ((u32MinClkDiv - 1ul) << UUART_BRGEN_CLKDIV_Pos) |
0000e4  9900              LDR      r1,[sp,#0]
0000e6  9801              LDR      r0,[sp,#4]
0000e8  028a              LSLS     r2,r1,#10
0000ea  2101              MOVS     r1,#1
0000ec  1e40              SUBS     r0,r0,#1
0000ee  0289              LSLS     r1,r1,#10
0000f0  0400              LSLS     r0,r0,#16
0000f2  1a51              SUBS     r1,r2,r1
0000f4  4308              ORRS     r0,r0,r1
0000f6  0229              LSLS     r1,r5,#8
0000f8  39ff              SUBS     r1,r1,#0xff
0000fa  3901              SUBS     r1,#1
0000fc  4308              ORRS     r0,r0,r1
0000fe  60b0              STR      r0,[r6,#8]
;;;359                       ((u32MinDSCnt - 1ul) << UUART_BRGEN_DSCNT_Pos) |
;;;360                       ((u32PDSCnt - 1ul) << UUART_BRGEN_PDSCNT_Pos);
;;;361    
;;;362        uuart->PROTCTL |= UUART_PROTCTL_PROTEN_Msk;
000100  6df0              LDR      r0,[r6,#0x5c]
000102  2101              MOVS     r1,#1
000104  07c9              LSLS     r1,r1,#31
000106  4308              ORRS     r0,r0,r1
000108  65f0              STR      r0,[r6,#0x5c]
;;;363    
;;;364        return (u32PCLKFreq / u32PDSCnt / u32MinDSCnt / u32MinClkDiv);
00010a  4629              MOV      r1,r5
00010c  9802              LDR      r0,[sp,#8]
00010e  f7fffffe          BL       __aeabi_uidivmod
000112  9900              LDR      r1,[sp,#0]
000114  f7fffffe          BL       __aeabi_uidivmod
000118  9901              LDR      r1,[sp,#4]
00011a  f7fffffe          BL       __aeabi_uidivmod
;;;365    }
00011e  b005              ADD      sp,sp,#0x14
000120  bdf0              POP      {r4-r7,pc}
;;;366    
                          ENDP

000122  0000              DCW      0x0000
                  |L10.292|
                          DCD      0x40070000
                  |L10.296|
                          DCD      0x40074000
                  |L10.300|
                          DCD      0x00000801

                          AREA ||i.UUART_Read||, CODE, READONLY, ALIGN=1

                  UUART_Read PROC
;;;378     */
;;;379    uint32_t UUART_Read(UUART_T* uuart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;380    {
000002  4604              MOV      r4,r0
;;;381        uint32_t  u32Count, u32delayno;
;;;382    
;;;383        for(u32Count = 0; u32Count < u32ReadBytes; u32Count++)
000004  2000              MOVS     r0,#0
;;;384        {
;;;385            u32delayno = 0;
;;;386    
;;;387            while(uuart->BUFSTS & UUART_BUFSTS_RXEMPTY_Msk)   /* Check RX empty => failed */
;;;388            {
;;;389                u32delayno++;
;;;390                if(u32delayno >= 0x40000000)
000006  2501              MOVS     r5,#1
000008  07ad              LSLS     r5,r5,#30
00000a  e00c              B        |L11.38|
                  |L11.12|
00000c  2300              MOVS     r3,#0                 ;385
00000e  e004              B        |L11.26|
                  |L11.16|
000010  1c5b              ADDS     r3,r3,#1              ;387
000012  42ab              CMP      r3,r5
000014  d301              BCC      |L11.26|
;;;391                    return FALSE;
000016  2000              MOVS     r0,#0
;;;392            }
;;;393            pu8RxBuf[u32Count] = uuart->RXDAT;    /* Get Data from USCI RX  */
;;;394        }
;;;395    
;;;396        return u32Count;
;;;397    
;;;398    }
000018  bd70              POP      {r4-r6,pc}
                  |L11.26|
00001a  6be6              LDR      r6,[r4,#0x3c]         ;387
00001c  07f6              LSLS     r6,r6,#31             ;387
00001e  d1f7              BNE      |L11.16|
000020  6b63              LDR      r3,[r4,#0x34]         ;393
000022  540b              STRB     r3,[r1,r0]            ;393
000024  1c40              ADDS     r0,r0,#1              ;393
                  |L11.38|
000026  4290              CMP      r0,r2                 ;383
000028  d3f0              BCC      |L11.12|
00002a  bd70              POP      {r4-r6,pc}
;;;399    
                          ENDP


                          AREA ||i.UUART_SetLine_Config||, CODE, READONLY, ALIGN=2

                  UUART_SetLine_Config PROC
;;;423     */
;;;424    uint32_t UUART_SetLine_Config(UUART_T* uuart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t u32stop_bits)
000000  b5ff              PUSH     {r0-r7,lr}
;;;425    {
000002  4606              MOV      r6,r0
;;;426        uint32_t u32PCLKFreq, u32PDSCnt, u32DSCnt, u32ClkDiv;
;;;427        uint32_t u32Tmp, u32Tmp2, u32Min, u32MinClkDiv, u32MinDSCnt;
;;;428        uint32_t u32Div;
;;;429    
;;;430        /* Get PCLK frequency */
;;;431        if((uuart == UUART0) || (uuart == UUART2))
000004  4851              LDR      r0,|L12.332|
000006  b085              SUB      sp,sp,#0x14           ;425
000008  460d              MOV      r5,r1                 ;425
00000a  4286              CMP      r6,r0
00000c  d002              BEQ      |L12.20|
00000e  4850              LDR      r0,|L12.336|
000010  4286              CMP      r6,r0
000012  d102              BNE      |L12.26|
                  |L12.20|
;;;432        {
;;;433            u32PCLKFreq = CLK_GetPCLK0Freq();
000014  f7fffffe          BL       CLK_GetPCLK0Freq
000018  e001              B        |L12.30|
                  |L12.26|
;;;434        }
;;;435        else     /* UUART1 */
;;;436        {
;;;437            u32PCLKFreq = CLK_GetPCLK1Freq();
00001a  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L12.30|
;;;438        }
;;;439    
;;;440        if(u32baudrate != 0ul)
00001e  9002              STR      r0,[sp,#8]
000020  2d00              CMP      r5,#0
000022  d066              BEQ      |L12.242|
;;;441        {
;;;442    
;;;443            /* Calculate baud rate divider */
;;;444            u32Div = u32PCLKFreq / u32baudrate;
000024  4629              MOV      r1,r5
000026  f7fffffe          BL       __aeabi_uidivmod
00002a  4604              MOV      r4,r0
;;;445            u32Tmp = (u32PCLKFreq / u32Div) - u32baudrate;
00002c  4601              MOV      r1,r0
00002e  9802              LDR      r0,[sp,#8]
000030  f7fffffe          BL       __aeabi_uidivmod
000034  1b47              SUBS     r7,r0,r5
;;;446            u32Tmp2 = u32baudrate - (u32PCLKFreq / (u32Div + 1ul));
000036  1c61              ADDS     r1,r4,#1
000038  9802              LDR      r0,[sp,#8]
00003a  f7fffffe          BL       __aeabi_uidivmod
00003e  1a28              SUBS     r0,r5,r0
;;;447    
;;;448            if(u32Tmp >= u32Tmp2) u32Div = u32Div + 1ul;
000040  4287              CMP      r7,r0
000042  d300              BCC      |L12.70|
000044  1c64              ADDS     r4,r4,#1
                  |L12.70|
;;;449    
;;;450            if(u32Div >= 65536ul)
000046  2001              MOVS     r0,#1
000048  0400              LSLS     r0,r0,#16
00004a  4284              CMP      r4,r0
00004c  d305              BCC      |L12.90|
;;;451            {
;;;452    
;;;453                /* Set the smallest baud rate that USCI_UART can generate */
;;;454                u32PDSCnt = 0x4ul;
;;;455                u32MinDSCnt = 0x10ul;
00004e  2010              MOVS     r0,#0x10
000050  2504              MOVS     r5,#4                 ;454
;;;456                u32MinClkDiv = 0x400ul;
000052  9000              STR      r0,[sp,#0]
000054  0180              LSLS     r0,r0,#6
000056  9001              STR      r0,[sp,#4]
000058  e03c              B        |L12.212|
                  |L12.90|
;;;457    
;;;458            }
;;;459            else
;;;460            {
;;;461    
;;;462                u32Tmp = 0x400ul * 0x10ul;
00005a  2101              MOVS     r1,#1
00005c  0389              LSLS     r1,r1,#14
;;;463                for(u32PDSCnt = 1ul; u32PDSCnt <= 0x04ul; u32PDSCnt++)
00005e  2501              MOVS     r5,#1
                  |L12.96|
;;;464                {
;;;465                    if(u32Div <= (u32Tmp * u32PDSCnt)) break;
000060  4608              MOV      r0,r1
000062  4368              MULS     r0,r5,r0
000064  42a0              CMP      r0,r4
000066  d203              BCS      |L12.112|
000068  1c6d              ADDS     r5,r5,#1
00006a  2d04              CMP      r5,#4                 ;463
00006c  d9f8              BLS      |L12.96|
00006e  e001              B        |L12.116|
                  |L12.112|
;;;466                }
;;;467    
;;;468                if(u32PDSCnt > 0x4ul) u32PDSCnt = 0x4ul;
000070  2d04              CMP      r5,#4
000072  d900              BLS      |L12.118|
                  |L12.116|
000074  2504              MOVS     r5,#4
                  |L12.118|
;;;469    
;;;470                u32Div = u32Div / u32PDSCnt;
000076  4629              MOV      r1,r5
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       __aeabi_uidivmod
;;;471    
;;;472                /* Find best solution */
;;;473                u32Min = (uint32_t) - 1;
;;;474                u32MinDSCnt = 0ul;
00007e  9003              STR      r0,[sp,#0xc]
000080  2000              MOVS     r0,#0
000082  2700              MOVS     r7,#0                 ;473
000084  43ff              MVNS     r7,r7                 ;473
;;;475                u32MinClkDiv = 0ul;
000086  9000              STR      r0,[sp,#0]
;;;476    
;;;477                for(u32DSCnt = 6ul; u32DSCnt <= 0x10ul; u32DSCnt++)   /* DSCNT could be 0x5~0xF */
000088  2406              MOVS     r4,#6
00008a  9001              STR      r0,[sp,#4]
                  |L12.140|
;;;478                {
;;;479                    u32ClkDiv = u32Div / u32DSCnt;
00008c  4621              MOV      r1,r4
00008e  9803              LDR      r0,[sp,#0xc]
000090  f7fffffe          BL       __aeabi_uidivmod
;;;480    
;;;481                    if(u32ClkDiv > 0x400ul)
000094  2101              MOVS     r1,#1
000096  0289              LSLS     r1,r1,#10
000098  4288              CMP      r0,r1
00009a  d905              BLS      |L12.168|
;;;482                    {
;;;483                        u32ClkDiv = 0x400ul;
00009c  4608              MOV      r0,r1
;;;484                        u32Tmp = u32Div - (u32ClkDiv * u32DSCnt);
00009e  9903              LDR      r1,[sp,#0xc]
0000a0  02a2              LSLS     r2,r4,#10
0000a2  1a8a              SUBS     r2,r1,r2
;;;485                        u32Tmp2 = u32Tmp + 1ul;
0000a4  1c51              ADDS     r1,r2,#1
0000a6  e007              B        |L12.184|
                  |L12.168|
0000a8  4601              MOV      r1,r0
;;;486                    }
;;;487                    else
;;;488                    {
;;;489                        u32Tmp = u32Div - (u32ClkDiv * u32DSCnt);
0000aa  9a03              LDR      r2,[sp,#0xc]
0000ac  4361              MULS     r1,r4,r1
0000ae  1a52              SUBS     r2,r2,r1
;;;490                        u32Tmp2 = ((u32ClkDiv + 1ul) * u32DSCnt) - u32Div;
0000b0  1c41              ADDS     r1,r0,#1
0000b2  9b03              LDR      r3,[sp,#0xc]
0000b4  4361              MULS     r1,r4,r1
0000b6  1ac9              SUBS     r1,r1,r3
                  |L12.184|
;;;491                    }
;;;492    
;;;493                    if(u32Tmp >= u32Tmp2)
0000b8  428a              CMP      r2,r1
0000ba  d301              BCC      |L12.192|
0000bc  1c40              ADDS     r0,r0,#1
;;;494                    {
;;;495                        u32ClkDiv = u32ClkDiv + 1ul;
0000be  e000              B        |L12.194|
                  |L12.192|
;;;496                    }
;;;497                    else u32Tmp2 = u32Tmp;
0000c0  4611              MOV      r1,r2
                  |L12.194|
;;;498    
;;;499                    if(u32Tmp2 < u32Min)
0000c2  42b9              CMP      r1,r7
0000c4  d203              BCS      |L12.206|
;;;500                    {
;;;501                        u32Min = u32Tmp2;
0000c6  000f              MOVS     r7,r1
;;;502                        u32MinDSCnt = u32DSCnt;
;;;503                        u32MinClkDiv = u32ClkDiv;
;;;504    
;;;505                        /* Break when get good results */
;;;506                        if(u32Min == 0ul)
0000c8  9400              STR      r4,[sp,#0]
0000ca  9001              STR      r0,[sp,#4]
0000cc  d002              BEQ      |L12.212|
                  |L12.206|
0000ce  1c64              ADDS     r4,r4,#1
0000d0  2c10              CMP      r4,#0x10              ;477
0000d2  d9db              BLS      |L12.140|
                  |L12.212|
;;;507                        {
;;;508                            break;
;;;509                        }
;;;510                    }
;;;511                }
;;;512    
;;;513            }
;;;514    
;;;515            /* Set USCI_UART baud rate */
;;;516            uuart->BRGEN = ((u32MinClkDiv - 1ul) << UUART_BRGEN_CLKDIV_Pos) |
0000d4  9900              LDR      r1,[sp,#0]
0000d6  9801              LDR      r0,[sp,#4]
0000d8  028a              LSLS     r2,r1,#10
0000da  2101              MOVS     r1,#1
0000dc  1e40              SUBS     r0,r0,#1
0000de  0289              LSLS     r1,r1,#10
0000e0  0400              LSLS     r0,r0,#16
0000e2  1a51              SUBS     r1,r2,r1
0000e4  4308              ORRS     r0,r0,r1
0000e6  0229              LSLS     r1,r5,#8
0000e8  39ff              SUBS     r1,r1,#0xff
0000ea  3901              SUBS     r1,#1
0000ec  4308              ORRS     r0,r0,r1
0000ee  60b0              STR      r0,[r6,#8]
0000f0  e00d              B        |L12.270|
                  |L12.242|
;;;517                           ((u32MinDSCnt - 1ul) << UUART_BRGEN_DSCNT_Pos) |
;;;518                           ((u32PDSCnt - 1ul) << UUART_BRGEN_PDSCNT_Pos);
;;;519    
;;;520        }
;;;521        else
;;;522        {
;;;523            u32PDSCnt = ((uuart->BRGEN & UUART_BRGEN_PDSCNT_Msk) >> UUART_BRGEN_PDSCNT_Pos) + 1ul;
0000f2  68b0              LDR      r0,[r6,#8]
;;;524            u32MinDSCnt = ((uuart->BRGEN & UUART_BRGEN_DSCNT_Msk) >> UUART_BRGEN_DSCNT_Pos) + 1ul;
;;;525            u32MinClkDiv = ((uuart->BRGEN & UUART_BRGEN_CLKDIV_Msk) >> UUART_BRGEN_CLKDIV_Pos) + 1ul;
;;;526        }
;;;527    
;;;528        /* Set USCI_UART line configuration */
;;;529        uuart->LINECTL = (uuart->LINECTL & ~UUART_LINECTL_DWIDTH_Msk) | u32data_width;
;;;530        uuart->PROTCTL = (uuart->PROTCTL & ~(UUART_PROTCTL_STICKEN_Msk | UUART_PROTCTL_EVENPARITY_Msk |
;;;531                                             UUART_PROTCTL_PARITYEN_Msk)) | u32parity;
;;;532        uuart->PROTCTL = (uuart->PROTCTL & ~UUART_PROTCTL_STOPB_Msk) | u32stop_bits;
;;;533    
;;;534        return (u32PCLKFreq / u32PDSCnt / u32MinDSCnt / u32MinClkDiv);
;;;535    }
0000f4  0580              LSLS     r0,r0,#22
0000f6  0f85              LSRS     r5,r0,#30
0000f8  68b0              LDR      r0,[r6,#8]            ;524
0000fa  0440              LSLS     r0,r0,#17
0000fc  0ec0              LSRS     r0,r0,#27
0000fe  1c40              ADDS     r0,r0,#1
000100  9000              STR      r0,[sp,#0]            ;525
000102  68b0              LDR      r0,[r6,#8]            ;525
000104  0180              LSLS     r0,r0,#6
000106  0d80              LSRS     r0,r0,#22
000108  1c40              ADDS     r0,r0,#1
00010a  1c6d              ADDS     r5,r5,#1              ;525
00010c  9001              STR      r0,[sp,#4]            ;525
                  |L12.270|
00010e  6af0              LDR      r0,[r6,#0x2c]         ;529
000110  210f              MOVS     r1,#0xf               ;529
000112  0209              LSLS     r1,r1,#8              ;529
000114  4388              BICS     r0,r0,r1              ;529
000116  9907              LDR      r1,[sp,#0x1c]         ;529
000118  4308              ORRS     r0,r0,r1              ;529
00011a  62f0              STR      r0,[r6,#0x2c]         ;529
00011c  6df0              LDR      r0,[r6,#0x5c]         ;530
00011e  490d              LDR      r1,|L12.340|
000120  4008              ANDS     r0,r0,r1              ;530
000122  9908              LDR      r1,[sp,#0x20]         ;530
000124  4308              ORRS     r0,r0,r1              ;530
000126  65f0              STR      r0,[r6,#0x5c]         ;530
000128  6df0              LDR      r0,[r6,#0x5c]         ;532
00012a  990e              LDR      r1,[sp,#0x38]         ;532
00012c  0840              LSRS     r0,r0,#1              ;532
00012e  0040              LSLS     r0,r0,#1              ;532
000130  4308              ORRS     r0,r0,r1              ;532
000132  65f0              STR      r0,[r6,#0x5c]         ;532
000134  4629              MOV      r1,r5                 ;534
000136  9802              LDR      r0,[sp,#8]            ;534
000138  f7fffffe          BL       __aeabi_uidivmod
00013c  9900              LDR      r1,[sp,#0]            ;534
00013e  f7fffffe          BL       __aeabi_uidivmod
000142  9901              LDR      r1,[sp,#4]            ;534
000144  f7fffffe          BL       __aeabi_uidivmod
000148  b009              ADD      sp,sp,#0x24
00014a  bdf0              POP      {r4-r7,pc}
;;;536    
                          ENDP

                  |L12.332|
                          DCD      0x40070000
                  |L12.336|
                          DCD      0x40074000
                  |L12.340|
                          DCD      0xfbfffff9

                          AREA ||i.UUART_Write||, CODE, READONLY, ALIGN=1

                  UUART_Write PROC
;;;548     */
;;;549    uint32_t UUART_Write(UUART_T* uuart, uint8_t *pu8TxBuf, uint32_t u32WriteBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;550    {
000002  4604              MOV      r4,r0
;;;551        uint32_t  u32Count, u32delayno;
;;;552    
;;;553        for(u32Count = 0; u32Count != u32WriteBytes; u32Count++)
000004  2000              MOVS     r0,#0
;;;554        {
;;;555            u32delayno = 0;
;;;556            while((uuart->BUFSTS & UUART_BUFSTS_TXEMPTY_Msk) == 0)   /* Wait Tx empty */
;;;557            {
;;;558                u32delayno++;
;;;559                if(u32delayno >= 0x40000000)
000006  2501              MOVS     r5,#1
000008  07ad              LSLS     r5,r5,#30
00000a  e00c              B        |L13.38|
                  |L13.12|
00000c  2300              MOVS     r3,#0                 ;555
00000e  e004              B        |L13.26|
                  |L13.16|
000010  1c5b              ADDS     r3,r3,#1              ;556
000012  42ab              CMP      r3,r5
000014  d301              BCC      |L13.26|
;;;560                    return FALSE;
000016  2000              MOVS     r0,#0
;;;561            }
;;;562            uuart->TXDAT = pu8TxBuf[u32Count];    /* Send USCI_UART Data to buffer */
;;;563        }
;;;564    
;;;565        return u32Count;
;;;566    
;;;567    }
000018  bd70              POP      {r4-r6,pc}
                  |L13.26|
00001a  6be6              LDR      r6,[r4,#0x3c]         ;556
00001c  05f6              LSLS     r6,r6,#23             ;556
00001e  d5f7              BPL      |L13.16|
000020  5c0b              LDRB     r3,[r1,r0]            ;562
000022  6323              STR      r3,[r4,#0x30]         ;562
000024  1c40              ADDS     r0,r0,#1              ;562
                  |L13.38|
000026  4290              CMP      r0,r2                 ;553
000028  d1f0              BNE      |L13.12|
00002a  bd70              POP      {r4-r6,pc}
;;;568    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\lib\\StdDriver\\src\\usci_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_usci_uart_c_2f0f282b____REV16|
#line 388 "..\\lib\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___11_usci_uart_c_2f0f282b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_usci_uart_c_2f0f282b____REVSH|
#line 402
|__asm___11_usci_uart_c_2f0f282b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
