; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\i2c.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\i2c.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\lib\CMSIS\Include -I..\lib\Device\Nuvoton\NUC029xGE\Include -I..\lib\StdDriver\inc -I..\src\core\include -I..\src\driver\include -I..\src\io\include -I..\src\global -I..\src\server\include -I..\src\driver\audio -D__UVISION_VERSION=522 --omf_browse=.\obj\i2c.crf ..\lib\StdDriver\src\i2c.c]
                          THUMB

                          AREA ||i.I2C_ClearTimeoutFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearTimeoutFlag PROC
;;;91       */
;;;92     void I2C_ClearTimeoutFlag(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;93     {
;;;94         i2c->TOCTL |= I2C_TOCTL_TOIF_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;95     }
000008  4770              BX       lr
;;;96     
                          ENDP


                          AREA ||i.I2C_Close||, CODE, READONLY, ALIGN=2

                  I2C_Close PROC
;;;63     
;;;64     void I2C_Close(I2C_T *i2c)
000000  4a0b              LDR      r2,|L2.48|
;;;65     {
;;;66         /* Reset I2C controller */
;;;67         if((uint32_t)i2c == I2C0_BASE)
;;;68         {
;;;69             SYS->IPRST1 |= SYS_IPRST1_I2C0RST_Msk;
000002  2105              MOVS     r1,#5
000004  0709              LSLS     r1,r1,#28
000006  4290              CMP      r0,r2                 ;67
000008  d102              BNE      |L2.16|
00000a  68cb              LDR      r3,[r1,#0xc]
00000c  1582              ASRS     r2,r0,#22
;;;70             SYS->IPRST1 &= ~SYS_IPRST1_I2C0RST_Msk;
00000e  e004              B        |L2.26|
                  |L2.16|
;;;71         }
;;;72         else if((uint32_t)i2c == I2C1_BASE)
000010  4a08              LDR      r2,|L2.52|
000012  4290              CMP      r0,r2
000014  d106              BNE      |L2.36|
;;;73         {
;;;74             SYS->IPRST1 |= SYS_IPRST1_I2C1RST_Msk;
000016  68cb              LDR      r3,[r1,#0xc]
000018  1542              ASRS     r2,r0,#21
                  |L2.26|
00001a  4313              ORRS     r3,r3,r2
00001c  60cb              STR      r3,[r1,#0xc]
;;;75             SYS->IPRST1 &= ~SYS_IPRST1_I2C1RST_Msk;
00001e  68cb              LDR      r3,[r1,#0xc]
000020  4393              BICS     r3,r3,r2
000022  60cb              STR      r3,[r1,#0xc]
                  |L2.36|
;;;76         }
;;;77     
;;;78         /* Disable I2C */
;;;79         i2c->CTL &= ~I2C_CTL_I2CEN_Msk;
000024  6801              LDR      r1,[r0,#0]
000026  2240              MOVS     r2,#0x40
000028  4391              BICS     r1,r1,r2
00002a  6001              STR      r1,[r0,#0]
;;;80     }
00002c  4770              BX       lr
;;;81     
                          ENDP

00002e  0000              DCW      0x0000
                  |L2.48|
                          DCD      0x40020000
                  |L2.52|
                          DCD      0x40120000

                          AREA ||i.I2C_DisableInt||, CODE, READONLY, ALIGN=1

                  I2C_DisableInt PROC
;;;136      */
;;;137    void I2C_DisableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;138    {
;;;139        i2c->CTL &= ~I2C_CTL_INTEN_Msk;
000002  2280              MOVS     r2,#0x80
000004  4391              BICS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;140    }
000008  4770              BX       lr
;;;141    
                          ENDP


                          AREA ||i.I2C_DisableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_DisableTimeout PROC
;;;347     */
;;;348    void I2C_DisableTimeout(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;349    {
;;;350        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000002  2204              MOVS     r2,#4
000004  4391              BICS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;351    }
000008  4770              BX       lr
;;;352    
                          ENDP


                          AREA ||i.I2C_DisableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_DisableWakeup PROC
;;;377     */
;;;378    void I2C_DisableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;379    {
;;;380        i2c->WKCTL &= ~I2C_WKCTL_WKEN_Msk;
000002  0849              LSRS     r1,r1,#1
000004  0049              LSLS     r1,r1,#1
000006  63c1              STR      r1,[r0,#0x3c]
;;;381    }
000008  4770              BX       lr
;;;382    
                          ENDP


                          AREA ||i.I2C_EnableInt||, CODE, READONLY, ALIGN=1

                  I2C_EnableInt PROC
;;;151      */
;;;152    void I2C_EnableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;153    {
;;;154        i2c->CTL |= I2C_CTL_INTEN_Msk;
000002  2280              MOVS     r2,#0x80
000004  4311              ORRS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;155    }
000008  4770              BX       lr
;;;156    
                          ENDP


                          AREA ||i.I2C_EnableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_EnableTimeout PROC
;;;327     */
;;;328    void I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout)
000000  2202              MOVS     r2,#2
;;;329    {
;;;330        if(u8LongTimeout)
000002  2900              CMP      r1,#0
;;;331            i2c->TOCTL |= I2C_TOCTL_TOCDIV4_Msk;
;;;332        else
;;;333            i2c->TOCTL &= ~I2C_TOCTL_TOCDIV4_Msk;
000004  6941              LDR      r1,[r0,#0x14]
000006  d001              BEQ      |L7.12|
000008  4311              ORRS     r1,r1,r2              ;331
00000a  e000              B        |L7.14|
                  |L7.12|
00000c  4391              BICS     r1,r1,r2
                  |L7.14|
00000e  6141              STR      r1,[r0,#0x14]
;;;334    
;;;335        i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
000010  6941              LDR      r1,[r0,#0x14]
000012  2204              MOVS     r2,#4
000014  4311              ORRS     r1,r1,r2
000016  6141              STR      r1,[r0,#0x14]
;;;336    }
000018  4770              BX       lr
;;;337    
                          ENDP


                          AREA ||i.I2C_EnableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_EnableWakeup PROC
;;;362     */
;;;363    void I2C_EnableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;364    {
;;;365        i2c->WKCTL |= I2C_WKCTL_WKEN_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  63c1              STR      r1,[r0,#0x3c]
;;;366    }
000008  4770              BX       lr
;;;367    
                          ENDP


                          AREA ||i.I2C_GetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_GetBusClockFreq PROC
;;;165     */
;;;166    uint32_t I2C_GetBusClockFreq(I2C_T *i2c)
000000  b510              PUSH     {r4,lr}
;;;167    {
;;;168        uint32_t u32Divider = i2c->CLKDIV;
000002  6900              LDR      r0,[r0,#0x10]
;;;169    
;;;170        return (SystemCoreClock / ((u32Divider + 1) << 2));
000004  0081              LSLS     r1,r0,#2
000006  4803              LDR      r0,|L9.20|
000008  1d09              ADDS     r1,r1,#4
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  f7fffffe          BL       __aeabi_uidivmod
;;;171    }
000010  bd10              POP      {r4,pc}
;;;172    
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_GetData||, CODE, READONLY, ALIGN=1

                  I2C_GetData PROC
;;;229     */
;;;230    uint8_t I2C_GetData(I2C_T *i2c)
000000  6880              LDR      r0,[r0,#8]
;;;231    {
;;;232        return (i2c->DAT);
000002  b2c0              UXTB     r0,r0
;;;233    }
000004  4770              BX       lr
;;;234    
                          ENDP


                          AREA ||i.I2C_GetIntFlag||, CODE, READONLY, ALIGN=1

                  I2C_GetIntFlag PROC
;;;201     */
;;;202    uint32_t I2C_GetIntFlag(I2C_T *i2c)
000000  6800              LDR      r0,[r0,#0]
;;;203    {
;;;204        return ((i2c->CTL & I2C_CTL_SI_Msk) == I2C_CTL_SI_Msk ? 1 : 0);
000002  0700              LSLS     r0,r0,#28
000004  0fc0              LSRS     r0,r0,#31
;;;205    }
000006  4770              BX       lr
;;;206    
                          ENDP


                          AREA ||i.I2C_GetStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetStatus PROC
;;;215     */
;;;216    uint32_t I2C_GetStatus(I2C_T *i2c)
000000  68c0              LDR      r0,[r0,#0xc]
;;;217    {
;;;218        return (i2c->STATUS);
;;;219    }
000002  4770              BX       lr
;;;220    
                          ENDP


                          AREA ||i.I2C_Open||, CODE, READONLY, ALIGN=2

                  I2C_Open PROC
;;;39       */
;;;40     uint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;41     {
;;;42         uint32_t u32Div;
;;;43     
;;;44         u32Div = (uint32_t)(((SystemCoreClock * 10) / (u32BusClock * 4) + 5) / 10 - 1); /* Compute proper divider for I2C clock */
000002  4d0c              LDR      r5,|L13.52|
000004  4604              MOV      r4,r0                 ;41
000006  6828              LDR      r0,[r5,#0]  ; SystemCoreClock
000008  220a              MOVS     r2,#0xa
00000a  0089              LSLS     r1,r1,#2
00000c  4350              MULS     r0,r2,r0
00000e  f7fffffe          BL       __aeabi_uidivmod
000012  210a              MOVS     r1,#0xa
000014  1d40              ADDS     r0,r0,#5
000016  f7fffffe          BL       __aeabi_uidivmod
00001a  1e40              SUBS     r0,r0,#1
;;;45         i2c->CLKDIV = u32Div;
00001c  6120              STR      r0,[r4,#0x10]
;;;46     
;;;47         /* Enable I2C */
;;;48         i2c->CTL |= I2C_CTL_I2CEN_Msk;
00001e  6821              LDR      r1,[r4,#0]
000020  2240              MOVS     r2,#0x40
000022  4311              ORRS     r1,r1,r2
000024  6021              STR      r1,[r4,#0]
;;;49     
;;;50         return (SystemCoreClock / ((u32Div + 1) << 2));
000026  0081              LSLS     r1,r0,#2
000028  1d09              ADDS     r1,r1,#4
00002a  6828              LDR      r0,[r5,#0]  ; SystemCoreClock
00002c  f7fffffe          BL       __aeabi_uidivmod
;;;51     }
000030  bd70              POP      {r4-r6,pc}
;;;52     
                          ENDP

000032  0000              DCW      0x0000
                  |L13.52|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_ReadByte||, CODE, READONLY, ALIGN=1

                  I2C_ReadByte PROC
;;;750      */
;;;751    uint8_t I2C_ReadByte(I2C_T *i2c, uint8_t u8SlaveAddr)
000000  b5f0              PUSH     {r4-r7,lr}
;;;752    {
;;;753        uint8_t u8Xfering = 1, u8Err = 0, rdata = 0, u8Ctrl = 0;
000002  2401              MOVS     r4,#1
000004  2200              MOVS     r2,#0
;;;754    
;;;755        I2C_START(i2c);                                                /* Send START */
000006  6805              LDR      r5,[r0,#0]
000008  4613              MOV      r3,r2                 ;753
00000a  2628              MOVS     r6,#0x28
00000c  4335              ORRS     r5,r5,r6
00000e  6005              STR      r5,[r0,#0]
;;;756        while(u8Xfering && (u8Err == 0))
;;;757        {
;;;758            I2C_WAIT_READY(i2c);
;;;759            switch(I2C_GET_STATUS(i2c))
;;;760            {
;;;761                case 0x08:
;;;762                    I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));    /* Write SLA+R to Register I2CDAT */
000010  004f              LSLS     r7,r1,#1
;;;763                    u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;764                    break;
;;;765                case 0x40:                                             /* Slave Address ACK */
;;;766                    u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;767                    break;
;;;768                case 0x48:                                             /* Slave Address NACK */
;;;769                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;770                    u8Err = 1;
;;;771                    break;
;;;772                case 0x58:
;;;773                    rdata = (unsigned char) I2C_GET_DATA(i2c);         /* Receive Data */
;;;774                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;775                    u8Xfering = 0;
;;;776                    break;
;;;777                case 0x38:                                             /* Arbitration Lost */
;;;778                default:                                               /* Unknow status */
;;;779                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;780                    u8Err = 1;
;;;781                    break;
;;;782            }
;;;783            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
000012  263c              MOVS     r6,#0x3c
000014  1c7f              ADDS     r7,r7,#1
                  |L14.22|
000016  6801              LDR      r1,[r0,#0]            ;758
000018  0709              LSLS     r1,r1,#28             ;758
00001a  d5fc              BPL      |L14.22|
00001c  68c1              LDR      r1,[r0,#0xc]          ;759
00001e  2908              CMP      r1,#8                 ;759
000020  d008              BEQ      |L14.52|
000022  2940              CMP      r1,#0x40              ;759
000024  d007              BEQ      |L14.54|
000026  2948              CMP      r1,#0x48              ;759
000028  d001              BEQ      |L14.46|
00002a  2958              CMP      r1,#0x58              ;759
00002c  d005              BEQ      |L14.58|
                  |L14.46|
00002e  2118              MOVS     r1,#0x18              ;769
000030  2201              MOVS     r2,#1                 ;770
000032  e006              B        |L14.66|
                  |L14.52|
000034  6087              STR      r7,[r0,#8]            ;762
                  |L14.54|
000036  2108              MOVS     r1,#8                 ;766
000038  e003              B        |L14.66|
                  |L14.58|
00003a  6881              LDR      r1,[r0,#8]            ;773
00003c  b2cb              UXTB     r3,r1                 ;773
00003e  2118              MOVS     r1,#0x18              ;774
000040  2400              MOVS     r4,#0                 ;775
                  |L14.66|
000042  6805              LDR      r5,[r0,#0]
000044  43b5              BICS     r5,r5,r6
000046  430d              ORRS     r5,r5,r1
000048  6005              STR      r5,[r0,#0]
00004a  2c00              CMP      r4,#0                 ;756
00004c  d002              BEQ      |L14.84|
00004e  2a00              CMP      r2,#0                 ;756
000050  d0e1              BEQ      |L14.22|
000052  e001              B        |L14.88|
                  |L14.84|
;;;784        }
;;;785        if(u8Err)
000054  2a00              CMP      r2,#0
000056  d000              BEQ      |L14.90|
                  |L14.88|
;;;786            rdata = 0;                                                 /* If occurs error, return 0 */
000058  2300              MOVS     r3,#0
                  |L14.90|
;;;787        return rdata;                                                  /* Return read data */
00005a  4618              MOV      r0,r3
;;;788    }
00005c  bdf0              POP      {r4-r7,pc}
;;;789    
                          ENDP


                          AREA ||i.I2C_ReadByteOneReg||, CODE, READONLY, ALIGN=1

                  I2C_ReadByteOneReg PROC
;;;867      */
;;;868    uint8_t I2C_ReadByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;869    {
;;;870        uint8_t u8Xfering = 1, u8Err = 0, rdata = 0, u8Ctrl = 0;
000002  2601              MOVS     r6,#1
000004  2400              MOVS     r4,#0
;;;871    
;;;872        I2C_START(i2c);                                                /* Send START */
000006  6803              LDR      r3,[r0,#0]
000008  4625              MOV      r5,r4                 ;870
00000a  4622              MOV      r2,r4                 ;870
00000c  2728              MOVS     r7,#0x28
00000e  433b              ORRS     r3,r3,r7
000010  6003              STR      r3,[r0,#0]
;;;873        while(u8Xfering && (u8Err == 0))
;;;874        {
;;;875            I2C_WAIT_READY(i2c);
;;;876            switch(I2C_GET_STATUS(i2c))
;;;877            {
;;;878                case 0x08:
;;;879                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));      /* Write SLA+W to Register I2CDAT */
000012  004f              LSLS     r7,r1,#1
                  |L15.20|
000014  6801              LDR      r1,[r0,#0]            ;875
000016  0709              LSLS     r1,r1,#28             ;875
000018  d5fc              BPL      |L15.20|
00001a  68c1              LDR      r1,[r0,#0xc]          ;876
00001c  074b              LSLS     r3,r1,#29             ;876
00001e  0f5b              LSRS     r3,r3,#29             ;876
000020  d10f              BNE      |L15.66|
000022  10c9              ASRS     r1,r1,#3              ;876
000024  000b              MOVS     r3,r1                 ;876
000026  f7fffffe          BL       __ARM_common_switch8
00002a  0c0c              DCB      0x0c,0x0c
00002c  0711090c          DCB      0x07,0x11,0x09,0x0c
000030  0f0c0c13          DCB      0x0f,0x0c,0x0c,0x13
000034  0c0c150c          DCB      0x0c,0x0c,0x15,0x0c
000038  6087              STR      r7,[r0,#8]
;;;880                    u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;881                    break;
00003a  e009              B        |L15.80|
;;;882                case 0x18:                                             /* Slave Address ACK */
;;;883                    I2C_SET_DATA(i2c, u8DataAddr);                     /* Write Lo byte address of register */
00003c  9902              LDR      r1,[sp,#8]
00003e  6081              STR      r1,[r0,#8]
;;;884                    break;
000040  e00c              B        |L15.92|
                  |L15.66|
;;;885                case 0x20:                                             /* Slave Address NACK */
;;;886                case 0x30:                                             /* Master transmit data NACK */
;;;887                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000042  2218              MOVS     r2,#0x18
;;;888                    u8Err = 1;
000044  2401              MOVS     r4,#1
;;;889                    break;
000046  e009              B        |L15.92|
;;;890                case 0x28:
;;;891                    u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
000048  2228              MOVS     r2,#0x28
;;;892                    break;
00004a  e007              B        |L15.92|
;;;893                case 0x10:
;;;894                    I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));    /* Write SLA+R to Register I2CDAT */
00004c  1c79              ADDS     r1,r7,#1
00004e  6081              STR      r1,[r0,#8]
                  |L15.80|
000050  2208              MOVS     r2,#8                 ;880
000052  e003              B        |L15.92|
;;;895                    u8Ctrl = I2C_CTL_SI;                               /* Clear SI */
;;;896                    break;
;;;897                case 0x40:                                             /* Slave Address ACK */
;;;898                    u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;899                    break;
;;;900                case 0x48:                                             /* Slave Address NACK */
;;;901                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;902                    u8Err = 1;
;;;903                    break;
;;;904                case 0x58:
;;;905                    rdata = (uint8_t) I2C_GET_DATA(i2c);               /* Receive Data */
000054  6881              LDR      r1,[r0,#8]
;;;906                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000056  2218              MOVS     r2,#0x18
000058  b2cd              UXTB     r5,r1                 ;905
;;;907                    u8Xfering = 0;
00005a  2600              MOVS     r6,#0
                  |L15.92|
;;;908                    break;
;;;909                case 0x38:                                             /* Arbitration Lost */
;;;910                default:                                               /* Unknow status */
;;;911                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;912                    u8Err = 1;
;;;913                    break;
;;;914            }
;;;915            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
00005c  6801              LDR      r1,[r0,#0]
00005e  233c              MOVS     r3,#0x3c
000060  4399              BICS     r1,r1,r3
000062  4311              ORRS     r1,r1,r2
000064  6001              STR      r1,[r0,#0]
000066  2e00              CMP      r6,#0                 ;873
000068  d002              BEQ      |L15.112|
00006a  2c00              CMP      r4,#0                 ;873
00006c  d0d2              BEQ      |L15.20|
00006e  e001              B        |L15.116|
                  |L15.112|
;;;916        }
;;;917        if(u8Err)
000070  2c00              CMP      r4,#0
000072  d000              BEQ      |L15.118|
                  |L15.116|
;;;918            rdata = 0;                                                 /* If occurs error, return 0 */
000074  2500              MOVS     r5,#0
                  |L15.118|
;;;919        return rdata;                                                  /* Return read data */
000076  4628              MOV      r0,r5
;;;920    }
000078  bdfe              POP      {r1-r7,pc}
;;;921    
                          ENDP


                          AREA ||i.I2C_ReadByteTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_ReadByteTwoRegs PROC
;;;1009     */
;;;1010   uint8_t I2C_ReadByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1011   {
;;;1012       uint8_t u8Xfering = 1, u8Err = 0, rdata = 0, u8Addr = 1, u8Ctrl = 0;
000002  2201              MOVS     r2,#1
000004  b081              SUB      sp,sp,#4              ;1011
000006  2400              MOVS     r4,#0
000008  9200              STR      r2,[sp,#0]
00000a  4616              MOV      r6,r2
;;;1013   
;;;1014       I2C_START(i2c);                                                         /* Send START */
00000c  6803              LDR      r3,[r0,#0]
00000e  4625              MOV      r5,r4                 ;1012
000010  4622              MOV      r2,r4                 ;1012
000012  2728              MOVS     r7,#0x28
000014  433b              ORRS     r3,r3,r7
000016  6003              STR      r3,[r0,#0]
;;;1015       while(u8Xfering && (u8Err == 0))
;;;1016       {
;;;1017           I2C_WAIT_READY(i2c);
;;;1018   		
;;;1019   		//printf("I2C_ReadByteTwoRegs*status= 0x%x,%x,%x,%x\n",I2C_GET_STATUS(i2c),u8Xfering,u8Err,(i2c)->DAT);
;;;1020           switch(I2C_GET_STATUS(i2c))
;;;1021           {
;;;1022               case 0x08:
;;;1023   		//		printf("(u8SlaveAddr << 1 | 0x00)= 0x%x\n",(u8SlaveAddr << 1 | 0x00));
;;;1024                   I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));               /* Write SLA+W to Register I2CDAT */
000018  004f              LSLS     r7,r1,#1
                  |L16.26|
00001a  6801              LDR      r1,[r0,#0]            ;1017
00001c  0709              LSLS     r1,r1,#28             ;1017
00001e  d5fc              BPL      |L16.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;1020
000022  074b              LSLS     r3,r1,#29             ;1020
000024  0f5b              LSRS     r3,r3,#29             ;1020
000026  d110              BNE      |L16.74|
000028  10c9              ASRS     r1,r1,#3              ;1020
00002a  000b              MOVS     r3,r1                 ;1020
00002c  f7fffffe          BL       __ARM_common_switch8
000030  0c0d0719          DCB      0x0c,0x0d,0x07,0x19
000034  090d100d          DCB      0x09,0x0d,0x10,0x0d
000038  0d1b0d0d          DCB      0x0d,0x1b,0x0d,0x0d
00003c  1d0d              DCB      0x1d,0x0d
00003e  6087              STR      r7,[r0,#8]
;;;1025                   u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1026                   break;
000040  e011              B        |L16.102|
;;;1027               case 0x18:                                                      /* Slave Address ACK */
;;;1028   		//		printf("(u16DataAddr & 0xFF00) >> 8= 0x%x\n",(u16DataAddr & 0xFF00) >> 8);
;;;1029                   I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00) >> 8));    /* Write Hi byte address of register */
000042  9903              LDR      r1,[sp,#0xc]
000044  0a09              LSRS     r1,r1,#8
000046  6081              STR      r1,[r0,#8]
;;;1030                   break;
000048  e014              B        |L16.116|
                  |L16.74|
;;;1031               case 0x20:                                                      /* Slave Address NACK */
;;;1032               case 0x30:                                                      /* Master transmit data NACK */
;;;1033                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00004a  2218              MOVS     r2,#0x18
;;;1034                   u8Err = 1;
00004c  2401              MOVS     r4,#1
;;;1035                   break;
00004e  e011              B        |L16.116|
;;;1036               case 0x28:
;;;1037                   if(u8Addr)
000050  2e00              CMP      r6,#0
000052  d004              BEQ      |L16.94|
;;;1038                   {
;;;1039   		//			printf("(u16DataAddr & 0xFF)= 0x%x\n",(u16DataAddr & 0xFF));
;;;1040                       I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF));       /* Write Lo byte address of register */
000054  9903              LDR      r1,[sp,#0xc]
000056  b2c9              UXTB     r1,r1
000058  6081              STR      r1,[r0,#8]
;;;1041                       u8Addr = 0;
00005a  2600              MOVS     r6,#0
00005c  e00a              B        |L16.116|
                  |L16.94|
;;;1042                   }
;;;1043                   else
;;;1044                       u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
00005e  2228              MOVS     r2,#0x28
000060  e008              B        |L16.116|
;;;1045                   break;
;;;1046               case 0x10:
;;;1047   		//		printf("((u8SlaveAddr << 1) | 0x01)= 0x%x\n",((u8SlaveAddr << 1) | 0x01));
;;;1048   				
;;;1049                   I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));             /* Write SLA+R to Register I2CDAT */
000062  1c79              ADDS     r1,r7,#1
000064  6081              STR      r1,[r0,#8]
                  |L16.102|
000066  2208              MOVS     r2,#8                 ;1025
000068  e004              B        |L16.116|
;;;1050                   u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1051                   break;
;;;1052               case 0x40:                                                      /* Slave Address ACK */
;;;1053                   u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1054                   break;
;;;1055               case 0x48:                                                      /* Slave Address NACK */
;;;1056                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1057                   u8Err = 1;
;;;1058                   break;
;;;1059               case 0x58:
;;;1060                   rdata = (unsigned char) I2C_GET_DATA(i2c);                  /* Receive Data */
00006a  6881              LDR      r1,[r0,#8]
;;;1061   				
;;;1062   	//			printf("rdata= 0x%x\n",rdata);
;;;1063                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00006c  2218              MOVS     r2,#0x18
00006e  b2cd              UXTB     r5,r1                 ;1060
;;;1064                   u8Xfering = 0;
000070  2100              MOVS     r1,#0
000072  9100              STR      r1,[sp,#0]
                  |L16.116|
;;;1065                   break;
;;;1066               case 0x38:                                                      /* Arbitration Lost */
;;;1067               default:                                                        /* Unknow status */
;;;1068                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1069                   u8Err = 1;
;;;1070                   break;
;;;1071           }
;;;1072   		
;;;1073   //		printf("1(i2c)->DAT=%x\n",(i2c)->DAT);
;;;1074           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
000074  6801              LDR      r1,[r0,#0]
000076  233c              MOVS     r3,#0x3c
000078  4399              BICS     r1,r1,r3
00007a  4311              ORRS     r1,r1,r2
00007c  6001              STR      r1,[r0,#0]
00007e  9900              LDR      r1,[sp,#0]            ;1015
000080  2900              CMP      r1,#0                 ;1015
000082  d002              BEQ      |L16.138|
000084  2c00              CMP      r4,#0                 ;1015
000086  d0c8              BEQ      |L16.26|
000088  e001              B        |L16.142|
                  |L16.138|
;;;1075       }
;;;1076       if(u8Err)
00008a  2c00              CMP      r4,#0
00008c  d000              BEQ      |L16.144|
                  |L16.142|
;;;1077           rdata = 0;                                                          /* If occurs error, return 0 */
00008e  2500              MOVS     r5,#0
                  |L16.144|
;;;1078       return rdata;                                                           /* Return read data */
000090  4628              MOV      r0,r5
;;;1079   }
000092  b004              ADD      sp,sp,#0x10
000094  bdf0              POP      {r4-r7,pc}
;;;1080   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytes||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytes PROC
;;;804      */
;;;805    uint32_t I2C_ReadMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t *rdata, uint32_t u32rLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;806    {
000002  468c              MOV      r12,r1
;;;807        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000004  2701              MOVS     r7,#1
000006  2600              MOVS     r6,#0
;;;808        uint32_t u32rxLen = 0;
;;;809    
;;;810        I2C_START(i2c);                                                /* Send START */
000008  6801              LDR      r1,[r0,#0]
00000a  469e              MOV      lr,r3                 ;806
00000c  4634              MOV      r4,r6                 ;808
00000e  2528              MOVS     r5,#0x28
000010  4329              ORRS     r1,r1,r5
000012  6001              STR      r1,[r0,#0]
                  |L17.20|
;;;811        while(u8Xfering && (u8Err == 0))
;;;812        {
;;;813            I2C_WAIT_READY(i2c);
000014  6801              LDR      r1,[r0,#0]
000016  0709              LSLS     r1,r1,#28
000018  d5fc              BPL      |L17.20|
;;;814            switch(I2C_GET_STATUS(i2c))
00001a  68c1              LDR      r1,[r0,#0xc]
00001c  2948              CMP      r1,#0x48
00001e  d009              BEQ      |L17.52|
000020  dc04              BGT      |L17.44|
000022  2908              CMP      r1,#8
000024  d009              BEQ      |L17.58|
000026  2940              CMP      r1,#0x40
000028  d104              BNE      |L17.52|
00002a  e012              B        |L17.82|
                  |L17.44|
00002c  2950              CMP      r1,#0x50
00002e  d009              BEQ      |L17.68|
000030  2958              CMP      r1,#0x58
000032  d012              BEQ      |L17.90|
                  |L17.52|
;;;815            {
;;;816                case 0x08:
;;;817                    I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));    /* Write SLA+R to Register I2CDAT */
;;;818                    u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;819                    break;
;;;820                case 0x40:                                             /* Slave Address ACK */
;;;821                    u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
;;;822                    break;
;;;823                case 0x48:                                             /* Slave Address NACK */
;;;824                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000034  2518              MOVS     r5,#0x18
;;;825                    u8Err = 1;
000036  2601              MOVS     r6,#1
;;;826                    break;
000038  e014              B        |L17.100|
                  |L17.58|
00003a  4661              MOV      r1,r12                ;817
00003c  0049              LSLS     r1,r1,#1              ;817
00003e  1c49              ADDS     r1,r1,#1              ;817
000040  6081              STR      r1,[r0,#8]            ;817
000042  e008              B        |L17.86|
                  |L17.68|
;;;827                case 0x50:
;;;828                    rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);    /* Receive Data */
000044  6881              LDR      r1,[r0,#8]
000046  5511              STRB     r1,[r2,r4]
;;;829                    if(u32rxLen < (u32rLen - 1))
000048  4671              MOV      r1,lr
00004a  1e49              SUBS     r1,r1,#1
00004c  1c64              ADDS     r4,r4,#1
00004e  428c              CMP      r4,r1
000050  d201              BCS      |L17.86|
                  |L17.82|
;;;830                    {
;;;831                        u8Ctrl = I2C_CTL_SI_AA;                             /* Clear SI and set ACK */
000052  250c              MOVS     r5,#0xc
000054  e006              B        |L17.100|
                  |L17.86|
;;;832                    }
;;;833                    else
;;;834                    {
;;;835                        u8Ctrl = I2C_CTL_SI;                                /* Clear SI */
000056  2508              MOVS     r5,#8
000058  e004              B        |L17.100|
                  |L17.90|
;;;836                    }
;;;837                    break;
;;;838                case 0x58:
;;;839                    rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);    /* Receive Data */
00005a  6881              LDR      r1,[r0,#8]
00005c  5511              STRB     r1,[r2,r4]
;;;840                    u8Ctrl = I2C_CTL_STO_SI;                                /* Clear SI and send STOP */
00005e  2518              MOVS     r5,#0x18
;;;841                    u8Xfering = 0;
000060  2700              MOVS     r7,#0
000062  1c64              ADDS     r4,r4,#1
                  |L17.100|
;;;842                    break;
;;;843                case 0x38:                                                    /* Arbitration Lost */
;;;844                default:                                                      /* Unknow status */
;;;845                    u8Ctrl = I2C_CTL_STO_SI;                                /* Clear SI and send STOP */
;;;846                    u8Err = 1;
;;;847                    break;
;;;848            }
;;;849            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                 /* Write controlbit to I2C_CTL register */
000064  6801              LDR      r1,[r0,#0]
000066  233c              MOVS     r3,#0x3c
000068  4399              BICS     r1,r1,r3
00006a  4329              ORRS     r1,r1,r5
00006c  6001              STR      r1,[r0,#0]
00006e  2f00              CMP      r7,#0                 ;811
000070  d001              BEQ      |L17.118|
000072  2e00              CMP      r6,#0                 ;811
000074  d0ce              BEQ      |L17.20|
                  |L17.118|
;;;850        }
;;;851        return u32rxLen;                                                      /* Return bytes length that have been received */
000076  4620              MOV      r0,r4
;;;852    }
000078  bdf0              POP      {r4-r7,pc}
;;;853    
                          ENDP


                          AREA ||i.I2C_ReadMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytesOneReg PROC
;;;936      */
;;;937    uint32_t I2C_ReadMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t *rdata, uint32_t u32rLen)
000000  b5ff              PUSH     {r0-r7,lr}
;;;938    {
;;;939        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000002  2601              MOVS     r6,#1
000004  2500              MOVS     r5,#0
;;;940        uint32_t u32rxLen = 0;
;;;941    
;;;942        I2C_START(i2c);                                                /* Send START */
000006  6803              LDR      r3,[r0,#0]
000008  462a              MOV      r2,r5                 ;939
00000a  462c              MOV      r4,r5                 ;940
00000c  2728              MOVS     r7,#0x28
00000e  433b              ORRS     r3,r3,r7
000010  6003              STR      r3,[r0,#0]
;;;943        while(u8Xfering && (u8Err == 0))
;;;944        {
;;;945            I2C_WAIT_READY(i2c);
;;;946            switch(I2C_GET_STATUS(i2c))
;;;947            {
;;;948                case 0x08:
;;;949                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));      /* Write SLA+W to Register I2CDAT */
000012  004f              LSLS     r7,r1,#1
                  |L18.20|
000014  6801              LDR      r1,[r0,#0]            ;945
000016  0709              LSLS     r1,r1,#28             ;945
000018  d5fc              BPL      |L18.20|
00001a  68c1              LDR      r1,[r0,#0xc]          ;946
00001c  074b              LSLS     r3,r1,#29             ;946
00001e  0f5b              LSRS     r3,r3,#29             ;946
000020  d10f              BNE      |L18.66|
000022  10c9              ASRS     r1,r1,#3              ;946
000024  000b              MOVS     r3,r1                 ;946
000026  f7fffffe          BL       __ARM_common_switch8
00002a  0c0c              DCB      0x0c,0x0c
00002c  0711090c          DCB      0x07,0x11,0x09,0x0c
000030  0f0c0c1c          DCB      0x0f,0x0c,0x0c,0x1c
000034  0c14200c          DCB      0x0c,0x14,0x20,0x0c
000038  6087              STR      r7,[r0,#8]
;;;950                    u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;951                    break;
00003a  e014              B        |L18.102|
;;;952                case 0x18:                                             /* Slave Address ACK */
;;;953                    I2C_SET_DATA(i2c, u8DataAddr);                     /* Write Lo byte address of register */
00003c  9902              LDR      r1,[sp,#8]
00003e  6081              STR      r1,[r0,#8]
;;;954                    break;
000040  e019              B        |L18.118|
                  |L18.66|
;;;955                case 0x20:                                             /* Slave Address NACK */
;;;956                case 0x30:                                             /* Master transmit data NACK */
;;;957                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000042  2218              MOVS     r2,#0x18
;;;958                    u8Err = 1;
000044  2501              MOVS     r5,#1
;;;959                    break;
000046  e016              B        |L18.118|
;;;960                case 0x28:
;;;961                    u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
000048  2228              MOVS     r2,#0x28
;;;962                    break;
00004a  e014              B        |L18.118|
;;;963                case 0x10:
;;;964                    I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));    /* Write SLA+R to Register I2CDAT */
00004c  1c79              ADDS     r1,r7,#1
00004e  6081              STR      r1,[r0,#8]
;;;965                    u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;966                    break;
000050  e009              B        |L18.102|
;;;967                case 0x40:                                             /* Slave Address ACK */
;;;968                    u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
;;;969                    break;
;;;970                case 0x48:                                             /* Slave Address NACK */
;;;971                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;972                    u8Err = 1;
;;;973                    break;
;;;974                case 0x50:
;;;975                    rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);   /* Receive Data */
000052  6881              LDR      r1,[r0,#8]
000054  9a03              LDR      r2,[sp,#0xc]
000056  5511              STRB     r1,[r2,r4]
;;;976                    if(u32rxLen < (u32rLen - 1))
000058  9909              LDR      r1,[sp,#0x24]
00005a  1c64              ADDS     r4,r4,#1
00005c  1e49              SUBS     r1,r1,#1
00005e  428c              CMP      r4,r1
000060  d201              BCS      |L18.102|
;;;977                        u8Ctrl = I2C_CTL_SI_AA;                      /* Clear SI and set ACK */
000062  220c              MOVS     r2,#0xc
000064  e007              B        |L18.118|
                  |L18.102|
;;;978                    else
;;;979                        u8Ctrl = I2C_CTL_SI;                         /* Clear SI */
000066  2208              MOVS     r2,#8
000068  e005              B        |L18.118|
;;;980                    break;
;;;981                case 0x58:
;;;982                    rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);   /* Receive Data */
00006a  6881              LDR      r1,[r0,#8]
00006c  9a03              LDR      r2,[sp,#0xc]
;;;983                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;984                    u8Xfering = 0;
00006e  2600              MOVS     r6,#0
000070  5511              STRB     r1,[r2,r4]            ;982
000072  2218              MOVS     r2,#0x18              ;983
000074  1c64              ADDS     r4,r4,#1
                  |L18.118|
;;;985                    break;
;;;986                case 0x38:                                             /* Arbitration Lost */
;;;987                default:                                               /* Unknow status */
;;;988                    u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;989                    u8Err = 1;
;;;990                    break;
;;;991            }
;;;992            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                          /* Write controlbit to I2C_CTL register */
000076  6801              LDR      r1,[r0,#0]
000078  233c              MOVS     r3,#0x3c
00007a  4399              BICS     r1,r1,r3
00007c  4311              ORRS     r1,r1,r2
00007e  6001              STR      r1,[r0,#0]
000080  2e00              CMP      r6,#0                 ;943
000082  d001              BEQ      |L18.136|
000084  2d00              CMP      r5,#0                 ;943
000086  d0c5              BEQ      |L18.20|
                  |L18.136|
;;;993        }
;;;994        return u32rxLen;                                               /* Return bytes length that have been received */
000088  4620              MOV      r0,r4
;;;995    }
00008a  b004              ADD      sp,sp,#0x10
00008c  bdf0              POP      {r4-r7,pc}
;;;996    
                          ENDP


                          AREA ||i.I2C_ReadMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytesTwoRegs PROC
;;;1095     */
;;;1096   uint32_t I2C_ReadMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t *rdata, uint32_t u32rLen)
000000  b5ff              PUSH     {r0-r7,lr}
;;;1097   {
;;;1098       uint8_t u8Xfering = 1, u8Err = 0, u8Addr = 1, u8Ctrl = 0;
000002  2601              MOVS     r6,#1
000004  b081              SUB      sp,sp,#4              ;1097
000006  2500              MOVS     r5,#0
;;;1099       uint32_t u32rxLen = 0;
;;;1100   
;;;1101       I2C_START(i2c);                                                         /* Send START */
000008  9600              STR      r6,[sp,#0]
00000a  6803              LDR      r3,[r0,#0]
00000c  462a              MOV      r2,r5                 ;1098
00000e  462c              MOV      r4,r5                 ;1099
000010  2728              MOVS     r7,#0x28
000012  433b              ORRS     r3,r3,r7
000014  6003              STR      r3,[r0,#0]
;;;1102       while(u8Xfering && (u8Err == 0))
;;;1103       {
;;;1104           I2C_WAIT_READY(i2c);
;;;1105           switch(I2C_GET_STATUS(i2c))
;;;1106           {
;;;1107               case 0x08:
;;;1108                   I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));               /* Write SLA+W to Register I2CDAT */
000016  004f              LSLS     r7,r1,#1
                  |L19.24|
000018  6801              LDR      r1,[r0,#0]            ;1104
00001a  0709              LSLS     r1,r1,#28             ;1104
00001c  d5fc              BPL      |L19.24|
00001e  68c1              LDR      r1,[r0,#0xc]          ;1105
000020  074b              LSLS     r3,r1,#29             ;1105
000022  0f5b              LSRS     r3,r3,#29             ;1105
000024  d10f              BNE      |L19.70|
000026  10c9              ASRS     r1,r1,#3              ;1105
000028  000b              MOVS     r3,r1                 ;1105
00002a  f7fffffe          BL       __ARM_common_switch8
00002e  0c0c              DCB      0x0c,0x0c
000030  071a090c          DCB      0x07,0x1a,0x09,0x0c
000034  0f0c0c25          DCB      0x0f,0x0c,0x0c,0x25
000038  0c1d290c          DCB      0x0c,0x1d,0x29,0x0c
00003c  6087              STR      r7,[r0,#8]
;;;1109                   u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1110                   break;
00003e  e01d              B        |L19.124|
;;;1111               case 0x18:                                                      /* Slave Address ACK */
;;;1112                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF00) >> 8);    /* Write Hi byte address of register */
000040  2100              MOVS     r1,#0
000042  6081              STR      r1,[r0,#8]
;;;1113                   break;
000044  e022              B        |L19.140|
                  |L19.70|
;;;1114               case 0x20:                                                      /* Slave Address NACK */
;;;1115               case 0x30:                                                      /* Master transmit data NACK */
;;;1116                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
000046  2218              MOVS     r2,#0x18
;;;1117                   u8Err = 1;
000048  2501              MOVS     r5,#1
;;;1118                   break;
00004a  e01f              B        |L19.140|
;;;1119               case 0x28:
;;;1120                   if(u8Addr)
00004c  9900              LDR      r1,[sp,#0]
00004e  2900              CMP      r1,#0
000050  d005              BEQ      |L19.94|
;;;1121                   {
;;;1122                       I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF));       /* Write Lo byte address of register */
000052  9903              LDR      r1,[sp,#0xc]
000054  b2c9              UXTB     r1,r1
000056  6081              STR      r1,[r0,#8]
;;;1123                       u8Addr = 0;
000058  2100              MOVS     r1,#0
00005a  9100              STR      r1,[sp,#0]
00005c  e016              B        |L19.140|
                  |L19.94|
;;;1124                   }
;;;1125                   else
;;;1126                       u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
00005e  2228              MOVS     r2,#0x28
000060  e014              B        |L19.140|
;;;1127                   break;
;;;1128               case 0x10:
;;;1129                   I2C_SET_DATA(i2c, ((u8SlaveAddr << 1) | 0x01));             /* Write SLA+R to Register I2CDAT */
000062  1c79              ADDS     r1,r7,#1
000064  6081              STR      r1,[r0,#8]
;;;1130                   u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1131                   break;
000066  e009              B        |L19.124|
;;;1132               case 0x40:                                                      /* Slave Address ACK */
;;;1133                   u8Ctrl = I2C_CTL_SI_AA;                                   /* Clear SI and set ACK */
;;;1134                   break;
;;;1135               case 0x48:                                                      /* Slave Address NACK */
;;;1136                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1137                   u8Err = 1;
;;;1138                   break;
;;;1139               case 0x50:
;;;1140                   rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);      /* Receive Data */
000068  6881              LDR      r1,[r0,#8]
00006a  9a04              LDR      r2,[sp,#0x10]
00006c  5511              STRB     r1,[r2,r4]
;;;1141                   if(u32rxLen < (u32rLen - 1))
00006e  990a              LDR      r1,[sp,#0x28]
000070  1c64              ADDS     r4,r4,#1
000072  1e49              SUBS     r1,r1,#1
000074  428c              CMP      r4,r1
000076  d201              BCS      |L19.124|
;;;1142                       u8Ctrl = I2C_CTL_SI_AA;                               /* Clear SI and set ACK */
000078  220c              MOVS     r2,#0xc
00007a  e007              B        |L19.140|
                  |L19.124|
;;;1143                   else
;;;1144                       u8Ctrl = I2C_CTL_SI;                                  /* Clear SI */
00007c  2208              MOVS     r2,#8
00007e  e005              B        |L19.140|
;;;1145                   break;
;;;1146               case 0x58:
;;;1147                   rdata[u32rxLen++] = (unsigned char) I2C_GET_DATA(i2c);      /* Receive Data */
000080  6881              LDR      r1,[r0,#8]
000082  9a04              LDR      r2,[sp,#0x10]
;;;1148                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1149                   u8Xfering = 0;
000084  2600              MOVS     r6,#0
000086  5511              STRB     r1,[r2,r4]            ;1147
000088  2218              MOVS     r2,#0x18              ;1148
00008a  1c64              ADDS     r4,r4,#1
                  |L19.140|
;;;1150                   break;
;;;1151               case 0x38:                                                      /* Arbitration Lost */
;;;1152               default:                                                        /* Unknow status */
;;;1153                   u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1154                   u8Err = 1;
;;;1155                   break;
;;;1156           }
;;;1157           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
00008c  6801              LDR      r1,[r0,#0]
00008e  233c              MOVS     r3,#0x3c
000090  4399              BICS     r1,r1,r3
000092  4311              ORRS     r1,r1,r2
000094  6001              STR      r1,[r0,#0]
000096  2e00              CMP      r6,#0                 ;1102
000098  d001              BEQ      |L19.158|
00009a  2d00              CMP      r5,#0                 ;1102
00009c  d0bc              BEQ      |L19.24|
                  |L19.158|
;;;1158       }
;;;1159       return u32rxLen;                                                        /* Return bytes length that have been received */
00009e  4620              MOV      r0,r4
;;;1160   }
0000a0  b005              ADD      sp,sp,#0x14
0000a2  bdf0              POP      {r4-r7,pc}
;;;1161   
                          ENDP


                          AREA ||i.I2C_SetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_SetBusClockFreq PROC
;;;182     */
;;;183    uint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;184    {
000002  4604              MOV      r4,r0
;;;185        uint32_t u32Div;
;;;186    
;;;187        u32Div = (uint32_t)(((SystemCoreClock * 10) / (u32BusClock * 4) + 5) / 10 - 1); /* Compute proper divider for I2C clock */
000004  4809              LDR      r0,|L20.44|
000006  220a              MOVS     r2,#0xa
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000a  0089              LSLS     r1,r1,#2
00000c  4605              MOV      r5,r0
00000e  4350              MULS     r0,r2,r0
000010  f7fffffe          BL       __aeabi_uidivmod
000014  210a              MOVS     r1,#0xa
000016  1d40              ADDS     r0,r0,#5
000018  f7fffffe          BL       __aeabi_uidivmod
00001c  1e40              SUBS     r0,r0,#1
;;;188        i2c->CLKDIV = u32Div;
00001e  6120              STR      r0,[r4,#0x10]
;;;189    
;;;190        return (SystemCoreClock / ((u32Div + 1) << 2));
000020  0081              LSLS     r1,r0,#2
000022  4628              MOV      r0,r5
000024  1d09              ADDS     r1,r1,#4
000026  f7fffffe          BL       __aeabi_uidivmod
;;;191    }
00002a  bd70              POP      {r4-r6,pc}
;;;192    
                          ENDP

                  |L20.44|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_SetData||, CODE, READONLY, ALIGN=1

                  I2C_SetData PROC
;;;244     */
;;;245    void I2C_SetData(I2C_T *i2c, uint8_t u8Data)
000000  6081              STR      r1,[r0,#8]
;;;246    {
;;;247        i2c->DAT = u8Data;
;;;248    }
000002  4770              BX       lr
;;;249    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddr||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddr PROC
;;;263     */
;;;264    void I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode)
000000  0052              LSLS     r2,r2,#1
;;;265    {
;;;266        switch(u8SlaveNo)
;;;267        {
;;;268            case 1:
;;;269                i2c->ADDR1  = (u8SlaveAddr << 1) | u8GCMode;
000002  431a              ORRS     r2,r2,r3
000004  2901              CMP      r1,#1                 ;266
000006  d005              BEQ      |L22.20|
000008  2902              CMP      r1,#2                 ;266
00000a  d005              BEQ      |L22.24|
00000c  2903              CMP      r1,#3                 ;266
00000e  d005              BEQ      |L22.28|
;;;270                break;
;;;271            case 2:
;;;272                i2c->ADDR2  = (u8SlaveAddr << 1) | u8GCMode;
;;;273                break;
;;;274            case 3:
;;;275                i2c->ADDR3  = (u8SlaveAddr << 1) | u8GCMode;
;;;276                break;
;;;277            case 0:
;;;278            default:
;;;279                i2c->ADDR0  = (u8SlaveAddr << 1) | u8GCMode;
000010  6042              STR      r2,[r0,#4]
;;;280                break;
;;;281        }
;;;282    }
000012  4770              BX       lr
                  |L22.20|
000014  6182              STR      r2,[r0,#0x18]         ;269
000016  4770              BX       lr
                  |L22.24|
000018  61c2              STR      r2,[r0,#0x1c]         ;272
00001a  4770              BX       lr
                  |L22.28|
00001c  6202              STR      r2,[r0,#0x20]         ;275
00001e  4770              BX       lr
;;;283    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddrMask||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddrMask PROC
;;;295     */
;;;296    void I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask)
000000  0052              LSLS     r2,r2,#1
;;;297    {
;;;298        switch(u8SlaveNo)
000002  2901              CMP      r1,#1
000004  d005              BEQ      |L23.18|
000006  2902              CMP      r1,#2
000008  d005              BEQ      |L23.22|
00000a  2903              CMP      r1,#3
00000c  d005              BEQ      |L23.26|
;;;299        {
;;;300            case 1:
;;;301                i2c->ADDRMSK1  = u8SlaveAddrMask << 1;
;;;302                break;
;;;303            case 2:
;;;304                i2c->ADDRMSK2  = u8SlaveAddrMask << 1;
;;;305                break;
;;;306            case 3:
;;;307                i2c->ADDRMSK3  = u8SlaveAddrMask << 1;
;;;308                break;
;;;309            case 0:
;;;310            default:
;;;311                i2c->ADDRMSK0  = u8SlaveAddrMask << 1;
00000e  6242              STR      r2,[r0,#0x24]
;;;312                break;
;;;313        }
;;;314    }
000010  4770              BX       lr
                  |L23.18|
000012  6282              STR      r2,[r0,#0x28]         ;301
000014  4770              BX       lr
                  |L23.22|
000016  62c2              STR      r2,[r0,#0x2c]         ;304
000018  4770              BX       lr
                  |L23.26|
00001a  6302              STR      r2,[r0,#0x30]         ;307
00001c  4770              BX       lr
;;;315    
                          ENDP


                          AREA ||i.I2C_Trigger||, CODE, READONLY, ALIGN=1

                  I2C_Trigger PROC
;;;110      */
;;;111    void I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack)
000000  b530              PUSH     {r4,r5,lr}
;;;112    {
;;;113        uint32_t u32Reg = 0;
000002  2400              MOVS     r4,#0
;;;114    
;;;115        if(u8Start)
000004  9d03              LDR      r5,[sp,#0xc]
000006  2900              CMP      r1,#0
000008  d000              BEQ      |L24.12|
;;;116            u32Reg |= I2C_CTL_STA;
00000a  2420              MOVS     r4,#0x20
                  |L24.12|
;;;117        if(u8Stop)
00000c  2a00              CMP      r2,#0
00000e  d001              BEQ      |L24.20|
;;;118            u32Reg |= I2C_CTL_STO;
000010  2110              MOVS     r1,#0x10
000012  430c              ORRS     r4,r4,r1
                  |L24.20|
;;;119        if(u8Si)
000014  2b00              CMP      r3,#0
000016  d001              BEQ      |L24.28|
;;;120            u32Reg |= I2C_CTL_SI;
000018  2108              MOVS     r1,#8
00001a  430c              ORRS     r4,r4,r1
                  |L24.28|
;;;121        if(u8Ack)
00001c  2d00              CMP      r5,#0
00001e  d001              BEQ      |L24.36|
;;;122            u32Reg |= I2C_CTL_AA;
000020  2104              MOVS     r1,#4
000022  430c              ORRS     r4,r4,r1
                  |L24.36|
;;;123    
;;;124        i2c->CTL = (i2c->CTL & ~0x3C) | u32Reg;
000024  6801              LDR      r1,[r0,#0]
000026  223c              MOVS     r2,#0x3c
000028  4391              BICS     r1,r1,r2
00002a  4321              ORRS     r1,r1,r4
00002c  6001              STR      r1,[r0,#0]
;;;125    }
00002e  bd30              POP      {r4,r5,pc}
;;;126    
                          ENDP


                          AREA ||i.I2C_WriteByte||, CODE, READONLY, ALIGN=1

                  I2C_WriteByte PROC
;;;396    
;;;397    uint8_t I2C_WriteByte(I2C_T *i2c, uint8_t u8SlaveAddr, const uint8_t data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;398    {
;;;399        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000002  2501              MOVS     r5,#1
000004  2400              MOVS     r4,#0
;;;400    
;;;401        I2C_START(i2c);
000006  6806              LDR      r6,[r0,#0]
000008  4623              MOV      r3,r4                 ;399
00000a  2728              MOVS     r7,#0x28
00000c  433e              ORRS     r6,r6,r7
00000e  6006              STR      r6,[r0,#0]
;;;402        while(u8Xfering && (u8Err == 0))
;;;403        {
;;;404            I2C_WAIT_READY(i2c);
;;;405            switch(I2C_GET_STATUS(i2c))
;;;406            {
;;;407                case 0x08:
;;;408                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));    /* Write SLA+W to Register I2CDAT */
000010  004f              LSLS     r7,r1,#1
;;;409                    u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;410                    break;
;;;411                case 0x18:                                           /* Slave Address ACK */
;;;412                    I2C_SET_DATA(i2c, data);                         /* Write data to I2CDAT */
;;;413                    break;
;;;414                case 0x20:                                           /* Slave Address NACK */
;;;415                case 0x30:                                           /* Master transmit data NACK */
;;;416                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;417                    u8Err = 1;
;;;418                    break;
;;;419                case 0x28:
;;;420                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;421                    u8Xfering = 0;
;;;422                    break;
;;;423                case 0x38:                                           /* Arbitration Lost */
;;;424                default:                                             /* Unknow status */
;;;425                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;426                    u8Err = 1;
;;;427                    break;
;;;428            }
;;;429            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
000012  263c              MOVS     r6,#0x3c
                  |L25.20|
000014  6801              LDR      r1,[r0,#0]            ;404
000016  0709              LSLS     r1,r1,#28             ;404
000018  d5fc              BPL      |L25.20|
00001a  68c1              LDR      r1,[r0,#0xc]          ;405
00001c  2920              CMP      r1,#0x20              ;405
00001e  d007              BEQ      |L25.48|
000020  dc04              BGT      |L25.44|
000022  2908              CMP      r1,#8                 ;405
000024  d007              BEQ      |L25.54|
000026  2918              CMP      r1,#0x18              ;405
000028  d102              BNE      |L25.48|
00002a  e007              B        |L25.60|
                  |L25.44|
00002c  2928              CMP      r1,#0x28              ;405
00002e  d007              BEQ      |L25.64|
                  |L25.48|
000030  2318              MOVS     r3,#0x18              ;416
000032  2401              MOVS     r4,#1                 ;417
000034  e006              B        |L25.68|
                  |L25.54|
000036  6087              STR      r7,[r0,#8]            ;408
000038  2308              MOVS     r3,#8                 ;409
00003a  e003              B        |L25.68|
                  |L25.60|
00003c  6082              STR      r2,[r0,#8]            ;412
00003e  e001              B        |L25.68|
                  |L25.64|
000040  2318              MOVS     r3,#0x18              ;420
000042  2500              MOVS     r5,#0                 ;421
                  |L25.68|
000044  6801              LDR      r1,[r0,#0]
000046  43b1              BICS     r1,r1,r6
000048  4319              ORRS     r1,r1,r3
00004a  6001              STR      r1,[r0,#0]
00004c  2d00              CMP      r5,#0                 ;402
00004e  d001              BEQ      |L25.84|
000050  2c00              CMP      r4,#0                 ;402
000052  d0df              BEQ      |L25.20|
                  |L25.84|
000054  4620              MOV      r0,r4                 ;402
;;;430        }
;;;431        return (u8Err | u8Xfering);                                  /* return (Success)/(Fail) status */
000056  4328              ORRS     r0,r0,r5
;;;432    }
000058  bdf0              POP      {r4-r7,pc}
;;;433    
                          ENDP


                          AREA ||i.I2C_WriteByteOneReg||, CODE, READONLY, ALIGN=1

                  I2C_WriteByteOneReg PROC
;;;503    
;;;504    uint8_t I2C_WriteByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, const uint8_t data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;505    {
000002  4694              MOV      r12,r2
;;;506        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000004  2601              MOVS     r6,#1
000006  460a              MOV      r2,r1                 ;505
000008  2500              MOVS     r5,#0
;;;507        uint32_t u32txLen = 0;
;;;508    
;;;509        I2C_START(i2c);                                              /* Send START */
00000a  6801              LDR      r1,[r0,#0]
00000c  469e              MOV      lr,r3                 ;505
00000e  462c              MOV      r4,r5                 ;506
000010  462f              MOV      r7,r5                 ;507
000012  2328              MOVS     r3,#0x28
000014  4319              ORRS     r1,r1,r3
000016  6001              STR      r1,[r0,#0]
                  |L26.24|
;;;510        while(u8Xfering && (u8Err == 0))
;;;511        {
;;;512            I2C_WAIT_READY(i2c);
000018  6801              LDR      r1,[r0,#0]
00001a  0709              LSLS     r1,r1,#28
00001c  d5fc              BPL      |L26.24|
;;;513            switch(I2C_GET_STATUS(i2c))
00001e  68c1              LDR      r1,[r0,#0xc]
000020  2920              CMP      r1,#0x20
000022  d007              BEQ      |L26.52|
000024  dc04              BGT      |L26.48|
000026  2908              CMP      r1,#8
000028  d007              BEQ      |L26.58|
00002a  2918              CMP      r1,#0x18
00002c  d102              BNE      |L26.52|
00002e  e008              B        |L26.66|
                  |L26.48|
000030  2928              CMP      r1,#0x28
000032  d009              BEQ      |L26.72|
                  |L26.52|
;;;514            {
;;;515                case 0x08:
;;;516                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));    /* Send Slave address with write bit */
;;;517                    u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;518                    break;
;;;519                case 0x18:                                           /* Slave Address ACK */
;;;520                    I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
;;;521                    break;
;;;522                case 0x20:                                           /* Slave Address NACK */
;;;523                case 0x30:                                           /* Master transmit data NACK */
;;;524                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
000034  2418              MOVS     r4,#0x18
;;;525                    u8Err = 1;
000036  2501              MOVS     r5,#1
;;;526                    break;
000038  e00a              B        |L26.80|
                  |L26.58|
00003a  0051              LSLS     r1,r2,#1              ;516
00003c  6081              STR      r1,[r0,#8]            ;516
00003e  2408              MOVS     r4,#8                 ;517
000040  e006              B        |L26.80|
                  |L26.66|
000042  4661              MOV      r1,r12                ;520
000044  6081              STR      r1,[r0,#8]            ;520
000046  e003              B        |L26.80|
                  |L26.72|
;;;527                case 0x28:
;;;528                    if(u32txLen < 1)
000048  2f00              CMP      r7,#0
00004a  d00d              BEQ      |L26.104|
;;;529                    {
;;;530                        I2C_SET_DATA(i2c, data);
;;;531                        u32txLen++;
;;;532                    }
;;;533                    else
;;;534                    {
;;;535                        u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
00004c  2418              MOVS     r4,#0x18
;;;536                        u8Xfering = 0;
00004e  2600              MOVS     r6,#0
                  |L26.80|
;;;537                    }
;;;538                    break;
;;;539                case 0x38:                                           /* Arbitration Lost */
;;;540                default:                                             /* Unknow status */
;;;541                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;542                    u8Err = 1;
;;;543                    break;
;;;544            }
;;;545            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
000050  6801              LDR      r1,[r0,#0]
000052  233c              MOVS     r3,#0x3c
000054  4399              BICS     r1,r1,r3
000056  4321              ORRS     r1,r1,r4
000058  6001              STR      r1,[r0,#0]
00005a  2e00              CMP      r6,#0                 ;510
00005c  d001              BEQ      |L26.98|
00005e  2d00              CMP      r5,#0                 ;510
000060  d0da              BEQ      |L26.24|
                  |L26.98|
000062  4628              MOV      r0,r5                 ;510
;;;546        }
;;;547        return (u8Err | u8Xfering);                                  /* return (Success)/(Fail) status */
000064  4330              ORRS     r0,r0,r6
;;;548    }
000066  bdf0              POP      {r4-r7,pc}
                  |L26.104|
000068  4671              MOV      r1,lr                 ;530
00006a  6081              STR      r1,[r0,#8]            ;530
00006c  2701              MOVS     r7,#1                 ;531
00006e  e7ef              B        |L26.80|
;;;549    
                          ENDP


                          AREA ||i.I2C_WriteByteTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_WriteByteTwoRegs PROC
;;;624    
;;;625    uint8_t I2C_WriteByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, const uint8_t data)
000000  b5ff              PUSH     {r0-r7,lr}
;;;626    {
;;;627        uint8_t u8Xfering = 1, u8Err = 0, u8Addr = 1, u8Ctrl = 0;
000002  2501              MOVS     r5,#1
000004  468e              MOV      lr,r1                 ;626
000006  2400              MOVS     r4,#0
;;;628        uint32_t u32txLen = 0;
;;;629    
;;;630        I2C_START(i2c);                                                         /* Send START */
000008  6801              LDR      r1,[r0,#0]
00000a  4694              MOV      r12,r2                ;626
00000c  462f              MOV      r7,r5                 ;627
00000e  4623              MOV      r3,r4                 ;627
000010  4626              MOV      r6,r4                 ;628
000012  2228              MOVS     r2,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
                  |L27.24|
;;;631        while(u8Xfering && (u8Err == 0))
;;;632        {
;;;633            I2C_WAIT_READY(i2c);
000018  6802              LDR      r2,[r0,#0]
00001a  0712              LSLS     r2,r2,#28
00001c  d5fc              BPL      |L27.24|
;;;634            switch(I2C_GET_STATUS(i2c))
00001e  68c2              LDR      r2,[r0,#0xc]
000020  2a20              CMP      r2,#0x20
000022  d007              BEQ      |L27.52|
000024  dc04              BGT      |L27.48|
000026  2a08              CMP      r2,#8
000028  d007              BEQ      |L27.58|
00002a  2a18              CMP      r2,#0x18
00002c  d102              BNE      |L27.52|
00002e  e009              B        |L27.68|
                  |L27.48|
000030  2a28              CMP      r2,#0x28
000032  d00b              BEQ      |L27.76|
                  |L27.52|
;;;635            {
;;;636                case 0x08:
;;;637                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));               /* Write SLA+W to Register I2CDAT */
;;;638                    u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;639                    break;
;;;640                case 0x18:                                                      /* Slave Address ACK */
;;;641                    I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00) >> 8));    /* Write Hi byte address of register */
;;;642                    break;
;;;643                case 0x20:                                                      /* Slave Address NACK */
;;;644                case 0x30:                                                      /* Master transmit data NACK */
;;;645                    u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
000034  2318              MOVS     r3,#0x18
;;;646                    u8Err = 1;
000036  2401              MOVS     r4,#1
;;;647                    break;
000038  e013              B        |L27.98|
                  |L27.58|
00003a  4671              MOV      r1,lr                 ;637
00003c  0049              LSLS     r1,r1,#1              ;637
00003e  6081              STR      r1,[r0,#8]            ;637
000040  2308              MOVS     r3,#8                 ;638
000042  e00e              B        |L27.98|
                  |L27.68|
000044  4661              MOV      r1,r12                ;641
000046  0a0a              LSRS     r2,r1,#8              ;641
000048  6082              STR      r2,[r0,#8]            ;641
00004a  e00a              B        |L27.98|
                  |L27.76|
;;;648                case 0x28:
;;;649                    if(u8Addr)
00004c  2f00              CMP      r7,#0
00004e  d004              BEQ      |L27.90|
;;;650                    {
;;;651                        I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF));       /* Write Lo byte address of register */
000050  4661              MOV      r1,r12
000052  b2c9              UXTB     r1,r1
000054  6081              STR      r1,[r0,#8]
;;;652                        u8Addr = 0;
000056  2700              MOVS     r7,#0
000058  e003              B        |L27.98|
                  |L27.90|
;;;653                    }
;;;654                    else if((u32txLen < 1) && (u8Addr == 0))
00005a  2e00              CMP      r6,#0
00005c  d00f              BEQ      |L27.126|
;;;655                    {
;;;656                        I2C_SET_DATA(i2c, data);
;;;657                        u32txLen++;
;;;658                    }
;;;659                    else
;;;660                    {
;;;661                        u8Ctrl = I2C_CTL_STO_SI;                              /* Clear SI and send STOP */
00005e  2318              MOVS     r3,#0x18
;;;662                        u8Xfering = 0;
000060  2500              MOVS     r5,#0
                  |L27.98|
;;;663                    }
;;;664                    break;
;;;665                case 0x38:                                                      /* Arbitration Lost */
;;;666                default:                                                        /* Unknow status */
;;;667                    u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;668                    u8Err = 1;
;;;669                    break;
;;;670            }
;;;671            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
000062  6801              LDR      r1,[r0,#0]
000064  223c              MOVS     r2,#0x3c
000066  4391              BICS     r1,r1,r2
000068  460a              MOV      r2,r1
00006a  431a              ORRS     r2,r2,r3
00006c  6002              STR      r2,[r0,#0]
00006e  2d00              CMP      r5,#0                 ;631
000070  d001              BEQ      |L27.118|
000072  2c00              CMP      r4,#0                 ;631
000074  d0d0              BEQ      |L27.24|
                  |L27.118|
000076  4620              MOV      r0,r4                 ;631
;;;672        }
;;;673        return (u8Err | u8Xfering);                                             /* return (Success)/(Fail) status */
000078  4328              ORRS     r0,r0,r5
;;;674    }
00007a  b004              ADD      sp,sp,#0x10
00007c  bdf0              POP      {r4-r7,pc}
                  |L27.126|
00007e  9903              LDR      r1,[sp,#0xc]          ;656
000080  6081              STR      r1,[r0,#8]            ;656
000082  2601              MOVS     r6,#1                 ;657
000084  e7ed              B        |L27.98|
;;;675    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytes||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytes PROC
;;;447    
;;;448    uint32_t I2C_WriteMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, const uint8_t *data, uint32_t u32wLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;449    {
000002  4694              MOV      r12,r2
;;;450        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000004  2701              MOVS     r7,#1
000006  460a              MOV      r2,r1                 ;449
000008  2600              MOVS     r6,#0
;;;451        uint32_t u32txLen = 0;
;;;452    
;;;453        I2C_START(i2c);                                              /* Send START */
00000a  6801              LDR      r1,[r0,#0]
00000c  469e              MOV      lr,r3                 ;449
00000e  4634              MOV      r4,r6                 ;450
000010  4635              MOV      r5,r6                 ;451
000012  2328              MOVS     r3,#0x28
000014  4319              ORRS     r1,r1,r3
000016  6001              STR      r1,[r0,#0]
                  |L28.24|
;;;454        while(u8Xfering && (u8Err == 0))
;;;455        {
;;;456            I2C_WAIT_READY(i2c);
000018  6801              LDR      r1,[r0,#0]
00001a  0709              LSLS     r1,r1,#28
00001c  d5fc              BPL      |L28.24|
;;;457            switch(I2C_GET_STATUS(i2c))
00001e  68c1              LDR      r1,[r0,#0xc]
000020  2920              CMP      r1,#0x20
000022  d007              BEQ      |L28.52|
000024  dc04              BGT      |L28.48|
000026  2908              CMP      r1,#8
000028  d011              BEQ      |L28.78|
00002a  2918              CMP      r1,#0x18
00002c  d102              BNE      |L28.52|
00002e  e012              B        |L28.86|
                  |L28.48|
000030  2928              CMP      r1,#0x28
000032  d010              BEQ      |L28.86|
                  |L28.52|
;;;458            {
;;;459                case 0x08:
;;;460                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));    /* Write SLA+W to Register I2CDAT */
;;;461                    u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;462                    break;
;;;463                case 0x18:                                           /* Slave Address ACK */
;;;464                case 0x28:
;;;465                    if(u32txLen < u32wLen)
;;;466                        I2C_SET_DATA(i2c, data[u32txLen++]);                /* Write Data to I2CDAT */
;;;467                    else
;;;468                    {
;;;469                        u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;470                        u8Xfering = 0;
;;;471                    }
;;;472                    break;
;;;473                case 0x20:                                           /* Slave Address NACK */
;;;474                case 0x30:                                           /* Master transmit data NACK */
;;;475                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
000034  2418              MOVS     r4,#0x18
;;;476                    u8Err = 1;
000036  2601              MOVS     r6,#1
                  |L28.56|
;;;477                    break;
;;;478                case 0x38:                                           /* Arbitration Lost */
;;;479                default:                                             /* Unknow status */
;;;480                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;481                    u8Err = 1;
;;;482                    break;
;;;483            }
;;;484            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
000038  6801              LDR      r1,[r0,#0]
00003a  233c              MOVS     r3,#0x3c
00003c  4399              BICS     r1,r1,r3
00003e  4321              ORRS     r1,r1,r4
000040  6001              STR      r1,[r0,#0]
000042  2f00              CMP      r7,#0                 ;454
000044  d001              BEQ      |L28.74|
000046  2e00              CMP      r6,#0                 ;454
000048  d0e6              BEQ      |L28.24|
                  |L28.74|
;;;485        }
;;;486        return u32txLen;                                             /* Return bytes length that have been transmitted */
00004a  4628              MOV      r0,r5
;;;487    }
00004c  bdf0              POP      {r4-r7,pc}
                  |L28.78|
00004e  0051              LSLS     r1,r2,#1              ;460
000050  6081              STR      r1,[r0,#8]            ;460
000052  2408              MOVS     r4,#8                 ;461
000054  e7f0              B        |L28.56|
                  |L28.86|
000056  4575              CMP      r5,lr                 ;465
000058  d204              BCS      |L28.100|
00005a  4661              MOV      r1,r12                ;466
00005c  5d49              LDRB     r1,[r1,r5]            ;466
00005e  6081              STR      r1,[r0,#8]            ;466
000060  1c6d              ADDS     r5,r5,#1              ;466
000062  e7e9              B        |L28.56|
                  |L28.100|
000064  2418              MOVS     r4,#0x18              ;469
000066  2700              MOVS     r7,#0                 ;470
000068  e7e6              B        |L28.56|
;;;488    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytesOneReg PROC
;;;565    
;;;566    uint32_t I2C_WriteMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, const uint8_t *data, uint32_t u32wLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;567    {
;;;568        uint8_t u8Xfering = 1, u8Err = 0, u8Ctrl = 0;
000002  2701              MOVS     r7,#1
000004  468c              MOV      r12,r1                ;567
000006  2600              MOVS     r6,#0
;;;569        uint32_t u32txLen = 0;
;;;570    
;;;571        I2C_START(i2c);                                              /* Send START */
000008  6801              LDR      r1,[r0,#0]
00000a  469e              MOV      lr,r3                 ;567
00000c  4634              MOV      r4,r6                 ;568
00000e  4635              MOV      r5,r6                 ;569
000010  2328              MOVS     r3,#0x28
000012  4319              ORRS     r1,r1,r3
000014  6001              STR      r1,[r0,#0]
                  |L29.22|
;;;572        while(u8Xfering && (u8Err == 0))
;;;573        {
;;;574            I2C_WAIT_READY(i2c);
000016  6801              LDR      r1,[r0,#0]
000018  0709              LSLS     r1,r1,#28
00001a  d5fc              BPL      |L29.22|
;;;575            switch(I2C_GET_STATUS(i2c))
00001c  68c1              LDR      r1,[r0,#0xc]
00001e  2920              CMP      r1,#0x20
000020  d007              BEQ      |L29.50|
000022  dc04              BGT      |L29.46|
000024  2908              CMP      r1,#8
000026  d007              BEQ      |L29.56|
000028  2918              CMP      r1,#0x18
00002a  d102              BNE      |L29.50|
00002c  e009              B        |L29.66|
                  |L29.46|
00002e  2928              CMP      r1,#0x28
000030  d009              BEQ      |L29.70|
                  |L29.50|
;;;576            {
;;;577                case 0x08:
;;;578                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));    /* Write SLA+W to Register I2CDAT */
;;;579                    u8Ctrl = I2C_CTL_SI;
;;;580                    break;
;;;581                case 0x18:                                           /* Slave Address ACK */
;;;582                    I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
;;;583                    break;
;;;584                case 0x20:                                           /* Slave Address NACK */
;;;585                case 0x30:                                           /* Master transmit data NACK */
;;;586                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
000032  2418              MOVS     r4,#0x18
;;;587                    u8Err = 1;
000034  2601              MOVS     r6,#1
;;;588                    break;
000036  e010              B        |L29.90|
                  |L29.56|
000038  4661              MOV      r1,r12                ;578
00003a  0049              LSLS     r1,r1,#1              ;578
00003c  6081              STR      r1,[r0,#8]            ;578
00003e  2408              MOVS     r4,#8                 ;579
000040  e00b              B        |L29.90|
                  |L29.66|
000042  6082              STR      r2,[r0,#8]            ;582
000044  e009              B        |L29.90|
                  |L29.70|
;;;589                case 0x28:
;;;590                    if(u32txLen < u32wLen)
000046  9905              LDR      r1,[sp,#0x14]
000048  428d              CMP      r5,r1
00004a  d204              BCS      |L29.86|
;;;591                        I2C_SET_DATA(i2c, data[u32txLen++]);
00004c  4673              MOV      r3,lr
00004e  5d59              LDRB     r1,[r3,r5]
000050  6081              STR      r1,[r0,#8]
000052  1c6d              ADDS     r5,r5,#1
000054  e001              B        |L29.90|
                  |L29.86|
;;;592                    else
;;;593                    {
;;;594                        u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
000056  2418              MOVS     r4,#0x18
;;;595                        u8Xfering = 0;
000058  2700              MOVS     r7,#0
                  |L29.90|
;;;596                    }
;;;597                    break;
;;;598                case 0x38:                                           /* Arbitration Lost */
;;;599                default:                                             /* Unknow status */
;;;600                    u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;601                    u8Err = 1;
;;;602                    break;
;;;603            }
;;;604            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                        /* Write controlbit to I2C_CTL register */
00005a  6801              LDR      r1,[r0,#0]
00005c  233c              MOVS     r3,#0x3c
00005e  4399              BICS     r1,r1,r3
000060  4321              ORRS     r1,r1,r4
000062  6001              STR      r1,[r0,#0]
000064  2f00              CMP      r7,#0                 ;572
000066  d001              BEQ      |L29.108|
000068  2e00              CMP      r6,#0                 ;572
00006a  d0d4              BEQ      |L29.22|
                  |L29.108|
;;;605        }
;;;606    
;;;607        return u32txLen;                                             /* Return bytes length that have been transmitted */
00006c  4628              MOV      r0,r5
;;;608    }
00006e  bdf0              POP      {r4-r7,pc}
;;;609    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytesTwoRegs PROC
;;;691    
;;;692    uint32_t I2C_WriteMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, const uint8_t *data, uint32_t u32wLen)
000000  b5ff              PUSH     {r0-r7,lr}
;;;693    {
;;;694        uint8_t u8Xfering = 1, u8Err = 0, u8Addr = 1, u8Ctrl = 0;
000002  2701              MOVS     r7,#1
000004  468c              MOV      r12,r1                ;693
000006  2500              MOVS     r5,#0
;;;695        uint32_t u32txLen = 0;
;;;696    
;;;697        I2C_START(i2c);                                                         /* Send START */
000008  6801              LDR      r1,[r0,#0]
00000a  4696              MOV      lr,r2                 ;693
00000c  463e              MOV      r6,r7                 ;694
00000e  462b              MOV      r3,r5                 ;694
000010  462c              MOV      r4,r5                 ;695
000012  2228              MOVS     r2,#0x28
000014  4311              ORRS     r1,r1,r2
000016  6001              STR      r1,[r0,#0]
                  |L30.24|
;;;698        while(u8Xfering && (u8Err == 0))
;;;699        {
;;;700            I2C_WAIT_READY(i2c);
000018  6801              LDR      r1,[r0,#0]
00001a  0709              LSLS     r1,r1,#28
00001c  d5fc              BPL      |L30.24|
;;;701            switch(I2C_GET_STATUS(i2c))
00001e  68c1              LDR      r1,[r0,#0xc]
000020  2920              CMP      r1,#0x20
000022  d007              BEQ      |L30.52|
000024  dc04              BGT      |L30.48|
000026  2908              CMP      r1,#8
000028  d007              BEQ      |L30.58|
00002a  2918              CMP      r1,#0x18
00002c  d102              BNE      |L30.52|
00002e  e009              B        |L30.68|
                  |L30.48|
000030  2928              CMP      r1,#0x28
000032  d00a              BEQ      |L30.74|
                  |L30.52|
;;;702            {
;;;703                case 0x08:
;;;704                    I2C_SET_DATA(i2c, (u8SlaveAddr << 1 | 0x00));               /* Write SLA+W to Register I2CDAT */
;;;705                    u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;706                    break;
;;;707                case 0x18:                                                      /* Slave Address ACK */
;;;708                    I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF00) >> 8);    /* Write Hi byte address of register */
;;;709                    break;
;;;710                case 0x20:                                                      /* Slave Address NACK */
;;;711                case 0x30:                                                      /* Master transmit data NACK */
;;;712                    u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
000034  2318              MOVS     r3,#0x18
;;;713                    u8Err = 1;
000036  2501              MOVS     r5,#1
;;;714                    break;
000038  e018              B        |L30.108|
                  |L30.58|
00003a  4661              MOV      r1,r12                ;704
00003c  0049              LSLS     r1,r1,#1              ;704
00003e  6081              STR      r1,[r0,#8]            ;704
000040  2308              MOVS     r3,#8                 ;705
000042  e013              B        |L30.108|
                  |L30.68|
000044  2100              MOVS     r1,#0                 ;708
000046  6081              STR      r1,[r0,#8]            ;708
000048  e010              B        |L30.108|
                  |L30.74|
;;;715                case 0x28:
;;;716                    if(u8Addr)
00004a  2e00              CMP      r6,#0
00004c  d004              BEQ      |L30.88|
;;;717                    {
;;;718                        I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFF));       /* Write Lo byte address of register */
00004e  4671              MOV      r1,lr
000050  b2c9              UXTB     r1,r1
000052  6081              STR      r1,[r0,#8]
;;;719                        u8Addr = 0;
000054  2600              MOVS     r6,#0
000056  e009              B        |L30.108|
                  |L30.88|
;;;720                    }
;;;721                    else if((u32txLen < u32wLen) && (u8Addr == 0))
000058  9909              LDR      r1,[sp,#0x24]
00005a  428c              CMP      r4,r1
00005c  d204              BCS      |L30.104|
;;;722                        I2C_SET_DATA(i2c, data[u32txLen++]);                           /* Write data to Register I2CDAT*/
00005e  9903              LDR      r1,[sp,#0xc]
000060  5d09              LDRB     r1,[r1,r4]
000062  6081              STR      r1,[r0,#8]
000064  1c64              ADDS     r4,r4,#1
000066  e001              B        |L30.108|
                  |L30.104|
;;;723                    else
;;;724                    {
;;;725                        u8Ctrl = I2C_CTL_STO_SI;                              /* Clear SI and send STOP */
000068  2318              MOVS     r3,#0x18
;;;726                        u8Xfering = 0;
00006a  2700              MOVS     r7,#0
                  |L30.108|
;;;727                    }
;;;728                    break;
;;;729                case 0x38:                                                      /* Arbitration Lost */
;;;730                default:                                                        /* Unknow status */
;;;731                    u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;732                    u8Err = 1;
;;;733                    break;
;;;734            }
;;;735            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                                   /* Write controlbit to I2C_CTL register */
00006c  6801              LDR      r1,[r0,#0]
00006e  223c              MOVS     r2,#0x3c
000070  4391              BICS     r1,r1,r2
000072  4319              ORRS     r1,r1,r3
000074  6001              STR      r1,[r0,#0]
000076  2f00              CMP      r7,#0                 ;698
000078  d001              BEQ      |L30.126|
00007a  2d00              CMP      r5,#0                 ;698
00007c  d0cc              BEQ      |L30.24|
                  |L30.126|
;;;736        }
;;;737        return u32txLen;                                                        /* Return bytes length that have been transmitted */
00007e  4620              MOV      r0,r4
;;;738    }
000080  b004              ADD      sp,sp,#0x10
000082  bdf0              POP      {r4-r7,pc}
;;;739    
                          ENDP


                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L187.16|
00000e  461d              MOV      r5,r3
                  |L187.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\lib\\StdDriver\\src\\i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REV16|
#line 388 "..\\lib\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_i2c_c_I2C_Open____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REVSH|
#line 402
|__asm___5_i2c_c_I2C_Open____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
