L 1 "..\src\io\io_gpio.c"
N/****************************************************************************
N * @file     gpio.c
N * @version  V1.15
N * @Date     2019/06/05-17:08:19 
N * @author   Aaron.Shao
N * @brief    gpio config file
N *
N * Copyright (C) 2019 Tymphnay.
N*****************************************************************************/
N#include "stdio.h"
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060019
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 11 "..\src\io\io_gpio.c" 2
N#include "NUC029xGE.h"
L 1 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 1
N/**************************************************************************//**
N * @file     NUC029xGE.h
N * @version  V3.0
N * $Revision: 39 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE Series Peripheral Access Layer Header File
N *
N * @note
N * Copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N
N/**
N  \mainpage Introduction
N  *
N  *
N  * This user manual describes the usage of NUC029xGE MCU device driver
N  *
N  * <b>Disclaimer</b>
N  *
N  * The Software is furnished "AS IS", without warranty as to performance or results, and
N  * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N  * warranties, express, implied or otherwise, with regard to the Software, its use, or
N  * operation, including without limitation any and all warranties of merchantability, fitness
N  * for a particular purpose, and non-infringement of intellectual property rights.
N  *
N  * <b>Copyright Notice</b>
N  *
N  * Copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N  */
N
N#ifndef __NUC029xGE_H__
N#define __NUC029xGE_H__
N
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N */
N
N/**
N * @details  Interrupt Number Definition. The maximum of 32 Specific Interrupts are possible.
N */
Ntypedef enum IRQn
N{
N    /******  Cortex-M0 Processor Exceptions Numbers ***************************************************/
N    NonMaskableInt_IRQn       = -14,      /*!< 2 Non Maskable Interrupt                             */
N    HardFault_IRQn            = -13,      /*!< 3 Cortex-M0 Hard Fault Interrupt                     */
N    SVCall_IRQn               = -5,       /*!< 11 Cortex-M0 SV Call Interrupt                       */
N    PendSV_IRQn               = -2,       /*!< 14 Cortex-M0 Pend SV Interrupt                       */
N    SysTick_IRQn              = -1,       /*!< 15 Cortex-M0 System Tick Interrupt                   */
N
N    /******  ARMIKMCU Swift specific Interrupt Numbers ************************************************/
N    BOD_IRQn                  = 0,        /*!< Brown-Out Low Voltage Detected Interrupt             */
N    WDT_IRQn                  = 1,        /*!< Watch Dog Timer Interrupt                            */
N    EINT024_IRQn              = 2,        /*!< EINT0, EINT2 and EINT4 Interrupt                     */
N    EINT135_IRQn              = 3,        /*!< EINT1, EINT3 and EINT5 Interrupt                     */
N    GPAB_IRQn                 = 4,        /*!< GPIO_PA/PB Interrupt                                 */
N    GPCDEF_IRQn               = 5,        /*!< GPIO_PC/PD/PE/PF Interrupt                           */
N    PWM0_IRQn                 = 6,        /*!< PWM0 Interrupt                                       */
N    PWM1_IRQn                 = 7,        /*!< PWM1 Interrupt                                       */
N    TMR0_IRQn                 = 8,        /*!< TIMER0 Interrupt                                     */
N    TMR1_IRQn                 = 9,        /*!< TIMER1 Interrupt                                     */
N    TMR2_IRQn                 = 10,       /*!< TIMER2 Interrupt                                     */
N    TMR3_IRQn                 = 11,       /*!< TIMER3 Interrupt                                     */
N    UART02_IRQn               = 12,       /*!< UART0 and UART2 Interrupt                            */
N    UART1_IRQn                = 13,       /*!< UART1 Interrupt                                      */
N    SPI0_IRQn                 = 14,       /*!< SPI0 Interrupt                                       */
N    SPI1_IRQn                 = 15,       /*!< SPI1 Interrupt                                       */
N    I2C0_IRQn                 = 18,       /*!< I2C0 Interrupt                                       */
N    I2C1_IRQn                 = 19,       /*!< I2C1 Interrupt                                       */
N    USCI_IRQn                 = 22,       /*!< USCI0, USCI1 and USCI2 interrupt                     */
N    USBD_IRQn                 = 23,       /*!< USB Device Interrupt                                 */
N    SC01_IRQn                 = 24,       /*!< SC0 and SC1 Interrupt                                */
N    ACMP01_IRQn               = 25,       /*!< ACMP0/1 Interrupt                                    */
N    PDMA_IRQn                 = 26,       /*!< PDMA Interrupt                                       */
N    PWRWU_IRQn                = 28,       /*!< Power Down Wake Up Interrupt                         */
N    ADC_IRQn                  = 29,       /*!< ADC Interrupt                                        */
N    CLKDIRC_IRQn              = 30,       /*!< Clock fail detect and IRC TRIM Interrupt             */
N    RTC_IRQn                  = 31        /*!< Real Time Clock Interrupt                            */
N
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M0 Processor and Core Peripherals */
N#define __MPU_PRESENT           0       /*!< armikcmu does not provide a MPU present or not       */
N#define __NVIC_PRIO_BITS        2       /*!< armikcmu Supports 2 Bits for the Priority Levels     */
N#define __Vendor_SysTickConfig  0       /*!< Set to 1 if different SysTick Config is used         */
N
N
N#include "core_cm0.h"                   /*!< Cortex-M0 processor and core peripherals             */
L 1 "..\lib\CMSIS\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S#pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S#pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 45 "..\lib\CMSIS\Include\core_cm0.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M0
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CMSIS HAL main version */
N#define __CM0_CMSIS_VERSION_SUB   (0x1EU)                                      /*!< [15:0]  CMSIS HAL sub version */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM0_CMSIS_VERSION_SUB           )        /*!< CMSIS HAL version number */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) |                                     __CM0_CMSIS_VERSION_SUB           )         
N
N#define __CORTEX_M                (0x00U)                                      /*!< Cortex-M Core */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N#define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
N#define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
N#define __STATIC_INLINE  static __inline
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S#define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S#define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S#define __STATIC_INLINE  static __inline
S
S#elif defined ( __GNUC__ )
S#define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
S#define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
S#define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S#define __ASM            __asm                                      /*!< asm keyword for IAR Compiler */
S#define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S#define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S#define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler */
S#define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S#define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler */
S#define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler */
S#define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S#define __packed
S#define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler */
S#define __INLINE         inline                                    /*!< inline keyword for COSMIC Compiler. Use -pc99 on compile line */
S#define __STATIC_INLINE  static inline
S
S#else
S#error Unknown compiler
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N#if defined __TARGET_FPU_VFP
X#if 0L
S#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N#endif
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S#if defined __ARM_PCS_VFP
S#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S#endif
S
S#elif defined ( __GNUC__ )
S#if defined (__VFP_FP__) && !defined(__SOFTFP__)
S#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S#endif
S
S#elif defined ( __ICCARM__ )
S#if defined __ARMVFP__
S#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S#endif
S
S#elif defined ( __TMS470__ )
S#if defined __TI_VFP_SUPPORT__
S#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S#endif
S
S#elif defined ( __TASKING__ )
S#if defined __FPU_VFP__
S#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S#endif
S
S#elif defined ( __CSMC__ )
S#if ( __CSMC__ & 0x400U)
S#error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S#endif
S
N#endif
N
N#include "core_cmInstr.h"                /* Core Instruction Access */
L 1 "..\lib\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S#pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S#pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N#include "cmsis_armcc.h"
L 1 "..\lib\CMSIS\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS Cortex-M Core Function/Instruction Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060422 < 400677)
S#error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N    register uint32_t __regControl         __ASM("control");
X    register uint32_t __regControl         __asm("control");
N    return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N    register uint32_t __regControl         __ASM("control");
X    register uint32_t __regControl         __asm("control");
N    __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N    register uint32_t __regIPSR          __ASM("ipsr");
X    register uint32_t __regIPSR          __asm("ipsr");
N    return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N    register uint32_t __regAPSR          __ASM("apsr");
X    register uint32_t __regAPSR          __asm("apsr");
N    return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N    register uint32_t __regXPSR          __ASM("xpsr");
X    register uint32_t __regXPSR          __asm("xpsr");
N    return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N    register uint32_t __regProcessStackPointer  __ASM("psp");
X    register uint32_t __regProcessStackPointer  __asm("psp");
N    return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N    register uint32_t __regProcessStackPointer  __ASM("psp");
X    register uint32_t __regProcessStackPointer  __asm("psp");
N    __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N    register uint32_t __regMainStackPointer     __ASM("msp");
X    register uint32_t __regMainStackPointer     __asm("msp");
N    return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N    register uint32_t __regMainStackPointer     __ASM("msp");
X    register uint32_t __regMainStackPointer     __asm("msp");
N    __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N    register uint32_t __regPriMask         __ASM("primask");
X    register uint32_t __regPriMask         __asm("primask");
N    return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N    register uint32_t __regPriMask         __ASM("primask");
X    register uint32_t __regPriMask         __asm("primask");
N    __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x00U) >= 0x03U) || (__CORTEX_SC >= 300U)
S
S/**
S  \brief   Enable FIQ
S  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/**
S  \brief   Disable FIQ
S  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/**
S  \brief   Get Base Priority
S  \details Returns the current value of the Base Priority register.
S  \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S    register uint32_t __regBasePri         __ASM("basepri");
S    return(__regBasePri);
S}
S
S
S/**
S  \brief   Set Base Priority
S  \details Assigns the given value to the Base Priority register.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S    register uint32_t __regBasePri         __ASM("basepri");
S    __regBasePri = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Set Base Priority with condition
S  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S           or the new value increases the BASEPRI priority level.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
S{
S    register uint32_t __regBasePriMax      __ASM("basepri_max");
S    __regBasePriMax = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Get Fault Mask
S  \details Returns the current value of the Fault Mask register.
S  \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S    register uint32_t __regFaultMask       __ASM("faultmask");
S    return(__regFaultMask);
S}
S
S
S/**
S  \brief   Set Fault Mask
S  \details Assigns the given value to the Fault Mask register.
S  \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S    register uint32_t __regFaultMask       __ASM("faultmask");
S    __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N
N#if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
X#if       ((0x00U) == 0x04U) || ((0x00U) == 0x07U)
S
S/**
S  \brief   Get FPSCR
S  \details Returns the current value of the Floating Point Status/Control register.
S  \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
S    register uint32_t __regfpscr         __ASM("fpscr");
S    return(__regfpscr);
S#else
S    return(0U);
S#endif
S}
S
S
S/**
S  \brief   Set FPSCR
S  \details Assigns the given value to the Floating Point Status/Control register.
S  \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
S    register uint32_t __regfpscr         __ASM("fpscr");
S    __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N    rev16 r0, r0
N    bx lr
N}
N#endif
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N    revsh r0, r0
N    bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    value  Value to rotate
N  \param [in]    value  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x00U) >= 0x03U) || (__CORTEX_SC >= 300U)
S#define __RBIT                          __rbit
N#else
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
X__attribute__((always_inline)) static __inline uint32_t __RBIT(uint32_t value)
N{
N    uint32_t result;
N    int32_t s = 4 /*sizeof(v)*/ * 8 - 1; /* extra shift needed at end */
N
N    result = value;                      /* r will be reversed bits of v; first get LSB of v */
N    for(value >>= 1U; value; value >>= 1U)
N    {
N        result <<= 1U;
N        result |= value & 1U;
N        s--;
N    }
N    result <<= s;                        /* shift when v's highest bits are zero */
N    return(result);
N}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x00U) >= 0x03U) || (__CORTEX_SC >= 300U)
S
S/**
S  \brief   LDR Exclusive (8 bit)
S  \details Executes a exclusive LDR instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S#define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
S#else
S#define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (16 bit)
S  \details Executes a exclusive LDR instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S#define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
S#else
S#define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (32 bit)
S  \details Executes a exclusive LDR instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S#define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
S#else
S#define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (8 bit)
S  \details Executes a exclusive STR instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S#define __STREXB(value, ptr)                                                 __strex(value, ptr)
S#else
S#define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (16 bit)
S  \details Executes a exclusive STR instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S#define __STREXH(value, ptr)                                                 __strex(value, ptr)
S#else
S#define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (32 bit)
S  \details Executes a exclusive STR instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S#define __STREXW(value, ptr)                                                 __strex(value, ptr)
S#else
S#define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   Remove the exclusive lock
S  \details Removes the exclusive lock which is created by LDREX.
S */
S#define __CLREX                           __clrex
S
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/**
S  \brief   Rotate Right with Extend (32 bit)
S  \details Moves each bit of a bitstring right by one bit.
S           The carry input is shifted in at the left end of the bitstring.
S  \param [in]    value  Value to rotate
S  \return               Rotated value
S */
S#ifndef __NO_EMBEDDED_ASM
S__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
S{
S    rrx r0, r0
S    bx lr
S}
S#endif
S
S
S/**
S  \brief   LDRT Unprivileged (8 bit)
S  \details Executes a Unprivileged LDRT instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (16 bit)
S  \details Executes a Unprivileged LDRT instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (32 bit)
S  \details Executes a Unprivileged LDRT instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
S
S
S/**
S  \brief   STRT Unprivileged (8 bit)
S  \details Executes a Unprivileged STRT instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRBT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (16 bit)
S  \details Executes a Unprivileged STRT instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRHT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (32 bit)
S  \details Executes a Unprivileged STRT instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRT(value, ptr)                __strt(value, ptr)
S
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if (__CORTEX_M >= 0x04U)  /* only for Cortex-M4 and above */
X#if ((0x00U) >= 0x04U)   
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* (__CORTEX_M >= 0x04) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 54 "..\lib\CMSIS\Include\core_cmInstr.h" 2
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S#include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S#include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S#include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S#include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S#include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 164 "..\lib\CMSIS\Include\core_cm0.h" 2
N#include "core_cmFunc.h"                 /* Core Function Access */
L 1 "..\lib\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S#pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S#pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N#include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S#include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S#include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S#include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S#include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S#include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 165 "..\lib\CMSIS\Include\core_cm0.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S#ifndef __CM0_REV
S#define __CM0_REV               0x0000U
S#warning "__CM0_REV not defined in device header file; using default!"
S#endif
S
S#ifndef __NVIC_PRIO_BITS
S#define __NVIC_PRIO_BITS          2U
S#warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S#endif
S
S#ifndef __Vendor_SysTickConfig
S#define __Vendor_SysTickConfig    0U
S#warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S#endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S#define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N#define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N    struct
N    {
N        uint32_t _reserved0: 28;             /*!< bit:  0..27  Reserved */
N        uint32_t V: 1;                       /*!< bit:     28  Overflow condition code flag */
N        uint32_t C: 1;                       /*!< bit:     29  Carry condition code flag */
N        uint32_t Z: 1;                       /*!< bit:     30  Zero condition code flag */
N        uint32_t N: 1;                       /*!< bit:     31  Negative condition code flag */
N    } b;                                   /*!< Structure used for bit  access */
N    uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N    struct
N    {
N        uint32_t ISR: 9;                     /*!< bit:  0.. 8  Exception number */
N        uint32_t _reserved0: 23;             /*!< bit:  9..31  Reserved */
N    } b;                                   /*!< Structure used for bit  access */
N    uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N    struct
N    {
N        uint32_t ISR: 9;                     /*!< bit:  0.. 8  Exception number */
N        uint32_t _reserved0: 15;             /*!< bit:  9..23  Reserved */
N        uint32_t T: 1;                       /*!< bit:     24  Thumb bit        (read 0) */
N        uint32_t _reserved1: 3;              /*!< bit: 25..27  Reserved */
N        uint32_t V: 1;                       /*!< bit:     28  Overflow condition code flag */
N        uint32_t C: 1;                       /*!< bit:     29  Carry condition code flag */
N        uint32_t Z: 1;                       /*!< bit:     30  Zero condition code flag */
N        uint32_t N: 1;                       /*!< bit:     31  Negative condition code flag */
N    } b;                                   /*!< Structure used for bit  access */
N    uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N    struct
N    {
N        uint32_t _reserved0: 1;              /*!< bit:      0  Reserved */
N        uint32_t SPSEL: 1;                   /*!< bit:      1  Stack to be used */
N        uint32_t _reserved1: 30;             /*!< bit:  2..31  Reserved */
N    } b;                                   /*!< Structure used for bit  access */
N    uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N    __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X    volatile uint32_t ISER[1U];                
N    uint32_t RESERVED0[31U];
N    __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X    volatile uint32_t ICER[1U];                
N    uint32_t RSERVED1[31U];
N    __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X    volatile uint32_t ISPR[1U];                
N    uint32_t RESERVED2[31U];
N    __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X    volatile uint32_t ICPR[1U];                
N    uint32_t RESERVED3[31U];
N    uint32_t RESERVED4[64U];
N    __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
X    volatile uint32_t IP[8U];                  
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N    __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X    volatile const  uint32_t CPUID;                   
N    __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X    volatile uint32_t ICSR;                    
N    uint32_t RESERVED0;
N    __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X    volatile uint32_t AIRCR;                   
N    __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X    volatile uint32_t SCR;                     
N    __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X    volatile uint32_t CCR;                     
N    uint32_t RESERVED1;
N    __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
X    volatile uint32_t SHP[2U];                 
N    __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X    volatile uint32_t SHCSR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N    __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X    volatile uint32_t CTRL;                    
N    __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X    volatile uint32_t LOAD;                    
N    __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X    volatile uint32_t VAL;                     
N    __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X    volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
N            Therefore they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
N#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
N#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
N
N
N/**
N  \brief   Enable External Interrupt
N  \details Enables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Disable External Interrupt
N  \details Disables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N    return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of an external interrupt.
N  \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N    NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of an external interrupt.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of an interrupt.
N  \note    The priority cannot be set for every core interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N    if((int32_t)(IRQn) < 0)
N    {
N        SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X        ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] = ((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N                                    (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X                                    (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N    }
N    else
N    {
N        NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X        ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  = ((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N                                    (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X                                    (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N    }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of an interrupt.
N           The interrupt number can be positive to specify an external (device specific) interrupt,
N           or negative to specify an internal (core) interrupt.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N    if((int32_t)(IRQn) < 0)
N    {
N        return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn)) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X        return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)) & (uint32_t)0xFFUL) >> (8U - 2)));
N    }
N    else
N    {
N        return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn)) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X        return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)) & (uint32_t)0xFFUL) >> (8U - 2)));
N    }
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N    __DSB();                                                          /* Ensure all outstanding memory accesses included
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N    SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FAUL << 16U) |
N                   SCB_AIRCR_SYSRESETREQ_Msk);
X                   (1UL << 2U));
N    __DSB();                                                          /* Ensure completion of memory access */
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N    for(;;)                                                           /* wait until reset */
N    {
N        __NOP();
X        __nop();
N    }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0U)
X#if (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N    if((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X    if((ticks - 1UL) > (0xFFFFFFUL ))
N    {
N        return (1UL);                                                   /* Reload value impossible */
N    }
N
N    SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N    NVIC_SetPriority(SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL);  /* set Priority for Systick Interrupt */
X    NVIC_SetPriority(SysTick_IRQn, (1UL << 2) - 1UL);   
N    SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N    SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                     SysTick_CTRL_TICKINT_Msk   |
X                     (1UL << 1U)   |
N                     SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                     (1UL );                          
N    return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 99 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "system_NUC029xGE.h"           /*!< NUC029xGE System                                    */
L 1 "..\lib\Device\Nuvoton\NUC029xGE\Include\system_NUC029xGE.h" 1
N/**************************************************************************//**
N * @file     system_NUC092xGE.h
N * @version  V3.00
N * $Revision: 5 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE Series System Setting Header File
N *
N * @note
N * Copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __SYSTEM_NUC029xGE_H__
N#define __SYSTEM_NUC029xGE_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro Definition                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#ifndef DEBUG_PORT
N# define DEBUG_PORT      UART2       /*!< Select Debug Port which is used for retarget.c to output debug message to UART */
N#endif
N
N/**
N *
N * @details    This is used to enable PLL to speed up booting at startup. Remove it will cause system using
N *             default clock source (External crystal or internal 22.1184MHz IRC).
N *             Enable this option will cause system booting in 72MHz(By XTAL) or 71.8848MHz(By IRC22M) according to
N *             user configuration setting in CONFIG0
N *
N */
N//#define INIT_SYSCLK_AT_BOOTING
N
N/*----------------------------------------------------------------------------
N  Define SYSCLK
N *----------------------------------------------------------------------------*/
N#define __HXT       (12000000UL)    /*!< External Crystal Clock Frequency     */
N#define __LIRC      (10000UL)       /*!< Internal 10K RC Oscillator Frequency */
N#define __HIRC      (22118400UL)    /*!< Internal 22M RC Oscillator Frequency */
N#define __LXT       (32768UL)       /*!< External Crystal Clock Frequency 32.768KHz */
N#define __HSI       (71884800UL)    /*!< PLL default output is 71.8848MHz from HIRC */
N#define __HIRC48    (48000000UL)    /*!< Internal high speed RC oscillator 48 MHz */
N
Nextern uint32_t SystemCoreClock;    /*!< System Clock Frequency (Core Clock)  */
Nextern uint32_t CyclesPerUs;        /*!< Cycles per micro second              */
Nextern uint32_t PllClock;           /*!< PLL Output Clock Frequency           */
N
N#if USE_ASSERT
S/**
S * @brief      Assert Function
S *
S * @param[in]  expr  Expression to be evaluated
S *
S * @return     None
S *
S * @details    If the expression is false, an error message will be printed out
S *             from debug port (UART0 or UART1).
S */
S#define ASSERT_PARAM(expr)  { if (!(expr)) { AssertError((uint8_t*)__FILE__, __LINE__); } }
S
Svoid AssertError(uint8_t* file, uint32_t line);
N#else
N#define ASSERT_PARAM(expr)
N#endif
N
N#define assert_param(expr)  ASSERT_PARAM(expr)
N
N
N/**
N * @brief    System Initialization
N *
N * @param    None
N *
N * @return   None
N *
N * @details  The necessary initialization of system.
N */
Nextern void SystemInit(void);
N
N
N/**
N * @brief    Update the Variable SystemCoreClock
N *
N * @param    None
N *
N * @return   None
N *
N * @details  This function is used to update the variable SystemCoreClock
N *           and must be called whenever the core clock is changed.
N */
Nextern void SystemCoreClockUpdate(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
N/* Copyright (C) 2018 Nuvoton Technology Corp. All rights reserved. */
L 100 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#endif
N
N
N/**
N * Initialize the system clock
N *
N * @param  None
N * @return None
N *
N * @brief  Setup the microcontroller system
N *         Initialize the PLL and update the SystemFrequency variable
N */
Nextern void SystemInit(void);
N
N
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N
N/** @addtogroup REGISTER Control Register
N
N  @{
N
N*/
N
N
N/*---------------------- Analog Comparator Controller -------------------------*/
N/**
N    @addtogroup ACMP Analog Comparator Controller(ACMP)
N    Memory Mapped Structure for ACMP Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var ACMP_T::CTL
N     * Offset: 0x00  Analog Comparator 0 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ACMPEN    |Comparator Enable Bit
N     * |        |          |0 = Comparator 0 Disabled.
N     * |        |          |1 = Comparator 0 Enabled.
N     * |[1]     |ACMPIE    |Comparator Interrupt Enable Bit
N     * |        |          |0 = Comparator 0 interrupt Disabled.
N     * |        |          |1 = Comparator 0 interrupt Enabled
N     * |        |          |If WKEN (ACMP_CTL0[16]) is set to 1, the wake-up interrupt function will be enabled as well.
N     * |[2]     |HYSEN     |Comparator Hysteresis Enable Bit
N     * |        |          |0 = Comparator 0 hysteresis Disabled.
N     * |        |          |1 = Comparator 0 hysteresis Enabled.
N     * |[3]     |ACMPOINV  |Comparator Output Inverse
N     * |        |          |0 = Comparator 0 output inverse Disabled.
N     * |        |          |1 = Comparator 0 output inverse Enabled.
N     * |[5:4]   |NEGSEL    |Comparator Negative Input Selection
N     * |        |          |00 = ACMP0_N pin.
N     * |        |          |01 = Internal comparator reference voltage (CRV).
N     * |        |          |10 = Band-gap voltage.
N     * |        |          |11 = ReservedGround.
N     * |[7:6]   |POSSEL    |Comparator Positive Input Selection
N     * |        |          |00 = Input from ACMP0_P0.
N     * |        |          |01 = Input from ACMP0_P1.
N     * |        |          |10 = Input from ACMP0_P2.
N     * |        |          |11 = Input from ACMP0_P3.
N     * |[9:8]   |INTPOL    |Interrupt Condition Polarity Selection
N     * |        |          |ACMPIF0 will be set to 1 when comparator output edge condition is detected.
N     * |        |          |00 = Rising edge or falling edge.
N     * |        |          |01 = Rising edge.
N     * |        |          |10 = Falling edge.
N     * |        |          |11 = Reserved.
N     * |[12]    |OUTSEL    |Comparator Output Selection
N     * |        |          |0 = Comparator 0 output to ACMP0_O pin is unfiltered comparator output.
N     * |        |          |1 = Comparator 0 output to ACMP0_O pin is from filter output.
N     * |[15:13] |FILTSEL   |Comparator Output Filter Count Selection
N     * |        |          |000 = Filter function is Disabled.
N     * |        |          |001 = ACMP output is sampled 1 consecutive PCLK.
N     * |        |          |010 = ACMP output is sampled 2 consecutive PCLKs.
N     * |        |          |011 = ACMP output is sampled 4 consecutive PCLKs.
N     * |        |          |100 = ACMP output is sampled 8 consecutive PCLKs.
N     * |        |          |101 = ACMP output is sampled 16 consecutive PCLKs.
N     * |        |          |110 = ACMP output is sampled 32 consecutive PCLKs.
N     * |        |          |111 = ACMP output is sampled 64 consecutive PCLKs.
N     * |[16]    |WKEN      |Power-down Wake-up Enable Bit
N     * |        |          |0 = Wake-up function Disabled.
N     * |        |          |1 = Wake-up function Enabled.
N     * |[17]    |WLATEN    |Window Mode SelectionLatch Function Enable Bit
N     * |        |          |0 = Window Latch Function Disabled.
N     * |        |          |1 = Window Latch Function Enabled.
N     * |[18]    |WCMPSEL   |Window Compare Mode Selection
N     * |        |          |0 = Window Compare Mode Disabled.
N     * |        |          |1 = Window Compare Mode is Selected.
N     * @var ACMP_T::STATUS
N     * Offset: 0x08  Analog Comparator Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ACMPIF0   |Comparator 0 Interrupt Flag
N     * |        |          |This bit is set by hardware when the edge condition defined by INTPOL (ACMP_CTL0[9:8]) is detected on comparator 0 output
N     * |        |          |This will generate an interrupt if ACMPIE (ACMP_CTL0[1]) is set to 1.
N     * |        |          |Note: Write 1 to clear this bit to 0.
N     * |[1]     |ACMPIF1   |Comparator 1 Interrupt Flag
N     * |        |          |This bit is set by hardware when the edge condition defined by INTPOL (ACMP_CTL1[9:8]) is detected on comparator 1 output
N     * |        |          |This will cause an interrupt if ACMPIE (ACMP_CTL1[1]) is set to 1.
N     * |        |          |Note: Write 1 to clear this bit to 0.
N     * |[4]     |ACMPO0    |Comparator 0 Output
N     * |        |          |Synchronized to the PCLK to allow reading by software
N     * |        |          |Cleared when the comparator 0 is disabled, i.e
N     * |        |          |ACMPEN (ACMP_CTL0[0]) is cleared to 0.
N     * |[5]     |ACMPO1    |Comparator 1 Output
N     * |        |          |Synchronized to the PCLK to allow reading by software
N     * |        |          |Cleared when the comparator 1 is disabled, i.e
N     * |        |          |ACMPEN (ACMP_CTL1[0]) is cleared to 0.
N     * |[8]     |WKIF0     |Comparator 0 Power-down Wake-up Interrupt Flag
N     * |        |          |This bit will be set to 1 when ACMP0 wake-up interrupt event occurs.
N     * |        |          |0 = No power-down wake-up occurred.
N     * |        |          |1 = Power-down wake-up occurred.
N     * |        |          |Note: Write 1 to clear this bit to 0.
N     * |[9]     |WKIF1     |Comparator 1 Power-down Wake-up Interrupt Flag
N     * |        |          |This bit will be set to 1 when ACMP1 wake-up interrupt event occurs.
N     * |        |          |0 = No power-down wake-up occurred.
N     * |        |          |1 = Power-down wake-up occurred.
N     * |        |          |Note: Write 1 to clear this bit to 0.
N     * |[12]    |ACMPS0    |Comparator 0 StatusResult
N     * |        |          |Synchronized to the PCLK to allow reading by software
N     * |        |          |Cleared when the comparator 0 is disabled, i.e
N     * |        |          |ACMPEN (ACMP_CTL0[0]) is cleared to 0.Window Compare Output
N     * |[13]    |ACMPS1    |Window Comparator 1 StatusResultOutput
N     * |        |          |Synchronized to the PCLK to allow reading by software
N     * |        |          |Cleared when the comparator 1 is disabled, i.e
N     * |        |          |ACMPEN (ACMP_CTL1[0]) is cleared to 0.
N     * |[16]    |ACMPWO    |Comparator Window Compare Output
N     * |        |          |This bit shows the output status of window compare mode
N     * |        |          |0 = The positvie input voltage is outside the window.
N     * |        |          |1 = The positive input voltage is in the window.
N     * @var ACMP_T::VREF
N     * Offset: 0x0C  Analog Comparator Reference Voltage Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |CRVCTL    |Comparator Reference Voltage Setting
N     * |        |          |CRV = CRV source voltage * (1/6+CRVCTL/24).
N     * |[6]     |CRVSSEL   |CRV Source Voltage Selection
N     * |        |          |0 = AVDD is selected as CRV voltage source.
N     * |        |          |1 = The reference voltage defined by SYS_VREFCTL register is selected as CRV source voltage.
N     */
N    __IO uint32_t CTL[2];                /*!< [0x0000~0x0004] Analog Comparator 0/1 Control Register                    */
X    volatile uint32_t CTL[2];                 
N    __IO uint32_t STATUS;                /*!< [0x0008] Analog Comparator Status Register                                */
X    volatile uint32_t STATUS;                 
N    __IO uint32_t VREF;                  /*!< [0x000c] Analog Comparator Reference Voltage Control Register             */
X    volatile uint32_t VREF;                   
N
N} ACMP_T;
N
N/**
N    @addtogroup ACMP_CONST ACMP Bit Field Definition
N    Constant Definitions for ACMP Controller
N@{ */
N
N#define ACMP_CTL_ACMPEN_Pos             (0)                                                /*!< ACMP_T::CTL: ACMPEN Position          */
N#define ACMP_CTL_ACMPEN_Msk             (0x1ul << ACMP_CTL_ACMPEN_Pos)                     /*!< ACMP_T::CTL: ACMPEN Mask              */
N
N#define ACMP_CTL_ACMPIE_Pos             (1)                                                /*!< ACMP_T::CTL: ACMPIE Position          */
N#define ACMP_CTL_ACMPIE_Msk             (0x1ul << ACMP_CTL_ACMPIE_Pos)                     /*!< ACMP_T::CTL: ACMPIE Mask              */
N
N#define ACMP_CTL_HYSEN_Pos              (2)                                                /*!< ACMP_T::CTL: HYSEN Position           */
N#define ACMP_CTL_HYSEN_Msk              (0x1ul << ACMP_CTL_HYSEN_Pos)                      /*!< ACMP_T::CTL: HYSEN Mask               */
N
N#define ACMP_CTL_ACMPOINV_Pos           (3)                                                /*!< ACMP_T::CTL: ACMPOINV Position        */
N#define ACMP_CTL_ACMPOINV_Msk           (0x1ul << ACMP_CTL_ACMPOINV_Pos)                   /*!< ACMP_T::CTL: ACMPOINV Mask            */
N
N#define ACMP_CTL_NEGSEL_Pos             (4)                                                /*!< ACMP_T::CTL: NEGSEL Position          */
N#define ACMP_CTL_NEGSEL_Msk             (0x3ul << ACMP_CTL_NEGSEL_Pos)                     /*!< ACMP_T::CTL: NEGSEL Mask              */
N
N#define ACMP_CTL_POSSEL_Pos             (6)                                                /*!< ACMP_T::CTL: POSSEL Position          */
N#define ACMP_CTL_POSSEL_Msk             (0x3ul << ACMP_CTL_POSSEL_Pos)                     /*!< ACMP_T::CTL: POSSEL Mask              */
N
N#define ACMP_CTL_INTPOL_Pos             (8)                                                /*!< ACMP_T::CTL: INTPOL Position          */
N#define ACMP_CTL_INTPOL_Msk             (0x3ul << ACMP_CTL_INTPOL_Pos)                     /*!< ACMP_T::CTL: INTPOL Mask              */
N
N#define ACMP_CTL_OUTSEL_Pos             (12)                                               /*!< ACMP_T::CTL: OUTSEL Position          */
N#define ACMP_CTL_OUTSEL_Msk             (0x1ul << ACMP_CTL_OUTSEL_Pos)                     /*!< ACMP_T::CTL: OUTSEL Mask              */
N
N#define ACMP_CTL_FILTSEL_Pos            (13)                                               /*!< ACMP_T::CTL: FILTSEL Position         */
N#define ACMP_CTL_FILTSEL_Msk            (0x7ul << ACMP_CTL_FILTSEL_Pos)                    /*!< ACMP_T::CTL: FILTSEL Mask             */
N
N#define ACMP_CTL_WKEN_Pos               (16)                                               /*!< ACMP_T::CTL: WKEN Position            */
N#define ACMP_CTL_WKEN_Msk               (0x1ul << ACMP_CTL_WKEN_Pos)                       /*!< ACMP_T::CTL: WKEN Mask                */
N
N#define ACMP_CTL_WLATEN_Pos             (17)                                               /*!< ACMP_T::CTL: WLATEN Position          */
N#define ACMP_CTL_WLATEN_Msk             (0x1ul << ACMP_CTL_WLATEN_Pos)                     /*!< ACMP_T::CTL: WLATEN Mask              */
N
N#define ACMP_CTL_WCMPSEL_Pos            (18)                                               /*!< ACMP_T::CTL: WCMPSEL Position         */
N#define ACMP_CTL_WCMPSEL_Msk            (0x1ul << ACMP_CTL_WCMPSEL_Pos)                    /*!< ACMP_T::CTL: WCMPSEL Mask             */
N
N#define ACMP_STATUS_ACMPIF0_Pos          (0)                                               /*!< ACMP_T::STATUS: ACMPIF0 Position       */
N#define ACMP_STATUS_ACMPIF0_Msk          (0x1ul << ACMP_STATUS_ACMPIF0_Pos)                /*!< ACMP_T::STATUS: ACMPIF0 Mask           */
N
N#define ACMP_STATUS_ACMPIF1_Pos          (1)                                               /*!< ACMP_T::STATUS: ACMPIF1 Position       */
N#define ACMP_STATUS_ACMPIF1_Msk          (0x1ul << ACMP_STATUS_ACMPIF1_Pos)                /*!< ACMP_T::STATUS: ACMPIF1 Mask           */
N
N#define ACMP_STATUS_ACMPO0_Pos           (4)                                               /*!< ACMP_T::STATUS: ACMPO0 Position        */
N#define ACMP_STATUS_ACMPO0_Msk           (0x1ul << ACMP_STATUS_ACMPO0_Pos)                 /*!< ACMP_T::STATUS: ACMPO0 Mask            */
N
N#define ACMP_STATUS_ACMPO1_Pos           (5)                                               /*!< ACMP_T::STATUS: ACMPO1 Position        */
N#define ACMP_STATUS_ACMPO1_Msk           (0x1ul << ACMP_STATUS_ACMPO1_Pos)                 /*!< ACMP_T::STATUS: ACMPO1 Mask            */
N
N#define ACMP_STATUS_WKIF0_Pos            (8)                                               /*!< ACMP_T::STATUS: WKIF0 Position         */
N#define ACMP_STATUS_WKIF0_Msk            (0x1ul << ACMP_STATUS_WKIF0_Pos)                  /*!< ACMP_T::STATUS: WKIF0 Mask             */
N
N#define ACMP_STATUS_WKIF1_Pos            (9)                                               /*!< ACMP_T::STATUS: WKIF1 Position         */
N#define ACMP_STATUS_WKIF1_Msk            (0x1ul << ACMP_STATUS_WKIF1_Pos)                  /*!< ACMP_T::STATUS: WKIF1 Mask             */
N
N#define ACMP_STATUS_ACMPS0_Pos           (12)                                              /*!< ACMP_T::STATUS: ACMPS0 Position        */
N#define ACMP_STATUS_ACMPS0_Msk           (0x1ul << ACMP_STATUS_ACMPS0_Pos)                 /*!< ACMP_T::STATUS: ACMPS0 Mask            */
N
N#define ACMP_STATUS_ACMPS1_Pos           (13)                                              /*!< ACMP_T::STATUS: ACMPS1 Position        */
N#define ACMP_STATUS_ACMPS1_Msk           (0x1ul << ACMP_STATUS_ACMPS1_Pos)                 /*!< ACMP_T::STATUS: ACMPS1 Mask            */
N
N#define ACMP_STATUS_ACMPWO_Pos           (16)                                              /*!< ACMP_T::STATUS: ACMPWO Position        */
N#define ACMP_STATUS_ACMPWO_Msk           (0x1ul << ACMP_STATUS_ACMPWO_Pos)                 /*!< ACMP_T::STATUS: ACMPWO Mask            */
N
N#define ACMP_VREF_CRVCTL_Pos             (0)                                               /*!< ACMP_T::VREF: CRVCTL Position          */
N#define ACMP_VREF_CRVCTL_Msk             (0xful << ACMP_VREF_CRVCTL_Pos)                   /*!< ACMP_T::VREF: CRVCTL Mask              */
N
N#define ACMP_VREF_CRVSSEL_Pos            (6)                                               /*!< ACMP_T::VREF: CRVSSEL Position         */
N#define ACMP_VREF_CRVSSEL_Msk            (0x1ul << ACMP_VREF_CRVSSEL_Pos)                  /*!< ACMP_T::VREF: CRVSSEL Mask             */
N
N/**@}*/ /* ACMP_CONST */
N/**@}*/ /* end of ACMP register group */
N
N
N/*---------------------- Analog to Digital Converter -------------------------*/
N/**
N    @addtogroup ADC Analog to Digital Converter(ADC)
N    Memory Mapped Structure for ADC Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var ADC_T::ADDR
N     * Offset: 0x00~0x4C, 0x74~0x7C  ADC Data Register 0~19, 29~31
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RSLT      |A/D Conversion Result (Read Only)
N     * |        |          |This field contains conversion result of ADC.
N     * |[16]    |OVERRUN   |Overrun Flag (Read Only)
N     * |        |          |If converted data in RSLT bits has not been read before new conversion result is loaded to this register, OVERRUN bit is set to 1.
N     * |        |          |It is cleared by hardware after ADDR register is read.
N     * |        |          |0 = Data in RSLT bits is not overwrote.
N     * |        |          |1 = Data in RSLT bits is overwrote..
N     * |[17]    |VALID     |Valid Flag (Read Only)
N     * |        |          |This bit will be set to 1 when the conversion of the corresponding channel is completed.
N     * |        |          |This bit will be cleared to 0 by hardware after ADDR register is read.
N     * |        |          |0 = Data in RSLT bits is not valid.
N     * |        |          |1 = Data in RSLT bits is valid.
N     * @var ADC_T::ADCR
N     * Offset: 0x80  ADC Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ADEN      |A/D Converter Enable
N     * |        |          |0 = A/D converter Disabled.
N     * |        |          |1 = A/D converter Enabled.
N     * |        |          |Note: Before starting A/D conversion function, this bit should be set to 1.
N     * |        |          |Clear it to 0 to disable A/D converter analog circuit to save power consumption.
N     * |[1]     |ADIE      |A/D Interrupt Enable Control
N     * |        |          |A/D conversion end interrupt request is generated if ADIE bit is set to 1.
N     * |        |          |0 = A/D interrupt function Disabled.
N     * |        |          |1 = A/D interrupt function Enabled.
N     * |[3:2]   |ADMD      |A/D Converter Operation Mode Control
N     * |        |          |00 = Single conversion.
N     * |        |          |01 = Burst conversion.
N     * |        |          |10 = Single-cycle Scan.
N     * |        |          |11 = Continuous Scan.
N     * |        |          |Note1: When changing the operation mode, software should clear ADST bit first.
N     * |        |          |Note2: In Burst mode, the A/D result data is always at ADC Data Register 0.
N     * |[5:4]   |TRGS      |Hardware Trigger Source
N     * |        |          |00 = A/D conversion is started by external STADC pin.
N     * |        |          |01 = Timer0 ~ Timer3 overflow pulse trigger.
N     * |        |          |10 = Reserved.
N     * |        |          |11 = A/D conversion is started by PWM trigger.
N     * |        |          |Note: Software should clear TRGEN bit and ADST bit to 0 before changing TRGS bits.
N     * |[7:6]   |TRGCOND   |External Trigger Condition
N     * |        |          |These two bits decide external pin STADC trigger event is level or edge.
N     * |        |          |The signal must be kept at stable state at least 8 PCLKs for level trigger and at least 4 PCLKs for edge trigger.
N     * |        |          |00 = Low level.
N     * |        |          |01 = High level.
N     * |        |          |10 = Falling edge.
N     * |        |          |11 = Rising edge.
N     * |[8]     |TRGEN     |External Trigger Enable Control
N     * |        |          |Enable or disable triggering of A/D conversion by external STADC pin, PWM trigger and Timer trigger.
N     * |        |          |If external trigger is enabled, the ADST bit can be set to 1 by the selected hardware trigger source.
N     * |        |          |0 = External trigger Disabled.
N     * |        |          |1 = External trigger Enabled.
N     * |        |          |Note: The ADC external trigger function is only supported in Single-cycle Scan mode.
N     * |[9]     |PTEN      |PDMA Transfer Enable Bit
N     * |        |          |When A/D conversion is completed, the converted data is loaded into ADDR0~19, ADDR29~ADDR31.
N     * |        |          |Software can enable this bit to generate a PDMA data transfer request.
N     * |        |          |0 = PDMA data transfer Disabled.
N     * |        |          |1 = PDMA data transfer in ADDR0~19, ADDR29~ADDR31 Enabled.
N     * |        |          |Note: When PTEN=1, software must set ADIE=0 to disable interrupt.
N     * |[10]    |DIFFEN    |Differential Input Mode Control
N     * |        |          |0 = Single-end analog input mode.
N     * |        |          |1 = Differential analog input mode.
N     * |        |          |Differential input voltage (Vdiff) = Vplus - Vminus,
N     * |        |          |where Vplus is the analog input; Vminus is the inverted analog input.
N     * |        |          |The Vplus of differential input paired channel x is from ADC0_CHy pin; Vminus is from ADC0_CHz pin, x=0,1..9, y=2*x, z=y+1.
N     * |        |          |0 = Single-end analog input mode.
N     * |        |          |1 = Differential analog input mode.
N     * |        |          |Note: In Differential Input mode, only the even number of the two corresponding channels needs to be enabled in ADCHER register
N     * |        |          |The conversion result will be placed to the corresponding data register of the enabled channel.
N     * |[11]    |ADST      |A/D Conversion Start
N     * |        |          |ADST bit can be set to 1 from four sources: software, external pin STADC, PWM trigger and Timer trigger.
N     * |        |          |ADST bit will be cleared to 0 by hardware automatically at the ends of Single mode and Single-cycle Scan mode.
N     * |        |          |In Continuous Scan mode and Burst mode, A/D conversion is continuously performed until software writes 0 to this bit or chip is reset.
N     * |        |          |0 = Conversion stops and A/D converter enters idle state.
N     * |        |          |1 = Conversion starts.
N     * |[18:16] |SMPTSEL   |ADC Internal Sampling Time Selection
N     * |        |          |Total ADC conversion cycle = sampling cycle + 12
N     * |        |          |000 = 4 ADC clock for sampling; 16 ADC clock for complete conversion.
N     * |        |          |001 = 5 ADC clock for sampling; 17 ADC clock for complete conversion.
N     * |        |          |010 = 6 ADC clock for sampling; 18 ADC clock for complete conversion.
N     * |        |          |011 = 7 ADC clock for sampling; 19 ADC clock for complete conversion.
N     * |        |          |100 = 8 ADC clock for sampling; 20 ADC clock for complete conversion.
N     * |        |          |101 = 9 ADC clock for sampling; 21 ADC clock for complete conversion.
N     * |        |          |110 = 10 ADC clock for sampling; 22 ADC clock for complete conversion.
N     * |        |          |111 = 11 ADC clock for sampling; 23 ADC clock for complete conversion.
N     * |[31]    |DMOF      |Differential Input Mode Output Format
N     * |        |          |If user enables differential input mode, the conversion result can be expressed with binary straight format (unsigned format) or 2's complement format (signed format).
N     * |        |          |0 = A/D Conversion result will be filled in RSLT at ADDRx registers with unsigned format (straight binary format).
N     * |        |          |1 = A/D Conversion result will be filled in RSLT at ADDRx registers with 2's complement format.
N     * @var ADC_T::ADCHER
N     * Offset: 0x84  ADC Channel Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |CHEN      |Analog Input Channel Enable Control
N     * |        |          |Set ADCHENR[19:0] bits to enable the corresponding analog input channel 19 ~ 0
N     * |        |          |If DIFFEN bit is set to 1, only the even number channel needs to be enabled.
N     * |        |          |Besides, set ADCHENR[29] to ADCHENR[31] bits will enable internal channel for band-gap voltage, temperature sensor and battery power respectively.
N     * |        |          |Other bits are reserved.
N     * |        |          |0 = Channel Disabled.
N     * |        |          |1 = Channel Enabled.
N     * |        |          |Note 1 : If the internal channel for band-gap voltage (CHEN[29]) is active, the maximum sampling rate will be 300k SPS.
N     * |        |          |Note 2 : If the internal channel for temperature sensor (CHEN[30]) is active, the maximum sampling rate will be 300k SPS.
N     * @var ADC_T::ADCMPR
N     * Offset: 0x88/0x8C  ADC Compare Register 0/1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CMPEN     |Compare Enable Control
N     * |        |          |Set this bit to 1 to enable ADC controller to compare CMPD (ADCMPRx[27:16]) with specified channel conversion result when converted data is loaded into ADDR register.
N     * |        |          |0 = Compare function Disabled.
N     * |        |          |1 = Compare function Enabled.
N     * |[1]     |CMPIE     |Compare Interrupt Enable Control
N     * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMATCNT, CMPFx bit will be asserted, in the meanwhile, if CMPIE bit is set to 1, a compare interrupt request is generated.
N     * |        |          |0 = Compare function interrupt Disabled.
N     * |        |          |1 = Compare function interrupt Enabled.
N     * |[2]     |CMPCOND   |Compare Condition
N     * |        |          |0 = Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPD (ADCMPRx[27:16])bits, the internal match counter will increase one.
N     * |        |          |1 = Set the compare condition as that when a 12-bit A/D conversion result is greater than or equal to the 12-bit CMPD (ADCMPRx[27:16])bits, the internal match counter will increase one.
N     * |        |          |Note: When the internal counter reaches to (CMPMATCNT +1), the CMPFx bit will be set.
N     * |[7:3]   |CMPCH     |Compare Channel Selection
N     * |        |          |00000 = Channel 0 conversion result is selected to be compared.
N     * |        |          |00001 = Channel 1 conversion result is selected to be compared.
N     * |        |          |00010 = Channel 2 conversion result is selected to be compared.
N     * |        |          |00011 = Channel 3 conversion result is selected to be compared.
N     * |        |          |00100 = Channel 4 conversion result is selected to be compared.
N     * |        |          |00101 = Channel 5 conversion result is selected to be compared.
N     * |        |          |00110 = Channel 6 conversion result is selected to be compared.
N     * |        |          |00111 = Channel 7 conversion result is selected to be compared.
N     * |        |          |01000 = Channel 8 conversion result is selected to be compared.
N     * |        |          |01001 = Channel 9 conversion result is selected to be compared.
N     * |        |          |01010 = Channel 10 conversion result is selected to be compared.
N     * |        |          |01011 = Channel 11 conversion result is selected to be compared.
N     * |        |          |01100 = Channel 12 conversion result is selected to be compared.
N     * |        |          |01101 = Channel 13 conversion result is selected to be compared.
N     * |        |          |01110 = Channel 14 conversion result is selected to be compared.
N     * |        |          |01111 = Channel 15 conversion result is selected to be compared.
N     * |        |          |10000 = Channel 16 conversion result is selected to be compared.
N     * |        |          |10001 = Channel 17 conversion result is selected to be compared.
N     * |        |          |10010 = Channel 18 conversion result is selected to be compared.
N     * |        |          |10011 = Channel 19 conversion result is selected to be compared.
N     * |        |          |11101 = Band-gap voltage conversion result is selected to be compared.
N     * |        |          |11110 = Temperature sensor conversion result is selected to be compared.
N     * |        |          |11111 = Battery power conversion result is selected to be compared.
N     * |        |          |Others = Reserved.
N     * |[11:8]  |CMPMATCNT |Compare Match Count
N     * |        |          |When the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND bit, the internal match counter will increase 1.
N     * |        |          |When the internal counter reaches the value to (CMPMATCNT +1), the CMPFx bit will be set.
N     * |[15]    |CMPWEN    |Compare Window Mode Enable Bit
N     * |        |          |0 = Compare Window Mode Disabled.
N     * |        |          |1 = Compare Window Mode Enabled.
N     * |        |          |Note: This bit is only presented in ADCMPR0 register.
N     * |[27:16] |CMPD      |Comparison Data
N     * |        |          |The 12-bit data is used to compare with conversion result of specified channel.
N     * |        |          |Note: CMPD bits should be filled in unsigned format (straight binary format).
N     * @var ADC_T::ADSR0
N     * Offset: 0x90  ADC Status Register0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ADF       |A/D Conversion End Flag
N     * |        |          |A status flag that indicates the end of A/D conversion. Software can write 1 to clear this bit.
N     * |        |          |ADF bit is set to 1 at the following three conditions:
N     * |        |          |1. When A/D conversion ends in Single mode.
N     * |        |          |2. When A/D conversion ends on all specified channels in Single-cycle Scan mode and Continuous Scan mode.
N     * |        |          |3. When more than or equal to 8 samples in FIFO in Burst mode.
N     * |[1]     |CMPF0     |Compare Flag 0
N     * |        |          |When the A/D conversion result of the selected channel meets setting condition in ADCMPR0 register then this bit is set to 1.
N     * |        |          |This bit is cleared by writing 1 to it.
N     * |        |          |0 = Conversion result in ADDR does not meet ADCMPR0 setting.
N     * |        |          |1 = Conversion result in ADDR meets ADCMPR0 setting.
N     * |[2]     |CMPF1     |Compare Flag 1
N     * |        |          |When the A/D conversion result of the selected channel meets setting condition in ADCMPR1 register then this bit is set to 1; it is cleared by writing 1 to it.
N     * |        |          |0 = Conversion result in ADDR does not meet ADCMPR1 setting.
N     * |        |          |1 = Conversion result in ADDR meets ADCMPR1 setting.
N     * |[7]     |BUSY      |BUSY/IDLE (Read Only)
N     * |        |          |This bit is a mirror of ADST bit in ADCR register.
N     * |        |          |0 = A/D converter is in idle state.
N     * |        |          |1 = A/D converter is busy at conversion.
N     * |[8]     |VALIDF    |Data Valid Flag (Read Only)
N     * |        |          |If any one of VALID (ADDRx[17]) is set, this flag will be set to 1.
N     * |        |          |Note: When ADC is in burst mode and any conversion result is valid, this flag will be set to 1.
N     * |[16]    |OVERRUNF  |Overrun Flag (Read Only)
N     * |        |          |If any one of OVERRUN (ADDRx[16]) is set, this flag will be set to 1.
N     * |        |          |Note: When ADC is in burst mode and the FIFO is overrun, this flag will be set to 1.
N     * |[31:27] |CHANNEL   |Current Conversion Channel (Read Only)
N     * |        |          |When BUSY=1, this filed reflects current conversion channel.
N     * |        |          |When BUSY=0, it shows the number of the next converted channel.
N     * @var ADC_T::ADSR1
N     * Offset: 0x94  ADC Status Register1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |VALID     |Data Valid Flag (Read Only)
N     * |        |          |VALID[31:29, 19:0] are the mirror of the VALID bits in ADDR31[17] ~ ADDR29[17], ADDR19[17]~ ADDR0[17].
N     * |        |          |The other bits are reserved.
N     * |        |          |Note: When ADC is in burst mode and any conversion result is valid, VALID[31:29, 19:0] will be set to 1.
N     * @var ADC_T::ADSR2
N     * Offset: 0x98  ADC Status Register2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |OVERRUN   |Overrun Flag (Read Only)
N     * |        |          |OVERRUN[31:29, 19:0] are the mirror of the OVERRUN bit in ADDR31[16] ~ADDR29[16], ADDR19[16] ~ ADDR0[16].
N     * |        |          |The other bits are reserved.
N     * |        |          |Note: When ADC is in burst mode and the FIFO is overrun, OVERRUN[31:29, 19:0] will be set to 1.
N     * @var ADC_T::ADTDCR
N     * Offset: 0x9C  ADC Trigger Delay Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |PTDT      |PWM Trigger Delay Time
N     * |        |          |Set this field will delay ADC start conversion time after PWM trigger.
N     * |        |          |PWM trigger delay time is (4 * PTDT) * system clock
N     * @var ADC_T::ADPDMA
N     * Offset: 0x100  ADC PDMA Current Transfer Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[17:0]  |CURDAT    |ADC PDMA Current Transfer Data Register (Read Only)
N     * |        |          |When PDMA transferring, read this register can monitor current PDMA transfer data.
N     * |        |          |Current PDMA transfer data could be the content of ADDR0 ~ ADDR19 and ADDR29 ~ ADDR31 registers.
N     */
N
N    __I  uint32_t ADDR[32];              /*!< [0x0000 ~ 0x007c] ADC Data Register 31                                    */
X    volatile const  uint32_t ADDR[32];               
N    __IO uint32_t ADCR;                  /*!< [0x0080] ADC Control Register                                             */
X    volatile uint32_t ADCR;                   
N    __IO uint32_t ADCHER;                /*!< [0x0084] ADC Channel Enable Register                                      */
X    volatile uint32_t ADCHER;                 
N    __IO uint32_t ADCMPR[2];             /*!< [0x0088 ~ 0x008C] ADC Compare Register 0 & 1                              */
X    volatile uint32_t ADCMPR[2];              
N    __IO uint32_t ADSR0;                 /*!< [0x0090] ADC Status Register0                                             */
X    volatile uint32_t ADSR0;                  
N    __I  uint32_t ADSR1;                 /*!< [0x0094] ADC Status Register1                                             */
X    volatile const  uint32_t ADSR1;                  
N    __I  uint32_t ADSR2;                 /*!< [0x0098] ADC Status Register2                                             */
X    volatile const  uint32_t ADSR2;                  
N    __IO uint32_t ADTDCR;                /*!< [0x009c] ADC Trigger Delay Control Register                               */
X    volatile uint32_t ADTDCR;                 
N    __I  uint32_t RESERVE0[24];
X    volatile const  uint32_t RESERVE0[24];
N    __I  uint32_t ADPDMA;                /*!< [0x0100] ADC PDMA Current Transfer Data Register                          */
X    volatile const  uint32_t ADPDMA;                 
N
N} ADC_T;
N
N/**
N    @addtogroup ADC_CONST ADC Bit Field Definition
N    Constant Definitions for ADC Controller
N@{ */
N
N#define ADC_ADDR_RSLT_Pos                (0)                                               /*!< ADC_T::ADDR: RSLT Position             */
N#define ADC_ADDR_RSLT_Msk                (0xfffful << ADC_ADDR_RSLT_Pos)                   /*!< ADC_T::ADDR: RSLT Mask                 */
N
N#define ADC_ADDR_OVERRUN_Pos             (16)                                              /*!< ADC_T::ADDR: OVERRUN Position          */
N#define ADC_ADDR_OVERRUN_Msk             (0x1ul << ADC_ADDR_OVERRUN_Pos)                   /*!< ADC_T::ADDR: OVERRUN Mask              */
N
N#define ADC_ADDR_VALID_Pos               (17)                                              /*!< ADC_T::ADDR: VALID Position            */
N#define ADC_ADDR_VALID_Msk               (0x1ul << ADC_ADDR_VALID_Pos)                     /*!< ADC_T::ADDR: VALID Mask                */
N
N#define ADC_ADCR_ADEN_Pos                (0)                                               /*!< ADC_T::ADCR: ADEN Position             */
N#define ADC_ADCR_ADEN_Msk                (0x1ul << ADC_ADCR_ADEN_Pos)                      /*!< ADC_T::ADCR: ADEN Mask                 */
N
N#define ADC_ADCR_ADIE_Pos                (1)                                               /*!< ADC_T::ADCR: ADIE Position             */
N#define ADC_ADCR_ADIE_Msk                (0x1ul << ADC_ADCR_ADIE_Pos)                      /*!< ADC_T::ADCR: ADIE Mask                 */
N
N#define ADC_ADCR_ADMD_Pos                (2)                                               /*!< ADC_T::ADCR: ADMD Position             */
N#define ADC_ADCR_ADMD_Msk                (0x3ul << ADC_ADCR_ADMD_Pos)                      /*!< ADC_T::ADCR: ADMD Mask                 */
N
N#define ADC_ADCR_TRGS_Pos                (4)                                               /*!< ADC_T::ADCR: TRGS Position             */
N#define ADC_ADCR_TRGS_Msk                (0x3ul << ADC_ADCR_TRGS_Pos)                      /*!< ADC_T::ADCR: TRGS Mask                 */
N
N#define ADC_ADCR_TRGCOND_Pos             (6)                                               /*!< ADC_T::ADCR: TRGCOND Position          */
N#define ADC_ADCR_TRGCOND_Msk             (0x3ul << ADC_ADCR_TRGCOND_Pos)                   /*!< ADC_T::ADCR: TRGCOND Mask              */
N
N#define ADC_ADCR_TRGEN_Pos               (8)                                               /*!< ADC_T::ADCR: TRGEN Position            */
N#define ADC_ADCR_TRGEN_Msk               (0x1ul << ADC_ADCR_TRGEN_Pos)                     /*!< ADC_T::ADCR: TRGEN Mask                */
N
N#define ADC_ADCR_PTEN_Pos                (9)                                               /*!< ADC_T::ADCR: PTEN Position             */
N#define ADC_ADCR_PTEN_Msk                (0x1ul << ADC_ADCR_PTEN_Pos)                      /*!< ADC_T::ADCR: PTEN Mask                 */
N
N#define ADC_ADCR_DIFFEN_Pos              (10)                                              /*!< ADC_T::ADCR: DIFFEN Position           */
N#define ADC_ADCR_DIFFEN_Msk              (0x1ul << ADC_ADCR_DIFFEN_Pos)                    /*!< ADC_T::ADCR: DIFFEN Mask               */
N
N#define ADC_ADCR_ADST_Pos                (11)                                              /*!< ADC_T::ADCR: ADST Position             */
N#define ADC_ADCR_ADST_Msk                (0x1ul << ADC_ADCR_ADST_Pos)                      /*!< ADC_T::ADCR: ADST Mask                 */
N
N#define ADC_ADCR_SMPTSEL_Pos             (16)                                              /*!< ADC_T::ADCR: SMPTSEL Position          */
N#define ADC_ADCR_SMPTSEL_Msk             (0x7ul << ADC_ADCR_SMPTSEL_Pos)                   /*!< ADC_T::ADCR: SMPTSEL Mask              */
N
N#define ADC_ADCR_DMOF_Pos                (31)                                              /*!< ADC_T::ADCR: DMOF Position             */
N#define ADC_ADCR_DMOF_Msk                (0x1ul << ADC_ADCR_DMOF_Pos)                      /*!< ADC_T::ADCR: DMOF Mask                 */
N
N#define ADC_ADCHER_CHEN_Pos              (0)                                               /*!< ADC_T::ADCHER: CHEN Position           */
N#define ADC_ADCHER_CHEN_Msk              (0xfffffffful << ADC_ADCHER_CHEN_Pos)             /*!< ADC_T::ADCHER: CHEN Mask               */
N
N#define ADC_ADCMPR_CMPEN_Pos             (0)                                               /*!< ADC_T::ADCMPR: CMPEN Position          */
N#define ADC_ADCMPR_CMPEN_Msk             (0x1ul << ADC_ADCMPR_CMPEN_Pos)                   /*!< ADC_T::ADCMPR: CMPEN Mask              */
N
N#define ADC_ADCMPR_CMPIE_Pos             (1)                                               /*!< ADC_T::ADCMPR: CMPIE Position          */
N#define ADC_ADCMPR_CMPIE_Msk             (0x1ul << ADC_ADCMPR_CMPIE_Pos)                   /*!< ADC_T::ADCMPR: CMPIE Mask              */
N
N#define ADC_ADCMPR_CMPCOND_Pos           (2)                                               /*!< ADC_T::ADCMPR: CMPCOND Position        */
N#define ADC_ADCMPR_CMPCOND_Msk           (0x1ul << ADC_ADCMPR_CMPCOND_Pos)                 /*!< ADC_T::ADCMPR: CMPCOND Mask            */
N
N#define ADC_ADCMPR_CMPCH_Pos             (3)                                               /*!< ADC_T::ADCMPR: CMPCH Position          */
N#define ADC_ADCMPR_CMPCH_Msk             (0x1ful << ADC_ADCMPR_CMPCH_Pos)                  /*!< ADC_T::ADCMPR: CMPCH Mask              */
N
N#define ADC_ADCMPR_CMPMATCNT_Pos         (8)                                               /*!< ADC_T::ADCMPR: CMPMATCNT Position      */
N#define ADC_ADCMPR_CMPMATCNT_Msk         (0xful << ADC_ADCMPR_CMPMATCNT_Pos)               /*!< ADC_T::ADCMPR: CMPMATCNT Mask          */
N
N#define ADC_ADCMPR_CMPWEN_Pos            (15)                                              /*!< ADC_T::ADCMPR: CMPWEN Position         */
N#define ADC_ADCMPR_CMPWEN_Msk            (0x1ul << ADC_ADCMPR_CMPWEN_Pos)                  /*!< ADC_T::ADCMPR: CMPWEN Mask             */
N
N#define ADC_ADCMPR_CMPD_Pos              (16)                                              /*!< ADC_T::ADCMPR: CMPD Position           */
N#define ADC_ADCMPR_CMPD_Msk              (0xffful << ADC_ADCMPR_CMPD_Pos)                  /*!< ADC_T::ADCMPR: CMPD Mask               */
N
N#define ADC_ADSR0_ADF_Pos                (0)                                               /*!< ADC_T::ADSR0: ADF Position             */
N#define ADC_ADSR0_ADF_Msk                (0x1ul << ADC_ADSR0_ADF_Pos)                      /*!< ADC_T::ADSR0: ADF Mask                 */
N
N#define ADC_ADSR0_CMPF0_Pos              (1)                                               /*!< ADC_T::ADSR0: CMPF0 Position           */
N#define ADC_ADSR0_CMPF0_Msk              (0x1ul << ADC_ADSR0_CMPF0_Pos)                    /*!< ADC_T::ADSR0: CMPF0 Mask               */
N
N#define ADC_ADSR0_CMPF1_Pos              (2)                                               /*!< ADC_T::ADSR0: CMPF1 Position           */
N#define ADC_ADSR0_CMPF1_Msk              (0x1ul << ADC_ADSR0_CMPF1_Pos)                    /*!< ADC_T::ADSR0: CMPF1 Mask               */
N
N#define ADC_ADSR0_BUSY_Pos               (7)                                               /*!< ADC_T::ADSR0: BUSY Position            */
N#define ADC_ADSR0_BUSY_Msk               (0x1ul << ADC_ADSR0_BUSY_Pos)                     /*!< ADC_T::ADSR0: BUSY Mask                */
N
N#define ADC_ADSR0_VALIDF_Pos             (8)                                               /*!< ADC_T::ADSR0: VALIDF Position          */
N#define ADC_ADSR0_VALIDF_Msk             (0x1ul << ADC_ADSR0_VALIDF_Pos)                   /*!< ADC_T::ADSR0: VALIDF Mask              */
N
N#define ADC_ADSR0_OVERRUNF_Pos           (16)                                              /*!< ADC_T::ADSR0: OVERRUNF Position        */
N#define ADC_ADSR0_OVERRUNF_Msk           (0x1ul << ADC_ADSR0_OVERRUNF_Pos)                 /*!< ADC_T::ADSR0: OVERRUNF Mask            */
N
N#define ADC_ADSR0_CHANNEL_Pos            (27)                                              /*!< ADC_T::ADSR0: CHANNEL Position         */
N#define ADC_ADSR0_CHANNEL_Msk            (0x1ful << ADC_ADSR0_CHANNEL_Pos)                 /*!< ADC_T::ADSR0: CHANNEL Mask             */
N
N#define ADC_ADSR1_VALID_Pos              (0)                                               /*!< ADC_T::ADSR1: VALID Position           */
N#define ADC_ADSR1_VALID_Msk              (0xfffffffful << ADC_ADSR1_VALID_Pos)             /*!< ADC_T::ADSR1: VALID Mask               */
N
N#define ADC_ADSR2_OVERRUN_Pos            (0)                                               /*!< ADC_T::ADSR2: OVERRUN Position         */
N#define ADC_ADSR2_OVERRUN_Msk            (0xfffffffful << ADC_ADSR2_OVERRUN_Pos)           /*!< ADC_T::ADSR2: OVERRUN Mask             */
N
N#define ADC_ADTDCR_PTDT_Pos              (0)                                               /*!< ADC_T::ADTDCR: PTDT Position           */
N#define ADC_ADTDCR_PTDT_Msk              (0xfful << ADC_ADTDCR_PTDT_Pos)                   /*!< ADC_T::ADTDCR: PTDT Mask               */
N
N#define ADC_ADPDMA_CURDAT_Pos            (0)                                               /*!< ADC_T::ADPDMA: CURDAT Position         */
N#define ADC_ADPDMA_CURDAT_Msk            (0x3fffful << ADC_ADPDMA_CURDAT_Pos)              /*!< ADC_T::ADPDMA: CURDAT Mask             */
N
N/**@}*/ /* ADC_CONST */
N/**@}*/ /* end of ADC register group */
N
N
N/*---------------------- System Clock Controller -------------------------*/
N/**
N    @addtogroup CLK System Clock Controller(CLK)
N    Memory Mapped Structure for CLK Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var CLK_T::PWRCTL
N     * Offset: 0x00  System Power-down Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |HXTEN     |HXT Enable Bit (Write Protect)
N     * |        |          |The bit default value is set by flash controller user configuration register CONFIG0 [26:24].
N     * |        |          |When the default clock source is from HXT, this bit is set to 1 automatically.
N     * |        |          |0 = 4~24 MHz External High Speed Crystal (HXT) Disabled.
N     * |        |          |1 = 4~24 MHz External High Speed Crystal (HXT) Enabled.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[1]     |LXTEN     |LXT Enable Bit (Write Protect)
N     * |        |          |0 = 32.768 KHz External Low Speed Crystal (LXT) Disabled.
N     * |        |          |1 = 32.768 KHz External Low Speed Crystal (LXT) Enabled.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[2]     |HIRCEN    |HIRC Enable Bit (Write Protect)
N     * |        |          |0 = 22.1184 MHz internal high speed RC oscillator (HIRC) Disabled.
N     * |        |          |1 = 22.1184 MHz internal high speed RC oscillator (HIRC) Enabled.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[3]     |LIRCEN    |LIRC Enable Bit (Write Protect)
N     * |        |          |0 = 10 kHz internal low speed RC oscillator (LIRC) Disabled.
N     * |        |          |1 = 10 kHz internal low speed RC oscillator (LIRC) Enabled.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[4]     |PDWKDLY   |Enable the Wake-up Delay Counter (Write Protect)
N     * |        |          |When the chip wakes up from Power-down mode, the clock control will delay certain clock cycles to wait system clock stable.
N     * |        |          |The delayed clock cycle is 4096 clock cycles when chip work at 4~24 MHz external high speed crystal oscillator (HXT), 256 clock cycles when chip work at 22.1184 MHz internal high speed RC oscillator (HIRC) and 512 clock cycles when chip work at 48 MHz internal high speed RC oscillator (HIRC48).
N     * |        |          |0 = Clock cycles delay Disabled.
N     * |        |          |1 = Clock cycles delay Enabled.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[5]     |PDWKIEN   |Power-down Mode Wake-up Interrupt Enable Bit (Write Protect)
N     * |        |          |0 = Power-down mode wake-up interrupt Disabled.
N     * |        |          |1 = Power-down mode wake-up interrupt Enabled.
N     * |        |          |Note1: The interrupt will occur when both PDWKIF and PDWKIEN are high.
N     * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[6]     |PDWKIF    |Power-down Mode Wake-up Interrupt Status
N     * |        |          |Set by u201CPower-down wake-up eventu201D, it indicates that resume from Power-down modeu201D
N     * |        |          |The flag is set if the EINT0~5, GPIO, USBD, UART0~2, WDT, ACMP01, BOD, EBOD, RTC, TMR0~3, I2C0~1 or USCI0~2 wake-up occurred.
N     * |        |          |Note1: Write 1 to clear the bit to 0.
N     * |        |          |Note2: This bit works only if PDWKIEN (CLK_PWRCTL[5]) set to 1.
N     * |[7]     |PDEN      |System Power-down Enable (Write Protect)
N     * |        |          |When this bit is set to 1, Power-down mode is enabled and chip keeps active till the CPU sleep mode is also active and then the chip enters Power-down mode.
N     * |        |          |When chip wakes up from Power-down mode, this bit is auto cleared.
N     * |        |          |Users need to set this bit again for next Power-down.
N     * |        |          |In Power-down mode, HXT, HIRC and the HIRC48 will be disabled in this mode, but LXT and LIRC are not controlled by Power-down mode.
N     * |        |          |In Power-down mode, the PLL and system clock are disabled, and ignored the clock source selection.
N     * |        |          |The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock source is from LXT or LIRC.
N     * |        |          |0 = Chip operating normally or chip in idle mode because of WFI command.
N     * |        |          |1 = Chip waits CPU sleep command WFI and then enters Power-down mode.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[11:10] |HXTGAIN   |HXT Gain Control Bit (Write Protect)
N     * |        |          |Gain control is used to enlarge the gain of crystal to make sure crystal work normally.
N     * |        |          |If gain control is enabled, crystal will consume more power than gain control off.
N     * |        |          |00 = HXT frequency is lower than from 8 MHz.
N     * |        |          |01 = HXT frequency is from 8 MHz to 12 MHz.
N     * |        |          |10 = HXT frequency is from 12 MHz to 16 MHz.
N     * |        |          |11 = HXT frequency is higher than 16 MHz.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[12]    |HXTSELTYP |HXT Crystal Type Select Bit (Write Protect)
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |0 = Select INV type.
N     * |        |          |1 = Select GM type.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[13]    |HIRC48EN  |HIRC48 Enable Bit (Write Protect)
N     * |        |          |0 = 48 MHz internal high speed RC oscillator (HIRC48) Disabled.
N     * |        |          |1 = 48 MHz internal high speed RC oscillator (HIRC48) Enabled.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * @var CLK_T::AHBCLK
N     * Offset: 0x04  AHB Devices Clock Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |PDMACKEN  |PDMA Controller Clock Enable Bit
N     * |        |          |0 = PDMA peripheral clock Disabled.
N     * |        |          |1 = PDMA peripheral clock Enabled.
N     * |[2]     |ISPCKEN   |Flash ISP Controller Clock Enable Bit
N     * |        |          |0 = Flash ISP peripheral clock Disabled.
N     * |        |          |1 = Flash ISP peripheral clock Enabled.
N     * |[3]     |EBICKEN   |EBI Controller Clock Enable Bit
N     * |        |          |0 = EBI peripheral clock Disabled.
N     * |        |          |1 = EBI peripheral clock Enabled.
N     * |[4]     |HDIVCKEN  |Hardware Divider Controller Clock Enable Bit
N     * |        |          |0 = Hardware divider peripheral clock Disabled.
N     * |        |          |1 = Hardware divider peripheral clock Enabled.
N     * |[7]     |CRCCKEN   |CRC Generator Controller Clock Enable Bit
N     * |        |          |0 = CRC peripheral clock Disabled.
N     * |        |          |1 = CRC peripheral clock Enabled.
N     * |[15]    |FMCIDLE   |Flash Memory Controller Clock Enable Bit in IDLE Mode
N     * |        |          |0 = FMC peripheral clock Disabled when chip operating at IDLE mode.
N     * |        |          |1 = FMC peripheral clock Enabled when chip operating at IDLE mode.
N     * |[16]    |GPIOACKEN |General Purpose I/O PA Group Clock Enable Bit
N     * |        |          |0 = GPIO PA group clock Disabled.
N     * |        |          |1 = GPIO PA group clock Enabled.
N     * |[17]    |GPIOBCKEN |General Purpose I/O PB Group Clock Enable Bit
N     * |        |          |0 = GPIO PB group clock Disabled.
N     * |        |          |1 = GPIO PB group clock Enabled.
N     * |[18]    |GPIOCCKEN |General Purpose I/O PC Group Clock Enable Bit
N     * |        |          |0 = GPIO PC group clock Disabled.
N     * |        |          |1 = GPIO PC group clock Enabled.
N     * |[19]    |GPIODCKEN |General Purpose I/O PD Group Clock Enable Bit
N     * |        |          |0 = GPIO PD group clock Disabled.
N     * |        |          |1 = GPIO PD group clock Enabled.
N     * |[20]    |GPIOECKEN |General Purpose I/O PE Group Clock Enable Bit
N     * |        |          |0 = GPIO PE group clock Disabled.
N     * |        |          |1 = GPIO PE group clock Enabled.
N     * |[21]    |GPIOFCKEN |General Purpose I/O PF Group Clock Enable Bit
N     * |        |          |0 = GPIO PF group clock Disabled.
N     * |        |          |1 = GPIO PF group clock Enabled.
N     * @var CLK_T::APBCLK0
N     * Offset: 0x08  APB Devices Clock Enable Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WDTCKEN   |Watchdog Timer Clock Enable Bit (Write Protect)
N     * |        |          |0 = Watchdog Timer Clock Disabled.
N     * |        |          |1 = Watchdog Timer Clock Enabled.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[1]     |RTCCKEN   |Real-time-clock APB Interface Clock Enable Bit
N     * |        |          |This bit is used to control the RTC APB clock only
N     * |        |          |The RTC peripheral clock source is selected from RTCSEL(CLK_CLKSEL2[18]).
N     * |        |          |It can be selected to external 32.768 kHz low speed crystal (LXT) or 10 kHz internal low speed RC oscillator (LIRC).
N     * |        |          |0 = RTC Clock Disabled.
N     * |        |          |1 = RTC Clock Enabled.
N     * |[2]     |TMR0CKEN  |Timer0 Clock Enable Bit
N     * |        |          |0 = Timer0 Clock Disabled.
N     * |        |          |1 = Timer0 Clock Enabled.
N     * |[3]     |TMR1CKEN  |Timer1 Clock Enable Bit
N     * |        |          |0 = Timer1 Clock Disabled.
N     * |        |          |1 = Timer1 Clock Enabled.
N     * |[4]     |TMR2CKEN  |Timer2 Clock Enable Bit
N     * |        |          |0 = Timer2 Clock Disabled.
N     * |        |          |1 = Timer2 Clock Enabled.
N     * |[5]     |TMR3CKEN  |Timer3 Clock Enable Bit
N     * |        |          |0 = Timer3 Clock Disabled.
N     * |        |          |1 = Timer3 Clock Enabled.
N     * |[6]     |CLKOCKEN  |CLKO Clock Enable Bit
N     * |        |          |0 = CLKO Clock Disabled.
N     * |        |          |1 = CLKO Clock Enabled.
N     * |[8]     |I2C0CKEN  |I2C0 Clock Enable Bit
N     * |        |          |0 = I2C0 Clock Disabled.
N     * |        |          |1 = I2C0 Clock Enabled.
N     * |[9]     |I2C1CKEN  |I2C1 Clock Enable Bit
N     * |        |          |0 = I2C1 Clock Disabled.
N     * |        |          |1 = I2C1 Clock Enabled.
N     * |[12]    |SPI0CKEN  |SPI0 Clock Enable Bit
N     * |        |          |0 = SPI0 Clock Disabled.
N     * |        |          |1 = SPI0 Clock Enabled.
N     * |[13]    |SPI1CKEN  |SPI1 Clock Enable Bit
N     * |        |          |0 = SPI1 Clock Disabled.
N     * |        |          |1 = SPI1 Clock Enabled.
N     * |[16]    |UART0CKEN |UART0 Clock Enable Bit
N     * |        |          |0 = UART0 clock Disabled.
N     * |        |          |1 = UART0 clock Enabled.
N     * |[17]    |UART1CKEN |UART1 Clock Enable Bit
N     * |        |          |0 = UART1 clock Disabled.
N     * |        |          |1 = UART1 clock Enabled.
N     * |[18]    |UART2CKEN |UART2 Clock Enable Bit
N     * |        |          |0 = UART2 clock Disabled.
N     * |        |          |1 = UART2 clock Enabled.
N     * |[20]    |PWM0CKEN  |PWM0 Clock Enable Bit
N     * |        |          |0 = PWM0 clock Disabled.
N     * |        |          |1 = PWM0 clock Enabled.
N     * |[21]    |PWM1CKEN  |PWM1 Clock Enable Bit
N     * |        |          |0 = PWM1 clock Disabled.
N     * |        |          |1 = PWM1 clock Enabled.
N     * |[27]    |USBDCKEN  |USB Device Clock Enable Bit
N     * |        |          |0 = USB Device clock Disabled.
N     * |        |          |1 = USB Device clock Enabled.
N     * |[28]    |ADCCKEN   |Analog-digital-converter (ADC) Clock Enable Bit
N     * |        |          |0 = ADC clock Disabled.
N     * |        |          |1 = ADC clock Enabled.
N     * |[30]    |ACMP01CKEN|Analog Comparator 0/1 Clock Enable Bit
N     * |        |          |0 = Analog Comparator 0/1 clock Disabled.
N     * |        |          |1 = Analog Comparator 0/1 clock Enabled.
N     * @var CLK_T::STATUS
N     * Offset: 0x0C  Clock Status Monitor Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |HXTSTB    |HXT Clock Source Stable Flag (Read Only)
N     * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT) clock is not stable or disabled.
N     * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT)clock is stable and enabled.
N     * |[1]     |LXTSTB    |LXT Clock Source Stable Flag (Read Only)
N     * |        |          |0 = 32.768 kHz external low speed crystal oscillator (LXT) clock is not stable or disabled.
N     * |        |          |1 = 32.768 kHz external low speed crystal oscillator (LXT) clock is stabled and enabled.
N     * |[2]     |PLLSTB    |Internal PLL Clock Source Stable Flag (Read Only)
N     * |        |          |0 = Internal PLL clock is not stable or disabled.
N     * |        |          |1 = Internal PLL clock is stable and enabled.
N     * |[3]     |LIRCSTB   |LIRC Clock Source Stable Flag (Read Only)
N     * |        |          |0 = 10 kHz internal low speed RC oscillator (LIRC) clock is not stable or disabled.
N     * |        |          |1 = 10 kHz internal low speed RC oscillator (LIRC) clock is stable and enabled.
N     * |[4]     |HIRCSTB   |HIRC Clock Source Stable Flag (Read Only)
N     * |        |          |0 = 22.1184 MHz internal high speed RC oscillator (HIRC) clock is not stable or disabled.
N     * |        |          |1 = 22.1184 MHz internal high speed RC oscillator (HIRC) clock is stable and enabled.
N     * |[5]     |HIRC48STB |HIRC48 Clock Source Stable Flag (Read Only)
N     * |        |          |0 = 48 MHz internal high speed RC oscillator (HIRC48) clock is not stable or disabled.
N     * |        |          |1 = 48 MHz internal high speed RC oscillator (HIRC48) clock is stable and enabled.
N     * |[7]     |CLKSFAIL  |Clock Switching Fail Flag (Read Only)
N     * |        |          |This bit is updated when software switches system clock source.
N     * |        |          |If switch target clock is stable, this bit will be set to 0.
N     * |        |          |If switch target clock is not stable, this bit will be set to 1.
N     * |        |          |0 = Clock switching success.
N     * |        |          |1 = Clock switching failure.
N     * |        |          |Note: This bit is read only.
N     * |        |          |After selected clock source is stable, hardware will switch system clock to selected clock automatically, and CLKSFAIL will be cleared automatically by hardware.
N     * @var CLK_T::CLKSEL0
N     * Offset: 0x10  Clock Source Select Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |HCLKSEL   |HCLK Clock Source Selection (Write Protect)
N     * |        |          |Before clock switching, the related clock sources (both pre-select and new-select) must be turned on.
N     * |        |          |The default value is reloaded from the value of CFOSC (CONFIG0[26:24]) in user configuration register of Flash controller by any reset.
N     * |        |          |Therefore the default value is either 000b or 111b.
N     * |        |          |000 = Clock source from HXT.
N     * |        |          |001 = Clock source from LXT.
N     * |        |          |010 = Clock source from PLL clock.
N     * |        |          |011 = Clock source from LIRC.
N     * |        |          |100 = Clock source from HIRC48.
N     * |        |          |111 = Clock source from HIRC clock.
N     * |        |          |Others = Reserved.
N     * |        |          |Note: These bits are write protected. Refer to the SYS_REGLCTL register.
N     * |[5:3]   |STCLKSEL  |Cortex-M0 SysTick Clock Source Selection (Write Protect)
N     * |        |          |If SYST_CTRL[2]=0, SysTick uses listed clock source below.
N     * |        |          |000 = Clock source from HXT.
N     * |        |          |001 = Clock source from LXT.
N     * |        |          |010 = Clock source from HXT/2.
N     * |        |          |011 = Clock source from HCLK/2.
N     * |        |          |111 = Clock source from HIRC/2.
N     * |        |          |Note1: if SysTick clock source is not from HCLK (i.e. SYST_CTRL[2] = 0), SysTick clock source must less than or equal to HCLK/2.
N     * |        |          |Note2: These bits are write protected. Refer to the SYS_REGLCTL register.
N     * |[6]     |PCLK0SEL  |PCLK0 Clock Source Selection (Write Protect)
N     * |        |          |0 = APB0 BUS clock source from HCLK.
N     * |        |          |1 = APB0 BUS clock source from HCLK/2.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[7]     |PCLK1SEL  |PCLK1 Clock Source Selection (Write Protect)
N     * |        |          |0 = APB1 BUS clock source from HCLK.
N     * |        |          |1 = APB1 BUS clock source from HCLK/2.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * @var CLK_T::CLKSEL1
N     * Offset: 0x14  Clock Source Select Control Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |WDTSEL    |Watchdog Timer Clock Source Selection (Write Protect)
N     * |        |          |00 = Reserved.
N     * |        |          |01 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT) clock.
N     * |        |          |10 = Clock source from HCLK/2048 clock.
N     * |        |          |11 = Clock source from 10 kHz internal low speed RC oscillator (LIRC) clock.
N     * |        |          |Note: This These bits is are write protected. Refer to the SYS_REGLCTL register.
N     * |[3:2]   |ADCSEL    |ADC Clock Source Selection
N     * |        |          |00 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
N     * |        |          |01 = Clock source from PLL.
N     * |        |          |10 = Clock source from PCLK0.
N     * |        |          |11 = Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC) clock.
N     * |[10:8]  |TMR0SEL   |TIMER0 Clock Source Selection
N     * |        |          |000 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
N     * |        |          |001 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT) clock.
N     * |        |          |010 = Clock source from PCLK0.
N     * |        |          |011 = Clock source from external clock T0 pin.
N     * |        |          |101 = Clock source from 10 kHz internal low speed RC oscillator (LIRC) clock.
N     * |        |          |111 = Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC) clock.
N     * |        |          |Others = Reserved.
N     * |[14:12] |TMR1SEL   |TIMER1 Clock Source Selection
N     * |        |          |000 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
N     * |        |          |001 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT) clock.
N     * |        |          |010 = Clock source from PCLK0.
N     * |        |          |011 = Clock source from external clock T1 pin.
N     * |        |          |101 = Clock source from 10 kHz internal low speed RC oscillator (LIRC) clock.
N     * |        |          |111 = Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC) clock.
N     * |        |          |Others = Reserved.
N     * |[18:16] |TMR2SEL   |TIMER2 Clock Source Selection
N     * |        |          |000 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
N     * |        |          |001 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT) clock.
N     * |        |          |010 = Clock source from PCLK1.
N     * |        |          |011 = Clock source from external clock T2 pin.
N     * |        |          |101 = Clock source from 10 kHz internal low speed RC oscillator (LIRC) clock.
N     * |        |          |111 = Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC) clock.
N     * |        |          |Others = Reserved.
N     * |[22:20] |TMR3SEL   |TIMER3 Clock Source Selection
N     * |        |          |000 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
N     * |        |          |001 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT) clock.
N     * |        |          |010 = Clock source from PCLK1.
N     * |        |          |011 = Clock source from external clock T3 pin.
N     * |        |          |101 = Clock source from 10 kHz internal low speed RC oscillator (LIRC) clock.
N     * |        |          |111 = Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC) clock.
N     * |        |          |Others = Reserved.
N     * |[25:24] |UARTSEL   |UART Clock Source Selection
N     * |        |          |00 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
N     * |        |          |01 = Clock source from PLL clock.
N     * |        |          |10 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT) clock.
N     * |        |          |11 = Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC) clock.
N     * |[28]    |PWM0SEL   |PWM0 Clock Source Selection
N     * |        |          |The peripheral clock source of PWM0 is defined by PWM0SEL.
N     * |        |          |0 = Clock source from PLL clock.
N     * |        |          |1 = Clock source from PCLK0.
N     * |[29]    |PWM1SEL   |PWM1 Clock Source Selection
N     * |        |          |The peripheral clock source of PWM1 is defined by PWM1SEL.
N     * |        |          |0 = Clock source from PLL clock.
N     * |        |          |1 = Clock source from PCLK1.
N     * @var CLK_T::CLKDIV0
N     * Offset: 0x18  Clock Divider Number Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |HCLKDIV   |HCLK Clock Divide Number From HCLK Clock Source
N     * |        |          |HCLK clock frequency = (HCLK clock source frequency) / (HCLKDIV + 1).
N     * |[7:4]   |USBDIV    |USB Clock Divide Number From PLL Clock
N     * |        |          |USB clock frequency = (PLL clock source frequency) / (USBDIV + 1).
N     * |        |          |Note: If the HIRC48 is selected, it is delivery to USB clock directly.
N     * |[11:8]  |UARTDIV   |UART Clock Divide Number From UART Clock Source
N     * |        |          |UART clock frequency = (UART clock source frequency) / (UARTDIV + 1).
N     * |[23:16] |ADCDIV    |ADC Clock Divide Number From ADC Clock Source
N     * |        |          |ADC clock frequency = (ADC clock source frequency) / (ADCDIV + 1).
N     * @var CLK_T::CLKSEL2
N     * Offset: 0x1C  Clock Source Select Control Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4:2]   |CLKOSEL   |Clock Divider Clock Source Selection
N     * |        |          |000 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
N     * |        |          |001 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT) clock.
N     * |        |          |010 = Clock source from HCLK.
N     * |        |          |011 = Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC) clock.
N     * |        |          |100 = Clock source from SOF (USB start of frame event).
N     * |        |          |101 = Clock source from 48 MHz internal high speed RC oscillator (HIRC48) clock.
N     * |        |          |Others = Reserved.
N     * |[17:16] |WWDTSEL   |Window Watchdog Timer Clock Source Selection
N     * |        |          |10 = Clock source from HCLK/2048 clock.
N     * |        |          |11 = Clock source from 10 kHz internal low speed RC oscillator (LIRC).
N     * |        |          |Others = Reserved.
N     * |[18]    |RTCSEL    |RTC Clock Source Selection
N     * |        |          |0 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT).
N     * |        |          |1 = Clock source from 10 kHz internal low speed RC oscillator (LIRC).
N     * |[25:24] |SPI0SEL   |SPI0 Clock Source Selection
N     * |        |          |00 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
N     * |        |          |01 = Clock source from PLL clock.
N     * |        |          |10 = Clock source from PCLK0.
N     * |        |          |11 = Clock source from 48 MHz internal high speed RC oscillator (HIRC48) clock.
N     * |[27:26] |SPI1SEL   |SPI1 Clock Source Selection
N     * |        |          |00 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
N     * |        |          |01 = Clock source from PLL clock.
N     * |        |          |10 = Clock source from PCLK0.
N     * |        |          |11 = Clock source from 48 MHz internal high speed RC oscillator (HIRC48) clock.
N     * @var CLK_T::PLLCTL
N     * Offset: 0x20  PLL Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8:0]   |FBDIV     |PLL Feedback Divider Control
N     * |        |          |Refer to the PLL formulas.
N     * |[13:9]  |INDIV     |PLL Input Divider Control
N     * |        |          |Refer to the PLL formulas.
N     * |[15:14] |OUTDIV    |PLL Output Divider Control
N     * |        |          |Refer to the PLL formulas.
N     * |[16]    |PD        |Power-down Mode
N     * |        |          |If set PDEN(CLK_PWRCTL[7]) bit to 1, the PLL will enter Power-down mode, too.
N     * |        |          |0 = PLL is in normal mode.
N     * |        |          |1 = PLL is in Power-down mode (default).
N     * |[17]    |BP        |PLL Bypass Control
N     * |        |          |0 = PLL is in normal mode (default).
N     * |        |          |1 = PLL clock output is same as PLL input clock.
N     * |[18]    |OE        |PLL OE (FOUT Enable) Control
N     * |        |          |0 = PLL FOUT Enabled.
N     * |        |          |1 = PLL FOUT is fixed low.
N     * |[19]    |PLLSRC    |PLL Source Clock Selection
N     * |        |          |0 = PLL source clock from external 4~24 MHz high-speed crystal (HXT).
N     * |        |          |1 = PLL source clock from internal 22.1184 MHz high-speed oscillator (HIRC).
N     * |[23]    |STBSEL    |PLL Stable Counter Selection
N     * |        |          |0 = PLL stable time is 6144 PLL source clock (suitable for source clock is equal to or less than 12MHz).
N     * |        |          |1 = PLL stable time is 12288 PLL source clock (suitable for source clock is larger than 12MHz).
N     * @var CLK_T::CLKOCTL
N     * Offset: 0x24  Clock Output Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |FREQSEL   |Clock Output Frequency Selection
N     * |        |          |The formula of output frequency is Fout = Fin/2(N+1).
N     * |        |          |Fin is the input clock frequency.
N     * |        |          |Fout is the frequency of divider output clock.
N     * |        |          |N is the 4-bit value of FREQSEL[3:0].
N     * |[4]     |CLKOEN    |Clock Output Enable Bit
N     * |        |          |0 = Clock Output function Disabled.
N     * |        |          |1 = Clock Output function Enabled.
N     * |[5]     |DIV1EN    |Clock Output Divide One Enable Bit
N     * |        |          |0 = Clock Output will output clock with source frequency divided by FREQSEL.
N     * |        |          |1 = Clock Output will output clock with source frequency.
N     * |[6]     |CLK1HZEN  |Clock Output 1Hz Enable Bit
N     * |        |          |0 = 1 Hz clock output for 32.768 kHz external low speed crystal oscillator (LXT) frequency compensation Disabled.
N     * |        |          |1 = 1 Hz clock output for 32.768 kHz external low speed crystal oscillator (LXT) frequency compensation Enabled.
N     * @var CLK_T::APBCLK1
N     * Offset: 0x30  APB Devices Clock Enable Control Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SC0CKEN   |SC0 Clock Enable Bit
N     * |        |          |0 = SC0 Clock Disabled.
N     * |        |          |1 = SC0 Clock Enabled.
N     * |[1]     |SC1CKEN   |SC1 Clock Enable Bit
N     * |        |          |0 = SC1 clock Disabled.
N     * |        |          |1 = SC1 clock Enabled.
N     * |[8]     |USCI0CKEN |USCI0 Clock Enable Bit
N     * |        |          |0 = USCI0 clock Disabled.
N     * |        |          |1 = USCI0 clock Enabled.
N     * |[9]     |USCI1CKEN |USCI1 Clock Enable Bit
N     * |        |          |0 = USCI1 clock Disabled.
N     * |        |          |1 = USCI1 clock Enabled.
N     * |[10]    |USCI2CKEN |USCI2 Clock Enable Bit
N     * |        |          |0 = USCI2 clock Disabled.
N     * |        |          |1 = USCI2 clock Enabled.
N     * @var CLK_T::CLKSEL3
N     * Offset: 0x34  Clock Source Select Control Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |SC0SEL    |SC0 Clock Source Selection
N     * |        |          |00 = Clock source from 4~24 MHz external high speed crystal oscillator(HXT) clock.
N     * |        |          |01 = Clock source from PLL clock.
N     * |        |          |10 = Clock source from PCLK1.
N     * |        |          |11 = Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC) clock.
N     * |[3:2]   |SC1SEL    |SC1 Clock Source Selection
N     * |        |          |00 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
N     * |        |          |01 = Clock source from PLL clock.
N     * |        |          |10 = Clock source from PCLK1.
N     * |        |          |11 = Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC) clock.
N     * |[8]     |USBDSEL   |USBD Clock Source Selection (Write Protect)
N     * |        |          |0 = Clock source from 48MHz internal hight speed RC oscillator (HIRC48) clock.
N     * |        |          |1 = Clock source from PLL clock.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * @var CLK_T::CLKDIV1
N     * Offset: 0x38  Clock Divider Number Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |SC0DIV    |SC0 Clock Divide Number From SC0 Clock Source
N     * |        |          |SC0 clock frequency = (SC0 clock source frequency ) / (SC0DIV + 1).
N     * |[15:8]  |SC1DIV    |SC1 Clock Divide Number From SC1 Clock Source
N     * |        |          |SC1 clock frequency = (SC1 clock source frequency ) / (SC1DIV + 1).
N     * @var CLK_T::BODCLK
N     * Offset: 0x40  Clock Source Select for BOD Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |EBODCKSEL |Clock Source Selection for External BOD
N     * |        |          |The EXTBOD external BOD clock source for detecting external input voltage is defined by EBODCKSEL.
N     * |        |          |0 = Clock source is from 10 kHz internal low speed RC oscillator (LIRC) clock.
N     * |        |          |1 = Clock source is from 32.768 kHz external low speed crystal oscillator (LXT) clock.
N     * |        |          |Note1: If LIRC is selected, LIRCEN (CLK_PWRCTL[3]) must be enabled.
N     * |        |          |Note2: If LXT is selected, LXTEN (CLK_PWRCTL[1]) must be enabled.
N     * @var CLK_T::CLKDCTL
N     * Offset: 0x70  Clock Fail Detector Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4]     |HXTFDEN   |HXT Clock Fail Detector Enable Bit
N     * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT) clock Fail detector Disabled.
N     * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT) clock Fail detector Enabled.
N     * |[5]     |HXTFIEN   |HXT Clock Fail Interrupt Enable Bit
N     * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT)clock Fail interrupt Disabled.
N     * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT)clock Fail interrupt Enabled.
N     * |[12]    |LXTFDEN   |LXT Clock Fail Detector Enable Bit
N     * |        |          |0 = 32.768 kHz external low speed crystal oscillator (LXT) clock Fail detector Disabled.
N     * |        |          |1 = 32.768 kHz external low speed crystal oscillator (LXT) clock Fail detector Enabled.
N     * |[13]    |LXTFIEN   |LXT Clock Fail Interrupt Enable Bit
N     * |        |          |0 = 32.768 kHz external low speed crystal oscillator (LXT) clock Fail interrupt Disabled.
N     * |        |          |1 = 32.768 kHz external low speed crystal oscillator (LXT) clock Fail interrupt Enabled.
N     * |[16]    |HXTFQDEN  |HXT Clock Frequency Monitor Enable Bit
N     * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT) clock frequency monitor Disabled.
N     * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT) clock frequency monitor Enabled.
N     * |[17]    |HXTFQIEN  |HXT Clock Frequency Monitor Interrupt Enable Bit
N     * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT) clock frequency monitor fail interrupt Disabled.
N     * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT) clock frequency monitor fail interrupt Enabled.
N     * @var CLK_T::CLKDSTS
N     * Offset: 0x74  Clock Fail Detector Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |HXTFIF    |HXT Clock Fail Interrupt Flag (Write Protect)
N     * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT) clock normal.
N     * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT) clock stop.
N     * |        |          |Note1: This bit can be cleared to 0 by software writing 1.
N     * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[1]     |LXTFIF    |LXT Clock Fail Interrupt Flag (Write Protect)
N     * |        |          |0 = 32.768 kHz external low speed crystal oscillator (LXT) clock normal.
N     * |        |          |1 = 32.768 kHz external low speed crystal oscillator (LXT) stop.
N     * |        |          |Note1: This bit can be cleared to 0 by software writing 1.
N     * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[8]     |HXTFQIF   |HXT Clock Frequency Monitor Interrupt Flag (Write Protect)
N     * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT) clock normal.
N     * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT) clock frequency abnormal.
N     * |        |          |Note1: This bit can be cleared to 0 by software writing 1.
N     * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * @var CLK_T::CDUPB
N     * Offset: 0x78  Clock Frequency Detector Upper Boundary Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[9:0]   |UPERBD    |HXT Clock Frequency Detector Upper Boundary
N     * |        |          |The bits define the high value of frequency monitor window.
N     * |        |          |When HXT frequency monitor value higher than this register, the HXT frequency detect fail interrupt flag will set to 1.
N     * @var CLK_T::CDLOWB
N     * Offset: 0x7C  Clock Frequency Detector Low Boundary Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[9:0]   |LOWERBD   |HXT Clock Frequency Detector Low Boundary
N     * |        |          |The bits define the low value of frequency monitor window.
N     * |        |          |When HXT frequency monitor value lower than this register, the HXT frequency detect fail interrupt flag will set to 1.
N     */
N
N
N    __IO uint32_t PWRCTL;                /*!< [0x0000] System Power-down Control Register                               */
X    volatile uint32_t PWRCTL;                 
N    __IO uint32_t AHBCLK;                /*!< [0x0004] AHB Devices Clock Enable Control Register                        */
X    volatile uint32_t AHBCLK;                 
N    __IO uint32_t APBCLK0;               /*!< [0x0008] APB Devices Clock Enable Control Register 0                      */
X    volatile uint32_t APBCLK0;                
N    __I  uint32_t STATUS;                /*!< [0x000c] Clock Status Monitor Register                                    */
X    volatile const  uint32_t STATUS;                 
N    __IO uint32_t CLKSEL0;               /*!< [0x0010] Clock Source Select Control Register 0                           */
X    volatile uint32_t CLKSEL0;                
N    __IO uint32_t CLKSEL1;               /*!< [0x0014] Clock Source Select Control Register 1                           */
X    volatile uint32_t CLKSEL1;                
N    __IO uint32_t CLKDIV0;               /*!< [0x0018] Clock Divider Number Register 0                                  */
X    volatile uint32_t CLKDIV0;                
N    __IO uint32_t CLKSEL2;               /*!< [0x001c] Clock Source Select Control Register 2                           */
X    volatile uint32_t CLKSEL2;                
N    __IO uint32_t PLLCTL;                /*!< [0x0020] PLL Control Register                                             */
X    volatile uint32_t PLLCTL;                 
N    __IO uint32_t CLKOCTL;               /*!< [0x0024] Clock Output Control Register                                    */
X    volatile uint32_t CLKOCTL;                
N    __I  uint32_t RESERVE0[2];
X    volatile const  uint32_t RESERVE0[2];
N    __IO uint32_t APBCLK1;               /*!< [0x0030] APB Devices Clock Enable Control Register 1                      */
X    volatile uint32_t APBCLK1;                
N    __IO uint32_t CLKSEL3;               /*!< [0x0034] Clock Source Select Control Register 3                           */
X    volatile uint32_t CLKSEL3;                
N    __IO uint32_t CLKDIV1;               /*!< [0x0038] Clock Divider Number Register 1                                  */
X    volatile uint32_t CLKDIV1;                
N    __I  uint32_t RESERVE1[1];
X    volatile const  uint32_t RESERVE1[1];
N    __IO uint32_t BODCLK;                /*!< [0x0040] Clock Source Select for BOD Control Register                     */
X    volatile uint32_t BODCLK;                 
N    __I  uint32_t RESERVE2[11];
X    volatile const  uint32_t RESERVE2[11];
N    __IO uint32_t CLKDCTL;               /*!< [0x0070] Clock Fail Detector Control Register                             */
X    volatile uint32_t CLKDCTL;                
N    __IO uint32_t CLKDSTS;               /*!< [0x0074] Clock Fail Detector Status Register                              */
X    volatile uint32_t CLKDSTS;                
N    __IO uint32_t CDUPB;                 /*!< [0x0078] Clock Frequency Detector Upper Boundary Register                 */
X    volatile uint32_t CDUPB;                  
N    __IO uint32_t CDLOWB;                /*!< [0x007c] Clock Frequency Detector Low Boundary Register                   */
X    volatile uint32_t CDLOWB;                 
N
N
N} CLK_T;
N
N/**
N    @addtogroup CLK_CONST CLK Bit Field Definition
N    Constant Definitions for CLK Controller
N@{ */
N
N#define CLK_PWRCTL_HXTEN_Pos             (0)                                               /*!< CLK_T::PWRCTL: HXTEN Position          */
N#define CLK_PWRCTL_HXTEN_Msk             (0x1ul << CLK_PWRCTL_HXTEN_Pos)                   /*!< CLK_T::PWRCTL: HXTEN Mask              */
N
N#define CLK_PWRCTL_LXTEN_Pos             (1)                                               /*!< CLK_T::PWRCTL: LXTEN Position          */
N#define CLK_PWRCTL_LXTEN_Msk             (0x1ul << CLK_PWRCTL_LXTEN_Pos)                   /*!< CLK_T::PWRCTL: LXTEN Mask              */
N
N#define CLK_PWRCTL_HIRCEN_Pos            (2)                                               /*!< CLK_T::PWRCTL: HIRCEN Position         */
N#define CLK_PWRCTL_HIRCEN_Msk            (0x1ul << CLK_PWRCTL_HIRCEN_Pos)                  /*!< CLK_T::PWRCTL: HIRCEN Mask             */
N
N#define CLK_PWRCTL_LIRCEN_Pos            (3)                                               /*!< CLK_T::PWRCTL: LIRCEN Position         */
N#define CLK_PWRCTL_LIRCEN_Msk            (0x1ul << CLK_PWRCTL_LIRCEN_Pos)                  /*!< CLK_T::PWRCTL: LIRCEN Mask             */
N
N#define CLK_PWRCTL_PDWKDLY_Pos           (4)                                               /*!< CLK_T::PWRCTL: PDWKDLY Position        */
N#define CLK_PWRCTL_PDWKDLY_Msk           (0x1ul << CLK_PWRCTL_PDWKDLY_Pos)                 /*!< CLK_T::PWRCTL: PDWKDLY Mask            */
N
N#define CLK_PWRCTL_PDWKIEN_Pos           (5)                                               /*!< CLK_T::PWRCTL: PDWKIEN Position        */
N#define CLK_PWRCTL_PDWKIEN_Msk           (0x1ul << CLK_PWRCTL_PDWKIEN_Pos)                 /*!< CLK_T::PWRCTL: PDWKIEN Mask            */
N
N#define CLK_PWRCTL_PDWKIF_Pos            (6)                                               /*!< CLK_T::PWRCTL: PDWKIF Position         */
N#define CLK_PWRCTL_PDWKIF_Msk            (0x1ul << CLK_PWRCTL_PDWKIF_Pos)                  /*!< CLK_T::PWRCTL: PDWKIF Mask             */
N
N#define CLK_PWRCTL_PDEN_Pos              (7)                                               /*!< CLK_T::PWRCTL: PDEN Position           */
N#define CLK_PWRCTL_PDEN_Msk              (0x1ul << CLK_PWRCTL_PDEN_Pos)                    /*!< CLK_T::PWRCTL: PDEN Mask               */
N
N#define CLK_PWRCTL_HXTGAIN_Pos           (10)                                              /*!< CLK_T::PWRCTL: HXTGAIN Position        */
N#define CLK_PWRCTL_HXTGAIN_Msk           (0x3ul << CLK_PWRCTL_HXTGAIN_Pos)                 /*!< CLK_T::PWRCTL: HXTGAIN Mask            */
N
N#define CLK_PWRCTL_HXTSELTYP_Pos         (12)                                              /*!< CLK_T::PWRCTL: HXTSELTYP Position      */
N#define CLK_PWRCTL_HXTSELTYP_Msk         (0x1ul << CLK_PWRCTL_HXTSELTYP_Pos)               /*!< CLK_T::PWRCTL: HXTSELTYP Mask          */
N
N#define CLK_PWRCTL_HIRC48EN_Pos          (13)                                              /*!< CLK_T::PWRCTL: HIRC48EN Position       */
N#define CLK_PWRCTL_HIRC48EN_Msk          (0x1ul << CLK_PWRCTL_HIRC48EN_Pos)                /*!< CLK_T::PWRCTL: HIRC48EN Mask           */
N
N#define CLK_AHBCLK_PDMACKEN_Pos          (1)                                               /*!< CLK_T::AHBCLK: PDMACKEN Position       */
N#define CLK_AHBCLK_PDMACKEN_Msk          (0x1ul << CLK_AHBCLK_PDMACKEN_Pos)                /*!< CLK_T::AHBCLK: PDMACKEN Mask           */
N
N#define CLK_AHBCLK_ISPCKEN_Pos           (2)                                               /*!< CLK_T::AHBCLK: ISPCKEN Position        */
N#define CLK_AHBCLK_ISPCKEN_Msk           (0x1ul << CLK_AHBCLK_ISPCKEN_Pos)                 /*!< CLK_T::AHBCLK: ISPCKEN Mask            */
N
N#define CLK_AHBCLK_EBICKEN_Pos           (3)                                               /*!< CLK_T::AHBCLK: EBICKEN Position        */
N#define CLK_AHBCLK_EBICKEN_Msk           (0x1ul << CLK_AHBCLK_EBICKEN_Pos)                 /*!< CLK_T::AHBCLK: EBICKEN Mask            */
N
N#define CLK_AHBCLK_HDIVCKEN_Pos          (4)                                               /*!< CLK_T::AHBCLK: HDIVCKEN Position       */
N#define CLK_AHBCLK_HDIVCKEN_Msk          (0x1ul << CLK_AHBCLK_HDIVCKEN_Pos)                /*!< CLK_T::AHBCLK: HDIVCKEN Mask           */
N
N#define CLK_AHBCLK_CRCCKEN_Pos           (7)                                               /*!< CLK_T::AHBCLK: CRCCKEN Position        */
N#define CLK_AHBCLK_CRCCKEN_Msk           (0x1ul << CLK_AHBCLK_CRCCKEN_Pos)                 /*!< CLK_T::AHBCLK: CRCCKEN Mask            */
N
N#define CLK_AHBCLK_FMCIDLE_Pos           (15)                                              /*!< CLK_T::AHBCLK: FMCIDLE Position        */
N#define CLK_AHBCLK_FMCIDLE_Msk           (0x1ul << CLK_AHBCLK_FMCIDLE_Pos)                 /*!< CLK_T::AHBCLK: FMCIDLE Mask            */
N
N#define CLK_AHBCLK_GPIOACKEN_Pos         (16)                                              /*!< CLK_T::AHBCLK: GPIOACKEN Position      */
N#define CLK_AHBCLK_GPIOACKEN_Msk         (0x1ul << CLK_AHBCLK_GPIOACKEN_Pos)               /*!< CLK_T::AHBCLK: GPIOACKEN Mask          */
N
N#define CLK_AHBCLK_GPIOBCKEN_Pos         (17)                                              /*!< CLK_T::AHBCLK: GPIOBCKEN Position      */
N#define CLK_AHBCLK_GPIOBCKEN_Msk         (0x1ul << CLK_AHBCLK_GPIOBCKEN_Pos)               /*!< CLK_T::AHBCLK: GPIOBCKEN Mask          */
N
N#define CLK_AHBCLK_GPIOCCKEN_Pos         (18)                                              /*!< CLK_T::AHBCLK: GPIOCCKEN Position      */
N#define CLK_AHBCLK_GPIOCCKEN_Msk         (0x1ul << CLK_AHBCLK_GPIOCCKEN_Pos)               /*!< CLK_T::AHBCLK: GPIOCCKEN Mask          */
N
N#define CLK_AHBCLK_GPIODCKEN_Pos         (19)                                              /*!< CLK_T::AHBCLK: GPIODCKEN Position      */
N#define CLK_AHBCLK_GPIODCKEN_Msk         (0x1ul << CLK_AHBCLK_GPIODCKEN_Pos)               /*!< CLK_T::AHBCLK: GPIODCKEN Mask          */
N
N#define CLK_AHBCLK_GPIOECKEN_Pos         (20)                                              /*!< CLK_T::AHBCLK: GPIOECKEN Position      */
N#define CLK_AHBCLK_GPIOECKEN_Msk         (0x1ul << CLK_AHBCLK_GPIOECKEN_Pos)               /*!< CLK_T::AHBCLK: GPIOECKEN Mask          */
N
N#define CLK_AHBCLK_GPIOFCKEN_Pos         (21)                                              /*!< CLK_T::AHBCLK: GPIOFCKEN Position      */
N#define CLK_AHBCLK_GPIOFCKEN_Msk         (0x1ul << CLK_AHBCLK_GPIOFCKEN_Pos)               /*!< CLK_T::AHBCLK: GPIOFCKEN Mask          */
N
N#define CLK_APBCLK0_WDTCKEN_Pos          (0)                                               /*!< CLK_T::APBCLK0: WDTCKEN Position       */
N#define CLK_APBCLK0_WDTCKEN_Msk          (0x1ul << CLK_APBCLK0_WDTCKEN_Pos)                /*!< CLK_T::APBCLK0: WDTCKEN Mask           */
N
N#define CLK_APBCLK0_RTCCKEN_Pos          (1)                                               /*!< CLK_T::APBCLK0: RTCCKEN Position       */
N#define CLK_APBCLK0_RTCCKEN_Msk          (0x1ul << CLK_APBCLK0_RTCCKEN_Pos)                /*!< CLK_T::APBCLK0: RTCCKEN Mask           */
N
N#define CLK_APBCLK0_TMR0CKEN_Pos         (2)                                               /*!< CLK_T::APBCLK0: TMR0CKEN Position      */
N#define CLK_APBCLK0_TMR0CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR0CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR0CKEN Mask          */
N
N#define CLK_APBCLK0_TMR1CKEN_Pos         (3)                                               /*!< CLK_T::APBCLK0: TMR1CKEN Position      */
N#define CLK_APBCLK0_TMR1CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR1CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR1CKEN Mask          */
N
N#define CLK_APBCLK0_TMR2CKEN_Pos         (4)                                               /*!< CLK_T::APBCLK0: TMR2CKEN Position      */
N#define CLK_APBCLK0_TMR2CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR2CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR2CKEN Mask          */
N
N#define CLK_APBCLK0_TMR3CKEN_Pos         (5)                                               /*!< CLK_T::APBCLK0: TMR3CKEN Position      */
N#define CLK_APBCLK0_TMR3CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR3CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR3CKEN Mask          */
N
N#define CLK_APBCLK0_CLKOCKEN_Pos         (6)                                               /*!< CLK_T::APBCLK0: CLKOCKEN Position      */
N#define CLK_APBCLK0_CLKOCKEN_Msk         (0x1ul << CLK_APBCLK0_CLKOCKEN_Pos)               /*!< CLK_T::APBCLK0: CLKOCKEN Mask          */
N
N#define CLK_APBCLK0_I2C0CKEN_Pos         (8)                                               /*!< CLK_T::APBCLK0: I2C0CKEN Position      */
N#define CLK_APBCLK0_I2C0CKEN_Msk         (0x1ul << CLK_APBCLK0_I2C0CKEN_Pos)               /*!< CLK_T::APBCLK0: I2C0CKEN Mask          */
N
N#define CLK_APBCLK0_I2C1CKEN_Pos         (9)                                               /*!< CLK_T::APBCLK0: I2C1CKEN Position      */
N#define CLK_APBCLK0_I2C1CKEN_Msk         (0x1ul << CLK_APBCLK0_I2C1CKEN_Pos)               /*!< CLK_T::APBCLK0: I2C1CKEN Mask          */
N
N#define CLK_APBCLK0_SPI0CKEN_Pos         (12)                                              /*!< CLK_T::APBCLK0: SPI0CKEN Position      */
N#define CLK_APBCLK0_SPI0CKEN_Msk         (0x1ul << CLK_APBCLK0_SPI0CKEN_Pos)               /*!< CLK_T::APBCLK0: SPI0CKEN Mask          */
N
N#define CLK_APBCLK0_SPI1CKEN_Pos         (13)                                              /*!< CLK_T::APBCLK0: SPI1CKEN Position      */
N#define CLK_APBCLK0_SPI1CKEN_Msk         (0x1ul << CLK_APBCLK0_SPI1CKEN_Pos)               /*!< CLK_T::APBCLK0: SPI1CKEN Mask          */
N
N#define CLK_APBCLK0_UART0CKEN_Pos        (16)                                              /*!< CLK_T::APBCLK0: UART0CKEN Position     */
N#define CLK_APBCLK0_UART0CKEN_Msk        (0x1ul << CLK_APBCLK0_UART0CKEN_Pos)              /*!< CLK_T::APBCLK0: UART0CKEN Mask         */
N
N#define CLK_APBCLK0_UART1CKEN_Pos        (17)                                              /*!< CLK_T::APBCLK0: UART1CKEN Position     */
N#define CLK_APBCLK0_UART1CKEN_Msk        (0x1ul << CLK_APBCLK0_UART1CKEN_Pos)              /*!< CLK_T::APBCLK0: UART1CKEN Mask         */
N
N#define CLK_APBCLK0_UART2CKEN_Pos        (18)                                              /*!< CLK_T::APBCLK0: UART2CKEN Position     */
N#define CLK_APBCLK0_UART2CKEN_Msk        (0x1ul << CLK_APBCLK0_UART2CKEN_Pos)              /*!< CLK_T::APBCLK0: UART2CKEN Mask         */
N
N#define CLK_APBCLK0_PWM0CKEN_Pos         (20)                                              /*!< CLK_T::APBCLK0: PWM0CKEN Position      */
N#define CLK_APBCLK0_PWM0CKEN_Msk         (0x1ul << CLK_APBCLK0_PWM0CKEN_Pos)               /*!< CLK_T::APBCLK0: PWM0CKEN Mask          */
N
N#define CLK_APBCLK0_PWM1CKEN_Pos         (21)                                              /*!< CLK_T::APBCLK0: PWM1CKEN Position      */
N#define CLK_APBCLK0_PWM1CKEN_Msk         (0x1ul << CLK_APBCLK0_PWM1CKEN_Pos)               /*!< CLK_T::APBCLK0: PWM1CKEN Mask          */
N
N#define CLK_APBCLK0_USBDCKEN_Pos         (27)                                              /*!< CLK_T::APBCLK0: USBDCKEN Position      */
N#define CLK_APBCLK0_USBDCKEN_Msk         (0x1ul << CLK_APBCLK0_USBDCKEN_Pos)               /*!< CLK_T::APBCLK0: USBDCKEN Mask          */
N
N#define CLK_APBCLK0_ADCCKEN_Pos          (28)                                              /*!< CLK_T::APBCLK0: ADCCKEN Position       */
N#define CLK_APBCLK0_ADCCKEN_Msk          (0x1ul << CLK_APBCLK0_ADCCKEN_Pos)                /*!< CLK_T::APBCLK0: ADCCKEN Mask           */
N
N#define CLK_APBCLK0_ACMP01CKEN_Pos       (30)                                              /*!< CLK_T::APBCLK0: ACMP01CKEN Position    */
N#define CLK_APBCLK0_ACMP01CKEN_Msk       (0x1ul << CLK_APBCLK0_ACMP01CKEN_Pos)             /*!< CLK_T::APBCLK0: ACMP01CKEN Mask        */
N
N#define CLK_STATUS_HXTSTB_Pos            (0)                                               /*!< CLK_T::STATUS: HXTSTB Position         */
N#define CLK_STATUS_HXTSTB_Msk            (0x1ul << CLK_STATUS_HXTSTB_Pos)                  /*!< CLK_T::STATUS: HXTSTB Mask             */
N
N#define CLK_STATUS_LXTSTB_Pos            (1)                                               /*!< CLK_T::STATUS: LXTSTB Position         */
N#define CLK_STATUS_LXTSTB_Msk            (0x1ul << CLK_STATUS_LXTSTB_Pos)                  /*!< CLK_T::STATUS: LXTSTB Mask             */
N
N#define CLK_STATUS_PLLSTB_Pos            (2)                                               /*!< CLK_T::STATUS: PLLSTB Position         */
N#define CLK_STATUS_PLLSTB_Msk            (0x1ul << CLK_STATUS_PLLSTB_Pos)                  /*!< CLK_T::STATUS: PLLSTB Mask             */
N
N#define CLK_STATUS_LIRCSTB_Pos           (3)                                               /*!< CLK_T::STATUS: LIRCSTB Position        */
N#define CLK_STATUS_LIRCSTB_Msk           (0x1ul << CLK_STATUS_LIRCSTB_Pos)                 /*!< CLK_T::STATUS: LIRCSTB Mask            */
N
N#define CLK_STATUS_HIRCSTB_Pos           (4)                                               /*!< CLK_T::STATUS: HIRCSTB Position        */
N#define CLK_STATUS_HIRCSTB_Msk           (0x1ul << CLK_STATUS_HIRCSTB_Pos)                 /*!< CLK_T::STATUS: HIRCSTB Mask            */
N
N#define CLK_STATUS_HIRC48STB_Pos         (5)                                               /*!< CLK_T::STATUS: HIRC48STB Position      */
N#define CLK_STATUS_HIRC48STB_Msk         (0x1ul << CLK_STATUS_HIRC48STB_Pos)               /*!< CLK_T::STATUS: HIRC48STB Mask          */
N
N#define CLK_STATUS_CLKSFAIL_Pos          (7)                                               /*!< CLK_T::STATUS: CLKSFAIL Position       */
N#define CLK_STATUS_CLKSFAIL_Msk          (0x1ul << CLK_STATUS_CLKSFAIL_Pos)                /*!< CLK_T::STATUS: CLKSFAIL Mask           */
N
N#define CLK_CLKSEL0_HCLKSEL_Pos          (0)                                               /*!< CLK_T::CLKSEL0: HCLKSEL Position       */
N#define CLK_CLKSEL0_HCLKSEL_Msk          (0x7ul << CLK_CLKSEL0_HCLKSEL_Pos)                /*!< CLK_T::CLKSEL0: HCLKSEL Mask           */
N
N#define CLK_CLKSEL0_STCLKSEL_Pos         (3)                                               /*!< CLK_T::CLKSEL0: STCLKSEL Position      */
N#define CLK_CLKSEL0_STCLKSEL_Msk         (0x7ul << CLK_CLKSEL0_STCLKSEL_Pos)               /*!< CLK_T::CLKSEL0: STCLKSEL Mask          */
N
N#define CLK_CLKSEL0_PCLK0SEL_Pos         (6)                                               /*!< CLK_T::CLKSEL0: PCLK0SEL Position      */
N#define CLK_CLKSEL0_PCLK0SEL_Msk         (0x1ul << CLK_CLKSEL0_PCLK0SEL_Pos)               /*!< CLK_T::CLKSEL0: PCLK0SEL Mask          */
N
N#define CLK_CLKSEL0_PCLK1SEL_Pos         (7)                                               /*!< CLK_T::CLKSEL0: PCLK1SEL Position      */
N#define CLK_CLKSEL0_PCLK1SEL_Msk         (0x1ul << CLK_CLKSEL0_PCLK1SEL_Pos)               /*!< CLK_T::CLKSEL0: PCLK1SEL Mask          */
N
N#define CLK_CLKSEL1_WDTSEL_Pos           (0)                                               /*!< CLK_T::CLKSEL1: WDTSEL Position        */
N#define CLK_CLKSEL1_WDTSEL_Msk           (0x3ul << CLK_CLKSEL1_WDTSEL_Pos)                 /*!< CLK_T::CLKSEL1: WDTSEL Mask            */
N
N#define CLK_CLKSEL1_ADCSEL_Pos           (2)                                               /*!< CLK_T::CLKSEL1: ADCSEL Position        */
N#define CLK_CLKSEL1_ADCSEL_Msk           (0x3ul << CLK_CLKSEL1_ADCSEL_Pos)                 /*!< CLK_T::CLKSEL1: ADCSEL Mask            */
N
N#define CLK_CLKSEL1_TMR0SEL_Pos          (8)                                               /*!< CLK_T::CLKSEL1: TMR0SEL Position       */
N#define CLK_CLKSEL1_TMR0SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR0SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR0SEL Mask           */
N
N#define CLK_CLKSEL1_TMR1SEL_Pos          (12)                                              /*!< CLK_T::CLKSEL1: TMR1SEL Position       */
N#define CLK_CLKSEL1_TMR1SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR1SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR1SEL Mask           */
N
N#define CLK_CLKSEL1_TMR2SEL_Pos          (16)                                              /*!< CLK_T::CLKSEL1: TMR2SEL Position       */
N#define CLK_CLKSEL1_TMR2SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR2SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR2SEL Mask           */
N
N#define CLK_CLKSEL1_TMR3SEL_Pos          (20)                                              /*!< CLK_T::CLKSEL1: TMR3SEL Position       */
N#define CLK_CLKSEL1_TMR3SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR3SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR3SEL Mask           */
N
N#define CLK_CLKSEL1_UARTSEL_Pos          (24)                                              /*!< CLK_T::CLKSEL1: UARTSEL Position       */
N#define CLK_CLKSEL1_UARTSEL_Msk          (0x3ul << CLK_CLKSEL1_UARTSEL_Pos)                /*!< CLK_T::CLKSEL1: UARTSEL Mask           */
N
N#define CLK_CLKSEL1_PWM0SEL_Pos          (28)                                              /*!< CLK_T::CLKSEL1: PWM0SEL Position       */
N#define CLK_CLKSEL1_PWM0SEL_Msk          (0x1ul << CLK_CLKSEL1_PWM0SEL_Pos)                /*!< CLK_T::CLKSEL1: PWM0SEL Mask           */
N
N#define CLK_CLKSEL1_PWM1SEL_Pos          (29)                                              /*!< CLK_T::CLKSEL1: PWM1SEL Position       */
N#define CLK_CLKSEL1_PWM1SEL_Msk          (0x1ul << CLK_CLKSEL1_PWM1SEL_Pos)                /*!< CLK_T::CLKSEL1: PWM1SEL Mask           */
N
N#define CLK_CLKDIV0_HCLKDIV_Pos          (0)                                               /*!< CLK_T::CLKDIV0: HCLKDIV Position       */
N#define CLK_CLKDIV0_HCLKDIV_Msk          (0xful << CLK_CLKDIV0_HCLKDIV_Pos)                /*!< CLK_T::CLKDIV0: HCLKDIV Mask           */
N
N#define CLK_CLKDIV0_USBDIV_Pos           (4)                                               /*!< CLK_T::CLKDIV0: USBDIV Position        */
N#define CLK_CLKDIV0_USBDIV_Msk           (0xful << CLK_CLKDIV0_USBDIV_Pos)                 /*!< CLK_T::CLKDIV0: USBDIV Mask            */
N
N#define CLK_CLKDIV0_UARTDIV_Pos          (8)                                               /*!< CLK_T::CLKDIV0: UARTDIV Position       */
N#define CLK_CLKDIV0_UARTDIV_Msk          (0xful << CLK_CLKDIV0_UARTDIV_Pos)                /*!< CLK_T::CLKDIV0: UARTDIV Mask           */
N
N#define CLK_CLKDIV0_ADCDIV_Pos           (16)                                              /*!< CLK_T::CLKDIV0: ADCDIV Position        */
N#define CLK_CLKDIV0_ADCDIV_Msk           (0xfful << CLK_CLKDIV0_ADCDIV_Pos)                /*!< CLK_T::CLKDIV0: ADCDIV Mask            */
N
N#define CLK_CLKSEL2_CLKOSEL_Pos          (2)                                               /*!< CLK_T::CLKSEL2: CLKOSEL Position       */
N#define CLK_CLKSEL2_CLKOSEL_Msk          (0x7ul << CLK_CLKSEL2_CLKOSEL_Pos)                /*!< CLK_T::CLKSEL2: CLKOSEL Mask           */
N
N#define CLK_CLKSEL2_WWDTSEL_Pos          (16)                                              /*!< CLK_T::CLKSEL2: WWDTSEL Position       */
N#define CLK_CLKSEL2_WWDTSEL_Msk          (0x3ul << CLK_CLKSEL2_WWDTSEL_Pos)                /*!< CLK_T::CLKSEL2: WWDTSEL Mask           */
N
N#define CLK_CLKSEL2_RTCSEL_Pos           (18)                                              /*!< CLK_T::CLKSEL2: RTCSEL Position        */
N#define CLK_CLKSEL2_RTCSEL_Msk           (0x1ul << CLK_CLKSEL2_RTCSEL_Pos)                 /*!< CLK_T::CLKSEL2: RTCSEL Mask            */
N
N#define CLK_CLKSEL2_SPI0SEL_Pos          (24)                                              /*!< CLK_T::CLKSEL2: SPI0SEL Position       */
N#define CLK_CLKSEL2_SPI0SEL_Msk          (0x3ul << CLK_CLKSEL2_SPI0SEL_Pos)                /*!< CLK_T::CLKSEL2: SPI0SEL Mask           */
N
N#define CLK_CLKSEL2_SPI1SEL_Pos          (26)                                              /*!< CLK_T::CLKSEL2: SPI1SEL Position       */
N#define CLK_CLKSEL2_SPI1SEL_Msk          (0x3ul << CLK_CLKSEL2_SPI1SEL_Pos)                /*!< CLK_T::CLKSEL2: SPI1SEL Mask           */
N
N#define CLK_PLLCTL_FBDIV_Pos             (0)                                               /*!< CLK_T::PLLCTL: FBDIV Position          */
N#define CLK_PLLCTL_FBDIV_Msk             (0x1fful << CLK_PLLCTL_FBDIV_Pos)                 /*!< CLK_T::PLLCTL: FBDIV Mask              */
N
N#define CLK_PLLCTL_INDIV_Pos             (9)                                               /*!< CLK_T::PLLCTL: INDIV Position          */
N#define CLK_PLLCTL_INDIV_Msk             (0x1ful << CLK_PLLCTL_INDIV_Pos)                  /*!< CLK_T::PLLCTL: INDIV Mask              */
N
N#define CLK_PLLCTL_OUTDIV_Pos            (14)                                              /*!< CLK_T::PLLCTL: OUTDIV Position         */
N#define CLK_PLLCTL_OUTDIV_Msk            (0x3ul << CLK_PLLCTL_OUTDIV_Pos)                  /*!< CLK_T::PLLCTL: OUTDIV Mask             */
N
N#define CLK_PLLCTL_PD_Pos                (16)                                              /*!< CLK_T::PLLCTL: PD Position             */
N#define CLK_PLLCTL_PD_Msk                (0x1ul << CLK_PLLCTL_PD_Pos)                      /*!< CLK_T::PLLCTL: PD Mask                 */
N
N#define CLK_PLLCTL_BP_Pos                (17)                                              /*!< CLK_T::PLLCTL: BP Position             */
N#define CLK_PLLCTL_BP_Msk                (0x1ul << CLK_PLLCTL_BP_Pos)                      /*!< CLK_T::PLLCTL: BP Mask                 */
N
N#define CLK_PLLCTL_OE_Pos                (18)                                              /*!< CLK_T::PLLCTL: OE Position             */
N#define CLK_PLLCTL_OE_Msk                (0x1ul << CLK_PLLCTL_OE_Pos)                      /*!< CLK_T::PLLCTL: OE Mask                 */
N
N#define CLK_PLLCTL_PLLSRC_Pos            (19)                                              /*!< CLK_T::PLLCTL: PLLSRC Position         */
N#define CLK_PLLCTL_PLLSRC_Msk            (0x1ul << CLK_PLLCTL_PLLSRC_Pos)                  /*!< CLK_T::PLLCTL: PLLSRC Mask             */
N
N#define CLK_PLLCTL_STBSEL_Pos            (23)                                              /*!< CLK_T::PLLCTL: STBSEL Position         */
N#define CLK_PLLCTL_STBSEL_Msk            (0x1ul << CLK_PLLCTL_STBSEL_Pos)                  /*!< CLK_T::PLLCTL: STBSEL Mask             */
N
N#define CLK_CLKOCTL_FREQSEL_Pos          (0)                                               /*!< CLK_T::CLKOCTL: FREQSEL Position       */
N#define CLK_CLKOCTL_FREQSEL_Msk          (0xful << CLK_CLKOCTL_FREQSEL_Pos)                /*!< CLK_T::CLKOCTL: FREQSEL Mask           */
N
N#define CLK_CLKOCTL_CLKOEN_Pos           (4)                                               /*!< CLK_T::CLKOCTL: CLKOEN Position        */
N#define CLK_CLKOCTL_CLKOEN_Msk           (0x1ul << CLK_CLKOCTL_CLKOEN_Pos)                 /*!< CLK_T::CLKOCTL: CLKOEN Mask            */
N
N#define CLK_CLKOCTL_DIV1EN_Pos           (5)                                               /*!< CLK_T::CLKOCTL: DIV1EN Position        */
N#define CLK_CLKOCTL_DIV1EN_Msk           (0x1ul << CLK_CLKOCTL_DIV1EN_Pos)                 /*!< CLK_T::CLKOCTL: DIV1EN Mask            */
N
N#define CLK_CLKOCTL_CLK1HZEN_Pos         (6)                                               /*!< CLK_T::CLKOCTL: CLK1HZEN Position      */
N#define CLK_CLKOCTL_CLK1HZEN_Msk         (0x1ul << CLK_CLKOCTL_CLK1HZEN_Pos)               /*!< CLK_T::CLKOCTL: CLK1HZEN Mask          */
N
N#define CLK_APBCLK1_SC0CKEN_Pos          (0)                                               /*!< CLK_T::APBCLK1: SC0CKEN Position       */
N#define CLK_APBCLK1_SC0CKEN_Msk          (0x1ul << CLK_APBCLK1_SC0CKEN_Pos)                /*!< CLK_T::APBCLK1: SC0CKEN Mask           */
N
N#define CLK_APBCLK1_SC1CKEN_Pos          (1)                                               /*!< CLK_T::APBCLK1: SC1CKEN Position       */
N#define CLK_APBCLK1_SC1CKEN_Msk          (0x1ul << CLK_APBCLK1_SC1CKEN_Pos)                /*!< CLK_T::APBCLK1: SC1CKEN Mask           */
N
N#define CLK_APBCLK1_USCI0CKEN_Pos        (8)                                               /*!< CLK_T::APBCLK1: USCI0CKEN Position     */
N#define CLK_APBCLK1_USCI0CKEN_Msk        (0x1ul << CLK_APBCLK1_USCI0CKEN_Pos)              /*!< CLK_T::APBCLK1: USCI0CKEN Mask         */
N
N#define CLK_APBCLK1_USCI1CKEN_Pos        (9)                                               /*!< CLK_T::APBCLK1: USCI1CKEN Position     */
N#define CLK_APBCLK1_USCI1CKEN_Msk        (0x1ul << CLK_APBCLK1_USCI1CKEN_Pos)              /*!< CLK_T::APBCLK1: USCI1CKEN Mask         */
N
N#define CLK_APBCLK1_USCI2CKEN_Pos        (10)                                              /*!< CLK_T::APBCLK1: USCI2CKEN Position     */
N#define CLK_APBCLK1_USCI2CKEN_Msk        (0x1ul << CLK_APBCLK1_USCI2CKEN_Pos)              /*!< CLK_T::APBCLK1: USCI2CKEN Mask         */
N
N#define CLK_CLKSEL3_SC0SEL_Pos           (0)                                               /*!< CLK_T::CLKSEL3: SC0SEL Position        */
N#define CLK_CLKSEL3_SC0SEL_Msk           (0x3ul << CLK_CLKSEL3_SC0SEL_Pos)                 /*!< CLK_T::CLKSEL3: SC0SEL Mask            */
N
N#define CLK_CLKSEL3_SC1SEL_Pos           (2)                                               /*!< CLK_T::CLKSEL3: SC1SEL Position        */
N#define CLK_CLKSEL3_SC1SEL_Msk           (0x3ul << CLK_CLKSEL3_SC1SEL_Pos)                 /*!< CLK_T::CLKSEL3: SC1SEL Mask            */
N
N#define CLK_CLKSEL3_USBDSEL_Pos          (8)                                               /*!< CLK_T::CLKSEL3: USBDSEL Position       */
N#define CLK_CLKSEL3_USBDSEL_Msk          (0x1ul << CLK_CLKSEL3_USBDSEL_Pos)                /*!< CLK_T::CLKSEL3: USBDSEL Mask           */
N
N#define CLK_CLKDIV1_SC0DIV_Pos           (0)                                               /*!< CLK_T::CLKDIV1: SC0DIV Position        */
N#define CLK_CLKDIV1_SC0DIV_Msk           (0xfful << CLK_CLKDIV1_SC0DIV_Pos)                /*!< CLK_T::CLKDIV1: SC0DIV Mask            */
N
N#define CLK_CLKDIV1_SC1DIV_Pos           (8)                                               /*!< CLK_T::CLKDIV1: SC1DIV Position        */
N#define CLK_CLKDIV1_SC1DIV_Msk           (0xfful << CLK_CLKDIV1_SC1DIV_Pos)                /*!< CLK_T::CLKDIV1: SC1DIV Mask            */
N
N#define CLK_BODCLK_EBODCKSEL_Pos         (0)                                               /*!< CLK_T::BODCLK: EBODCKSEL Position      */
N#define CLK_BODCLK_EBODCKSEL_Msk         (0x1ul << CLK_BODCLK_EBODCKSEL_Pos)               /*!< CLK_T::BODCLK: EBODCKSEL Mask          */
N
N#define CLK_CLKDCTL_HXTFDEN_Pos          (4)                                               /*!< CLK_T::CLKDCTL: HXTFDEN Position       */
N#define CLK_CLKDCTL_HXTFDEN_Msk          (0x1ul << CLK_CLKDCTL_HXTFDEN_Pos)                /*!< CLK_T::CLKDCTL: HXTFDEN Mask           */
N
N#define CLK_CLKDCTL_HXTFIEN_Pos          (5)                                               /*!< CLK_T::CLKDCTL: HXTFIEN Position       */
N#define CLK_CLKDCTL_HXTFIEN_Msk          (0x1ul << CLK_CLKDCTL_HXTFIEN_Pos)                /*!< CLK_T::CLKDCTL: HXTFIEN Mask           */
N
N#define CLK_CLKDCTL_LXTFDEN_Pos          (12)                                              /*!< CLK_T::CLKDCTL: LXTFDEN Position       */
N#define CLK_CLKDCTL_LXTFDEN_Msk          (0x1ul << CLK_CLKDCTL_LXTFDEN_Pos)                /*!< CLK_T::CLKDCTL: LXTFDEN Mask           */
N
N#define CLK_CLKDCTL_LXTFIEN_Pos          (13)                                              /*!< CLK_T::CLKDCTL: LXTFIEN Position       */
N#define CLK_CLKDCTL_LXTFIEN_Msk          (0x1ul << CLK_CLKDCTL_LXTFIEN_Pos)                /*!< CLK_T::CLKDCTL: LXTFIEN Mask           */
N
N#define CLK_CLKDCTL_HXTFQDEN_Pos         (16)                                              /*!< CLK_T::CLKDCTL: HXTFQDEN Position      */
N#define CLK_CLKDCTL_HXTFQDEN_Msk         (0x1ul << CLK_CLKDCTL_HXTFQDEN_Pos)               /*!< CLK_T::CLKDCTL: HXTFQDEN Mask          */
N
N#define CLK_CLKDCTL_HXTFQIEN_Pos         (17)                                              /*!< CLK_T::CLKDCTL: HXTFQIEN Position      */
N#define CLK_CLKDCTL_HXTFQIEN_Msk         (0x1ul << CLK_CLKDCTL_HXTFQIEN_Pos)               /*!< CLK_T::CLKDCTL: HXTFQIEN Mask          */
N
N#define CLK_CLKDSTS_HXTFIF_Pos           (0)                                               /*!< CLK_T::CLKDSTS: HXTFIF Position        */
N#define CLK_CLKDSTS_HXTFIF_Msk           (0x1ul << CLK_CLKDSTS_HXTFIF_Pos)                 /*!< CLK_T::CLKDSTS: HXTFIF Mask            */
N
N#define CLK_CLKDSTS_LXTFIF_Pos           (1)                                               /*!< CLK_T::CLKDSTS: LXTFIF Position        */
N#define CLK_CLKDSTS_LXTFIF_Msk           (0x1ul << CLK_CLKDSTS_LXTFIF_Pos)                 /*!< CLK_T::CLKDSTS: LXTFIF Mask            */
N
N#define CLK_CLKDSTS_HXTFQIF_Pos          (8)                                               /*!< CLK_T::CLKDSTS: HXTFQIF Position       */
N#define CLK_CLKDSTS_HXTFQIF_Msk          (0x1ul << CLK_CLKDSTS_HXTFQIF_Pos)                /*!< CLK_T::CLKDSTS: HXTFQIF Mask           */
N
N#define CLK_CDUPB_UPERBD_Pos             (0)                                               /*!< CLK_T::CDUPB: UPERBD Position          */
N#define CLK_CDUPB_UPERBD_Msk             (0x3fful << CLK_CDUPB_UPERBD_Pos)                 /*!< CLK_T::CDUPB: UPERBD Mask              */
N
N#define CLK_CDLOWB_LOWERBD_Pos           (0)                                               /*!< CLK_T::CDLOWB: LOWERBD Position        */
N#define CLK_CDLOWB_LOWERBD_Msk           (0x3fful << CLK_CDLOWB_LOWERBD_Pos)               /*!< CLK_T::CDLOWB: LOWERBD Mask            */
N
N/**@}*/ /* CLK_CONST */
N/**@}*/ /* end of CLK register group */
N
N
N
N/*---------------------- Cyclic Redundancy Check Controller -------------------------*/
N/**
N    @addtogroup CRC Cyclic Redundancy Check Controller(CRC)
N    Memory Mapped Structure for CRC Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var CRC_T::CTL
N     * Offset: 0x00  CRC Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CRCEN     |CRC Channel Generator Enable Bit
N     * |        |          |Set this bit 1 to enable CRC generator for CRC operation.
N     * |        |          |0 = No effect.
N     * |        |          |1 = CRC operation generator is activeEnabled.
N     * |[1]     |CHKSINIT  |CChecksum Initialization
N     * |        |          |Set this bit will auto reolad SEED (CRC_SEED [31:0]) to CHECKSUM (CRC_CHECKSUM[31:0]) as CRC operation initial value.RC Engine Reset
N     * |        |          |0 = No effect.
N     * |        |          |1 = InitialReolad SEED value to CHECKSUM as CRC operation initial value checksum value by auto reloadReset CRC_SEED register value to CRC_CHECKSUM register value.the internal CRC state machine
N     * |        |          |The others contents of CRC_CTL register will not be cleared.
N     * |        |          |Note1: This bit will be cleared automatically
N     * |        |          |Note2: Setting this bit will reload the seed value from CRC_SEED register as checksum initial value.
N     * |[24]    |DATREV    |Write Data Bit Order Reverse Enable Bit
N     * |        |          |This bit is used to enable the bit order reverse function per byte for write data value DATA (CRC_DATA[31:0]) write data value in CRC_DAT register.
N     * |        |          |0 = Bit order reversed for CRC DATACRC write data in Disabled.
N     * |        |          |1 = Bit order reversed for CRC DATACRC write data in Enabled (per byte).
N     * |        |          |Note: If the write data is 0xAABBCCDD, the bit order reverse for CRC write data in is 0x55DD33BB.
N     * |[25]    |CHKSREV   |Checksum Bit Order Reverse Enable Bit
N     * |        |          |This bit is used to enable the bit order reverse function for checksum result CHECKSUM (CRC_CHECKSUM[31:0]) write data value in CRC_CHECKSUM register.
N     * |        |          |0 = Bit order reverse for CRC CHECKSUMCRC checksum Disabled.
N     * |        |          |1 = Bit order reverse for CRC CHECKSUMCRC checksum Enabled.
N     * |        |          |Note: If the checksum result is 0xDD7B0F2E, the bit order reverse result for CRC checksum is 0x74F0DEBB.
N     * |[26]    |DATFMT    |Write Data 1u2019s Complement Enable Bit
N     * |        |          |This bit is used to enable the 1u2019s complement function for write data value DATA (CRC_DATA[31:0]).in CRC_DAT register.
N     * |        |          |0 = 1u2019s complement for CRC CRC writes data inDATA Disabled.
N     * |        |          |1 = 1u2019s complement for CRC DATACRC writes data in Enabled.
N     * |[27]    |CHKSFMT   |Checksum 1u2019s Complement Enable Bit
N     * |        |          |This bit is used to enable the 1u2019s complement function for checksum result in CHECKSUM (CRC_CHECKSUM[31:0]) register.
N     * |        |          |0 = 1u2019s complement for CRC CRC checksumCHECKSUM Disabled.
N     * |        |          |1 = 1u2019s complement for CRC CHECKSUMCRC checksum Enabled.
N     * |[29:28] |DATLEN    |CPU Write Data Length
N     * |        |          |This field indicates the valid write data length of DATA (CRC_DAT[31:0]).
N     * |        |          |00 = Data length is 8-bit mode.
N     * |        |          |01 = Data length is 16-bit mode.
N     * |        |          |1x = Data length is 32-bit mode.
N     * |        |          |Note: When the write data length is 8-bit mode, the valid data in CRC_DAT register is only DATA[7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_DAT register is only DATA[15:0]
N     * |[31:30] |CRCMODE   |CRC Polynomial Mode
N     * |        |          |This field indicates the CRC operation polynomial mode.
N     * |        |          |00 = CRC-CCITT Polynomial mode.
N     * |        |          |01 = CRC-8 Polynomial mode.
N     * |        |          |10 = CRC-16 Polynomial mode.
N     * |        |          |11 = CRC-32 Polynomial mode.
N     * @var CRC_T::DAT
N     * Offset: 0x04  CRC Write Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |DATA      |CRC Write Data Bits
N     * |        |          |User can write data directly by CPU mode or use PDMA function to write data to this field to perform CRC operation.
N     * |        |          |Note: When the write data length is 8-bit mode, the valid data in CRC_DAT register is only DATA[7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_DAT register is only DATA[15:0].
N     * @var CRC_T::SEED
N     * Offset: 0x08  CRC Seed Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |SEED      |CRC Seed Value
N     * |        |          |This field indicates the CRC seed value.
N     * |        |          |Note1: This field SEED value will be reloaded to as checksum initial value CHECKSUM (CRC_CHECKSUM[31:0]) register) a after perform set CRC engine resetCHKSINIT (CRC_CTL[1]) to 1.
N     * |        |          |Note2: The valid bits of CRC_SEED[31:0] is correlated to CRCMODE (CRC_CTL[31:30]).
N     * @var CRC_T::CHECKSUM
N     * Offset: 0x0C  CRC Checksum Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |CHECKSUM  |CRC Checksum Results
N     * |        |          |This field indicates the CRC checksum result.
N     * |        |          |Note: The valid bits of CRC_CHECKSUM[31:0] is correlated to CRCMODE (CRC_CTL[31:30]).
N     */
N    __IO uint32_t CTL;                   /*!< [0x0000] CRC Control Register                                             */
X    volatile uint32_t CTL;                    
N    __IO uint32_t DAT;                   /*!< [0x0004] CRC Write Data Register                                          */
X    volatile uint32_t DAT;                    
N    __IO uint32_t SEED;                  /*!< [0x0008] CRC Seed Register                                                */
X    volatile uint32_t SEED;                   
N    __I  uint32_t CHECKSUM;              /*!< [0x000c] CRC Checksum Register                                            */
X    volatile const  uint32_t CHECKSUM;               
N
N} CRC_T;
N
N/**
N    @addtogroup CRC_CONST CRC Bit Field Definition
N    Constant Definitions for CRC Controller
N@{ */
N
N#define CRC_CTL_CRCEN_Pos                (0)                                               /*!< CRC_T::CTL: CRCEN Position             */
N#define CRC_CTL_CRCEN_Msk                (0x1ul << CRC_CTL_CRCEN_Pos)                      /*!< CRC_T::CTL: CRCEN Mask                 */
N
N#define CRC_CTL_CHKSINIT_Pos             (1)                                               /*!< CRC_T::CTL: CHKSINIT Position          */
N#define CRC_CTL_CHKSINIT_Msk             (0x1ul << CRC_CTL_CHKSINIT_Pos)                   /*!< CRC_T::CTL: CHKSINIT Mask              */
N
N#define CRC_CTL_DATREV_Pos               (24)                                              /*!< CRC_T::CTL: DATREV Position            */
N#define CRC_CTL_DATREV_Msk               (0x1ul << CRC_CTL_DATREV_Pos)                     /*!< CRC_T::CTL: DATREV Mask                */
N
N#define CRC_CTL_CHKSREV_Pos              (25)                                              /*!< CRC_T::CTL: CHKSREV Position           */
N#define CRC_CTL_CHKSREV_Msk              (0x1ul << CRC_CTL_CHKSREV_Pos)                    /*!< CRC_T::CTL: CHKSREV Mask               */
N
N#define CRC_CTL_DATFMT_Pos               (26)                                              /*!< CRC_T::CTL: DATFMT Position            */
N#define CRC_CTL_DATFMT_Msk               (0x1ul << CRC_CTL_DATFMT_Pos)                     /*!< CRC_T::CTL: DATFMT Mask                */
N
N#define CRC_CTL_CHKSFMT_Pos              (27)                                              /*!< CRC_T::CTL: CHKSFMT Position           */
N#define CRC_CTL_CHKSFMT_Msk              (0x1ul << CRC_CTL_CHKSFMT_Pos)                    /*!< CRC_T::CTL: CHKSFMT Mask               */
N
N#define CRC_CTL_DATLEN_Pos               (28)                                              /*!< CRC_T::CTL: DATLEN Position            */
N#define CRC_CTL_DATLEN_Msk               (0x3ul << CRC_CTL_DATLEN_Pos)                     /*!< CRC_T::CTL: DATLEN Mask                */
N
N#define CRC_CTL_CRCMODE_Pos              (30)                                              /*!< CRC_T::CTL: CRCMODE Position           */
N#define CRC_CTL_CRCMODE_Msk              (0x3ul << CRC_CTL_CRCMODE_Pos)                    /*!< CRC_T::CTL: CRCMODE Mask               */
N
N#define CRC_DAT_DATA_Pos                 (0)                                               /*!< CRC_T::DAT: DATA Position              */
N#define CRC_DAT_DATA_Msk                 (0xfffffffful << CRC_DAT_DATA_Pos)                /*!< CRC_T::DAT: DATA Mask                  */
N
N#define CRC_SEED_SEED_Pos                (0)                                               /*!< CRC_T::SEED: SEED Position             */
N#define CRC_SEED_SEED_Msk                (0xfffffffful << CRC_SEED_SEED_Pos)               /*!< CRC_T::SEED: SEED Mask                 */
N
N#define CRC_CHECKSUM_CHECKSUM_Pos        (0)                                               /*!< CRC_T::CHECKSUM: CHECKSUM Position     */
N#define CRC_CHECKSUM_CHECKSUM_Msk        (0xfffffffful << CRC_CHECKSUM_CHECKSUM_Pos)       /*!< CRC_T::CHECKSUM: CHECKSUM Mask         */
N
N/**@}*/ /* CRC_CONST */
N/**@}*/ /* end of CRC register group */
N
N
N/*---------------------- External Bus Interface Controller -------------------------*/
N/**
N    @addtogroup EBI External Bus Interface Controller(EBI)
N    Memory Mapped Structure for EBI Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var EBI_T::CTL0
N     * Offset: 0x00  External Bus Interface Bank0 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |EN        |EBI Enable Bit
N     * |        |          |This bit is the functional enable bit for EBI.
N     * |        |          |0 = EBI function Disabled.
N     * |        |          |1 = EBI function Enabled.
N     * |[1]     |DW16      |EBI Data Width 16-bit Select
N     * |        |          |This bit defines if the EBI data width is 8-bit or 16-bit.
N     * |        |          |0 = EBI data width is 8-bit.
N     * |        |          |1 = EBI data width is 16-bit.
N     * |[2]     |CSPOLINV  |Chip Select Pin Polar Inverse
N     * |        |          |This bit defines the active level of EBI chip select pin (EBI_nCSx), x = 0 or 1..
N     * |        |          |0 = Chip select pin (EBI_nCSx) is active low.
N     * |        |          |1 = Chip select pin (EBI_nCSx) is active high.
N     * |        |          |x = 0, 1
N     * |[4]     |CACCESS   |Continuous Data Access Mode
N     * |        |          |When con ttinuousenuous access mode enabled, the tASU, tALE and tLHD cycles are bypass for continuous data transfer request.
N     * |        |          |0 = Continuous data access mode Disabled.
N     * |        |          |1 = Continuous data access mode Enabled.
N     * |[10:8]  |MCLKDIV   |External Output Clock Divider
N     * |        |          |The frequency of EBI output clock (MCLK) is controlled by MCLKDIV as follow:
N     * |        |          |000 = HCLK/1.
N     * |        |          |001 = HCLK/2.
N     * |        |          |010 = HCLK/4.
N     * |        |          |011 = HCLK/8.
N     * |        |          |100 = HCLK/16.
N     * |        |          |101 = HCLK/32.
N     * |        |          |110 = HCLK/64.
N     * |        |          |111 = HCLK/128.
N     * |[18:16] |TALE      |Extend Time Of of ALE
N     * |        |          |The EBI_ALE high pulse period (tALE) to latch the address can be controlled by TALE.
N     * |        |          |tALE = (TALE + 1)*EBI_MCLK.
N     * |        |          |Note: This field only available in EBI_CTL0 register
N     * |[24]    |WBUFEN    |EBI Write Buffer Enable Bit
N     * |        |          |0 = EBI write buffer Disabled.
N     * |        |          |1 = EBI write buffer Enabled.
N     * |        |          |Note: This bit only available in EBI_CTL0 register
N     * @var EBI_T::TCTL0
N     * Offset: 0x04  External Bus Interface Bank0 Timing Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:3]   |TACC      |EBI Data Access Time
N     * |        |          |TACC define data access time (tACC).
N     * |        |          |tACC = (TACC + 1) * EBI_MCLK.
N     * |[10:8]  |TAHD      |EBI Data Access Hold Time
N     * |        |          |TAHD define data access hold time (tAHD).
N     * |        |          |tAHD = (TAHD + 1) * EBI_MCLK.
N     * |[15:12] |W2X       |Idle Cycle After Write
N     * |        |          |This field defines the number of W2X idle cycle.
N     * |        |          |When write action is finish, W2X idle cycle is inserted and EBI_nCSx return to idle state, x = 0 or 1.
N     * |        |          |W2X idle cycle = (W2X * EBI_MCLK).
N     * |        |          |When write action is finish, W2X idle cycle is inserted and EBI_nCSx return to idle state. (x = 0, 1)
N     * |[22]    |RAHDOFF   |Access Hold Time Disable Control When Read
N     * |        |          |0 = The Data Access Hold Time (tAHD) during EBI reading is Enabled.
N     * |        |          |1 = The Data Access Hold Time (tAHD) during EBI reading is Disabled.
N     * |[23]    |WAHDOFF   |Access Hold Time Disable Control When Write
N     * |        |          |0 = The Data Access Hold Time (tAHD) during EBI writing is Enabled.
N     * |        |          |1 = The Data Access Hold Time (tAHD) during EBI writing is Disabled.
N     * |[27:24] |R2R       |Idle Cycle Between Read-to-read
N     * |        |          |This field defines the number of R2R idle cycle.
N     * |        |          |When read action is finish and next action is going to read, R2R idle cycle is inserted and EBI_nCSx return to idle state, x = 0 or 1.
N     * |        |          |R2R idle cycle = (R2R * EBI_MCLK).
N     * |        |          |When read action is finish and next action is going to read, R2R idle cycle is inserted and EBI_nCSx return to idle state
N     * |        |          |(x = 0, 1)
N     * @var EBI_T::CTL1
N     * Offset: 0x10  External Bus Interface Bank1 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |EN        |EBI Enable Bit
N     * |        |          |This bit is the functional enable bit for EBI.
N     * |        |          |0 = EBI function Disabled.
N     * |        |          |1 = EBI function Enabled.
N     * |[1]     |DW16      |EBI Data Width 16-bit Select
N     * |        |          |This bit defines if the EBI data width is 8-bit or 16-bit.
N     * |        |          |0 = EBI data width is 8-bit.
N     * |        |          |1 = EBI data width is 16-bit.
N     * |[2]     |CSPOLINV  |Chip Select Pin Polar Inverse
N     * |        |          |This bit defines the active level of EBI chip select pin (EBI_nCSx), x = 0 or 1..
N     * |        |          |0 = Chip select pin (EBI_nCSx) is active low.
N     * |        |          |1 = Chip select pin (EBI_nCSx) is active high.
N     * |        |          |x = 0, 1
N     * |[4]     |CACCESS   |Continuous Data Access Mode
N     * |        |          |When con ttinuousenuous access mode enabled, the tASU, tALE and tLHD cycles are bypass for continuous data transfer request.
N     * |        |          |0 = Continuous data access mode Disabled.
N     * |        |          |1 = Continuous data access mode Enabled.
N     * |[10:8]  |MCLKDIV   |External Output Clock Divider
N     * |        |          |The frequency of EBI output clock (MCLK) is controlled by MCLKDIV as follow:
N     * |        |          |000 = HCLK/1.
N     * |        |          |001 = HCLK/2.
N     * |        |          |010 = HCLK/4.
N     * |        |          |011 = HCLK/8.
N     * |        |          |100 = HCLK/16.
N     * |        |          |101 = HCLK/32.
N     * |        |          |110 = HCLK/64.
N     * |        |          |111 = HCLK/128.
N     * |[18:16] |TALE      |Extend Time Of of ALE
N     * |        |          |The EBI_ALE high pulse period (tALE) to latch the address can be controlled by TALE.
N     * |        |          |tALE = (TALE + 1)*EBI_MCLK.
N     * |        |          |Note: This field only available in EBI_CTL0 register
N     * |[24]    |WBUFEN    |EBI Write Buffer Enable Bit
N     * |        |          |0 = EBI write buffer Disabled.
N     * |        |          |1 = EBI write buffer Enabled.
N     * |        |          |Note: This bit only available in EBI_CTL0 register
N     * @var EBI_T::TCTL1
N     * Offset: 0x14  External Bus Interface Bank1 Timing Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:3]   |TACC      |EBI Data Access Time
N     * |        |          |TACC define data access time (tACC).
N     * |        |          |tACC = (TACC + 1) * EBI_MCLK.
N     * |[10:8]  |TAHD      |EBI Data Access Hold Time
N     * |        |          |TAHD define data access hold time (tAHD).
N     * |        |          |tAHD = (TAHD + 1) * EBI_MCLK.
N     * |[15:12] |W2X       |Idle Cycle After Write
N     * |        |          |This field defines the number of W2X idle cycle.
N     * |        |          |When write action is finish, W2X idle cycle is inserted and EBI_nCSx return to idle state, x = 0 or 1.
N     * |        |          |W2X idle cycle = (W2X * EBI_MCLK).
N     * |        |          |When write action is finish, W2X idle cycle is inserted and EBI_nCSx return to idle state. (x = 0, 1)
N     * |[22]    |RAHDOFF   |Access Hold Time Disable Control When Read
N     * |        |          |0 = The Data Access Hold Time (tAHD) during EBI reading is Enabled.
N     * |        |          |1 = The Data Access Hold Time (tAHD) during EBI reading is Disabled.
N     * |[23]    |WAHDOFF   |Access Hold Time Disable Control When Write
N     * |        |          |0 = The Data Access Hold Time (tAHD) during EBI writing is Enabled.
N     * |        |          |1 = The Data Access Hold Time (tAHD) during EBI writing is Disabled.
N     * |[27:24] |R2R       |Idle Cycle Between Read-to-read
N     * |        |          |This field defines the number of R2R idle cycle.
N     * |        |          |When read action is finish and next action is going to read, R2R idle cycle is inserted and EBI_nCSx return to idle state, x = 0 or 1.
N     * |        |          |R2R idle cycle = (R2R * EBI_MCLK).
N     * |        |          |When read action is finish and next action is going to read, R2R idle cycle is inserted and EBI_nCSx return to idle state
N     * |        |          |(x = 0, 1)
N     */
N    __IO uint32_t CTL0;                  /*!< [0x0000] External Bus Interface Bank0 Control Register                    */
X    volatile uint32_t CTL0;                   
N    __IO uint32_t TCTL0;                 /*!< [0x0004] External Bus Interface Bank0 Timing Control Register             */
X    volatile uint32_t TCTL0;                  
N    __I  uint32_t RESERVE0[2];
X    volatile const  uint32_t RESERVE0[2];
N    __IO uint32_t CTL1;                  /*!< [0x0010] External Bus Interface Bank1 Control Register                    */
X    volatile uint32_t CTL1;                   
N    __IO uint32_t TCTL1;                 /*!< [0x0014] External Bus Interface Bank1 Timing Control Register             */
X    volatile uint32_t TCTL1;                  
N
N} EBI_T;
N
N/**
N    @addtogroup EBI_CONST EBI Bit Field Definition
N    Constant Definitions for EBI Controller
N@{ */
N
N#define EBI_CTL_EN_Pos                   (0)                                               /*!< EBI_T::CTL: EN Position                  */
N#define EBI_CTL_EN_Msk                   (0x1ul << EBI_CTL_EN_Pos)                         /*!< EBI_T::CTL: EN Mask                      */
N
N#define EBI_CTL_DW16_Pos                 (1)                                               /*!< EBI_T::CTL: DW16 Position                */
N#define EBI_CTL_DW16_Msk                 (0x1ul << EBI_CTL_DW16_Pos)                       /*!< EBI_T::CTL: DW16 Mask                    */
N
N#define EBI_CTL_CSPOLINV_Pos             (2)                                               /*!< EBI_T::CTL: CSPOLINV Position            */
N#define EBI_CTL_CSPOLINV_Msk             (0x1ul << EBI_CTL_CSPOLINV_Pos)                   /*!< EBI_T::CTL: CSPOLINV Mask                */
N
N#define EBI_CTL_CACCESS_Pos              (4)                                               /*!< EBI_T::CTL: CACCESS Position             */
N#define EBI_CTL_CACCESS_Msk              (0x1ul << EBI_CTL_CACCESS_Pos)                    /*!< EBI_T::CTL: CACCESS Mask                 */
N
N#define EBI_CTL_MCLKDIV_Pos              (8)                                               /*!< EBI_T::CTL: MCLKDIV Position             */
N#define EBI_CTL_MCLKDIV_Msk              (0x7ul << EBI_CTL_MCLKDIV_Pos)                    /*!< EBI_T::CTL: MCLKDIV Mask                 */
N
N#define EBI_CTL_TALE_Pos                 (16)                                              /*!< EBI_T::CTL: TALE Position                */
N#define EBI_CTL_TALE_Msk                 (0x7ul << EBI_CTL_TALE_Pos)                       /*!< EBI_T::CTL: TALE Mask                    */
N
N#define EBI_CTL_WBUFEN_Pos               (24)                                              /*!< EBI_T::CTL: WBUFEN Position              */
N#define EBI_CTL_WBUFEN_Msk               (0x1ul << EBI_CTL_WBUFEN_Pos)                     /*!< EBI_T::CTL: WBUFEN Mask                  */
N
N#define EBI_TCTL_TACC_Pos                (3)                                               /*!< EBI_T::TCTL: TACC Position               */
N#define EBI_TCTL_TACC_Msk                (0x1ful << EBI_TCTL_TACC_Pos)                     /*!< EBI_T::TCTL: TACC Mask                   */
N
N#define EBI_TCTL_TAHD_Pos                (8)                                               /*!< EBI_T::TCTL: TAHD Position               */
N#define EBI_TCTL_TAHD_Msk                (0x7ul << EBI_TCTL_TAHD_Pos)                      /*!< EBI_T::TCTL: TAHD Mask                   */
N
N#define EBI_TCTL_W2X_Pos                 (12)                                              /*!< EBI_T::TCTL: W2X Position                */
N#define EBI_TCTL_W2X_Msk                 (0xful << EBI_TCTL_W2X_Pos)                       /*!< EBI_T::TCTL: W2X Mask                    */
N
N#define EBI_TCTL_RAHDOFF_Pos             (22)                                              /*!< EBI_T::TCTL: RAHDOFF Position            */
N#define EBI_TCTL_RAHDOFF_Msk             (0x1ul << EBI_TCTL_RAHDOFF_Pos)                   /*!< EBI_T::TCTL: RAHDOFF Mask                */
N
N#define EBI_TCTL_WAHDOFF_Pos             (23)                                              /*!< EBI_T::TCTL: WAHDOFF Position            */
N#define EBI_TCTL_WAHDOFF_Msk             (0x1ul << EBI_TCTL_WAHDOFF_Pos)                   /*!< EBI_T::TCTL: WAHDOFF Mask                */
N
N#define EBI_TCTL_R2R_Pos                 (24)                                              /*!< EBI_T::TCTL: R2R Position                */
N#define EBI_TCTL_R2R_Msk                 (0xful << EBI_TCTL_R2R_Pos)                       /*!< EBI_T::TCTL: R2R Mask                    */
N
N/**@}*/ /* EBI_CONST */
N/**@}*/ /* end of EBI register group */
N
N
N/*---------------------- Flash Memory Controller -------------------------*/
N/**
N    @addtogroup FMC Flash Memory Controller(FMC)
N    Memory Mapped Structure for FMC Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var FMC_T::ISPCTL
N     * Offset: 0x00  ISP Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPEN     |ISP Enable Bit (Write Protect)
N     * |        |          |ISP function enable bit. Set this bit to enable ISP function.
N     * |        |          |0 = ISP function Disabled.
N     * |        |          |1 = ISP function Enabled.
N     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
N     * |[1]     |BS        |Boot Select (Write Protect)
N     * |        |          |Set/clear this bit to select next booting from LDROM/APROM, respectively.
N     * |        |          |This bit also functions as chip booting status flag, which can be used to check where chip booted from.
N     * |        |          |This bit is initiated with the inversed value of CBS[1] (CONFIG0[7]) after any reset is happened except CPU reset (CPU is 1) or system reset (SYS) is happened.
N     * |        |          |0 = Booting from APROM.
N     * |        |          |1 = Booting from LDROM.
N     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
N     * |[2]     |SPUEN     |SPROM Update Enable Bit (Write Protect)
N     * |        |          |0 = SPROM cannot be updated.
N     * |        |          |1 = SPROM can be updated.
N     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
N     * |[3]     |APUEN     |APROM Update Enable Bit (Write Protect)
N     * |        |          |0 = APROM cannot be updated when the chip runs in APROM.
N     * |        |          |1 = APROM can be updated when the chip runs in APROM.
N     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
N     * |[4]     |CFGUEN    |CONFIG Update Enable Bit (Write Protect)
N     * |        |          |0 = CONFIG cannot be updated.
N     * |        |          |1 = CONFIG can be updated.
N     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
N     * |[5]     |LDUEN     |LDROM Update Enable Bit (Write Protect)
N     * |        |          |LDROM update enable bit.
N     * |        |          |0 = LDROM cannot be updated.
N     * |        |          |1 = LDROM can be updated.
N     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
N     * |[6]     |ISPFF     |ISP Fail Flag (Write Protect)
N     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N     * |        |          |This bit needs to be cleared by writing 1 to it.
N     * |        |          |(1) APROM writes to itself if APUEN is set to 0.
N     * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
N     * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
N     * |        |          |(4) SPROM is erased/programmed if SPUEN is set to 0.
N     * |        |          |(5) SPROM is programmed at SPROM secured mode.
N     * |        |          |(6) Page Erase command at LOCK mode with ICE connection.
N     * |        |          |(7) Erase or Program command at brown-out detected.
N     * |        |          |(8) Destination address is illegal, such as over an available range.
N     * |        |          |(9) Invalid ISP commands.
N     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
N     * @var FMC_T::ISPADDR
N     * Offset: 0x04  ISP Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPADDR   |ISP Address
N     * |        |          |The NuMicrou00AEu00E4 NUC029xGE series is equipped with embedded flash.
N     * |        |          |ISPADDR[1:0] must be kept 00 for ISP 32-bit operation.
N     * |        |          |ISPADDR[2:0] must be kept 000 for ISP 64-bit operation.
N     * |        |          |For Checksum Calculation command, this field is the flash starting address for checksum calculation, 512 bytes alignment is necessary for checksum calculation.
N     * @var FMC_T::ISPDAT
N     * Offset: 0x08  ISP Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPDAT    |ISP Data
N     * |        |          |Write data to this register before ISP program operation.
N     * |        |          |Read data from this register after ISP read operation.
N     * |        |          |For Run Checksum Calculation command, ISPDAT is the memory size (byte) and 512 bytes alignment.
N     * |        |          |For ISP Read Checksum command, ISPDAT is the checksum result.
N     * |        |          |If ISPDAT = 0x0000_0000, it means that (1) the checksum calculation is in progress, (2) the memory range for checksum calculation is incorrect.
N     * @var FMC_T::ISPCMD
N     * Offset: 0x0C  ISP CMD Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[6:0]   |CMD       |ISP CMD
N     * |        |          |ISP command table is shown below:
N     * |        |          |0x00= FLASH Read.
N     * |        |          |0x40= FLASH 64-bit Read.
N     * |        |          |0x04= Read Unique ID.
N     * |        |          |0x08= Read Flash All-One Result.
N     * |        |          |0x0B= Read Company ID.
N     * |        |          |0x0C= Read Device ID.
N     * |        |          |0x0D= Read Checksum.
N     * |        |          |0x21= FLASH 32-bit Program.
N     * |        |          |0x22= FLASH Page Erase.
N     * |        |          |0x26= FLASH Mass Erase.
N     * |        |          |0x27= FLASH Multi-Word Program.
N     * |        |          |0x28= Run Flash All-One Verification.
N     * |        |          |0x2D= Run Checksum Calculation.
N     * |        |          |0x2E= Vector Remap.
N     * |        |          |0x61= FLASH 64-bit Program.
N     * |        |          |The other commands are invalid.
N     * @var FMC_T::ISPTRG
N     * Offset: 0x10  ISP Trigger Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPGO     |ISP Start Trigger (Write Protect)
N     * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.
N     * |        |          |0 = ISP operation is finished.
N     * |        |          |1 = ISP is progressed.
N     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
N     * @var FMC_T::DFBA
N     * Offset: 0x14  Data Flash Base Address
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |DFBA      |Data Flash Base Address
N     * |        |          |This register indicates Data Flash start address. It is a read only register.
N     * |        |          |The Data Flash is shared with APROM. the content of this register is loaded from CONFIG1.
N     * |        |          |This register is valid when DFEN (CONFIG0[0]) =0 .
N     * @var FMC_T::FTCTL
N     * Offset: 0x18  Flash Access Time Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[6:4]   |FOM       |Frequency Optimization Mode (Write Protect)
N     * |        |          |The NuMicro M0564X series support adjustable flash access timing to optimize the flash access cycles in different working frequency.
N     * |        |          |0x1 = Frequency <= 24MHz.
N     * |        |          |1x1 = Frequency <= 72MHz.
N     * |        |          |Others = Frequency <= 48MHz.
N     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
N     * |[7]     |CACHEOFF  |Flash Cache Disable Control (Write Protect)
N     * |        |          |0 = Flash Cache function Enabled (default).
N     * |        |          |1 = Flash Cache [PT1]function Disabled.
N     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
N     * @var FMC_T::ISPSTS
N     * Offset: 0x40  ISP Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPBUSY   |ISP Busy Flag (Read Only)
N     * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.
N     * |        |          |This bit is the mirror of ISPGO(FMC_ISPTRG[0]).
N     * |        |          |0 = ISP operation is finished.
N     * |        |          |1 = ISP is progressed.
N     * |[2:1]   |CBS       |Boot Selection of CONFIG (Read Only)
N     * |        |          |This bit is initiated with the CBS (CONFIG0[7:6]) after any reset is happened except CPU reset (CPU is 1) or system reset (SYS) is happened.
N     * |        |          |00 = LDROM with IAP mode.
N     * |        |          |01 = LDROM without IAP mode.
N     * |        |          |10 = APROM with IAP mode.
N     * |        |          |11 = APROM without IAP mode.
N     * |[6]     |ISPFF     |ISP Fail Flag (Write Protect)
N     * |        |          |This bit is the mirror of ISPFF (FMC_ISPCTL[6]), it needs to be cleared by writing 1 to FMC_ISPCTL[6] or FMC_ISPSTS[6].
N     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N     * |        |          |(1) APROM writes to itself if APUEN is set to 0.
N     * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
N     * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
N     * |        |          |(4) SPROM is erased/programmed if SPUEN is set to 0.
N     * |        |          |(5) SPROM is programmed at SPROM secured mode.
N     * |        |          |(6) Page Erase command at LOCK mode with ICE connection.
N     * |        |          |(7) Erase or Program command at brown-out detected.
N     * |        |          |(8) Destination address is illegal, such as over an available range.
N     * |        |          |(9) Invalid ISP commands.
N     * |        |          |(10) system vector address is remapped to SPROM.
N     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
N     * |[7]     |ALLONE    |Flash All-one Verification Flag
N     * |        |          |This bit is set by hardware if all of flash bits are 1, and clear if flash bits are not all 1 after "Run Flash All-One Verification" complete; this bit also can be clear by writing 1.
N     * |        |          |0 = Flash bits are not all 1 after "Run Flash All-One Verification" complete.
N     * |        |          |1 = All of flash bits are 1 after "Run Flash All-One Verification" complete.
N     * |[29:9]  |VECMAP    |Vector Page Mapping Address (Read Only)
N     * |        |          |All access to 0x0000_0000~0x0000_01FF is remapped to the flash memory or SRAM address {VECMAP[20:0], 9u2019h000} ~ {VECMAP[20:0], 9u2019h1FF}, except SPROM.
N     * |        |          |VECMAP [20:19] = 00 system vector address is mapped to flash memory.
N     * |        |          |VECMAP [20:19] = 10 system vector address is mapped to SRAM memory.
N     * |        |          |VECMAP [18:12] should be 0.
N     * |[31]    |SCODE     |Security Code Active Flag
N     * |        |          |This bit is set by hardware when detecting SPROM secured code is active at flash initiation, or software writes 1 to this bit to make secured code active; this bit is clear by SPROM page erase operation.
N     * |        |          |0 = Secured code is inactive.
N     * |        |          |1 = Secured code is active.
N     * @var FMC_T::MPDAT0
N     * Offset: 0x80  ISP Data0 Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPDAT0   |ISP Data 0
N     * |        |          |This register is the first 32-bit data for 32-bit/64-bit/multi-word programming, and it is also the mirror of FMC_ISPDAT, both registers keep the same data.
N     * @var FMC_T::MPDAT1
N     * Offset: 0x84  ISP Data1 Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPDAT1   |ISP Data 1
N     * |        |          |This register is the second 32-bit data for 64-bit/multi-word programming.
N     * @var FMC_T::MPDAT2
N     * Offset: 0x88  ISP Data2 Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPDAT2   |ISP Data 2
N     * |        |          |This register is the third 32-bit data for multi-word programming.
N     * @var FMC_T::MPDAT3
N     * Offset: 0x8C  ISP Data3 Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPDAT3   |ISP Data 3
N     * |        |          |This register is the fourth 32-bit data for multi-word programming.
N     * @var FMC_T::MPSTS
N     * Offset: 0xC0  ISP Multi-Program Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |MPBUSY    |ISP Multi-word Program Busy Flag (Read Only)
N     * |        |          |Write 1 to start ISP Multi-Word program operation and this bit will be cleared to 0 by hardware automatically when ISP Multi-Word program operation is finished.
N     * |        |          |This bit is the mirror of ISPGO(FMC_ISPTRG[0]).
N     * |        |          |0 = ISP Multi-Word program operation is finished.
N     * |        |          |1 = ISP Multi-Word program operation is progressed.
N     * |[1]     |PPGO      |ISP Multi-program Status (Read Only)
N     * |        |          |0 = ISP multi-word program operation is not active.
N     * |        |          |1 = ISP multi-word program operation is in progress.
N     * |[2]     |ISPFF     |ISP Fail Flag (Read Only)
N     * |        |          |This bit is the mirror of ISPFF (FMC_ISPCTL[6]), it needs to be cleared by writing 1 to FMC_ISPCTL[6] or FMC_ISPSTS[6].
N     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N     * |        |          |(1) APROM writes to itself if APUEN is set to 0.
N     * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
N     * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
N     * |        |          |(4) Page Erase command at LOCK mode with ICE connection.
N     * |        |          |(5) Erase or Program command at brown-out detected.
N     * |        |          |(6) Destination address is illegal, such as over an available range.
N     * |        |          |(7) Invalid ISP commands.
N     * |[4]     |D0        |ISP DATA 0 Flag (Read Only)
N     * |        |          |This bit is set when FMC_MPDAT0 is written and auto-clear to 0 when the FMC_MPDAT0 data is programmed to flash complete.
N     * |        |          |0 = FMC_MPDAT0 register is empty, or program to flash complete.
N     * |        |          |1 = FMC_MPDAT0 register has been written, and not program to flash complete.
N     * |[5]     |D1        |ISP DATA 1 Flag (Read Only)
N     * |        |          |This bit is set when FMC_MPDAT1 is written and auto-clear to 0 when the FMC_MPDAT1 data is programmed to flash complete.
N     * |        |          |0 = FMC_MPDAT1 register is empty, or program to flash complete.
N     * |        |          |1 = FMC_MPDAT1 register has been written, and not program to flash complete.
N     * |[6]     |D2        |ISP DATA 2 Flag (Read Only)
N     * |        |          |This bit is set when FMC_MPDAT2 is written and auto-clear to 0 when the FMC_MPDAT2 data is programmed to flash complete.
N     * |        |          |0 = FMC_MPDAT2 register is empty, or program to flash complete.
N     * |        |          |1 = FMC_MPDAT2 register has been written, and not program to flash complete.
N     * |[7]     |D3        |ISP DATA 3 Flag (Read Only)
N     * |        |          |This bit is set when FMC_MPDAT3 is written and auto-clear to 0 when the FMC_MPDAT3 data is programmed to flash complete.
N     * |        |          |0 = FMC_MPDAT3 register is empty, or program to flash complete.
N     * |        |          |1 = FMC_MPDAT3 register has been written, and not program to flash complete.
N     * @var FMC_T::MPADDR
N     * Offset: 0xC4  ISP Multi-Program Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |MPADDR    |ISP Multi-word Program Address
N     * |        |          |MPADDR is the address of ISP multi-word program operation when ISPGO flag is 1.
N     * |        |          |MPADDR will keep the final ISP address when ISP multi-word program is complete.
N     */
N
N    __IO uint32_t ISPCTL;                /*!< [0x0000] ISP Control Register                                             */
X    volatile uint32_t ISPCTL;                 
N    __IO uint32_t ISPADDR;               /*!< [0x0004] ISP Address Register                                             */
X    volatile uint32_t ISPADDR;                
N    __IO uint32_t ISPDAT;                /*!< [0x0008] ISP Data Register                                                */
X    volatile uint32_t ISPDAT;                 
N    __IO uint32_t ISPCMD;                /*!< [0x000c] ISP CMD Register                                                 */
X    volatile uint32_t ISPCMD;                 
N    __IO uint32_t ISPTRG;                /*!< [0x0010] ISP Trigger Control Register                                     */
X    volatile uint32_t ISPTRG;                 
N    __I  uint32_t DFBA;                  /*!< [0x0014] Data Flash Base Address                                          */
X    volatile const  uint32_t DFBA;                   
N    __IO uint32_t FTCTL;                 /*!< [0x0018] Flash Access Time Control Register                               */
X    volatile uint32_t FTCTL;                  
N    __I  uint32_t RESERVE0[9];
X    volatile const  uint32_t RESERVE0[9];
N    __IO uint32_t ISPSTS;                /*!< [0x0040] ISP Status Register                                              */
X    volatile uint32_t ISPSTS;                 
N    __I  uint32_t RESERVE1[15];
X    volatile const  uint32_t RESERVE1[15];
N    __IO uint32_t MPDAT0;                /*!< [0x0080] ISP Data0 Register                                               */
X    volatile uint32_t MPDAT0;                 
N    __IO uint32_t MPDAT1;                /*!< [0x0084] ISP Data1 Register                                               */
X    volatile uint32_t MPDAT1;                 
N    __IO uint32_t MPDAT2;                /*!< [0x0088] ISP Data2 Register                                               */
X    volatile uint32_t MPDAT2;                 
N    __IO uint32_t MPDAT3;                /*!< [0x008c] ISP Data3 Register                                               */
X    volatile uint32_t MPDAT3;                 
N    __I  uint32_t RESERVE2[12];
X    volatile const  uint32_t RESERVE2[12];
N    __I  uint32_t MPSTS;                 /*!< [0x00c0] ISP Multi-Program Status Register                                */
X    volatile const  uint32_t MPSTS;                  
N    __I  uint32_t MPADDR;                /*!< [0x00c4] ISP Multi-Program Address Register                               */
X    volatile const  uint32_t MPADDR;                 
N
N} FMC_T;
N
N/**
N    @addtogroup FMC_CONST FMC Bit Field Definition
N    Constant Definitions for FMC Controller
N@{ */
N
N#define FMC_ISPCTL_ISPEN_Pos             (0)                                               /*!< FMC_T::ISPCTL: ISPEN Position          */
N#define FMC_ISPCTL_ISPEN_Msk             (0x1ul << FMC_ISPCTL_ISPEN_Pos)                   /*!< FMC_T::ISPCTL: ISPEN Mask              */
N
N#define FMC_ISPCTL_BS_Pos                (1)                                               /*!< FMC_T::ISPCTL: BS Position             */
N#define FMC_ISPCTL_BS_Msk                (0x1ul << FMC_ISPCTL_BS_Pos)                      /*!< FMC_T::ISPCTL: BS Mask                 */
N
N#define FMC_ISPCTL_SPUEN_Pos             (2)                                               /*!< FMC_T::ISPCTL: SPUEN Position          */
N#define FMC_ISPCTL_SPUEN_Msk             (0x1ul << FMC_ISPCTL_SPUEN_Pos)                   /*!< FMC_T::ISPCTL: SPUEN Mask              */
N
N#define FMC_ISPCTL_APUEN_Pos             (3)                                               /*!< FMC_T::ISPCTL: APUEN Position          */
N#define FMC_ISPCTL_APUEN_Msk             (0x1ul << FMC_ISPCTL_APUEN_Pos)                   /*!< FMC_T::ISPCTL: APUEN Mask              */
N
N#define FMC_ISPCTL_CFGUEN_Pos            (4)                                               /*!< FMC_T::ISPCTL: CFGUEN Position         */
N#define FMC_ISPCTL_CFGUEN_Msk            (0x1ul << FMC_ISPCTL_CFGUEN_Pos)                  /*!< FMC_T::ISPCTL: CFGUEN Mask             */
N
N#define FMC_ISPCTL_LDUEN_Pos             (5)                                               /*!< FMC_T::ISPCTL: LDUEN Position          */
N#define FMC_ISPCTL_LDUEN_Msk             (0x1ul << FMC_ISPCTL_LDUEN_Pos)                   /*!< FMC_T::ISPCTL: LDUEN Mask              */
N
N#define FMC_ISPCTL_ISPFF_Pos             (6)                                               /*!< FMC_T::ISPCTL: ISPFF Position          */
N#define FMC_ISPCTL_ISPFF_Msk             (0x1ul << FMC_ISPCTL_ISPFF_Pos)                   /*!< FMC_T::ISPCTL: ISPFF Mask              */
N
N#define FMC_ISPADDR_ISPADDR_Pos          (0)                                               /*!< FMC_T::ISPADDR: ISPADDR Position       */
N#define FMC_ISPADDR_ISPADDR_Msk          (0xfffffffful << FMC_ISPADDR_ISPADDR_Pos)         /*!< FMC_T::ISPADDR: ISPADDR Mask           */
N
N#define FMC_ISPDAT_ISPDAT_Pos            (0)                                               /*!< FMC_T::ISPDAT: ISPDAT Position         */
N#define FMC_ISPDAT_ISPDAT_Msk            (0xfffffffful << FMC_ISPDAT_ISPDAT_Pos)           /*!< FMC_T::ISPDAT: ISPDAT Mask             */
N
N#define FMC_ISPCMD_CMD_Pos               (0)                                               /*!< FMC_T::ISPCMD: CMD Position            */
N#define FMC_ISPCMD_CMD_Msk               (0x7ful << FMC_ISPCMD_CMD_Pos)                    /*!< FMC_T::ISPCMD: CMD Mask                */
N
N#define FMC_ISPTRG_ISPGO_Pos             (0)                                               /*!< FMC_T::ISPTRG: ISPGO Position          */
N#define FMC_ISPTRG_ISPGO_Msk             (0x1ul << FMC_ISPTRG_ISPGO_Pos)                   /*!< FMC_T::ISPTRG: ISPGO Mask              */
N
N#define FMC_DFBA_DFBA_Pos                (0)                                               /*!< FMC_T::DFBA: DFBA Position             */
N#define FMC_DFBA_DFBA_Msk                (0xfffffffful << FMC_DFBA_DFBA_Pos)               /*!< FMC_T::DFBA: DFBA Mask                 */
N
N#define FMC_FTCTL_FOM_Pos                (4)                                               /*!< FMC_T::FTCTL: FOM Position             */
N#define FMC_FTCTL_FOM_Msk                (0x7ul << FMC_FTCTL_FOM_Pos)                      /*!< FMC_T::FTCTL: FOM Mask                 */
N
N#define FMC_FTCTL_CACHEOFF_Pos           (7)                                               /*!< FMC_T::FTCTL: CACHEOFF Position        */
N#define FMC_FTCTL_CACHEOFF_Msk           (0x1ul << FMC_FTCTL_CACHEOFF_Pos)                 /*!< FMC_T::FTCTL: CACHEOFF Mask            */
N
N#define FMC_ISPSTS_ISPBUSY_Pos           (0)                                               /*!< FMC_T::ISPSTS: ISPBUSY Position        */
N#define FMC_ISPSTS_ISPBUSY_Msk           (0x1ul << FMC_ISPSTS_ISPBUSY_Pos)                 /*!< FMC_T::ISPSTS: ISPBUSY Mask            */
N
N#define FMC_ISPSTS_CBS_Pos               (1)                                               /*!< FMC_T::ISPSTS: CBS Position            */
N#define FMC_ISPSTS_CBS_Msk               (0x3ul << FMC_ISPSTS_CBS_Pos)                     /*!< FMC_T::ISPSTS: CBS Mask                */
N
N#define FMC_ISPSTS_ISPFF_Pos             (6)                                               /*!< FMC_T::ISPSTS: ISPFF Position          */
N#define FMC_ISPSTS_ISPFF_Msk             (0x1ul << FMC_ISPSTS_ISPFF_Pos)                   /*!< FMC_T::ISPSTS: ISPFF Mask              */
N
N#define FMC_ISPSTS_ALLONE_Pos            (7)                                               /*!< FMC_T::ISPSTS: ALLONE Position         */
N#define FMC_ISPSTS_ALLONE_Msk            (0x1ul << FMC_ISPSTS_ALLONE_Pos)                  /*!< FMC_T::ISPSTS: ALLONE Mask             */
N
N#define FMC_ISPSTS_VECMAP_Pos            (9)                                               /*!< FMC_T::ISPSTS: VECMAP Position         */
N#define FMC_ISPSTS_VECMAP_Msk            (0x1ffffful << FMC_ISPSTS_VECMAP_Pos)             /*!< FMC_T::ISPSTS: VECMAP Mask             */
N
N#define FMC_ISPSTS_SCODE_Pos             (31)                                              /*!< FMC_T::ISPSTS: SCODE Position          */
N#define FMC_ISPSTS_SCODE_Msk             (0x1ul << FMC_ISPSTS_SCODE_Pos)                   /*!< FMC_T::ISPSTS: SCODE Mask              */
N
N#define FMC_MPDAT0_ISPDAT0_Pos           (0)                                               /*!< FMC_T::MPDAT0: ISPDAT0 Position        */
N#define FMC_MPDAT0_ISPDAT0_Msk           (0xfffffffful << FMC_MPDAT0_ISPDAT0_Pos)          /*!< FMC_T::MPDAT0: ISPDAT0 Mask            */
N
N#define FMC_MPDAT1_ISPDAT1_Pos           (0)                                               /*!< FMC_T::MPDAT1: ISPDAT1 Position        */
N#define FMC_MPDAT1_ISPDAT1_Msk           (0xfffffffful << FMC_MPDAT1_ISPDAT1_Pos)          /*!< FMC_T::MPDAT1: ISPDAT1 Mask            */
N
N#define FMC_MPDAT2_ISPDAT2_Pos           (0)                                               /*!< FMC_T::MPDAT2: ISPDAT2 Position        */
N#define FMC_MPDAT2_ISPDAT2_Msk           (0xfffffffful << FMC_MPDAT2_ISPDAT2_Pos)          /*!< FMC_T::MPDAT2: ISPDAT2 Mask            */
N
N#define FMC_MPDAT3_ISPDAT3_Pos           (0)                                               /*!< FMC_T::MPDAT3: ISPDAT3 Position        */
N#define FMC_MPDAT3_ISPDAT3_Msk           (0xfffffffful << FMC_MPDAT3_ISPDAT3_Pos)          /*!< FMC_T::MPDAT3: ISPDAT3 Mask            */
N
N#define FMC_MPSTS_MPBUSY_Pos             (0)                                               /*!< FMC_T::MPSTS: MPBUSY Position          */
N#define FMC_MPSTS_MPBUSY_Msk             (0x1ul << FMC_MPSTS_MPBUSY_Pos)                   /*!< FMC_T::MPSTS: MPBUSY Mask              */
N
N#define FMC_MPSTS_PPGO_Pos               (1)                                               /*!< FMC_T::MPSTS: PPGO Position            */
N#define FMC_MPSTS_PPGO_Msk               (0x1ul << FMC_MPSTS_PPGO_Pos)                     /*!< FMC_T::MPSTS: PPGO Mask                */
N
N#define FMC_MPSTS_ISPFF_Pos              (2)                                               /*!< FMC_T::MPSTS: ISPFF Position           */
N#define FMC_MPSTS_ISPFF_Msk              (0x1ul << FMC_MPSTS_ISPFF_Pos)                    /*!< FMC_T::MPSTS: ISPFF Mask               */
N
N#define FMC_MPSTS_D0_Pos                 (4)                                               /*!< FMC_T::MPSTS: D0 Position              */
N#define FMC_MPSTS_D0_Msk                 (0x1ul << FMC_MPSTS_D0_Pos)                       /*!< FMC_T::MPSTS: D0 Mask                  */
N
N#define FMC_MPSTS_D1_Pos                 (5)                                               /*!< FMC_T::MPSTS: D1 Position              */
N#define FMC_MPSTS_D1_Msk                 (0x1ul << FMC_MPSTS_D1_Pos)                       /*!< FMC_T::MPSTS: D1 Mask                  */
N
N#define FMC_MPSTS_D2_Pos                 (6)                                               /*!< FMC_T::MPSTS: D2 Position              */
N#define FMC_MPSTS_D2_Msk                 (0x1ul << FMC_MPSTS_D2_Pos)                       /*!< FMC_T::MPSTS: D2 Mask                  */
N
N#define FMC_MPSTS_D3_Pos                 (7)                                               /*!< FMC_T::MPSTS: D3 Position              */
N#define FMC_MPSTS_D3_Msk                 (0x1ul << FMC_MPSTS_D3_Pos)                       /*!< FMC_T::MPSTS: D3 Mask                  */
N
N#define FMC_MPADDR_MPADDR_Pos            (0)                                               /*!< FMC_T::MPADDR: MPADDR Position         */
N#define FMC_MPADDR_MPADDR_Msk            (0xfffffffful << FMC_MPADDR_MPADDR_Pos)           /*!< FMC_T::MPADDR: MPADDR Mask             */
N
N/**@}*/ /* FMC_CONST */
N/**@}*/ /* end of FMC register group */
N
N
N/*---------------------- General Purpose Input/Output Controller -------------------------*/
N/**
N    @addtogroup GPIO General Purpose Input/Output Controller(GPIO)
N    Memory Mapped Structure for GPIO Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var GPIO_T::MODE
N     * Offset: 0x00/0x40/0x80/0xC0/0x100/0x140  PA-F I/O Mode Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2n+1:2n]|MODEn    |Port A-F I/O Pin[n] Mode Control
N     * |        |          |Determine each I/O mode of Px.n pins.
N     * |        |          |00 = Px.n is in Input mode.
N     * |        |          |01 = Px.n is in Push-pull Output mode.
N     * |        |          |10 = Px.n is in Open-drain Output mode.
N     * |        |          |11 = Px.n is in Quasi-bidirectional mode.
N     * |        |          |Note1: The initial value of this field is defined by CIOINI (CONFIG0 [10]).
N     * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on.
N     * |        |          |If CIOINI is set to 0, the default value is 0x0000_0000 and all pins will be input mode after chip powered on.
N     * |        |          |Note2:
N     * |        |          |Max. n=15 for port A/B/C/D/E.
N     * |        |          |Max. n=7 for port F.
N     * |        |          |Note3: The PE.14/PE.15 pin is ignored.
N     * @var GPIO_T::DINOFF
N     * Offset: 0x04/0x44/0x84/0xC4/0x104/0x144  PA-F Digital Input Path Disable Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[n+16]  |DINOFFn   |Port A-F Pin[n] Digital Input Path Disable Control
N     * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.
N     * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
N     * |        |          |0 = Px.n digital input path Enabled.
N     * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
N     * |        |          |Note1:
N     * |        |          |Max. n=15 for port A/B/C/D/E.
N     * |        |          |Max. n=7 for port F.
N     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
N     * @var GPIO_T::DOUT
N     * Offset: 0x08/0x48/0x88/0xC8/0x108/0x148  PA-F Data Output Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[n]     |DOUTn     |Port A-F Pin[n] Output Value
N     * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
N     * |        |          |Note1:
N     * |        |          |Max. n=15 for port A/B/C/D/E.
N     * |        |          |Max. n=7 for port F.
N     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
N     * @var GPIO_T::DATMSK
N     * Offset: 0x0C/0x4C/0x8C/0xCC/0x10C/0x14C  PA-F Data Output Write Mask
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[n]     |DATMSKn   |Port A-F Pin[n] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.
N     * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.
N     * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
N     * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
N     * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
N     * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
N     * |        |          |Note2:
N     * |        |          |Max. n=15 for port A/B/C/D/E.
N     * |        |          |Max. n=7 for port F.
N     * |        |          |Note3: The PE.14/PE.15 pin is ignored.
N     * @var GPIO_T::PIN
N     * Offset: 0x10/0x50/0x90/0xD0/0x110/0x150  PA-F Pin Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[n]     |PINn      |Port A-F Pin[n] Pin Value
N     * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin.
N     * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
N     * |        |          |Note1:
N     * |        |          |Max. n=15 for port A/B/C/D/E.
N     * |        |          |Max. n=7 for port F.
N     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
N     * @var GPIO_T::DBEN
N     * Offset: 0x14/0x54/0x94/0xD4/0x114/0x154  PA-F De-Bounce Enable Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[n]     |DBEN0     |Port A-F Pin[n] Input Signal De-bounce Enable Bit
N     * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.
N     * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N     * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
N     * |        |          |0 = Px.n de-bounce function Disabled.
N     * |        |          |1 = Px.n de-bounce function Enabled.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N     * |        |          |Note1:
N     * |        |          |Max. n=15 for port A/B/C/D/E.
N     * |        |          |Max. n=7 for port F.
N     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
N     * @var GPIO_T::INTTYPE
N     * Offset: 0x18/0x58/0x98/0xD8/0x118/0x158  PA-F Interrupt Trigger Type Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[n]     |TYPEn     |Port A-F Pin[n] Edge or Level Detection Interrupt Trigger Type Control
N     * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.
N     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
N     * |        |          |0 = Edge trigger interrupt.
N     * |        |          |1 = Level trigger interrupt.
N     * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).
N     * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N     * |        |          |Note1:
N     * |        |          |Max. n=15 for port A/B/C/D/E.
N     * |        |          |Max. n=7 for port F.
N     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
N     * @var GPIO_T::INTEN
N     * Offset: 0x1C/0x5C/0x9C/0xDC/0x11C/0x15C  PA-F Interrupt Enable Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[n]     |FLIENn    |Port 0-5 Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Bit
N     * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
N     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
N     * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
N     * |        |          |0 = Px.n level low or high to low interrupt Disabled.
N     * |        |          |1 = Px.n level low or high to low interrupt Enabled.
N     * |        |          |Note1:
N     * |        |          |Max. n=15 for port A/B/C/D/E.
N     * |        |          |Max. n=7 for port F.
N     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
N     * |[n+16   |RHIENn    |Port A-F Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
N     * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
N     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
N     * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
N     * |        |          |0 = Px.n level high or low to high interrupt Disabled.
N     * |        |          |1 = Px.n level high or low to high interrupt Enabled.
N     * |        |          |Note1:
N     * |        |          |Max. n=15 for port A/B/C/D/E.
N     * |        |          |Max. n=7 for port F.
N     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
N     * @var GPIO_T::INTSRC
N     * Offset: 0x20/0x60/0xA0/0xE0/0x120/0x160  PA-F Interrupt Source Flag
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[n]     |INTSRCn   |Port A-F Pin[n] Interrupt Source Flag
N     * |        |          |Write Operation :
N     * |        |          |0 = No action.
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |Read Operation :
N     * |        |          |0 = No interrupt at Px.n.
N     * |        |          |1 = Px.n generates an interrupt.
N     * |        |          |Note1:
N     * |        |          |Max. n=15 for port A/B/C/D/E.
N     * |        |          |Max. n=7 for port F.
N     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
N     * @var GPIO_T::SMTEN
N     * Offset: 0x24/0x64/0xA4/0xE4/0x124/0x164  PA-F Input Schmitt Trigger Enable
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[n]     |SMTENn    |Port 0-5 Pin[n] Input Schmitt Trigger Enable Bit
N     * |        |          |0 = Px.n input schmitt trigger function Disabled.
N     * |        |          |1 = Px.n input schmitt trigger function Enabled.
N     * |        |          |Note1:
N     * |        |          |Max. n=15 for port A/B/C/D/E.
N     * |        |          |Max. n=7 for port F.
N     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
N     * @var GPIO_T::SLEWCTL
N     * Offset: 0x28/0x68/0xA8/0xE8/0x128/0x168  PA-F High Slew Rate Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[n]     |HSRENn    |Port 0-5 Pin[n] High Slew Rate Control
N     * |        |          |0 = Px.n output with basic slew rate.
N     * |        |          |1 = Px.n output with higher slew rate.
N     * |        |          |Note1:
N     * |        |          |Max. n=15 for port A/B/C/D/E.
N     * |        |          |Max. n=7 for port F.
N     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
N     * @var GPIO_T::DRVCTL
N     * Offset: 0x12C  PE High Drive Strength Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[n]     |HDRVENn   |Port E Pin[n] Driving Strength Control
N     * |        |          |0 = Px.n output with basic driving strength.
N     * |        |          |1 = Px.n output with high driving strength.
N     * |        |          |Note:
N     * |        |          |n=8,9..13 for port E.
N     */
N
N
N    __IO uint32_t MODE;                  /*!< [0x00/0x40/0x80/0xC0/0x100/0x140] PA-F I/O Mode Control                   */
X    volatile uint32_t MODE;                   
N    __IO uint32_t DINOFF;                /*!< [0x04/0x44/0x84/0xC4/0x104/0x144] PA-F Digital Input Path Disable Control */
X    volatile uint32_t DINOFF;                 
N    __IO uint32_t DOUT;                  /*!< [0x08/0x48/0x88/0xC8/0x108/0x148] PA-F Data Output Value                  */
X    volatile uint32_t DOUT;                   
N    __IO uint32_t DATMSK;                /*!< [0x0C/0x4C/0x8C/0xCC/0x10C/0x14C] PA-F Data Output Write Mask             */
X    volatile uint32_t DATMSK;                 
N    __I  uint32_t PIN;                   /*!< [0x10/0x50/0x90/0xD0/0x110/0x150] PA-F Pin Value                          */
X    volatile const  uint32_t PIN;                    
N    __IO uint32_t DBEN;                  /*!< [0x14/0x54/0x94/0xD4/0x114/0x154] PA-F De-Bounce Enable Control           */
X    volatile uint32_t DBEN;                   
N    __IO uint32_t INTTYPE;               /*!< [0x18/0x58/0x98/0xD8/0x118/0x158] PA-F Interrupt Trigger Type Control     */
X    volatile uint32_t INTTYPE;                
N    __IO uint32_t INTEN;                 /*!< [0x1C/0x5C/0x9C/0xDC/0x11C/0x15C] PA-F Interrupt Enable Control           */
X    volatile uint32_t INTEN;                  
N    __IO uint32_t INTSRC;                /*!< [0x20/0x60/0xA0/0xE0/0x120/0x160] PA-F Interrupt Source Flag              */
X    volatile uint32_t INTSRC;                 
N    __IO uint32_t SMTEN;                 /*!< [0x24/0x64/0xA4/0xE4/0x124/0x164] PA-F Input Schmitt Trigger Enable       */
X    volatile uint32_t SMTEN;                  
N    __IO uint32_t SLEWCTL;               /*!< [0x28/0x68/0xA8/0xE8/0x128/0x168] PA-F High Slew Rate Control             */
X    volatile uint32_t SLEWCTL;                
N    __IO uint32_t DRVCTL;                /*!< [0x012c] PE High Drive Strength Control                                   */
X    volatile uint32_t DRVCTL;                 
N
N
N} GPIO_T;
N
N
Ntypedef struct
N{
N
N
N    /**
N     * @var GPIO_DBCTL_T::DBCTL
N     * Offset: 0x180  Interrupt De-bounce Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |DBCLKSEL  |De-bounce Sampling Cycle Selection
N     * |        |          |0000 = Sample interrupt input once per 1 clocks.
N     * |        |          |0001 = Sample interrupt input once per 2 clocks.
N     * |        |          |0010 = Sample interrupt input once per 4 clocks.
N     * |        |          |0011 = Sample interrupt input once per 8 clocks.
N     * |        |          |0100 = Sample interrupt input once per 16 clocks.
N     * |        |          |0101 = Sample interrupt input once per 32 clocks.
N     * |        |          |0110 = Sample interrupt input once per 64 clocks.
N     * |        |          |0111 = Sample interrupt input once per 128 clocks.
N     * |        |          |1000 = Sample interrupt input once per 256 clocks.
N     * |        |          |1001 = Sample interrupt input once per 2*256 clocks.
N     * |        |          |1010 = Sample interrupt input once per 4*256 clocks.
N     * |        |          |1011 = Sample interrupt input once per 8*256 clocks.
N     * |        |          |1100 = Sample interrupt input once per 16*256 clocks.
N     * |        |          |1101 = Sample interrupt input once per 32*256 clocks.
N     * |        |          |1110 = Sample interrupt input once per 64*256 clocks.
N     * |        |          |1111 = Sample interrupt input once per 128*256 clocks.
N     * |[4]     |DBCLKSRC  |De-bounce Counter Clock Source Selection
N     * |        |          |0 = De-bounce counter clock source is the HCLK.
N     * |        |          |1 = De-bounce counter clock source is the internal 10 kHz internal low speed oscillator.
N     * |[5]     |ICLKON    |Interrupt Clock on Mode
N     * |        |          |0 = Edge detection circuit is active only if I/O pin corresponding RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]) bit is set to 1.
N     * |        |          |1 = All I/O pins edge detection circuit is always active after reset.
N     * |        |          |Note: It is recommended to disable this bit to save system power if no special application concern.
N     */
N
N    __IO uint32_t DBCTL;                 /*!< [0x0180] Interrupt De-bounce Control                                      */
X    volatile uint32_t DBCTL;                  
N
N} GPIO_DBCTL_T;
N
N
N
N/**
N    @addtogroup GPIO_CONST GPIO Bit Field Definition
N    Constant Definitions for GPIO Controller
N@{ */
N
N#define GPIO_MODE_MODE0_Pos              (0)                                               /*!< GPIO_T::MODE: MODE0 Position           */
N#define GPIO_MODE_MODE0_Msk              (0x3ul << GPIO_MODE_MODE0_Pos)                    /*!< GPIO_T::MODE: MODE0 Mask               */
N
N#define GPIO_MODE_MODE1_Pos              (2)                                               /*!< GPIO_T::MODE: MODE1 Position           */
N#define GPIO_MODE_MODE1_Msk              (0x3ul << GPIO_MODE_MODE1_Pos)                    /*!< GPIO_T::MODE: MODE1 Mask               */
N
N#define GPIO_MODE_MODE2_Pos              (4)                                               /*!< GPIO_T::MODE: MODE2 Position           */
N#define GPIO_MODE_MODE2_Msk              (0x3ul << GPIO_MODE_MODE2_Pos)                    /*!< GPIO_T::MODE: MODE2 Mask               */
N
N#define GPIO_MODE_MODE3_Pos              (6)                                               /*!< GPIO_T::MODE: MODE3 Position           */
N#define GPIO_MODE_MODE3_Msk              (0x3ul << GPIO_MODE_MODE3_Pos)                    /*!< GPIO_T::MODE: MODE3 Mask               */
N
N#define GPIO_MODE_MODE4_Pos              (8)                                               /*!< GPIO_T::MODE: MODE4 Position           */
N#define GPIO_MODE_MODE4_Msk              (0x3ul << GPIO_MODE_MODE4_Pos)                    /*!< GPIO_T::MODE: MODE4 Mask               */
N
N#define GPIO_MODE_MODE5_Pos              (10)                                              /*!< GPIO_T::MODE: MODE5 Position           */
N#define GPIO_MODE_MODE5_Msk              (0x3ul << GPIO_MODE_MODE5_Pos)                    /*!< GPIO_T::MODE: MODE5 Mask               */
N
N#define GPIO_MODE_MODE6_Pos              (12)                                              /*!< GPIO_T::MODE: MODE6 Position           */
N#define GPIO_MODE_MODE6_Msk              (0x3ul << GPIO_MODE_MODE6_Pos)                    /*!< GPIO_T::MODE: MODE6 Mask               */
N
N#define GPIO_MODE_MODE7_Pos              (14)                                              /*!< GPIO_T::MODE: MODE7 Position           */
N#define GPIO_MODE_MODE7_Msk              (0x3ul << GPIO_MODE_MODE7_Pos)                    /*!< GPIO_T::MODE: MODE7 Mask               */
N
N#define GPIO_MODE_MODE8_Pos              (16)                                              /*!< GPIO_T::MODE: MODE8 Position           */
N#define GPIO_MODE_MODE8_Msk              (0x3ul << GPIO_MODE_MODE8_Pos)                    /*!< GPIO_T::MODE: MODE8 Mask               */
N
N#define GPIO_MODE_MODE9_Pos              (18)                                              /*!< GPIO_T::MODE: MODE9 Position           */
N#define GPIO_MODE_MODE9_Msk              (0x3ul << GPIO_MODE_MODE9_Pos)                    /*!< GPIO_T::MODE: MODE9 Mask               */
N
N#define GPIO_MODE_MODE10_Pos             (20)                                              /*!< GPIO_T::MODE: MODE10 Position          */
N#define GPIO_MODE_MODE10_Msk             (0x3ul << GPIO_MODE_MODE10_Pos)                   /*!< GPIO_T::MODE: MODE10 Mask              */
N
N#define GPIO_MODE_MODE11_Pos             (22)                                              /*!< GPIO_T::MODE: MODE11 Position          */
N#define GPIO_MODE_MODE11_Msk             (0x3ul << GPIO_MODE_MODE11_Pos)                   /*!< GPIO_T::MODE: MODE11 Mask              */
N
N#define GPIO_MODE_MODE12_Pos             (24)                                              /*!< GPIO_T::MODE: MODE12 Position          */
N#define GPIO_MODE_MODE12_Msk             (0x3ul << GPIO_MODE_MODE12_Pos)                   /*!< GPIO_T::MODE: MODE12 Mask              */
N
N#define GPIO_MODE_MODE13_Pos             (26)                                              /*!< GPIO_T::MODE: MODE13 Position          */
N#define GPIO_MODE_MODE13_Msk             (0x3ul << GPIO_MODE_MODE13_Pos)                   /*!< GPIO_T::MODE: MODE13 Mask              */
N
N#define GPIO_MODE_MODE14_Pos             (28)                                              /*!< GPIO_T::MODE: MODE14 Position          */
N#define GPIO_MODE_MODE14_Msk             (0x3ul << GPIO_MODE_MODE14_Pos)                   /*!< GPIO_T::MODE: MODE14 Mask              */
N
N#define GPIO_MODE_MODE15_Pos             (30)                                              /*!< GPIO_T::MODE: MODE15 Position          */
N#define GPIO_MODE_MODE15_Msk             (0x3ul << GPIO_MODE_MODE15_Pos)                   /*!< GPIO_T::MODE: MODE15 Mask              */
N
N#define GPIO_DINOFF_DINOFF0_Pos          (16)                                              /*!< GPIO_T::DINOFF: DINOFF0 Position       */
N#define GPIO_DINOFF_DINOFF0_Msk          (0x1ul << GPIO_DINOFF_DINOFF0_Pos)                /*!< GPIO_T::DINOFF: DINOFF0 Mask           */
N
N#define GPIO_DINOFF_DINOFF1_Pos          (17)                                              /*!< GPIO_T::DINOFF: DINOFF1 Position       */
N#define GPIO_DINOFF_DINOFF1_Msk          (0x1ul << GPIO_DINOFF_DINOFF1_Pos)                /*!< GPIO_T::DINOFF: DINOFF1 Mask           */
N
N#define GPIO_DINOFF_DINOFF2_Pos          (18)                                              /*!< GPIO_T::DINOFF: DINOFF2 Position       */
N#define GPIO_DINOFF_DINOFF2_Msk          (0x1ul << GPIO_DINOFF_DINOFF2_Pos)                /*!< GPIO_T::DINOFF: DINOFF2 Mask           */
N
N#define GPIO_DINOFF_DINOFF3_Pos          (19)                                              /*!< GPIO_T::DINOFF: DINOFF3 Position       */
N#define GPIO_DINOFF_DINOFF3_Msk          (0x1ul << GPIO_DINOFF_DINOFF3_Pos)                /*!< GPIO_T::DINOFF: DINOFF3 Mask           */
N
N#define GPIO_DINOFF_DINOFF4_Pos          (20)                                              /*!< GPIO_T::DINOFF: DINOFF4 Position       */
N#define GPIO_DINOFF_DINOFF4_Msk          (0x1ul << GPIO_DINOFF_DINOFF4_Pos)                /*!< GPIO_T::DINOFF: DINOFF4 Mask           */
N
N#define GPIO_DINOFF_DINOFF5_Pos          (21)                                              /*!< GPIO_T::DINOFF: DINOFF5 Position       */
N#define GPIO_DINOFF_DINOFF5_Msk          (0x1ul << GPIO_DINOFF_DINOFF5_Pos)                /*!< GPIO_T::DINOFF: DINOFF5 Mask           */
N
N#define GPIO_DINOFF_DINOFF6_Pos          (22)                                              /*!< GPIO_T::DINOFF: DINOFF6 Position       */
N#define GPIO_DINOFF_DINOFF6_Msk          (0x1ul << GPIO_DINOFF_DINOFF6_Pos)                /*!< GPIO_T::DINOFF: DINOFF6 Mask           */
N
N#define GPIO_DINOFF_DINOFF7_Pos          (23)                                              /*!< GPIO_T::DINOFF: DINOFF7 Position       */
N#define GPIO_DINOFF_DINOFF7_Msk          (0x1ul << GPIO_DINOFF_DINOFF7_Pos)                /*!< GPIO_T::DINOFF: DINOFF7 Mask           */
N
N#define GPIO_DINOFF_DINOFF8_Pos          (24)                                              /*!< GPIO_T::DINOFF: DINOFF8 Position       */
N#define GPIO_DINOFF_DINOFF8_Msk          (0x1ul << GPIO_DINOFF_DINOFF8_Pos)                /*!< GPIO_T::DINOFF: DINOFF8 Mask           */
N
N#define GPIO_DINOFF_DINOFF9_Pos          (25)                                              /*!< GPIO_T::DINOFF: DINOFF9 Position       */
N#define GPIO_DINOFF_DINOFF9_Msk          (0x1ul << GPIO_DINOFF_DINOFF9_Pos)                /*!< GPIO_T::DINOFF: DINOFF9 Mask           */
N
N#define GPIO_DINOFF_DINOFF10_Pos         (26)                                              /*!< GPIO_T::DINOFF: DINOFF10 Position      */
N#define GPIO_DINOFF_DINOFF10_Msk         (0x1ul << GPIO_DINOFF_DINOFF10_Pos)               /*!< GPIO_T::DINOFF: DINOFF10 Mask          */
N
N#define GPIO_DINOFF_DINOFF11_Pos         (27)                                              /*!< GPIO_T::DINOFF: DINOFF11 Position      */
N#define GPIO_DINOFF_DINOFF11_Msk         (0x1ul << GPIO_DINOFF_DINOFF11_Pos)               /*!< GPIO_T::DINOFF: DINOFF11 Mask          */
N
N#define GPIO_DINOFF_DINOFF12_Pos         (28)                                              /*!< GPIO_T::DINOFF: DINOFF12 Position      */
N#define GPIO_DINOFF_DINOFF12_Msk         (0x1ul << GPIO_DINOFF_DINOFF12_Pos)               /*!< GPIO_T::DINOFF: DINOFF12 Mask          */
N
N#define GPIO_DINOFF_DINOFF13_Pos         (29)                                              /*!< GPIO_T::DINOFF: DINOFF13 Position      */
N#define GPIO_DINOFF_DINOFF13_Msk         (0x1ul << GPIO_DINOFF_DINOFF13_Pos)               /*!< GPIO_T::DINOFF: DINOFF13 Mask          */
N
N#define GPIO_DINOFF_DINOFF14_Pos         (30)                                              /*!< GPIO_T::DINOFF: DINOFF14 Position      */
N#define GPIO_DINOFF_DINOFF14_Msk         (0x1ul << GPIO_DINOFF_DINOFF14_Pos)               /*!< GPIO_T::DINOFF: DINOFF14 Mask          */
N
N#define GPIO_DINOFF_DINOFF15_Pos         (31)                                              /*!< GPIO_T::DINOFF: DINOFF15 Position      */
N#define GPIO_DINOFF_DINOFF15_Msk         (0x1ul << GPIO_DINOFF_DINOFF15_Pos)               /*!< GPIO_T::DINOFF: DINOFF15 Mask          */
N
N#define GPIO_DOUT_DOUT0_Pos              (0)                                               /*!< GPIO_T::DOUT: DOUT0 Position           */
N#define GPIO_DOUT_DOUT0_Msk              (0x1ul << GPIO_DOUT_DOUT0_Pos)                    /*!< GPIO_T::DOUT: DOUT0 Mask               */
N
N#define GPIO_DOUT_DOUT1_Pos              (1)                                               /*!< GPIO_T::DOUT: DOUT1 Position           */
N#define GPIO_DOUT_DOUT1_Msk              (0x1ul << GPIO_DOUT_DOUT1_Pos)                    /*!< GPIO_T::DOUT: DOUT1 Mask               */
N
N#define GPIO_DOUT_DOUT2_Pos              (2)                                               /*!< GPIO_T::DOUT: DOUT2 Position           */
N#define GPIO_DOUT_DOUT2_Msk              (0x1ul << GPIO_DOUT_DOUT2_Pos)                    /*!< GPIO_T::DOUT: DOUT2 Mask               */
N
N#define GPIO_DOUT_DOUT3_Pos              (3)                                               /*!< GPIO_T::DOUT: DOUT3 Position           */
N#define GPIO_DOUT_DOUT3_Msk              (0x1ul << GPIO_DOUT_DOUT3_Pos)                    /*!< GPIO_T::DOUT: DOUT3 Mask               */
N
N#define GPIO_DOUT_DOUT4_Pos              (4)                                               /*!< GPIO_T::DOUT: DOUT4 Position           */
N#define GPIO_DOUT_DOUT4_Msk              (0x1ul << GPIO_DOUT_DOUT4_Pos)                    /*!< GPIO_T::DOUT: DOUT4 Mask               */
N
N#define GPIO_DOUT_DOUT5_Pos              (5)                                               /*!< GPIO_T::DOUT: DOUT5 Position           */
N#define GPIO_DOUT_DOUT5_Msk              (0x1ul << GPIO_DOUT_DOUT5_Pos)                    /*!< GPIO_T::DOUT: DOUT5 Mask               */
N
N#define GPIO_DOUT_DOUT6_Pos              (6)                                               /*!< GPIO_T::DOUT: DOUT6 Position           */
N#define GPIO_DOUT_DOUT6_Msk              (0x1ul << GPIO_DOUT_DOUT6_Pos)                    /*!< GPIO_T::DOUT: DOUT6 Mask               */
N
N#define GPIO_DOUT_DOUT7_Pos              (7)                                               /*!< GPIO_T::DOUT: DOUT7 Position           */
N#define GPIO_DOUT_DOUT7_Msk              (0x1ul << GPIO_DOUT_DOUT7_Pos)                    /*!< GPIO_T::DOUT: DOUT7 Mask               */
N
N#define GPIO_DOUT_DOUT8_Pos              (8)                                               /*!< GPIO_T::DOUT: DOUT8 Position           */
N#define GPIO_DOUT_DOUT8_Msk              (0x1ul << GPIO_DOUT_DOUT8_Pos)                    /*!< GPIO_T::DOUT: DOUT8 Mask               */
N
N#define GPIO_DOUT_DOUT9_Pos              (9)                                               /*!< GPIO_T::DOUT: DOUT9 Position           */
N#define GPIO_DOUT_DOUT9_Msk              (0x1ul << GPIO_DOUT_DOUT9_Pos)                    /*!< GPIO_T::DOUT: DOUT9 Mask               */
N
N#define GPIO_DOUT_DOUT10_Pos             (10)                                              /*!< GPIO_T::DOUT: DOUT10 Position          */
N#define GPIO_DOUT_DOUT10_Msk             (0x1ul << GPIO_DOUT_DOUT10_Pos)                   /*!< GPIO_T::DOUT: DOUT10 Mask              */
N
N#define GPIO_DOUT_DOUT11_Pos             (11)                                              /*!< GPIO_T::DOUT: DOUT11 Position          */
N#define GPIO_DOUT_DOUT11_Msk             (0x1ul << GPIO_DOUT_DOUT11_Pos)                   /*!< GPIO_T::DOUT: DOUT11 Mask              */
N
N#define GPIO_DOUT_DOUT12_Pos             (12)                                              /*!< GPIO_T::DOUT: DOUT12 Position          */
N#define GPIO_DOUT_DOUT12_Msk             (0x1ul << GPIO_DOUT_DOUT12_Pos)                   /*!< GPIO_T::DOUT: DOUT12 Mask              */
N
N#define GPIO_DOUT_DOUT13_Pos             (13)                                              /*!< GPIO_T::DOUT: DOUT13 Position          */
N#define GPIO_DOUT_DOUT13_Msk             (0x1ul << GPIO_DOUT_DOUT13_Pos)                   /*!< GPIO_T::DOUT: DOUT13 Mask              */
N
N#define GPIO_DOUT_DOUT14_Pos             (14)                                              /*!< GPIO_T::DOUT: DOUT14 Position          */
N#define GPIO_DOUT_DOUT14_Msk             (0x1ul << GPIO_DOUT_DOUT14_Pos)                   /*!< GPIO_T::DOUT: DOUT14 Mask              */
N
N#define GPIO_DOUT_DOUT15_Pos             (15)                                              /*!< GPIO_T::DOUT: DOUT15 Position          */
N#define GPIO_DOUT_DOUT15_Msk             (0x1ul << GPIO_DOUT_DOUT15_Pos)                   /*!< GPIO_T::DOUT: DOUT15 Mask              */
N
N#define GPIO_DATMSK_DATMSK0_Pos          (0)                                               /*!< GPIO_T::DATMSK: DATMSK0 Position       */
N#define GPIO_DATMSK_DATMSK0_Msk          (0x1ul << GPIO_DATMSK_DATMSK0_Pos)                /*!< GPIO_T::DATMSK: DATMSK0 Mask           */
N
N#define GPIO_DATMSK_DATMSK1_Pos          (1)                                               /*!< GPIO_T::DATMSK: DATMSK1 Position       */
N#define GPIO_DATMSK_DATMSK1_Msk          (0x1ul << GPIO_DATMSK_DATMSK1_Pos)                /*!< GPIO_T::DATMSK: DATMSK1 Mask           */
N
N#define GPIO_DATMSK_DATMSK2_Pos          (2)                                               /*!< GPIO_T::DATMSK: DATMSK2 Position       */
N#define GPIO_DATMSK_DATMSK2_Msk          (0x1ul << GPIO_DATMSK_DATMSK2_Pos)                /*!< GPIO_T::DATMSK: DATMSK2 Mask           */
N
N#define GPIO_DATMSK_DATMSK3_Pos          (3)                                               /*!< GPIO_T::DATMSK: DATMSK3 Position       */
N#define GPIO_DATMSK_DATMSK3_Msk          (0x1ul << GPIO_DATMSK_DATMSK3_Pos)                /*!< GPIO_T::DATMSK: DATMSK3 Mask           */
N
N#define GPIO_DATMSK_DATMSK4_Pos          (4)                                               /*!< GPIO_T::DATMSK: DATMSK4 Position       */
N#define GPIO_DATMSK_DATMSK4_Msk          (0x1ul << GPIO_DATMSK_DATMSK4_Pos)                /*!< GPIO_T::DATMSK: DATMSK4 Mask           */
N
N#define GPIO_DATMSK_DATMSK5_Pos          (5)                                               /*!< GPIO_T::DATMSK: DATMSK5 Position       */
N#define GPIO_DATMSK_DATMSK5_Msk          (0x1ul << GPIO_DATMSK_DATMSK5_Pos)                /*!< GPIO_T::DATMSK: DATMSK5 Mask           */
N
N#define GPIO_DATMSK_DATMSK6_Pos          (6)                                               /*!< GPIO_T::DATMSK: DATMSK6 Position       */
N#define GPIO_DATMSK_DATMSK6_Msk          (0x1ul << GPIO_DATMSK_DATMSK6_Pos)                /*!< GPIO_T::DATMSK: DATMSK6 Mask           */
N
N#define GPIO_DATMSK_DATMSK7_Pos          (7)                                               /*!< GPIO_T::DATMSK: DATMSK7 Position       */
N#define GPIO_DATMSK_DATMSK7_Msk          (0x1ul << GPIO_DATMSK_DATMSK7_Pos)                /*!< GPIO_T::DATMSK: DATMSK7 Mask           */
N
N#define GPIO_DATMSK_DATMSK8_Pos          (8)                                               /*!< GPIO_T::DATMSK: DATMSK8 Position       */
N#define GPIO_DATMSK_DATMSK8_Msk          (0x1ul << GPIO_DATMSK_DATMSK8_Pos)                /*!< GPIO_T::DATMSK: DATMSK8 Mask           */
N
N#define GPIO_DATMSK_DATMSK9_Pos          (9)                                               /*!< GPIO_T::DATMSK: DATMSK9 Position       */
N#define GPIO_DATMSK_DATMSK9_Msk          (0x1ul << GPIO_DATMSK_DATMSK9_Pos)                /*!< GPIO_T::DATMSK: DATMSK9 Mask           */
N
N#define GPIO_DATMSK_DATMSK10_Pos         (10)                                              /*!< GPIO_T::DATMSK: DATMSK10 Position      */
N#define GPIO_DATMSK_DATMSK10_Msk         (0x1ul << GPIO_DATMSK_DATMSK10_Pos)               /*!< GPIO_T::DATMSK: DATMSK10 Mask          */
N
N#define GPIO_DATMSK_DATMSK11_Pos         (11)                                              /*!< GPIO_T::DATMSK: DATMSK11 Position      */
N#define GPIO_DATMSK_DATMSK11_Msk         (0x1ul << GPIO_DATMSK_DATMSK11_Pos)               /*!< GPIO_T::DATMSK: DATMSK11 Mask          */
N
N#define GPIO_DATMSK_DATMSK12_Pos         (12)                                              /*!< GPIO_T::DATMSK: DATMSK12 Position      */
N#define GPIO_DATMSK_DATMSK12_Msk         (0x1ul << GPIO_DATMSK_DATMSK12_Pos)               /*!< GPIO_T::DATMSK: DATMSK12 Mask          */
N
N#define GPIO_DATMSK_DATMSK13_Pos         (13)                                              /*!< GPIO_T::DATMSK: DATMSK13 Position      */
N#define GPIO_DATMSK_DATMSK13_Msk         (0x1ul << GPIO_DATMSK_DATMSK13_Pos)               /*!< GPIO_T::DATMSK: DATMSK13 Mask          */
N
N#define GPIO_DATMSK_DATMSK14_Pos         (14)                                              /*!< GPIO_T::DATMSK: DATMSK14 Position      */
N#define GPIO_DATMSK_DATMSK14_Msk         (0x1ul << GPIO_DATMSK_DATMSK14_Pos)               /*!< GPIO_T::DATMSK: DATMSK14 Mask          */
N
N#define GPIO_DATMSK_DATMSK15_Pos         (15)                                              /*!< GPIO_T::DATMSK: DATMSK15 Position      */
N#define GPIO_DATMSK_DATMSK15_Msk         (0x1ul << GPIO_DATMSK_DATMSK15_Pos)               /*!< GPIO_T::DATMSK: DATMSK15 Mask          */
N
N#define GPIO_PIN_PIN0_Pos                (0)                                               /*!< GPIO_T::PIN: PIN0 Position             */
N#define GPIO_PIN_PIN0_Msk                (0x1ul << GPIO_PIN_PIN0_Pos)                      /*!< GPIO_T::PIN: PIN0 Mask                 */
N
N#define GPIO_PIN_PIN1_Pos                (1)                                               /*!< GPIO_T::PIN: PIN1 Position             */
N#define GPIO_PIN_PIN1_Msk                (0x1ul << GPIO_PIN_PIN1_Pos)                      /*!< GPIO_T::PIN: PIN1 Mask                 */
N
N#define GPIO_PIN_PIN2_Pos                (2)                                               /*!< GPIO_T::PIN: PIN2 Position             */
N#define GPIO_PIN_PIN2_Msk                (0x1ul << GPIO_PIN_PIN2_Pos)                      /*!< GPIO_T::PIN: PIN2 Mask                 */
N
N#define GPIO_PIN_PIN3_Pos                (3)                                               /*!< GPIO_T::PIN: PIN3 Position             */
N#define GPIO_PIN_PIN3_Msk                (0x1ul << GPIO_PIN_PIN3_Pos)                      /*!< GPIO_T::PIN: PIN3 Mask                 */
N
N#define GPIO_PIN_PIN4_Pos                (4)                                               /*!< GPIO_T::PIN: PIN4 Position             */
N#define GPIO_PIN_PIN4_Msk                (0x1ul << GPIO_PIN_PIN4_Pos)                      /*!< GPIO_T::PIN: PIN4 Mask                 */
N
N#define GPIO_PIN_PIN5_Pos                (5)                                               /*!< GPIO_T::PIN: PIN5 Position             */
N#define GPIO_PIN_PIN5_Msk                (0x1ul << GPIO_PIN_PIN5_Pos)                      /*!< GPIO_T::PIN: PIN5 Mask                 */
N
N#define GPIO_PIN_PIN6_Pos                (6)                                               /*!< GPIO_T::PIN: PIN6 Position             */
N#define GPIO_PIN_PIN6_Msk                (0x1ul << GPIO_PIN_PIN6_Pos)                      /*!< GPIO_T::PIN: PIN6 Mask                 */
N
N#define GPIO_PIN_PIN7_Pos                (7)                                               /*!< GPIO_T::PIN: PIN7 Position             */
N#define GPIO_PIN_PIN7_Msk                (0x1ul << GPIO_PIN_PIN7_Pos)                      /*!< GPIO_T::PIN: PIN7 Mask                 */
N
N#define GPIO_PIN_PIN8_Pos                (8)                                               /*!< GPIO_T::PIN: PIN8 Position             */
N#define GPIO_PIN_PIN8_Msk                (0x1ul << GPIO_PIN_PIN8_Pos)                      /*!< GPIO_T::PIN: PIN8 Mask                 */
N
N#define GPIO_PIN_PIN9_Pos                (9)                                               /*!< GPIO_T::PIN: PIN9 Position             */
N#define GPIO_PIN_PIN9_Msk                (0x1ul << GPIO_PIN_PIN9_Pos)                      /*!< GPIO_T::PIN: PIN9 Mask                 */
N
N#define GPIO_PIN_PIN10_Pos               (10)                                              /*!< GPIO_T::PIN: PIN10 Position            */
N#define GPIO_PIN_PIN10_Msk               (0x1ul << GPIO_PIN_PIN10_Pos)                     /*!< GPIO_T::PIN: PIN10 Mask                */
N
N#define GPIO_PIN_PIN11_Pos               (11)                                              /*!< GPIO_T::PIN: PIN11 Position            */
N#define GPIO_PIN_PIN11_Msk               (0x1ul << GPIO_PIN_PIN11_Pos)                     /*!< GPIO_T::PIN: PIN11 Mask                */
N
N#define GPIO_PIN_PIN12_Pos               (12)                                              /*!< GPIO_T::PIN: PIN12 Position            */
N#define GPIO_PIN_PIN12_Msk               (0x1ul << GPIO_PIN_PIN12_Pos)                     /*!< GPIO_T::PIN: PIN12 Mask                */
N
N#define GPIO_PIN_PIN13_Pos               (13)                                              /*!< GPIO_T::PIN: PIN13 Position            */
N#define GPIO_PIN_PIN13_Msk               (0x1ul << GPIO_PIN_PIN13_Pos)                     /*!< GPIO_T::PIN: PIN13 Mask                */
N
N#define GPIO_PIN_PIN14_Pos               (14)                                              /*!< GPIO_T::PIN: PIN14 Position            */
N#define GPIO_PIN_PIN14_Msk               (0x1ul << GPIO_PIN_PIN14_Pos)                     /*!< GPIO_T::PIN: PIN14 Mask                */
N
N#define GPIO_PIN_PIN15_Pos               (15)                                              /*!< GPIO_T::PIN: PIN15 Position            */
N#define GPIO_PIN_PIN15_Msk               (0x1ul << GPIO_PIN_PIN15_Pos)                     /*!< GPIO_T::PIN: PIN15 Mask                */
N
N#define GPIO_DBEN_DBEN0_Pos              (0)                                               /*!< GPIO_T::DBEN: DBEN0 Position           */
N#define GPIO_DBEN_DBEN0_Msk              (0x1ul << GPIO_DBEN_DBEN0_Pos)                    /*!< GPIO_T::DBEN: DBEN0 Mask               */
N
N#define GPIO_DBEN_DBEN1_Pos              (1)                                               /*!< GPIO_T::DBEN: DBEN1 Position           */
N#define GPIO_DBEN_DBEN1_Msk              (0x1ul << GPIO_DBEN_DBEN1_Pos)                    /*!< GPIO_T::DBEN: DBEN1 Mask               */
N
N#define GPIO_DBEN_DBEN2_Pos              (2)                                               /*!< GPIO_T::DBEN: DBEN2 Position           */
N#define GPIO_DBEN_DBEN2_Msk              (0x1ul << GPIO_DBEN_DBEN2_Pos)                    /*!< GPIO_T::DBEN: DBEN2 Mask               */
N
N#define GPIO_DBEN_DBEN3_Pos              (3)                                               /*!< GPIO_T::DBEN: DBEN3 Position           */
N#define GPIO_DBEN_DBEN3_Msk              (0x1ul << GPIO_DBEN_DBEN3_Pos)                    /*!< GPIO_T::DBEN: DBEN3 Mask               */
N
N#define GPIO_DBEN_DBEN4_Pos              (4)                                               /*!< GPIO_T::DBEN: DBEN4 Position           */
N#define GPIO_DBEN_DBEN4_Msk              (0x1ul << GPIO_DBEN_DBEN4_Pos)                    /*!< GPIO_T::DBEN: DBEN4 Mask               */
N
N#define GPIO_DBEN_DBEN5_Pos              (5)                                               /*!< GPIO_T::DBEN: DBEN5 Position           */
N#define GPIO_DBEN_DBEN5_Msk              (0x1ul << GPIO_DBEN_DBEN5_Pos)                    /*!< GPIO_T::DBEN: DBEN5 Mask               */
N
N#define GPIO_DBEN_DBEN6_Pos              (6)                                               /*!< GPIO_T::DBEN: DBEN6 Position           */
N#define GPIO_DBEN_DBEN6_Msk              (0x1ul << GPIO_DBEN_DBEN6_Pos)                    /*!< GPIO_T::DBEN: DBEN6 Mask               */
N
N#define GPIO_DBEN_DBEN7_Pos              (7)                                               /*!< GPIO_T::DBEN: DBEN7 Position           */
N#define GPIO_DBEN_DBEN7_Msk              (0x1ul << GPIO_DBEN_DBEN7_Pos)                    /*!< GPIO_T::DBEN: DBEN7 Mask               */
N
N#define GPIO_DBEN_DBEN8_Pos              (8)                                               /*!< GPIO_T::DBEN: DBEN8 Position           */
N#define GPIO_DBEN_DBEN8_Msk              (0x1ul << GPIO_DBEN_DBEN8_Pos)                    /*!< GPIO_T::DBEN: DBEN8 Mask               */
N
N#define GPIO_DBEN_DBEN9_Pos              (9)                                               /*!< GPIO_T::DBEN: DBEN9 Position           */
N#define GPIO_DBEN_DBEN9_Msk              (0x1ul << GPIO_DBEN_DBEN9_Pos)                    /*!< GPIO_T::DBEN: DBEN9 Mask               */
N
N#define GPIO_DBEN_DBEN10_Pos             (10)                                              /*!< GPIO_T::DBEN: DBEN10 Position          */
N#define GPIO_DBEN_DBEN10_Msk             (0x1ul << GPIO_DBEN_DBEN10_Pos)                   /*!< GPIO_T::DBEN: DBEN10 Mask              */
N
N#define GPIO_DBEN_DBEN11_Pos             (11)                                              /*!< GPIO_T::DBEN: DBEN11 Position          */
N#define GPIO_DBEN_DBEN11_Msk             (0x1ul << GPIO_DBEN_DBEN11_Pos)                   /*!< GPIO_T::DBEN: DBEN11 Mask              */
N
N#define GPIO_DBEN_DBEN12_Pos             (12)                                              /*!< GPIO_T::DBEN: DBEN12 Position          */
N#define GPIO_DBEN_DBEN12_Msk             (0x1ul << GPIO_DBEN_DBEN12_Pos)                   /*!< GPIO_T::DBEN: DBEN12 Mask              */
N
N#define GPIO_DBEN_DBEN13_Pos             (13)                                              /*!< GPIO_T::DBEN: DBEN13 Position          */
N#define GPIO_DBEN_DBEN13_Msk             (0x1ul << GPIO_DBEN_DBEN13_Pos)                   /*!< GPIO_T::DBEN: DBEN13 Mask              */
N
N#define GPIO_DBEN_DBEN14_Pos             (14)                                              /*!< GPIO_T::DBEN: DBEN14 Position          */
N#define GPIO_DBEN_DBEN14_Msk             (0x1ul << GPIO_DBEN_DBEN14_Pos)                   /*!< GPIO_T::DBEN: DBEN14 Mask              */
N
N#define GPIO_DBEN_DBEN15_Pos             (15)                                              /*!< GPIO_T::DBEN: DBEN15 Position          */
N#define GPIO_DBEN_DBEN15_Msk             (0x1ul << GPIO_DBEN_DBEN15_Pos)                   /*!< GPIO_T::DBEN: DBEN15 Mask              */
N
N#define GPIO_INTTYPE_TYPE0_Pos           (0)                                               /*!< GPIO_T::INTTYPE: TYPE0 Position        */
N#define GPIO_INTTYPE_TYPE0_Msk           (0x1ul << GPIO_INTTYPE_TYPE0_Pos)                 /*!< GPIO_T::INTTYPE: TYPE0 Mask            */
N
N#define GPIO_INTTYPE_TYPE1_Pos           (1)                                               /*!< GPIO_T::INTTYPE: TYPE1 Position        */
N#define GPIO_INTTYPE_TYPE1_Msk           (0x1ul << GPIO_INTTYPE_TYPE1_Pos)                 /*!< GPIO_T::INTTYPE: TYPE1 Mask            */
N
N#define GPIO_INTTYPE_TYPE2_Pos           (2)                                               /*!< GPIO_T::INTTYPE: TYPE2 Position        */
N#define GPIO_INTTYPE_TYPE2_Msk           (0x1ul << GPIO_INTTYPE_TYPE2_Pos)                 /*!< GPIO_T::INTTYPE: TYPE2 Mask            */
N
N#define GPIO_INTTYPE_TYPE3_Pos           (3)                                               /*!< GPIO_T::INTTYPE: TYPE3 Position        */
N#define GPIO_INTTYPE_TYPE3_Msk           (0x1ul << GPIO_INTTYPE_TYPE3_Pos)                 /*!< GPIO_T::INTTYPE: TYPE3 Mask            */
N
N#define GPIO_INTTYPE_TYPE4_Pos           (4)                                               /*!< GPIO_T::INTTYPE: TYPE4 Position        */
N#define GPIO_INTTYPE_TYPE4_Msk           (0x1ul << GPIO_INTTYPE_TYPE4_Pos)                 /*!< GPIO_T::INTTYPE: TYPE4 Mask            */
N
N#define GPIO_INTTYPE_TYPE5_Pos           (5)                                               /*!< GPIO_T::INTTYPE: TYPE5 Position        */
N#define GPIO_INTTYPE_TYPE5_Msk           (0x1ul << GPIO_INTTYPE_TYPE5_Pos)                 /*!< GPIO_T::INTTYPE: TYPE5 Mask            */
N
N#define GPIO_INTTYPE_TYPE6_Pos           (6)                                               /*!< GPIO_T::INTTYPE: TYPE6 Position        */
N#define GPIO_INTTYPE_TYPE6_Msk           (0x1ul << GPIO_INTTYPE_TYPE6_Pos)                 /*!< GPIO_T::INTTYPE: TYPE6 Mask            */
N
N#define GPIO_INTTYPE_TYPE7_Pos           (7)                                               /*!< GPIO_T::INTTYPE: TYPE7 Position        */
N#define GPIO_INTTYPE_TYPE7_Msk           (0x1ul << GPIO_INTTYPE_TYPE7_Pos)                 /*!< GPIO_T::INTTYPE: TYPE7 Mask            */
N
N#define GPIO_INTTYPE_TYPE8_Pos           (8)                                               /*!< GPIO_T::INTTYPE: TYPE8 Position        */
N#define GPIO_INTTYPE_TYPE8_Msk           (0x1ul << GPIO_INTTYPE_TYPE8_Pos)                 /*!< GPIO_T::INTTYPE: TYPE8 Mask            */
N
N#define GPIO_INTTYPE_TYPE9_Pos           (9)                                               /*!< GPIO_T::INTTYPE: TYPE9 Position        */
N#define GPIO_INTTYPE_TYPE9_Msk           (0x1ul << GPIO_INTTYPE_TYPE9_Pos)                 /*!< GPIO_T::INTTYPE: TYPE9 Mask            */
N
N#define GPIO_INTTYPE_TYPE10_Pos          (10)                                              /*!< GPIO_T::INTTYPE: TYPE10 Position       */
N#define GPIO_INTTYPE_TYPE10_Msk          (0x1ul << GPIO_INTTYPE_TYPE10_Pos)                /*!< GPIO_T::INTTYPE: TYPE10 Mask           */
N
N#define GPIO_INTTYPE_TYPE11_Pos          (11)                                              /*!< GPIO_T::INTTYPE: TYPE11 Position       */
N#define GPIO_INTTYPE_TYPE11_Msk          (0x1ul << GPIO_INTTYPE_TYPE11_Pos)                /*!< GPIO_T::INTTYPE: TYPE11 Mask           */
N
N#define GPIO_INTTYPE_TYPE12_Pos          (12)                                              /*!< GPIO_T::INTTYPE: TYPE12 Position       */
N#define GPIO_INTTYPE_TYPE12_Msk          (0x1ul << GPIO_INTTYPE_TYPE12_Pos)                /*!< GPIO_T::INTTYPE: TYPE12 Mask           */
N
N#define GPIO_INTTYPE_TYPE13_Pos          (13)                                              /*!< GPIO_T::INTTYPE: TYPE13 Position       */
N#define GPIO_INTTYPE_TYPE13_Msk          (0x1ul << GPIO_INTTYPE_TYPE13_Pos)                /*!< GPIO_T::INTTYPE: TYPE13 Mask           */
N
N#define GPIO_INTTYPE_TYPE14_Pos          (14)                                              /*!< GPIO_T::INTTYPE: TYPE14 Position       */
N#define GPIO_INTTYPE_TYPE14_Msk          (0x1ul << GPIO_INTTYPE_TYPE14_Pos)                /*!< GPIO_T::INTTYPE: TYPE14 Mask           */
N
N#define GPIO_INTTYPE_TYPE15_Pos          (15)                                              /*!< GPIO_T::INTTYPE: TYPE15 Position       */
N#define GPIO_INTTYPE_TYPE15_Msk          (0x1ul << GPIO_INTTYPE_TYPE15_Pos)                /*!< GPIO_T::INTTYPE: TYPE15 Mask           */
N
N#define GPIO_INTEN_FLIEN0_Pos            (0)                                               /*!< GPIO_T::INTEN: FLIEN0 Position         */
N#define GPIO_INTEN_FLIEN0_Msk            (0x1ul << GPIO_INTEN_FLIEN0_Pos)                  /*!< GPIO_T::INTEN: FLIEN0 Mask             */
N
N#define GPIO_INTEN_FLIEN1_Pos            (1)                                               /*!< GPIO_T::INTEN: FLIEN1 Position         */
N#define GPIO_INTEN_FLIEN1_Msk            (0x1ul << GPIO_INTEN_FLIEN1_Pos)                  /*!< GPIO_T::INTEN: FLIEN1 Mask             */
N
N#define GPIO_INTEN_FLIEN2_Pos            (2)                                               /*!< GPIO_T::INTEN: FLIEN2 Position         */
N#define GPIO_INTEN_FLIEN2_Msk            (0x1ul << GPIO_INTEN_FLIEN2_Pos)                  /*!< GPIO_T::INTEN: FLIEN2 Mask             */
N
N#define GPIO_INTEN_FLIEN3_Pos            (3)                                               /*!< GPIO_T::INTEN: FLIEN3 Position         */
N#define GPIO_INTEN_FLIEN3_Msk            (0x1ul << GPIO_INTEN_FLIEN3_Pos)                  /*!< GPIO_T::INTEN: FLIEN3 Mask             */
N
N#define GPIO_INTEN_FLIEN4_Pos            (4)                                               /*!< GPIO_T::INTEN: FLIEN4 Position         */
N#define GPIO_INTEN_FLIEN4_Msk            (0x1ul << GPIO_INTEN_FLIEN4_Pos)                  /*!< GPIO_T::INTEN: FLIEN4 Mask             */
N
N#define GPIO_INTEN_FLIEN5_Pos            (5)                                               /*!< GPIO_T::INTEN: FLIEN5 Position         */
N#define GPIO_INTEN_FLIEN5_Msk            (0x1ul << GPIO_INTEN_FLIEN5_Pos)                  /*!< GPIO_T::INTEN: FLIEN5 Mask             */
N
N#define GPIO_INTEN_FLIEN6_Pos            (6)                                               /*!< GPIO_T::INTEN: FLIEN6 Position         */
N#define GPIO_INTEN_FLIEN6_Msk            (0x1ul << GPIO_INTEN_FLIEN6_Pos)                  /*!< GPIO_T::INTEN: FLIEN6 Mask             */
N
N#define GPIO_INTEN_FLIEN7_Pos            (7)                                               /*!< GPIO_T::INTEN: FLIEN7 Position         */
N#define GPIO_INTEN_FLIEN7_Msk            (0x1ul << GPIO_INTEN_FLIEN7_Pos)                  /*!< GPIO_T::INTEN: FLIEN7 Mask             */
N
N#define GPIO_INTEN_FLIEN8_Pos            (8)                                               /*!< GPIO_T::INTEN: FLIEN8 Position         */
N#define GPIO_INTEN_FLIEN8_Msk            (0x1ul << GPIO_INTEN_FLIEN8_Pos)                  /*!< GPIO_T::INTEN: FLIEN8 Mask             */
N
N#define GPIO_INTEN_FLIEN9_Pos            (9)                                               /*!< GPIO_T::INTEN: FLIEN9 Position         */
N#define GPIO_INTEN_FLIEN9_Msk            (0x1ul << GPIO_INTEN_FLIEN9_Pos)                  /*!< GPIO_T::INTEN: FLIEN9 Mask             */
N
N#define GPIO_INTEN_FLIEN10_Pos           (10)                                              /*!< GPIO_T::INTEN: FLIEN10 Position        */
N#define GPIO_INTEN_FLIEN10_Msk           (0x1ul << GPIO_INTEN_FLIEN10_Pos)                 /*!< GPIO_T::INTEN: FLIEN10 Mask            */
N
N#define GPIO_INTEN_FLIEN11_Pos           (11)                                              /*!< GPIO_T::INTEN: FLIEN11 Position        */
N#define GPIO_INTEN_FLIEN11_Msk           (0x1ul << GPIO_INTEN_FLIEN11_Pos)                 /*!< GPIO_T::INTEN: FLIEN11 Mask            */
N
N#define GPIO_INTEN_FLIEN12_Pos           (12)                                              /*!< GPIO_T::INTEN: FLIEN12 Position        */
N#define GPIO_INTEN_FLIEN12_Msk           (0x1ul << GPIO_INTEN_FLIEN12_Pos)                 /*!< GPIO_T::INTEN: FLIEN12 Mask            */
N
N#define GPIO_INTEN_FLIEN13_Pos           (13)                                              /*!< GPIO_T::INTEN: FLIEN13 Position        */
N#define GPIO_INTEN_FLIEN13_Msk           (0x1ul << GPIO_INTEN_FLIEN13_Pos)                 /*!< GPIO_T::INTEN: FLIEN13 Mask            */
N
N#define GPIO_INTEN_FLIEN14_Pos           (14)                                              /*!< GPIO_T::INTEN: FLIEN14 Position        */
N#define GPIO_INTEN_FLIEN14_Msk           (0x1ul << GPIO_INTEN_FLIEN14_Pos)                 /*!< GPIO_T::INTEN: FLIEN14 Mask            */
N
N#define GPIO_INTEN_FLIEN15_Pos           (15)                                              /*!< GPIO_T::INTEN: FLIEN15 Position        */
N#define GPIO_INTEN_FLIEN15_Msk           (0x1ul << GPIO_INTEN_FLIEN15_Pos)                 /*!< GPIO_T::INTEN: FLIEN15 Mask            */
N
N#define GPIO_INTEN_RHIEN0_Pos            (16)                                              /*!< GPIO_T::INTEN: RHIEN0 Position         */
N#define GPIO_INTEN_RHIEN0_Msk            (0x1ul << GPIO_INTEN_RHIEN0_Pos)                  /*!< GPIO_T::INTEN: RHIEN0 Mask             */
N
N#define GPIO_INTEN_RHIEN1_Pos            (17)                                              /*!< GPIO_T::INTEN: RHIEN1 Position         */
N#define GPIO_INTEN_RHIEN1_Msk            (0x1ul << GPIO_INTEN_RHIEN1_Pos)                  /*!< GPIO_T::INTEN: RHIEN1 Mask             */
N
N#define GPIO_INTEN_RHIEN2_Pos            (18)                                              /*!< GPIO_T::INTEN: RHIEN2 Position         */
N#define GPIO_INTEN_RHIEN2_Msk            (0x1ul << GPIO_INTEN_RHIEN2_Pos)                  /*!< GPIO_T::INTEN: RHIEN2 Mask             */
N
N#define GPIO_INTEN_RHIEN3_Pos            (19)                                              /*!< GPIO_T::INTEN: RHIEN3 Position         */
N#define GPIO_INTEN_RHIEN3_Msk            (0x1ul << GPIO_INTEN_RHIEN3_Pos)                  /*!< GPIO_T::INTEN: RHIEN3 Mask             */
N
N#define GPIO_INTEN_RHIEN4_Pos            (20)                                              /*!< GPIO_T::INTEN: RHIEN4 Position         */
N#define GPIO_INTEN_RHIEN4_Msk            (0x1ul << GPIO_INTEN_RHIEN4_Pos)                  /*!< GPIO_T::INTEN: RHIEN4 Mask             */
N
N#define GPIO_INTEN_RHIEN5_Pos            (21)                                              /*!< GPIO_T::INTEN: RHIEN5 Position         */
N#define GPIO_INTEN_RHIEN5_Msk            (0x1ul << GPIO_INTEN_RHIEN5_Pos)                  /*!< GPIO_T::INTEN: RHIEN5 Mask             */
N
N#define GPIO_INTEN_RHIEN6_Pos            (22)                                              /*!< GPIO_T::INTEN: RHIEN6 Position         */
N#define GPIO_INTEN_RHIEN6_Msk            (0x1ul << GPIO_INTEN_RHIEN6_Pos)                  /*!< GPIO_T::INTEN: RHIEN6 Mask             */
N
N#define GPIO_INTEN_RHIEN7_Pos            (23)                                              /*!< GPIO_T::INTEN: RHIEN7 Position         */
N#define GPIO_INTEN_RHIEN7_Msk            (0x1ul << GPIO_INTEN_RHIEN7_Pos)                  /*!< GPIO_T::INTEN: RHIEN7 Mask             */
N
N#define GPIO_INTEN_RHIEN8_Pos            (24)                                              /*!< GPIO_T::INTEN: RHIEN8 Position         */
N#define GPIO_INTEN_RHIEN8_Msk            (0x1ul << GPIO_INTEN_RHIEN8_Pos)                  /*!< GPIO_T::INTEN: RHIEN8 Mask             */
N
N#define GPIO_INTEN_RHIEN9_Pos            (25)                                              /*!< GPIO_T::INTEN: RHIEN9 Position         */
N#define GPIO_INTEN_RHIEN9_Msk            (0x1ul << GPIO_INTEN_RHIEN9_Pos)                  /*!< GPIO_T::INTEN: RHIEN9 Mask             */
N
N#define GPIO_INTEN_RHIEN10_Pos           (26)                                              /*!< GPIO_T::INTEN: RHIEN10 Position        */
N#define GPIO_INTEN_RHIEN10_Msk           (0x1ul << GPIO_INTEN_RHIEN10_Pos)                 /*!< GPIO_T::INTEN: RHIEN10 Mask            */
N
N#define GPIO_INTEN_RHIEN11_Pos           (27)                                              /*!< GPIO_T::INTEN: RHIEN11 Position        */
N#define GPIO_INTEN_RHIEN11_Msk           (0x1ul << GPIO_INTEN_RHIEN11_Pos)                 /*!< GPIO_T::INTEN: RHIEN11 Mask            */
N
N#define GPIO_INTEN_RHIEN12_Pos           (28)                                              /*!< GPIO_T::INTEN: RHIEN12 Position        */
N#define GPIO_INTEN_RHIEN12_Msk           (0x1ul << GPIO_INTEN_RHIEN12_Pos)                 /*!< GPIO_T::INTEN: RHIEN12 Mask            */
N
N#define GPIO_INTEN_RHIEN13_Pos           (29)                                              /*!< GPIO_T::INTEN: RHIEN13 Position        */
N#define GPIO_INTEN_RHIEN13_Msk           (0x1ul << GPIO_INTEN_RHIEN13_Pos)                 /*!< GPIO_T::INTEN: RHIEN13 Mask            */
N
N#define GPIO_INTEN_RHIEN14_Pos           (30)                                              /*!< GPIO_T::INTEN: RHIEN14 Position        */
N#define GPIO_INTEN_RHIEN14_Msk           (0x1ul << GPIO_INTEN_RHIEN14_Pos)                 /*!< GPIO_T::INTEN: RHIEN14 Mask            */
N
N#define GPIO_INTEN_RHIEN15_Pos           (31)                                              /*!< GPIO_T::INTEN: RHIEN15 Position        */
N#define GPIO_INTEN_RHIEN15_Msk           (0x1ul << GPIO_INTEN_RHIEN15_Pos)                 /*!< GPIO_T::INTEN: RHIEN15 Mask            */
N
N#define GPIO_INTSRC_INTSRC0_Pos          (0)                                               /*!< GPIO_T::INTSRC: INTSRC0 Position       */
N#define GPIO_INTSRC_INTSRC0_Msk          (0x1ul << GPIO_INTSRC_INTSRC0_Pos)                /*!< GPIO_T::INTSRC: INTSRC0 Mask           */
N
N#define GPIO_INTSRC_INTSRC1_Pos          (1)                                               /*!< GPIO_T::INTSRC: INTSRC1 Position       */
N#define GPIO_INTSRC_INTSRC1_Msk          (0x1ul << GPIO_INTSRC_INTSRC1_Pos)                /*!< GPIO_T::INTSRC: INTSRC1 Mask           */
N
N#define GPIO_INTSRC_INTSRC2_Pos          (2)                                               /*!< GPIO_T::INTSRC: INTSRC2 Position       */
N#define GPIO_INTSRC_INTSRC2_Msk          (0x1ul << GPIO_INTSRC_INTSRC2_Pos)                /*!< GPIO_T::INTSRC: INTSRC2 Mask           */
N
N#define GPIO_INTSRC_INTSRC3_Pos          (3)                                               /*!< GPIO_T::INTSRC: INTSRC3 Position       */
N#define GPIO_INTSRC_INTSRC3_Msk          (0x1ul << GPIO_INTSRC_INTSRC3_Pos)                /*!< GPIO_T::INTSRC: INTSRC3 Mask           */
N
N#define GPIO_INTSRC_INTSRC4_Pos          (4)                                               /*!< GPIO_T::INTSRC: INTSRC4 Position       */
N#define GPIO_INTSRC_INTSRC4_Msk          (0x1ul << GPIO_INTSRC_INTSRC4_Pos)                /*!< GPIO_T::INTSRC: INTSRC4 Mask           */
N
N#define GPIO_INTSRC_INTSRC5_Pos          (5)                                               /*!< GPIO_T::INTSRC: INTSRC5 Position       */
N#define GPIO_INTSRC_INTSRC5_Msk          (0x1ul << GPIO_INTSRC_INTSRC5_Pos)                /*!< GPIO_T::INTSRC: INTSRC5 Mask           */
N
N#define GPIO_INTSRC_INTSRC6_Pos          (6)                                               /*!< GPIO_T::INTSRC: INTSRC6 Position       */
N#define GPIO_INTSRC_INTSRC6_Msk          (0x1ul << GPIO_INTSRC_INTSRC6_Pos)                /*!< GPIO_T::INTSRC: INTSRC6 Mask           */
N
N#define GPIO_INTSRC_INTSRC7_Pos          (7)                                               /*!< GPIO_T::INTSRC: INTSRC7 Position       */
N#define GPIO_INTSRC_INTSRC7_Msk          (0x1ul << GPIO_INTSRC_INTSRC7_Pos)                /*!< GPIO_T::INTSRC: INTSRC7 Mask           */
N
N#define GPIO_INTSRC_INTSRC8_Pos          (8)                                               /*!< GPIO_T::INTSRC: INTSRC8 Position       */
N#define GPIO_INTSRC_INTSRC8_Msk          (0x1ul << GPIO_INTSRC_INTSRC8_Pos)                /*!< GPIO_T::INTSRC: INTSRC8 Mask           */
N
N#define GPIO_INTSRC_INTSRC9_Pos          (9)                                               /*!< GPIO_T::INTSRC: INTSRC9 Position       */
N#define GPIO_INTSRC_INTSRC9_Msk          (0x1ul << GPIO_INTSRC_INTSRC9_Pos)                /*!< GPIO_T::INTSRC: INTSRC9 Mask           */
N
N#define GPIO_INTSRC_INTSRC10_Pos         (10)                                              /*!< GPIO_T::INTSRC: INTSRC10 Position      */
N#define GPIO_INTSRC_INTSRC10_Msk         (0x1ul << GPIO_INTSRC_INTSRC10_Pos)               /*!< GPIO_T::INTSRC: INTSRC10 Mask          */
N
N#define GPIO_INTSRC_INTSRC11_Pos         (11)                                              /*!< GPIO_T::INTSRC: INTSRC11 Position      */
N#define GPIO_INTSRC_INTSRC11_Msk         (0x1ul << GPIO_INTSRC_INTSRC11_Pos)               /*!< GPIO_T::INTSRC: INTSRC11 Mask          */
N
N#define GPIO_INTSRC_INTSRC12_Pos         (12)                                              /*!< GPIO_T::INTSRC: INTSRC12 Position      */
N#define GPIO_INTSRC_INTSRC12_Msk         (0x1ul << GPIO_INTSRC_INTSRC12_Pos)               /*!< GPIO_T::INTSRC: INTSRC12 Mask          */
N
N#define GPIO_INTSRC_INTSRC13_Pos         (13)                                              /*!< GPIO_T::INTSRC: INTSRC13 Position      */
N#define GPIO_INTSRC_INTSRC13_Msk         (0x1ul << GPIO_INTSRC_INTSRC13_Pos)               /*!< GPIO_T::INTSRC: INTSRC13 Mask          */
N
N#define GPIO_INTSRC_INTSRC14_Pos         (14)                                              /*!< GPIO_T::INTSRC: INTSRC14 Position      */
N#define GPIO_INTSRC_INTSRC14_Msk         (0x1ul << GPIO_INTSRC_INTSRC14_Pos)               /*!< GPIO_T::INTSRC: INTSRC14 Mask          */
N
N#define GPIO_INTSRC_INTSRC15_Pos         (15)                                              /*!< GPIO_T::INTSRC: INTSRC15 Position      */
N#define GPIO_INTSRC_INTSRC15_Msk         (0x1ul << GPIO_INTSRC_INTSRC15_Pos)               /*!< GPIO_T::INTSRC: INTSRC15 Mask          */
N
N#define GPIO_SMTEN_SMTEN0_Pos            (0)                                               /*!< GPIO_T::SMTEN: SMTEN0 Position         */
N#define GPIO_SMTEN_SMTEN0_Msk            (0x1ul << GPIO_SMTEN_SMTEN0_Pos)                  /*!< GPIO_T::SMTEN: SMTEN0 Mask             */
N
N#define GPIO_SMTEN_SMTEN1_Pos            (1)                                               /*!< GPIO_T::SMTEN: SMTEN1 Position         */
N#define GPIO_SMTEN_SMTEN1_Msk            (0x1ul << GPIO_SMTEN_SMTEN1_Pos)                  /*!< GPIO_T::SMTEN: SMTEN1 Mask             */
N
N#define GPIO_SMTEN_SMTEN2_Pos            (2)                                               /*!< GPIO_T::SMTEN: SMTEN2 Position         */
N#define GPIO_SMTEN_SMTEN2_Msk            (0x1ul << GPIO_SMTEN_SMTEN2_Pos)                  /*!< GPIO_T::SMTEN: SMTEN2 Mask             */
N
N#define GPIO_SMTEN_SMTEN3_Pos            (3)                                               /*!< GPIO_T::SMTEN: SMTEN3 Position         */
N#define GPIO_SMTEN_SMTEN3_Msk            (0x1ul << GPIO_SMTEN_SMTEN3_Pos)                  /*!< GPIO_T::SMTEN: SMTEN3 Mask             */
N
N#define GPIO_SMTEN_SMTEN4_Pos            (4)                                               /*!< GPIO_T::SMTEN: SMTEN4 Position         */
N#define GPIO_SMTEN_SMTEN4_Msk            (0x1ul << GPIO_SMTEN_SMTEN4_Pos)                  /*!< GPIO_T::SMTEN: SMTEN4 Mask             */
N
N#define GPIO_SMTEN_SMTEN5_Pos            (5)                                               /*!< GPIO_T::SMTEN: SMTEN5 Position         */
N#define GPIO_SMTEN_SMTEN5_Msk            (0x1ul << GPIO_SMTEN_SMTEN5_Pos)                  /*!< GPIO_T::SMTEN: SMTEN5 Mask             */
N
N#define GPIO_SMTEN_SMTEN6_Pos            (6)                                               /*!< GPIO_T::SMTEN: SMTEN6 Position         */
N#define GPIO_SMTEN_SMTEN6_Msk            (0x1ul << GPIO_SMTEN_SMTEN6_Pos)                  /*!< GPIO_T::SMTEN: SMTEN6 Mask             */
N
N#define GPIO_SMTEN_SMTEN7_Pos            (7)                                               /*!< GPIO_T::SMTEN: SMTEN7 Position         */
N#define GPIO_SMTEN_SMTEN7_Msk            (0x1ul << GPIO_SMTEN_SMTEN7_Pos)                  /*!< GPIO_T::SMTEN: SMTEN7 Mask             */
N
N#define GPIO_SMTEN_SMTEN8_Pos            (8)                                               /*!< GPIO_T::SMTEN: SMTEN8 Position         */
N#define GPIO_SMTEN_SMTEN8_Msk            (0x1ul << GPIO_SMTEN_SMTEN8_Pos)                  /*!< GPIO_T::SMTEN: SMTEN8 Mask             */
N
N#define GPIO_SMTEN_SMTEN9_Pos            (9)                                               /*!< GPIO_T::SMTEN: SMTEN9 Position         */
N#define GPIO_SMTEN_SMTEN9_Msk            (0x1ul << GPIO_SMTEN_SMTEN9_Pos)                  /*!< GPIO_T::SMTEN: SMTEN9 Mask             */
N
N#define GPIO_SMTEN_SMTEN10_Pos           (10)                                              /*!< GPIO_T::SMTEN: SMTEN10 Position        */
N#define GPIO_SMTEN_SMTEN10_Msk           (0x1ul << GPIO_SMTEN_SMTEN10_Pos)                 /*!< GPIO_T::SMTEN: SMTEN10 Mask            */
N
N#define GPIO_SMTEN_SMTEN11_Pos           (11)                                              /*!< GPIO_T::SMTEN: SMTEN11 Position        */
N#define GPIO_SMTEN_SMTEN11_Msk           (0x1ul << GPIO_SMTEN_SMTEN11_Pos)                 /*!< GPIO_T::SMTEN: SMTEN11 Mask            */
N
N#define GPIO_SMTEN_SMTEN12_Pos           (12)                                              /*!< GPIO_T::SMTEN: SMTEN12 Position        */
N#define GPIO_SMTEN_SMTEN12_Msk           (0x1ul << GPIO_SMTEN_SMTEN12_Pos)                 /*!< GPIO_T::SMTEN: SMTEN12 Mask            */
N
N#define GPIO_SMTEN_SMTEN13_Pos           (13)                                              /*!< GPIO_T::SMTEN: SMTEN13 Position        */
N#define GPIO_SMTEN_SMTEN13_Msk           (0x1ul << GPIO_SMTEN_SMTEN13_Pos)                 /*!< GPIO_T::SMTEN: SMTEN13 Mask            */
N
N#define GPIO_SMTEN_SMTEN14_Pos           (14)                                              /*!< GPIO_T::SMTEN: SMTEN14 Position        */
N#define GPIO_SMTEN_SMTEN14_Msk           (0x1ul << GPIO_SMTEN_SMTEN14_Pos)                 /*!< GPIO_T::SMTEN: SMTEN14 Mask            */
N
N#define GPIO_SMTEN_SMTEN15_Pos           (15)                                              /*!< GPIO_T::SMTEN: SMTEN15 Position        */
N#define GPIO_SMTEN_SMTEN15_Msk           (0x1ul << GPIO_SMTEN_SMTEN15_Pos)                 /*!< GPIO_T::SMTEN: SMTEN15 Mask            */
N
N#define GPIO_SLEWCTL_HSREN0_Pos          (0)                                               /*!< GPIO_T::SLEWCTL: HSREN0 Position       */
N#define GPIO_SLEWCTL_HSREN0_Msk          (0x1ul << GPIO_SLEWCTL_HSREN0_Pos)                /*!< GPIO_T::SLEWCTL: HSREN0 Mask           */
N
N#define GPIO_SLEWCTL_HSREN1_Pos          (1)                                               /*!< GPIO_T::SLEWCTL: HSREN1 Position       */
N#define GPIO_SLEWCTL_HSREN1_Msk          (0x1ul << GPIO_SLEWCTL_HSREN1_Pos)                /*!< GPIO_T::SLEWCTL: HSREN1 Mask           */
N
N#define GPIO_SLEWCTL_HSREN2_Pos          (2)                                               /*!< GPIO_T::SLEWCTL: HSREN2 Position       */
N#define GPIO_SLEWCTL_HSREN2_Msk          (0x1ul << GPIO_SLEWCTL_HSREN2_Pos)                /*!< GPIO_T::SLEWCTL: HSREN2 Mask           */
N
N#define GPIO_SLEWCTL_HSREN3_Pos          (3)                                               /*!< GPIO_T::SLEWCTL: HSREN3 Position       */
N#define GPIO_SLEWCTL_HSREN3_Msk          (0x1ul << GPIO_SLEWCTL_HSREN3_Pos)                /*!< GPIO_T::SLEWCTL: HSREN3 Mask           */
N
N#define GPIO_SLEWCTL_HSREN4_Pos          (4)                                               /*!< GPIO_T::SLEWCTL: HSREN4 Position       */
N#define GPIO_SLEWCTL_HSREN4_Msk          (0x1ul << GPIO_SLEWCTL_HSREN4_Pos)                /*!< GPIO_T::SLEWCTL: HSREN4 Mask           */
N
N#define GPIO_SLEWCTL_HSREN5_Pos          (5)                                               /*!< GPIO_T::SLEWCTL: HSREN5 Position       */
N#define GPIO_SLEWCTL_HSREN5_Msk          (0x1ul << GPIO_SLEWCTL_HSREN5_Pos)                /*!< GPIO_T::SLEWCTL: HSREN5 Mask           */
N
N#define GPIO_SLEWCTL_HSREN6_Pos          (6)                                               /*!< GPIO_T::SLEWCTL: HSREN6 Position       */
N#define GPIO_SLEWCTL_HSREN6_Msk          (0x1ul << GPIO_SLEWCTL_HSREN6_Pos)                /*!< GPIO_T::SLEWCTL: HSREN6 Mask           */
N
N#define GPIO_SLEWCTL_HSREN7_Pos          (7)                                               /*!< GPIO_T::SLEWCTL: HSREN7 Position       */
N#define GPIO_SLEWCTL_HSREN7_Msk          (0x1ul << GPIO_SLEWCTL_HSREN7_Pos)                /*!< GPIO_T::SLEWCTL: HSREN7 Mask           */
N
N#define GPIO_SLEWCTL_HSREN8_Pos          (8)                                               /*!< GPIO_T::SLEWCTL: HSREN8 Position       */
N#define GPIO_SLEWCTL_HSREN8_Msk          (0x1ul << GPIO_SLEWCTL_HSREN8_Pos)                /*!< GPIO_T::SLEWCTL: HSREN8 Mask           */
N
N#define GPIO_SLEWCTL_HSREN9_Pos          (9)                                               /*!< GPIO_T::SLEWCTL: HSREN9 Position       */
N#define GPIO_SLEWCTL_HSREN9_Msk          (0x1ul << GPIO_SLEWCTL_HSREN9_Pos)                /*!< GPIO_T::SLEWCTL: HSREN9 Mask           */
N
N#define GPIO_SLEWCTL_HSREN10_Pos         (10)                                              /*!< GPIO_T::SLEWCTL: HSREN10 Position      */
N#define GPIO_SLEWCTL_HSREN10_Msk         (0x1ul << GPIO_SLEWCTL_HSREN10_Pos)               /*!< GPIO_T::SLEWCTL: HSREN10 Mask          */
N
N#define GPIO_SLEWCTL_HSREN11_Pos         (11)                                              /*!< GPIO_T::SLEWCTL: HSREN11 Position      */
N#define GPIO_SLEWCTL_HSREN11_Msk         (0x1ul << GPIO_SLEWCTL_HSREN11_Pos)               /*!< GPIO_T::SLEWCTL: HSREN11 Mask          */
N
N#define GPIO_SLEWCTL_HSREN12_Pos         (12)                                              /*!< GPIO_T::SLEWCTL: HSREN12 Position      */
N#define GPIO_SLEWCTL_HSREN12_Msk         (0x1ul << GPIO_SLEWCTL_HSREN12_Pos)               /*!< GPIO_T::SLEWCTL: HSREN12 Mask          */
N
N#define GPIO_SLEWCTL_HSREN13_Pos         (13)                                              /*!< GPIO_T::SLEWCTL: HSREN13 Position      */
N#define GPIO_SLEWCTL_HSREN13_Msk         (0x1ul << GPIO_SLEWCTL_HSREN13_Pos)               /*!< GPIO_T::SLEWCTL: HSREN13 Mask          */
N
N#define GPIO_SLEWCTL_HSREN14_Pos         (14)                                              /*!< GPIO_T::SLEWCTL: HSREN14 Position      */
N#define GPIO_SLEWCTL_HSREN14_Msk         (0x1ul << GPIO_SLEWCTL_HSREN14_Pos)               /*!< GPIO_T::SLEWCTL: HSREN14 Mask          */
N
N#define GPIO_SLEWCTL_HSREN15_Pos         (15)                                              /*!< GPIO_T::SLEWCTL: HSREN15 Position      */
N#define GPIO_SLEWCTL_HSREN15_Msk         (0x1ul << GPIO_SLEWCTL_HSREN15_Pos)               /*!< GPIO_T::SLEWCTL: HSREN15 Mask          */
N
N#define GPIO_DRVCTL_HDRVEN8_Pos          (8)                                               /*!< GPIO_T::DRVCTL: HDRVEN8 Position       */
N#define GPIO_DRVCTL_HDRVEN8_Msk          (0x1ul << GPIO_DRVCTL_HDRVEN8_Pos)                /*!< GPIO_T::DRVCTL: HDRVEN8 Mask           */
N
N#define GPIO_DRVCTL_HDRVEN9_Pos          (9)                                               /*!< GPIO_T::DRVCTL: HDRVEN9 Position       */
N#define GPIO_DRVCTL_HDRVEN9_Msk          (0x1ul << GPIO_DRVCTL_HDRVEN9_Pos)                /*!< GPIO_T::DRVCTL: HDRVEN9 Mask           */
N
N#define GPIO_DRVCTL_HDRVEN10_Pos         (10)                                              /*!< GPIO_T::DRVCTL: HDRVEN10 Position      */
N#define GPIO_DRVCTL_HDRVEN10_Msk         (0x1ul << GPIO_DRVCTL_HDRVEN10_Pos)               /*!< GPIO_T::DRVCTL: HDRVEN10 Mask          */
N
N#define GPIO_DRVCTL_HDRVEN11_Pos         (11)                                              /*!< GPIO_T::DRVCTL: HDRVEN11 Position      */
N#define GPIO_DRVCTL_HDRVEN11_Msk         (0x1ul << GPIO_DRVCTL_HDRVEN11_Pos)               /*!< GPIO_T::DRVCTL: HDRVEN11 Mask          */
N
N#define GPIO_DRVCTL_HDRVEN12_Pos         (12)                                              /*!< GPIO_T::DRVCTL: HDRVEN12 Position      */
N#define GPIO_DRVCTL_HDRVEN12_Msk         (0x1ul << GPIO_DRVCTL_HDRVEN12_Pos)               /*!< GPIO_T::DRVCTL: HDRVEN12 Mask          */
N
N#define GPIO_DRVCTL_HDRVEN13_Pos         (13)                                              /*!< GPIO_T::DRVCTL: HDRVEN13 Position      */
N#define GPIO_DRVCTL_HDRVEN13_Msk         (0x1ul << GPIO_DRVCTL_HDRVEN13_Pos)               /*!< GPIO_T::DRVCTL: HDRVEN13 Mask          */
N
N#define GPIO_DBCTL_DBCLKSEL_Pos          (0)                                               /*!< GPIO_DBCTL_T::DBCTL: DBCLKSEL Position */
N#define GPIO_DBCTL_DBCLKSEL_Msk          (0xful << GPIO_DBCTL_DBCLKSEL_Pos)                /*!< GPIO_DBCTL_T::DBCTL: DBCLKSEL Mask     */
N
N#define GPIO_DBCTL_DBCLKSRC_Pos          (4)                                               /*!< GPIO_DBCTL_T::DBCTL: DBCLKSRC Position */
N#define GPIO_DBCTL_DBCLKSRC_Msk          (0x1ul << GPIO_DBCTL_DBCLKSRC_Pos)                /*!< GPIO_DBCTL_T::DBCTL: DBCLKSRC Mask     */
N
N#define GPIO_DBCTL_ICLKON_Pos            (5)                                               /*!< GPIO_DBCTL_T::DBCTL: ICLKON Position   */
N#define GPIO_DBCTL_ICLKON_Msk            (0x1ul << GPIO_DBCTL_ICLKON_Pos)                  /*!< GPIO_DBCTL_T::DBCTL: ICLKON Mask       */
N
N
N/**@}*/ /* GPIO_CONST */
N/**@}*/ /* end of GPIO register group */
N
N/*---------------------- Hardware Divider --------------------------------*/
N/**
N    @addtogroup HDIV Hardware Divider(HDIV)
N    Memory Mapped Structure for HDIV Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var HDIV_T::DIVIDEND
N     * Offset: 0x00  Dividend Source Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |DIVIDEND  |Dividend Source
N     * |        |          |This register is given the dividend of divider before calculation starting.
N     * @var HDIV_T::DIVISOR
N     * Offset: 0x04  Divisor Source Resister
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |DIVISOR   |Divisor Source
N     * |        |          |This register is given the divisor of divider before calculation starts.
N     * |        |          |Note: When this register is written, hardware divider will start calculate.
N     * @var HDIV_T::DIVQUO
N     * Offset: 0x08  Quotient Result Resister
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |QUOTIENT  |Quotient Result
N     * |        |          |This register holds the quotient result of divider after calculation complete.
N     * @var HDIV_T::DIVREM
N     * Offset: 0x0C  Remainder Result Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |REMAINDER |Remainder Result
N     * |        |          |The remainder of hardware divider is 16-bit sign integer (REMAINDER[15:0]), which holds the remainder result of divider after calculation complete.
N     * |        |          |The remainder of hardware divider with sign extension (REMAINDER[31:16]) to 32-bit integer.
N     * |        |          |This register holds the remainder result of divider after calculation complete.
N     * @var HDIV_T::DIVSTS
N     * Offset: 0x10  Divider Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |FINISH    |Division Finish Flag
N     * |        |          |0 = Under Calculation.
N     * |        |          |1 = Calculation finished.
N     * |        |          |The flag will become low when the divider is in calculation.
N     * |        |          |The flag will go back to high once the calculation finished.
N     * |[1]     |DIV0      |Divisor Zero Warning
N     * |        |          |0 = The divisor is not 0.
N     * |        |          |1 = The divisor is 0.
N     * |        |          |Note: The DIV0 flag is used to indicate divide-by-zero situation and updated whenever DIVISOR is written
N     * |        |          |This register is read only.
N     */
N    __IO uint32_t DIVIDEND;              /*!< [0x0000] Dividend Source Register                                         */
X    volatile uint32_t DIVIDEND;               
N    __IO uint32_t DIVISOR;               /*!< [0x0004] Divisor Source Resister                                          */
X    volatile uint32_t DIVISOR;                
N    __IO uint32_t DIVQUO;                /*!< [0x0008] Quotient Result Resister                                         */
X    volatile uint32_t DIVQUO;                 
N    __IO uint32_t DIVREM;                /*!< [0x000c] Remainder Result Register                                        */
X    volatile uint32_t DIVREM;                 
N    __I  uint32_t DIVSTS;                /*!< [0x0010] Divider Status Register                                          */
X    volatile const  uint32_t DIVSTS;                 
N
N} HDIV_T;
N
N/**
N    @addtogroup HDIV_CONST HDIV Bit Field Definition
N    Constant Definitions for HDIV Controller
N@{ */
N
N#define HDIV_DIVIDEND_DIVIDEND_Pos       (0)                                               /*!< HDIV_T::DIVIDEND: DIVIDEND Position    */
N#define HDIV_DIVIDEND_DIVIDEND_Msk       (0xfffffffful << HDIV_DIVIDEND_DIVIDEND_Pos)      /*!< HDIV_T::DIVIDEND: DIVIDEND Mask        */
N
N#define HDIV_DIVISOR_DIVISOR_Pos         (0)                                               /*!< HDIV_T::DIVISOR: DIVISOR Position      */
N#define HDIV_DIVISOR_DIVISOR_Msk         (0xfffful << HDIV_DIVISOR_DIVISOR_Pos)            /*!< HDIV_T::DIVISOR: DIVISOR Mask          */
N
N#define HDIV_DIVQUO_QUOTIENT_Pos         (0)                                               /*!< HDIV_T::DIVQUO: QUOTIENT Position      */
N#define HDIV_DIVQUO_QUOTIENT_Msk         (0xfffffffful << HDIV_DIVQUO_QUOTIENT_Pos)        /*!< HDIV_T::DIVQUO: QUOTIENT Mask          */
N
N#define HDIV_DIVREM_REMAINDER_Pos        (0)                                               /*!< HDIV_T::DIVREM: REMAINDER Position     */
N#define HDIV_DIVREM_REMAINDER_Msk        (0xfffffffful << HDIV_DIVREM_REMAINDER_Pos)       /*!< HDIV_T::DIVREM: REMAINDER Mask         */
N
N#define HDIV_DIVSTS_FINISH_Pos           (0)                                               /*!< HDIV_T::DIVSTS: FINISH Position        */
N#define HDIV_DIVSTS_FINISH_Msk           (0x1ul << HDIV_DIVSTS_FINISH_Pos)                 /*!< HDIV_T::DIVSTS: FINISH Mask            */
N
N#define HDIV_DIVSTS_DIV0_Pos             (1)                                               /*!< HDIV_T::DIVSTS: DIV0 Position          */
N#define HDIV_DIVSTS_DIV0_Msk             (0x1ul << HDIV_DIVSTS_DIV0_Pos)                   /*!< HDIV_T::DIVSTS: DIV0 Mask              */
N
N/**@}*/ /* HDIV_CONST */
N/**@}*/ /* end of HDIV register group */
N
N
N/*---------------------- Inter-IC Bus Controller -------------------------*/
N/**
N    @addtogroup I2C Inter-IC Bus Controller(I2C)
N    Memory Mapped Structure for I2C Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var I2C_T::CTL
N     * Offset: 0x00  I2C Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2]     |AA        |Assert Acknowledge Control
N     * |        |          |When AA=1 prior to address or data is received, an acknowledged (low level to SDA) will be returned during the acknowledge clock pulse on the SCL line when 1.) A slave is acknowledging the address sent from master, 2.) The receiver devices are acknowledging the data sent by transmitter,
N     * |        |          |When AA=0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse on the SCL line.
N     * |[3]     |SI        |I2C Interrupt Flag
N     * |        |          |When a new I2C state is present in the I2C_STATUS register, the SI flag is set by hardware.
N     * |        |          |If bit INTEN (I2C_CTL [7]) is set, the I2C interrupt is requested.
N     * |        |          |SI must be cleared by software.Clear SI by writing 1 to this bit.
N     * |        |          |For ACKMEN is set in slave read mode, the SI flag is set in 8th clock period for user to confirm the acknowledge bit and 9th clock period for user to read the data in the data buffer.
N     * |[4]     |STO       |I2C STOP Control
N     * |        |          |In Master mode, setting STO to transmit a STOP condition to bus then I2C controller will check the bus condition if a STOP condition is detected.
N     * |        |          |This bit will be cleared by hardware automatically.
N     * |[5]     |STA       |I2C START Control
N     * |        |          |Setting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.
N     * |[6]     |I2CEN     |I2C Controller Enable Bit
N     * |        |          |Set to enable I2C serial function controller.When I2CEN=1 the I2C serial function enable.
N     * |        |          |The multi-function pin function must set to SDA, and SCL of I2C function first.
N     * |        |          |0 = I2C serial function Disabled.
N     * |        |          |1 = I2C serial function Enabled.
N     * |[7]     |INTEN     |Enable Interrupt
N     * |        |          |0 = I2C interrupt Disabled.
N     * |        |          |1 = I2C interrupt Enabled.
N     * @var I2C_T::ADDR0
N     * Offset: 0x04  I2C Slave Address Register0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = General Call Function Disabled.
N     * |        |          |1 = General Call Function Enabled.
N     * |[7:1]   |ADDR      |I2C Address
N     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
N     * |        |          |The I2C hardware will react if either of the address is matched.
N     * @var I2C_T::DAT
N     * Offset: 0x08  I2C Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |DAT       |I2C Data
N     * |        |          |Bit [7:0] is located with the 8-bit transferred/received data of I2C serial port.
N     * @var I2C_T::STATUS
N     * Offset: 0x0C  I2C Status Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |STATUS    |I2C Status
N     * |        |          |There are 28 possible status codes. When the content of I2C_STATUS is F8H, no serial interrupt is requested.
N     * |        |          |Others I2C_STATUS values correspond to defined I2C states.
N     * |        |          |When each of these states is entered, a status interrupt is requested (SI = 1).
N     * |        |          |A valid status code is present in I2C_STATUS one cycle after SI is set by hardware and is still present one cycle after SI has been reset by software.
N     * |        |          |In addition, states 00H stands for a Bus Error. A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame.
N     * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.
N     * @var I2C_T::CLKDIV
N     * Offset: 0x10  I2C Clock Divided Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |DIVIDER   |I2C Clock Divided
N     * |        |          |Indicates the I2C clock rate: Data Baud Rate of I2C = (system clock) / (4x (I2C_CLKDIV+1)).
N     * |        |          |Note: The minimum value of I2C_CLKDIV is 4.
N     * @var I2C_T::TOCTL
N     * Offset: 0x14  I2C Time-out Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TOIF      |Time-out Flag
N     * |        |          |This bit is set by hardware when I2C time-out happened and it can interrupt CPU if I2C interrupt enable bit (INTEN) is set to 1.
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[1]     |TOCDIV4   |Time-out Counter Input Clock Divided by 4
N     * |        |          |When Enabled, The time-out period is extend 4 times.
N     * |        |          |0 = Time-out period is extend 4 times Disabled.
N     * |        |          |1 = Time-out period is extend 4 times Enabled.
N     * |[2]     |TOCEN     |Time-out Counter Enable Bit
N     * |        |          |When Enabled, the 14-bit time-out counter will start counting when SI is clear.
N     * |        |          |Setting flag SI to '1' will reset counter and re-start up counting after SI is cleared.
N     * |        |          |0 = Time-out counter Disabled.
N     * |        |          |1 = Time-out counter Enabled.
N     * @var I2C_T::ADDR1
N     * Offset: 0x18  I2C Slave Address Register1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = General Call Function Disabled.
N     * |        |          |1 = General Call Function Enabled.
N     * |[7:1]   |ADDR      |I2C Address
N     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
N     * |        |          |The I2C hardware will react if either of the address is matched.
N     * @var I2C_T::ADDR2
N     * Offset: 0x1C  I2C Slave Address Register2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = General Call Function Disabled.
N     * |        |          |1 = General Call Function Enabled.
N     * |[7:1]   |ADDR      |I2C Address
N     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
N     * |        |          |The I2C hardware will react if either of the address is matched.
N     * @var I2C_T::ADDR3
N     * Offset: 0x20  I2C Slave Address Register3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = General Call Function Disabled.
N     * |        |          |1 = General Call Function Enabled.
N     * |[7:1]   |ADDR      |I2C Address
N     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
N     * |        |          |The I2C hardware will react if either of the address is matched.
N     * @var I2C_T::ADDRMSK0
N     * Offset: 0x24  I2C Slave Address Mask Register0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |ADDRMSK   |I2C Address Mask
N     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
N     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
N     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
N     * @var I2C_T::ADDRMSK1
N     * Offset: 0x28  I2C Slave Address Mask Register1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |ADDRMSK   |I2C Address Mask
N     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
N     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
N     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
N     * @var I2C_T::ADDRMSK2
N     * Offset: 0x2C  I2C Slave Address Mask Register2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |ADDRMSK   |I2C Address Mask
N     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
N     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
N     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
N     * @var I2C_T::ADDRMSK3
N     * Offset: 0x30  I2C Slave Address Mask Register3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |ADDRMSK   |I2C Address Mask
N     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
N     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
N     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
N     * @var I2C_T::WKCTL
N     * Offset: 0x3C  I2C Wake-up Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WKEN      |I2C Wake-up Enable Bit
N     * |        |          |0 = I2C wake-up function Disabled.
N     * |        |          |1= I2C wake-up function Enabled.
N     * |[7]     |NHDBUSEN  |I2C No Hold BUS Enable Bit
N     * |        |          |0 = I2C don't hold bus after wake-up disable.
N     * |        |          |1 = I2C don't hold bus after wake-up enable.
N     * |        |          |Note: I2C controller could response when WKIF event is not clear, it may cause error data transmitted or received.
N     * |        |          |If data transmitted or received when WKIF event is not clear, user must reset I2C controller and execute the original operation again.
N     * @var I2C_T::WKSTS
N     * Offset: 0x40  I2C Wake-up Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WKIF      |I2C Wake-up Flag
N     * |        |          |When chip is woken up from Power-down mode by I2C, this bit is set to 1.
N     * |        |          |Software can write 1 to clear this bit.
N     * |[1]     |WKAKDONE  |Wakeup Address Frame Acknowledge Bit Done
N     * |        |          |0 = The ACK bit cycle of address match frame isn't done.
N     * |        |          |1 = The ACK bit cycle of address match frame is done in power-down.
N     * |        |          |Note: This bit can't release WKIF. Software can write 1 to clear this bit.
N     * |[2]     |WRSTSWK   |Read/Write Status Bit in Address Wakeup Frame
N     * |        |          |0 = Write command be record on the address match wakeup frame.
N     * |        |          |1 = Read command be record on the address match wakeup frame.
N     * |        |          |Note: This bit will be cleared when software can write 1 to WKAKDONE bit.
N     * @var I2C_T::CTL1
N     * Offset: 0x44  I2C Control Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TXPDMAEN  |PDMA Transmit Channel Available
N     * |        |          |0 = Transmit PDMA function disable.
N     * |        |          |1 = Transmit PDMA function enable.
N     * |[1]     |RXPDMAEN  |PDMA Receive Channel Available
N     * |        |          |0 = Receive PDMA function disable.
N     * |        |          |1 = Receive PDMA function enable.
N     * |[2]     |PDMARST   |PDMA Reset
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the PDMA control logic. This bit will be cleared to 0 automatically.
N     * |[3]     |OVRIEN    |I2C over Run Interrupt Control Bit
N     * |        |          |Setting OVRIEN to logic 1 will send a interrupt to system when the TWOBUFEN bit is enabled and there is over run event in received buffer.
N     * |[4]     |UDRIEN    |I2C Under Run Interrupt Control Bit
N     * |        |          |Setting UDRIEN to logic 1 will send a interrupt to system when the TWOBUFEN bit is enabled and there is under run event happened in transmitted buffer.
N     * |[5]     |TWOBUFEN  |Two-level Buffer Enable Bit
N     * |        |          |0 = Two-level buffer Disabled.
N     * |        |          |1 = Two-level buffer Enabled.
N     * |        |          |Set to enable the two-level buffer for I2C transmitted or received buffer.
N     * |        |          |It is used to improve the performance of the I2C bus.
N     * |        |          |If this bit is set = 1, the control bit of STA for repeat start or STO bit should be set after the current SI is clear.
N     * |        |          |For example: if there are 4 data shall be transmitted and then stop it.
N     * |        |          |The STO bit shall be set after the 3rd data's SI event being clear.
N     * |        |          |In this time, the 4th data can be transmitted and the I2C stop after the 4th data transmission done.
N     * |[6]     |TWOBUFRST |Two-level Buffer Reset
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the related counters, two-level buffer state machine, and the content of data buffer.
N     * |[7]     |NSTRETCH  |No Stretch on the I2C Bus
N     * |        |          |0 = The I2C SCL bus is stretched by hardware if the SI is not cleared in master mode.
N     * |        |          |1 = The I2C SCL bus is not stretched by hardware if the SI is not cleared in master mode.
N     * |[8]     |PDMASTR   |PDMA Stretch Bit
N     * |        |          |0 = I2C send STOP automatically after PDMA transfer done. (only master TX)
N     * |        |          |1 = I2C SCL bus is stretched by hardware after PDMA transfer done if the SI is not cleared. (only master TX)
N     * @var I2C_T::STATUS1
N     * Offset: 0x48  I2C Status Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4]     |FULL      |Two-level Buffer Full
N     * |        |          |This bit indicates two-level buffer TX or RX full or not when the TWOBUFEN = 1.
N     * |        |          |This bit is set when POINTER is equal to 2.
N     * |[5]     |EMPTY     |Two-level Buffer Empty
N     * |        |          |This bit indicates two-level buffer TX or RX empty or not when the TWOBUFEN = 1.
N     * |        |          |This bit is set when POINTER is equal to 0.
N     * |[6]     |OVR       |I2C over Run Status Bit
N     * |        |          |This bit indicates the received two-level buffer TX or RX is over run when the TWOBUFEN = 1.
N     * |[7]     |UDR       |I2C Under Run Status Bit
N     * |        |          |This bit indicates the transmitted two-level buffer TX or RX is under run when the TWOBUFEN = 1.
N     * |[8]     |ONBUSY    |on Bus Busy
N     * |        |          |Indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected.
N     * |        |          |It is cleared by hardware when a STOP condition is detected.
N     * |        |          |0 = The bus is IDLE (both SCLK and SDA High).
N     * |        |          |1 = The bus is busy.
N     * @var I2C_T::TMCTL
N     * Offset: 0x4C  I2C Timing Configure Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |STCTL     |Setup Time Configure Control Register
N     * |        |          |This field is used to generate a delay timing between SDA falling edge and SCL rising edge in transmission mode.
N     * |        |          |The delay setup time is numbers of peripheral clock = STCTL x PCLK.
N     * |        |          |Note: Setup time setting should not make SCL output less than three PCLKs.
N     * |[11:6]  |HTCTL     |Hold Time Configure Control Register
N     * |        |          |This field is used to generate the delay timing between SCL falling edge and SDA rising edge in transmission mode.
N     * |        |          |The delay hold time is numbers of peripheral clock = HTCTL x PCLK.
N     */
N
N    __IO uint32_t CTL;                   /*!< [0x0000] I2C Control Register                                             */
X    volatile uint32_t CTL;                    
N    __IO uint32_t ADDR0;                 /*!< [0x0004] I2C Slave Address Register 0                                     */
X    volatile uint32_t ADDR0;                  
N    __IO uint32_t DAT;                   /*!< [0x0008] I2C Data Register                                                */
X    volatile uint32_t DAT;                    
N    __I  uint32_t STATUS;                /*!< [0x000c] I2C Status Register 0                                            */
X    volatile const  uint32_t STATUS;                 
N    __IO uint32_t CLKDIV;                /*!< [0x0010] I2C Clock Divided Register                                       */
X    volatile uint32_t CLKDIV;                 
N    __IO uint32_t TOCTL;                 /*!< [0x0014] I2C Time-out Control Register                                    */
X    volatile uint32_t TOCTL;                  
N    __IO uint32_t ADDR1;                 /*!< [0x0018] I2C Slave Address Register1                                      */
X    volatile uint32_t ADDR1;                  
N    __IO uint32_t ADDR2;                 /*!< [0x001c] I2C Slave Address Register2                                      */
X    volatile uint32_t ADDR2;                  
N    __IO uint32_t ADDR3;                 /*!< [0x0020] I2C Slave Address Register3                                      */
X    volatile uint32_t ADDR3;                  
N    __IO uint32_t ADDRMSK0;              /*!< [0x0024] I2C Slave Address Mask Register0                                 */
X    volatile uint32_t ADDRMSK0;               
N    __IO uint32_t ADDRMSK1;              /*!< [0x0028] I2C Slave Address Mask Register1                                 */
X    volatile uint32_t ADDRMSK1;               
N    __IO uint32_t ADDRMSK2;              /*!< [0x002c] I2C Slave Address Mask Register2                                 */
X    volatile uint32_t ADDRMSK2;               
N    __IO uint32_t ADDRMSK3;              /*!< [0x0030] I2C Slave Address Mask Register3                                 */
X    volatile uint32_t ADDRMSK3;               
N    __I  uint32_t RESERVE0[2];
X    volatile const  uint32_t RESERVE0[2];
N    __IO uint32_t WKCTL;                 /*!< [0x003c] I2C Wake-up Control Register                                     */
X    volatile uint32_t WKCTL;                  
N    __IO uint32_t WKSTS;                 /*!< [0x0040] I2C Wake-up Status Register                                      */
X    volatile uint32_t WKSTS;                  
N    __IO uint32_t CTL1;                  /*!< [0x0044] I2C Control Register 1                                           */
X    volatile uint32_t CTL1;                   
N    __I  uint32_t STATUS1;               /*!< [0x0048] I2C Status Register 1                                            */
X    volatile const  uint32_t STATUS1;                
N    __IO uint32_t TMCTL;                 /*!< [0x004c] I2C Timing Configure Control Register                            */
X    volatile uint32_t TMCTL;                  
N
N} I2C_T;
N
N/**
N    @addtogroup I2C_CONST I2C Bit Field Definition
N    Constant Definitions for I2C Controller
N@{ */
N
N#define I2C_CTL_AA_Pos                   (2)                                               /*!< I2C_T::CTL: AA Position                */
N#define I2C_CTL_AA_Msk                   (0x1ul << I2C_CTL_AA_Pos)                         /*!< I2C_T::CTL: AA Mask                    */
N
N#define I2C_CTL_SI_Pos                   (3)                                               /*!< I2C_T::CTL: SI Position                */
N#define I2C_CTL_SI_Msk                   (0x1ul << I2C_CTL_SI_Pos)                         /*!< I2C_T::CTL: SI Mask                    */
N
N#define I2C_CTL_STO_Pos                  (4)                                               /*!< I2C_T::CTL: STO Position               */
N#define I2C_CTL_STO_Msk                  (0x1ul << I2C_CTL_STO_Pos)                        /*!< I2C_T::CTL: STO Mask                   */
N
N#define I2C_CTL_STA_Pos                  (5)                                               /*!< I2C_T::CTL: STA Position               */
N#define I2C_CTL_STA_Msk                  (0x1ul << I2C_CTL_STA_Pos)                        /*!< I2C_T::CTL: STA Mask                   */
N
N#define I2C_CTL_I2CEN_Pos                (6)                                               /*!< I2C_T::CTL: I2CEN Position             */
N#define I2C_CTL_I2CEN_Msk                (0x1ul << I2C_CTL_I2CEN_Pos)                      /*!< I2C_T::CTL: I2CEN Mask                 */
N
N#define I2C_CTL_INTEN_Pos                (7)                                               /*!< I2C_T::CTL: INTEN Position             */
N#define I2C_CTL_INTEN_Msk                (0x1ul << I2C_CTL_INTEN_Pos)                      /*!< I2C_T::CTL: INTEN Mask                 */
N
N#define I2C_ADDR0_GC_Pos                 (0)                                               /*!< I2C_T::ADDR0: GC Position              */
N#define I2C_ADDR0_GC_Msk                 (0x1ul << I2C_ADDR0_GC_Pos)                       /*!< I2C_T::ADDR0: GC Mask                  */
N
N#define I2C_ADDR0_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR0: ADDR Position            */
N#define I2C_ADDR0_ADDR_Msk               (0x7ful << I2C_ADDR0_ADDR_Pos)                    /*!< I2C_T::ADDR0: ADDR Mask                */
N
N#define I2C_DAT_DAT_Pos                  (0)                                               /*!< I2C_T::DAT: DAT Position               */
N#define I2C_DAT_DAT_Msk                  (0xfful << I2C_DAT_DAT_Pos)                       /*!< I2C_T::DAT: DAT Mask                   */
N
N#define I2C_STATUS_STATUS_Pos            (0)                                               /*!< I2C_T::STATUS: STATUS Position         */
N#define I2C_STATUS_STATUS_Msk            (0xfful << I2C_STATUS_STATUS_Pos)                 /*!< I2C_T::STATUS: STATUS Mask             */
N
N#define I2C_CLKDIV_DIVIDER_Pos           (0)                                               /*!< I2C_T::CLKDIV: DIVIDER Position        */
N#define I2C_CLKDIV_DIVIDER_Msk           (0xfful << I2C_CLKDIV_DIVIDER_Pos)                /*!< I2C_T::CLKDIV: DIVIDER Mask            */
N
N#define I2C_TOCTL_TOIF_Pos               (0)                                               /*!< I2C_T::TOCTL: TOIF Position            */
N#define I2C_TOCTL_TOIF_Msk               (0x1ul << I2C_TOCTL_TOIF_Pos)                     /*!< I2C_T::TOCTL: TOIF Mask                */
N
N#define I2C_TOCTL_TOCDIV4_Pos            (1)                                               /*!< I2C_T::TOCTL: TOCDIV4 Position         */
N#define I2C_TOCTL_TOCDIV4_Msk            (0x1ul << I2C_TOCTL_TOCDIV4_Pos)                  /*!< I2C_T::TOCTL: TOCDIV4 Mask             */
N
N#define I2C_TOCTL_TOCEN_Pos              (2)                                               /*!< I2C_T::TOCTL: TOCEN Position           */
N#define I2C_TOCTL_TOCEN_Msk              (0x1ul << I2C_TOCTL_TOCEN_Pos)                    /*!< I2C_T::TOCTL: TOCEN Mask               */
N
N#define I2C_ADDR1_GC_Pos                 (0)                                               /*!< I2C_T::ADDR1: GC Position              */
N#define I2C_ADDR1_GC_Msk                 (0x1ul << I2C_ADDR1_GC_Pos)                       /*!< I2C_T::ADDR1: GC Mask                  */
N
N#define I2C_ADDR1_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR1: ADDR Position            */
N#define I2C_ADDR1_ADDR_Msk               (0x7ful << I2C_ADDR1_ADDR_Pos)                    /*!< I2C_T::ADDR1: ADDR Mask                */
N
N#define I2C_ADDR2_GC_Pos                 (0)                                               /*!< I2C_T::ADDR2: GC Position              */
N#define I2C_ADDR2_GC_Msk                 (0x1ul << I2C_ADDR2_GC_Pos)                       /*!< I2C_T::ADDR2: GC Mask                  */
N
N#define I2C_ADDR2_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR2: ADDR Position            */
N#define I2C_ADDR2_ADDR_Msk               (0x7ful << I2C_ADDR2_ADDR_Pos)                    /*!< I2C_T::ADDR2: ADDR Mask                */
N
N#define I2C_ADDR3_GC_Pos                 (0)                                               /*!< I2C_T::ADDR3: GC Position              */
N#define I2C_ADDR3_GC_Msk                 (0x1ul << I2C_ADDR3_GC_Pos)                       /*!< I2C_T::ADDR3: GC Mask                  */
N
N#define I2C_ADDR3_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR3: ADDR Position            */
N#define I2C_ADDR3_ADDR_Msk               (0x7ful << I2C_ADDR3_ADDR_Pos)                    /*!< I2C_T::ADDR3: ADDR Mask                */
N
N#define I2C_ADDRMSK0_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK0: ADDRMSK Position      */
N#define I2C_ADDRMSK0_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK0_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK0: ADDRMSK Mask          */
N
N#define I2C_ADDRMSK1_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK1: ADDRMSK Position      */
N#define I2C_ADDRMSK1_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK1_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK1: ADDRMSK Mask          */
N
N#define I2C_ADDRMSK2_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK2: ADDRMSK Position      */
N#define I2C_ADDRMSK2_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK2_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK2: ADDRMSK Mask          */
N
N#define I2C_ADDRMSK3_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK3: ADDRMSK Position      */
N#define I2C_ADDRMSK3_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK3_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK3: ADDRMSK Mask          */
N
N#define I2C_WKCTL_WKEN_Pos               (0)                                               /*!< I2C_T::WKCTL: WKEN Position            */
N#define I2C_WKCTL_WKEN_Msk               (0x1ul << I2C_WKCTL_WKEN_Pos)                     /*!< I2C_T::WKCTL: WKEN Mask                */
N
N#define I2C_WKCTL_NHDBUSEN_Pos           (7)                                               /*!< I2C_T::WKCTL: NHDBUSEN Position        */
N#define I2C_WKCTL_NHDBUSEN_Msk           (0x1ul << I2C_WKCTL_NHDBUSEN_Pos)                 /*!< I2C_T::WKCTL: NHDBUSEN Mask            */
N
N#define I2C_WKSTS_WKIF_Pos               (0)                                               /*!< I2C_T::WKSTS: WKIF Position            */
N#define I2C_WKSTS_WKIF_Msk               (0x1ul << I2C_WKSTS_WKIF_Pos)                     /*!< I2C_T::WKSTS: WKIF Mask                */
N
N#define I2C_WKSTS_WKAKDONE_Pos           (1)                                               /*!< I2C_T::WKSTS: WKAKDONE Position        */
N#define I2C_WKSTS_WKAKDONE_Msk           (0x1ul << I2C_WKSTS_WKAKDONE_Pos)                 /*!< I2C_T::WKSTS: WKAKDONE Mask            */
N
N#define I2C_WKSTS_WRSTSWK_Pos            (2)                                               /*!< I2C_T::WKSTS: WRSTSWK Position         */
N#define I2C_WKSTS_WRSTSWK_Msk            (0x1ul << I2C_WKSTS_WRSTSWK_Pos)                  /*!< I2C_T::WKSTS: WRSTSWK Mask             */
N
N#define I2C_CTL1_TXPDMAEN_Pos            (0)                                               /*!< I2C_T::CTL1: TXPDMAEN Position         */
N#define I2C_CTL1_TXPDMAEN_Msk            (0x1ul << I2C_CTL1_TXPDMAEN_Pos)                  /*!< I2C_T::CTL1: TXPDMAEN Mask             */
N
N#define I2C_CTL1_RXPDMAEN_Pos            (1)                                               /*!< I2C_T::CTL1: RXPDMAEN Position         */
N#define I2C_CTL1_RXPDMAEN_Msk            (0x1ul << I2C_CTL1_RXPDMAEN_Pos)                  /*!< I2C_T::CTL1: RXPDMAEN Mask             */
N
N#define I2C_CTL1_PDMARST_Pos             (2)                                               /*!< I2C_T::CTL1: PDMARST Position          */
N#define I2C_CTL1_PDMARST_Msk             (0x1ul << I2C_CTL1_PDMARST_Pos)                   /*!< I2C_T::CTL1: PDMARST Mask              */
N
N#define I2C_CTL1_OVRIEN_Pos              (3)                                               /*!< I2C_T::CTL1: OVRIEN Position           */
N#define I2C_CTL1_OVRIEN_Msk              (0x1ul << I2C_CTL1_OVRIEN_Pos)                    /*!< I2C_T::CTL1: OVRIEN Mask               */
N
N#define I2C_CTL1_UDRIEN_Pos              (4)                                               /*!< I2C_T::CTL1: UDRIEN Position           */
N#define I2C_CTL1_UDRIEN_Msk              (0x1ul << I2C_CTL1_UDRIEN_Pos)                    /*!< I2C_T::CTL1: UDRIEN Mask               */
N
N#define I2C_CTL1_TWOBUFEN_Pos            (5)                                               /*!< I2C_T::CTL1: TWOBUFEN Position         */
N#define I2C_CTL1_TWOBUFEN_Msk            (0x1ul << I2C_CTL1_TWOBUFEN_Pos)                  /*!< I2C_T::CTL1: TWOBUFEN Mask             */
N
N#define I2C_CTL1_TWOBUFRST_Pos           (6)                                               /*!< I2C_T::CTL1: TWOBUFRST Position        */
N#define I2C_CTL1_TWOBUFRST_Msk           (0x1ul << I2C_CTL1_TWOBUFRST_Pos)                 /*!< I2C_T::CTL1: TWOBUFRST Mask            */
N
N#define I2C_CTL1_NSTRETCH_Pos            (7)                                               /*!< I2C_T::CTL1: NSTRETCH Position         */
N#define I2C_CTL1_NSTRETCH_Msk            (0x1ul << I2C_CTL1_NSTRETCH_Pos)                  /*!< I2C_T::CTL1: NSTRETCH Mask             */
N
N#define I2C_CTL1_PDMASTR_Pos             (8)                                               /*!< I2C_T::CTL1: PDMASTR Position          */
N#define I2C_CTL1_PDMASTR_Msk             (0x1ul << I2C_CTL1_PDMASTR_Pos)                   /*!< I2C_T::CTL1: PDMASTR Mask              */
N
N#define I2C_STATUS1_FULL_Pos             (4)                                               /*!< I2C_T::STATUS1: FULL Position          */
N#define I2C_STATUS1_FULL_Msk             (0x1ul << I2C_STATUS1_FULL_Pos)                   /*!< I2C_T::STATUS1: FULL Mask              */
N
N#define I2C_STATUS1_EMPTY_Pos            (5)                                               /*!< I2C_T::STATUS1: EMPTY Position         */
N#define I2C_STATUS1_EMPTY_Msk            (0x1ul << I2C_STATUS1_EMPTY_Pos)                  /*!< I2C_T::STATUS1: EMPTY Mask             */
N
N#define I2C_STATUS1_OVR_Pos              (6)                                               /*!< I2C_T::STATUS1: OVR Position           */
N#define I2C_STATUS1_OVR_Msk              (0x1ul << I2C_STATUS1_OVR_Pos)                    /*!< I2C_T::STATUS1: OVR Mask               */
N
N#define I2C_STATUS1_UDR_Pos              (7)                                               /*!< I2C_T::STATUS1: UDR Position           */
N#define I2C_STATUS1_UDR_Msk              (0x1ul << I2C_STATUS1_UDR_Pos)                    /*!< I2C_T::STATUS1: UDR Mask               */
N
N#define I2C_STATUS1_ONBUSY_Pos           (8)                                               /*!< I2C_T::STATUS1: ONBUSY Position        */
N#define I2C_STATUS1_ONBUSY_Msk           (0x1ul << I2C_STATUS1_ONBUSY_Pos)                 /*!< I2C_T::STATUS1: ONBUSY Mask            */
N
N#define I2C_TMCTL_STCTL_Pos              (0)                                               /*!< I2C_T::TMCTL: STCTL Position           */
N#define I2C_TMCTL_STCTL_Msk              (0x3ful << I2C_TMCTL_STCTL_Pos)                   /*!< I2C_T::TMCTL: STCTL Mask               */
N
N#define I2C_TMCTL_HTCTL_Pos              (6)                                               /*!< I2C_T::TMCTL: HTCTL Position           */
N#define I2C_TMCTL_HTCTL_Msk              (0x3ful << I2C_TMCTL_HTCTL_Pos)                   /*!< I2C_T::TMCTL: HTCTL Mask               */
N
N/**@}*/ /* I2C_CONST */
N/**@}*/ /* end of I2C register group */
N
N
N/*---------------------- Peripheral Direct Memory Access Controller -------------------------*/
N/**
N    @addtogroup PDMA Peripheral Direct Memory Access Controller(PDMA)
N    Memory Mapped Structure for PDMA Controller
N@{ */
N
N
N
Ntypedef struct
N{
N    /**
N     * @var DSCT_T::CTL
N     * Offset: 0x00/0x10/0x20/0x30/0x40  Descriptor Table Control Register of PDMA Channel 0~4
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
N     * |        |          |00 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
N     * |        |          |01 = Basic mode: The descriptor table only has one task
N     * |        |          |When this task is finished, the TDIF(PDMA_INTSTS[1]) will be asserted.
N     * |        |          |10 = Scatter-Gather mode: When operating in this mode, user must give the first descriptor table address in PDMA_DSCT_FIRST register; PDMA controller will ignore this task, then load the next task to execute.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
N     * |[2]     |TXTYPE    |Transfer Type
N     * |        |          |0 = Burst transfer type.
N     * |        |          |1 = Single transfer type.
N     * |[6:4]   |BURSIZE   |Burst Size
N     * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
N     * |        |          |000 = 128 Transfers.
N     * |        |          |001 = 64 Transfers.
N     * |        |          |010 = 32 Transfers.
N     * |        |          |011 = 16 Transfers.
N     * |        |          |100 = 8 Transfers.
N     * |        |          |101 = 4 Transfers.
N     * |        |          |110 = 2 Transfers.
N     * |        |          |111 = 1 Transfers.
N     * |        |          |Note: This field is only useful in burst transfer type.
N     * |[7]     |TBINTDIS  |Table Interrupt Disable Bit
N     * |        |          |This field can be used to decide whether to enable table interrupt or not
N     * |        |          |If the TBINTDIS bit is enabled when PDMA controller finishes transfer task, it will not generates transfer done interrupt.
N     * |        |          |0 = Table interrupt Enabled.
N     * |        |          |1 = Table interrupt Disabled.
N     * |        |          |Note: If this bit set to 1, the TEMPTYF will not be set.
N     * |[9:8]   |SAINC     |Source Address Increment
N     * |        |          |This Field Is Used To Set The Source Address Increment Size.
N     * |        |          |11 = No Increment (Fixed Address).
N     * |        |          |Others = Increment And Size Is Depended On TXWIDTH Selection.
N     * |[11:10] |DAINC     |Destination Address Increment
N     * |        |          |This field is used to set the destination address increment size.
N     * |        |          |11 = No increment (fixed address).
N     * |        |          |Others = Increment and size is depended on TXWIDTH selection.
N     * |[13:12] |TXWIDTH   |Transfer Width Selection
N     * |        |          |This field is used for transfer width.
N     * |        |          |00 = One byte (8 bit) is transferred for every operation.
N     * |        |          |01 = One half-word (16 bit) is transferred for every operation.
N     * |        |          |10 = One word (32-bit) is transferred for every operation.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
N     * |        |          |For example, if source address is 0x2000_0202, but TXWIDTH is word transfer, the source address is not word alignment
N     * |        |          |The source address is aligned when TXWIDTH is byte or half-word transfer.
N     * |[29:16] |TXCNT     |Transfer Count
N     * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
N     * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
N     * @var DSCT_T::SA
N     * Offset: 0x04/0x14/0x24/0x34/0x44  Source Address Register of PDMA Channel 0~4
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |SA        |PDMA Transfer Source Address Register
N     * |        |          |This field indicates a 32-bit source address of PDMA controller.
N     * |        |          |Note: The PDMA transfer source address should be aligned with the TXWIDTH(PDMA_DSCTn_CTL[13:12], n=0,1..4) selection.
N     * @var DSCT_T::DA
N     * Offset: 0x08/0x18/0x28/0x38/0x48  Destination Address Register of PDMA Channel 0~4
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |DA        |PDMA Transfer Destination Address Register
N     * |        |          |This field indicates a 32-bit destination address of PDMA controller.
N     * |        |          |Note: The PDMA transfer destination address should be aligned with the TXWIDTH(PDMA_DSCTn_CTL[13:12], n=0,1..4) selection.
N     * @var DSCT_T::FIRST
N     * Offset: 0x0C/0x1C/0x2C/0x3C/0x4C  First Scatter-Gather Descriptor Table Offset of PDMA Channel 0~4
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FIRST     |PDMA First Descriptor Table Offset
N     * |        |          |This field indicates the offset of the first descriptor table address in system memory.
N     * |        |          |Write Operation:
N     * |        |          |If the system memory based address is 0x2000_0000 (PDMA_SCATBA), and the first descriptor table is start from 0x2000_0100, then this field must fill in 0x0100.
N     * |        |          |Read Operation:
N     * |        |          |When operating in scatter-gather mode, the last two bits FIRST[1:0] will become reserved.
N     * |        |          |Note1: The first descriptor table address must be word boundary.
N     * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
N     * |[31:16] |NEXT      |PDMA Next Descriptor Table Offset
N     * |        |          |This field indicates the offset of next descriptor table address in system memory.
N     * |        |          |Note: write operation is useless in this field.
N     */
N
N    __IO uint32_t CTL;             /*!< [0x00/0x10/0x20/0x30/0x40] Descriptor Table Control Register of PDMA Channel 0~4              */
X    volatile uint32_t CTL;              
N    __IO uint32_t SA;              /*!< [0x04/0x14/0x24/0x34/0x44] Source Address Register of PDMA Channel 0~4                        */
X    volatile uint32_t SA;               
N    __IO uint32_t DA;              /*!< [0x08/0x18/0x28/0x38/0x48] Destination Address Register of PDMA Channel 0~4                   */
X    volatile uint32_t DA;               
N    union
N    {
N        __IO uint32_t FIRST;       /*!< [0x0C/0x1C/0x2C/0x3C/0x4C] First Scatter-Gather Descriptor Table Offset of PDMA Channel 0~4   */
X        volatile uint32_t FIRST;        
N        __IO uint32_t NEXT;        /*!< Next Scatter-Gather Descriptor Table Offset                                                   */
X        volatile uint32_t NEXT;         
N    };
N
N} DSCT_T;
N
Ntypedef struct
N{
N
N
N    /**
N     * @var PDMA_T::CURSCAT
N     * Offset: 0x50/0x54/0x58/0x5C/0x60  Current Scatter-Gather Descriptor Table Address of PDMA Channel 0~4
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
N     * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
N     * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
N     * @var PDMA_T::CHCTL
N     * Offset: 0x400  PDMA Channel Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CHEN0     |PDMA Channel N Enable Bit
N     * |        |          |Set this bit to 1 to enable PDMAn operation. Channel cannot be active if it is not set as enabled.
N     * |        |          |0 = PDMA channel [n] Disabled.
N     * |        |          |1 = PDMA channel [n] Enabled.
N     * |        |          |Note: Set PDMA_PAUSE or PDMA_RESET register will also clear this bit.
N     * |[1]     |CHEN1     |PDMA Channel N Enable Bit
N     * |        |          |Set this bit to 1 to enable PDMAn operation. Channel cannot be active if it is not set as enabled.
N     * |        |          |0 = PDMA channel [n] Disabled.
N     * |        |          |1 = PDMA channel [n] Enabled.
N     * |        |          |Note: Set PDMA_PAUSE or PDMA_RESET register will also clear this bit.
N     * |[2]     |CHEN2     |PDMA Channel N Enable Bit
N     * |        |          |Set this bit to 1 to enable PDMAn operation. Channel cannot be active if it is not set as enabled.
N     * |        |          |0 = PDMA channel [n] Disabled.
N     * |        |          |1 = PDMA channel [n] Enabled.
N     * |        |          |Note: Set PDMA_PAUSE or PDMA_RESET register will also clear this bit.
N     * |[3]     |CHEN3     |PDMA Channel N Enable Bit
N     * |        |          |Set this bit to 1 to enable PDMAn operation. Channel cannot be active if it is not set as enabled.
N     * |        |          |0 = PDMA channel [n] Disabled.
N     * |        |          |1 = PDMA channel [n] Enabled.
N     * |        |          |Note: Set PDMA_PAUSE or PDMA_RESET register will also clear this bit.
N     * |[4]     |CHEN4     |PDMA Channel N Enable Bit
N     * |        |          |Set this bit to 1 to enable PDMAn operation. Channel cannot be active if it is not set as enabled.
N     * |        |          |0 = PDMA channel [n] Disabled.
N     * |        |          |1 = PDMA channel [n] Enabled.
N     * |        |          |Note: Set PDMA_PAUSE or PDMA_RESET register will also clear this bit.
N     * @var PDMA_T::PAUSE
N     * Offset: 0x404  PDMA Transfer Pause Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PAUSE0    |PDMA Channel N Transfer Pause Control Register (Write Only)
N     * |        |          |User can set PAUSEn bit field to pause the PDMA transfer
N     * |        |          |When user sets PAUSEn bit, the PDMA controller will pause the on-going transfer, then clear the channel enable bit CHEN(PDMA_CHCTL [n], n=0,1..4) and clear request active flag
N     * |        |          |If re-enable the paused channel agian, the remaining transfers will be processed.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Pause PDMA channel n transfer.
N     * |[1]     |PAUSE1    |PDMA Channel N Transfer Pause Control Register (Write Only)
N     * |        |          |User can set PAUSEn bit field to pause the PDMA transfer
N     * |        |          |When user sets PAUSEn bit, the PDMA controller will pause the on-going transfer, then clear the channel enable bit CHEN(PDMA_CHCTL [n], n=0,1..4) and clear request active flag
N     * |        |          |If re-enable the paused channel agian, the remaining transfers will be processed.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Pause PDMA channel n transfer.
N     * |[2]     |PAUSE2    |PDMA Channel N Transfer Pause Control Register (Write Only)
N     * |        |          |User can set PAUSEn bit field to pause the PDMA transfer
N     * |        |          |When user sets PAUSEn bit, the PDMA controller will pause the on-going transfer, then clear the channel enable bit CHEN(PDMA_CHCTL [n], n=0,1..4) and clear request active flag
N     * |        |          |If re-enable the paused channel agian, the remaining transfers will be processed.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Pause PDMA channel n transfer.
N     * |[3]     |PAUSE3    |PDMA Channel N Transfer Pause Control Register (Write Only)
N     * |        |          |User can set PAUSEn bit field to pause the PDMA transfer
N     * |        |          |When user sets PAUSEn bit, the PDMA controller will pause the on-going transfer, then clear the channel enable bit CHEN(PDMA_CHCTL [n], n=0,1..4) and clear request active flag
N     * |        |          |If re-enable the paused channel agian, the remaining transfers will be processed.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Pause PDMA channel n transfer.
N     * |[4]     |PAUSE4    |PDMA Channel N Transfer Pause Control Register (Write Only)
N     * |        |          |User can set PAUSEn bit field to pause the PDMA transfer
N     * |        |          |When user sets PAUSEn bit, the PDMA controller will pause the on-going transfer, then clear the channel enable bit CHEN(PDMA_CHCTL [n], n=0,1..4) and clear request active flag
N     * |        |          |If re-enable the paused channel agian, the remaining transfers will be processed.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Pause PDMA channel n transfer.
N     * @var PDMA_T::SWREQ
N     * Offset: 0x408  PDMA Software Request Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SWREQ0    |PDMA Channel N Software Request Register (Write Only)
N     * |        |          |Set this bit to 1 to generate a software request to PDMA [n].
N     * |        |          |0 = No effect.
N     * |        |          |1 = Generate a software request.
N     * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
N     * |        |          |Active flag may be triggered by software request or peripheral request.
N     * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
N     * |[1]     |SWREQ1    |PDMA Channel N Software Request Register (Write Only)
N     * |        |          |Set this bit to 1 to generate a software request to PDMA [n].
N     * |        |          |0 = No effect.
N     * |        |          |1 = Generate a software request.
N     * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
N     * |        |          |Active flag may be triggered by software request or peripheral request.
N     * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
N     * |[2]     |SWREQ2    |PDMA Channel N Software Request Register (Write Only)
N     * |        |          |Set this bit to 1 to generate a software request to PDMA [n].
N     * |        |          |0 = No effect.
N     * |        |          |1 = Generate a software request.
N     * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
N     * |        |          |Active flag may be triggered by software request or peripheral request.
N     * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
N     * |[3]     |SWREQ3    |PDMA Channel N Software Request Register (Write Only)
N     * |        |          |Set this bit to 1 to generate a software request to PDMA [n].
N     * |        |          |0 = No effect.
N     * |        |          |1 = Generate a software request.
N     * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
N     * |        |          |Active flag may be triggered by software request or peripheral request.
N     * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
N     * |[4]     |SWREQ4    |PDMA Channel N Software Request Register (Write Only)
N     * |        |          |Set this bit to 1 to generate a software request to PDMA [n].
N     * |        |          |0 = No effect.
N     * |        |          |1 = Generate a software request.
N     * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
N     * |        |          |Active flag may be triggered by software request or peripheral request.
N     * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
N     * @var PDMA_T::TRGSTS
N     * Offset: 0x40C  PDMA Channel Request Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |REQSTS0   |PDMA Channel N Request Status (Read Only)
N     * |        |          |This flag indicates whether channel[n] have a request or not, no matter request from software or peripheral
N     * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
N     * |        |          |0 = PDMA Channel n has no request.
N     * |        |          |1 = PDMA Channel n has a request.
N     * |        |          |Note: If user pauses or resets each PDMA transfer by setting PDMA_PAUSE or PDMA_RESET register respectively, this bit will be cleared automatically after finishing current transfer.
N     * |[1]     |REQSTS1   |PDMA Channel N Request Status (Read Only)
N     * |        |          |This flag indicates whether channel[n] have a request or not, no matter request from software or peripheral
N     * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
N     * |        |          |0 = PDMA Channel n has no request.
N     * |        |          |1 = PDMA Channel n has a request.
N     * |        |          |Note: If user pauses or resets each PDMA transfer by setting PDMA_PAUSE or PDMA_RESET register respectively, this bit will be cleared automatically after finishing current transfer.
N     * |[2]     |REQSTS2   |PDMA Channel N Request Status (Read Only)
N     * |        |          |This flag indicates whether channel[n] have a request or not, no matter request from software or peripheral
N     * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
N     * |        |          |0 = PDMA Channel n has no request.
N     * |        |          |1 = PDMA Channel n has a request.
N     * |        |          |Note: If user pauses or resets each PDMA transfer by setting PDMA_PAUSE or PDMA_RESET register respectively, this bit will be cleared automatically after finishing current transfer.
N     * |[3]     |REQSTS3   |PDMA Channel N Request Status (Read Only)
N     * |        |          |This flag indicates whether channel[n] have a request or not, no matter request from software or peripheral
N     * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
N     * |        |          |0 = PDMA Channel n has no request.
N     * |        |          |1 = PDMA Channel n has a request.
N     * |        |          |Note: If user pauses or resets each PDMA transfer by setting PDMA_PAUSE or PDMA_RESET register respectively, this bit will be cleared automatically after finishing current transfer.
N     * |[4]     |REQSTS4   |PDMA Channel N Request Status (Read Only)
N     * |        |          |This flag indicates whether channel[n] have a request or not, no matter request from software or peripheral
N     * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
N     * |        |          |0 = PDMA Channel n has no request.
N     * |        |          |1 = PDMA Channel n has a request.
N     * |        |          |Note: If user pauses or resets each PDMA transfer by setting PDMA_PAUSE or PDMA_RESET register respectively, this bit will be cleared automatically after finishing current transfer.
N     * @var PDMA_T::PRISET
N     * Offset: 0x410  PDMA Fixed Priority Setting Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |FPRISET0  |PDMA Channel N Fixed Priority Setting Register
N     * |        |          |Set this bit to 1 to enable fixed priority level
N     * |        |          |The fixed priority channel has higher priority than round-robin priority channel
N     * |        |          |If multiple channels are set as the same priority, the higher number of channels have higher priority.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Set PDMA channel [n] to fixed priority channel.
N     * |        |          |Read Operation:
N     * |        |          |0 = Corresponding PDMA channel is round-robin priority.
N     * |        |          |1 = Corresponding PDMA channel is fixed priority.
N     * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
N     * |[1]     |FPRISET1  |PDMA Channel N Fixed Priority Setting Register
N     * |        |          |Set this bit to 1 to enable fixed priority level
N     * |        |          |The fixed priority channel has higher priority than round-robin priority channel
N     * |        |          |If multiple channels are set as the same priority, the higher number of channels have higher priority.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Set PDMA channel [n] to fixed priority channel.
N     * |        |          |Read Operation:
N     * |        |          |0 = Corresponding PDMA channel is round-robin priority.
N     * |        |          |1 = Corresponding PDMA channel is fixed priority.
N     * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
N     * |[2]     |FPRISET2  |PDMA Channel N Fixed Priority Setting Register
N     * |        |          |Set this bit to 1 to enable fixed priority level
N     * |        |          |The fixed priority channel has higher priority than round-robin priority channel
N     * |        |          |If multiple channels are set as the same priority, the higher number of channels have higher priority.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Set PDMA channel [n] to fixed priority channel.
N     * |        |          |Read Operation:
N     * |        |          |0 = Corresponding PDMA channel is round-robin priority.
N     * |        |          |1 = Corresponding PDMA channel is fixed priority.
N     * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
N     * |[3]     |FPRISET3  |PDMA Channel N Fixed Priority Setting Register
N     * |        |          |Set this bit to 1 to enable fixed priority level
N     * |        |          |The fixed priority channel has higher priority than round-robin priority channel
N     * |        |          |If multiple channels are set as the same priority, the higher number of channels have higher priority.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Set PDMA channel [n] to fixed priority channel.
N     * |        |          |Read Operation:
N     * |        |          |0 = Corresponding PDMA channel is round-robin priority.
N     * |        |          |1 = Corresponding PDMA channel is fixed priority.
N     * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
N     * |[4]     |FPRISET4  |PDMA Channel N Fixed Priority Setting Register
N     * |        |          |Set this bit to 1 to enable fixed priority level
N     * |        |          |The fixed priority channel has higher priority than round-robin priority channel
N     * |        |          |If multiple channels are set as the same priority, the higher number of channels have higher priority.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Set PDMA channel [n] to fixed priority channel.
N     * |        |          |Read Operation:
N     * |        |          |0 = Corresponding PDMA channel is round-robin priority.
N     * |        |          |1 = Corresponding PDMA channel is fixed priority.
N     * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
N     * @var PDMA_T::PRICLR
N     * Offset: 0x414  PDMA Fixed Priority Clear Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |FPRICLR0  |PDMA Channel N Fixed Priority Clear Register (Write Only)
N     * |        |          |Set this bit to 1 to clear fixed priority level.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear PDMA channel [n] fixed priority setting.
N     * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
N     * |[1]     |FPRICLR1  |PDMA Channel N Fixed Priority Clear Register (Write Only)
N     * |        |          |Set this bit to 1 to clear fixed priority level.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear PDMA channel [n] fixed priority setting.
N     * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
N     * |[2]     |FPRICLR2  |PDMA Channel N Fixed Priority Clear Register (Write Only)
N     * |        |          |Set this bit to 1 to clear fixed priority level.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear PDMA channel [n] fixed priority setting.
N     * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
N     * |[3]     |FPRICLR3  |PDMA Channel N Fixed Priority Clear Register (Write Only)
N     * |        |          |Set this bit to 1 to clear fixed priority level.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear PDMA channel [n] fixed priority setting.
N     * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
N     * |[4]     |FPRICLR4  |PDMA Channel N Fixed Priority Clear Register (Write Only)
N     * |        |          |Set this bit to 1 to clear fixed priority level.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear PDMA channel [n] fixed priority setting.
N     * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
N     * @var PDMA_T::INTEN
N     * Offset: 0x418  PDMA Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |INTEN0    |PDMA Channel N Interrupt Enable Register
N     * |        |          |This field is used for enabling PDMA channel[n] interrupt.
N     * |        |          |0 = PDMA channel n interrupt Disabled.
N     * |        |          |1 = PDMA channel n interrupt Enabled.
N     * |[1]     |INTEN1    |PDMA Channel N Interrupt Enable Register
N     * |        |          |This field is used for enabling PDMA channel[n] interrupt.
N     * |        |          |0 = PDMA channel n interrupt Disabled.
N     * |        |          |1 = PDMA channel n interrupt Enabled.
N     * |[2]     |INTEN2    |PDMA Channel N Interrupt Enable Register
N     * |        |          |This field is used for enabling PDMA channel[n] interrupt.
N     * |        |          |0 = PDMA channel n interrupt Disabled.
N     * |        |          |1 = PDMA channel n interrupt Enabled.
N     * |[3]     |INTEN3    |PDMA Channel N Interrupt Enable Register
N     * |        |          |This field is used for enabling PDMA channel[n] interrupt.
N     * |        |          |0 = PDMA channel n interrupt Disabled.
N     * |        |          |1 = PDMA channel n interrupt Enabled.
N      * |[4]     |INTEN4    |PDMA Channel N Interrupt Enable Register
N     * |        |          |This field is used for enabling PDMA channel[n] interrupt.
N     * |        |          |0 = PDMA channel n interrupt Disabled.
N     * |        |          |1 = PDMA channel n interrupt Enabled.
N     * @var PDMA_T::INTSTS
N     * Offset: 0x41C  PDMA Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ABTIF     |PDMA Read/Write Target Abort Interrupt Flag (Read Only)
N     * |        |          |This bit indicates that PDMA has target abort error; Software can read PDMA_ABTSTS register to find which channel has target abort error.
N     * |        |          |0 = No AHB bus ERROR response received.
N     * |        |          |1 = AHB bus ERROR response received.
N     * |[1]     |TDIF      |Transfer Done Interrupt Flag (Read Only)
N     * |        |          |This bit indicates that PDMA controller has finished transmission; User can read PDMA_TDSTS register to indicate which channel finished transfer.
N     * |        |          |0 = Not finished yet.
N     * |        |          |1 = PDMA channel has finished transmission.
N     * |[2]     |TEIF      |Table Empty Interrupt Flag (Read Only)
N     * |        |          |This bit indicates PDMA channel scatter-gather table is empty
N     * |        |          |User can read PDMA_SCATSTS register to indicate which channel scatter-gather table is empty.
N     * |        |          |0 = PDMA channel scatter-gather table is not empty.
N     * |        |          |1 = PDMA channel scatter-gather table is empty.
N     * |[8]     |REQTOF0   |PDMA Channel N Request Time-out Flag for Each Channel [N]
N     * |        |          |This flag indicates that PDMA controller has waited peripheral request for a period defined by PDMA_TOC0, user can write 1 to clear these bits.
N     * |        |          |0 = No request time-out.
N     * |        |          |1 = Peripheral request time-out.
N     * |[9]     |REQTOF1   |PDMA Channel N Request Time-out Flag for Each Channel [N]
N     * |        |          |This flag indicates that PDMA controller has waited peripheral request for a period defined by PDMA_TOC10, user can write 1 to clear these bits.
N     * |        |          |0 = No request time-out.
N     * |        |          |1 = Peripheral request time-out.
N     * @var PDMA_T::ABTSTS
N     * Offset: 0x420  PDMA Channel Read/Write Target Abort Flag Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ABTIF0    |PDMA Channel 0 Read/Write Target Abort Interrupt Status Flag
N     * |        |          |This bit indicates which PDMA controller has target abort error; User can write 1 to clear these bits.
N     * |        |          |0 = No AHB bus ERROR response received when channel n transfer.
N     * |        |          |1 = AHB bus ERROR response received when channel n transfer.
N     * |[1]     |ABTIF1    |PDMA Channel 1 Read/Write Target Abort Interrupt Status Flag
N     * |        |          |This bit indicates which PDMA controller has target abort error; User can write 1 to clear these bits.
N     * |        |          |0 = No AHB bus ERROR response received when channel n transfer.
N     * |        |          |1 = AHB bus ERROR response received when channel n transfer.
N     * |[2]     |ABTIF2    |PDMA Channel 2 Read/Write Target Abort Interrupt Status Flag
N     * |        |          |This bit indicates which PDMA controller has target abort error; User can write 1 to clear these bits.
N     * |        |          |0 = No AHB bus ERROR response received when channel n transfer.
N     * |        |          |1 = AHB bus ERROR response received when channel n transfer.
N     * |[3]     |ABTIF3    |PDMA Channel 3 Read/Write Target Abort Interrupt Status Flag
N     * |        |          |This bit indicates which PDMA controller has target abort error; User can write 1 to clear these bits.
N     * |        |          |0 = No AHB bus ERROR response received when channel n transfer.
N     * |        |          |1 = AHB bus ERROR response received when channel n transfer.
N     * |[4]     |ABTIF4    |PDMA Channel 4 Read/Write Target Abort Interrupt Status Flag
N     * |        |          |This bit indicates which PDMA controller has target abort error; User can write 1 to clear these bits.
N     * |        |          |0 = No AHB bus ERROR response received when channel n transfer.
N     * |        |          |1 = AHB bus ERROR response received when channel n transfer.
N     * @var PDMA_T::TDSTS
N     * Offset: 0x424  PDMA Channel Transfer Done Flag Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TDIF0     |PDMA Channel 0 Transfer Done Flag Register
N     * |        |          |This bit indicates whether PDMA controller channel transfer has been finished or not, user can write 1 to clear these bits.
N     * |        |          |0 = PDMA channel transfer has not finished.
N     * |        |          |1 = PDMA channel has finished transmission.
N     * |[1]     |TDIF1     |PDMA Channel 1 Transfer Done Flag Register
N     * |        |          |This bit indicates whether PDMA controller channel transfer has been finished or not, user can write 1 to clear these bits.
N     * |        |          |0 = PDMA channel transfer has not finished.
N     * |        |          |1 = PDMA channel has finished transmission.
N     * |[2]     |TDIF2     |PDMA Channel 2 Transfer Done Flag Register
N     * |        |          |This bit indicates whether PDMA controller channel transfer has been finished or not, user can write 1 to clear these bits.
N     * |        |          |0 = PDMA channel transfer has not finished.
N     * |        |          |1 = PDMA channel has finished transmission.
N     * |[3]     |TDIF3     |PDMA Channel 3 Transfer Done Flag Register
N     * |        |          |This bit indicates whether PDMA controller channel transfer has been finished or not, user can write 1 to clear these bits.
N     * |        |          |0 = PDMA channel transfer has not finished.
N     * |        |          |1 = PDMA channel has finished transmission.
N     * |[4]     |TDIF4     |PDMA Channel 4 Transfer Done Flag Register
N     * |        |          |This bit indicates whether PDMA controller channel transfer has been finished or not, user can write 1 to clear these bits.
N     * |        |          |0 = PDMA channel transfer has not finished.
N     * |        |          |1 = PDMA channel has finished transmission.
N     * @var PDMA_T::SCATSTS
N     * Offset: 0x428  PDMA Scatter-Gather Table Empty Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TEMPTYF0  |Table Empty Flag Register
N     * |        |          |T This bit indicates which PDMA channel table is empty when channel have a request , no matter request from software or peripheral, but operation mode of channel descriptor table is idle state, or channel has finished current transfer and next table operation mode is idle state for PDMA Scatter-Gather mode
N     * |        |          |User can write 1 to clear these bits.
N     * |        |          |0 = PDMA channel scatter-gather table is not empty.
N     * |        |          |1 = PDMA channel scatter-gather table is empty and PDMA SWREQ has be set.
N     * |[1]     |TEMPTYF1  |Table Empty Flag Register
N     * |        |          |T This bit indicates which PDMA channel table is empty when channel have a request , no matter request from software or peripheral, but operation mode of channel descriptor table is idle state, or channel has finished current transfer and next table operation mode is idle state for PDMA Scatter-Gather mode
N     * |        |          |User can write 1 to clear these bits.
N     * |        |          |0 = PDMA channel scatter-gather table is not empty.
N     * |        |          |1 = PDMA channel scatter-gather table is empty and PDMA SWREQ has be set.
N     * |[2]     |TEMPTYF2  |Table Empty Flag Register
N     * |        |          |T This bit indicates which PDMA channel table is empty when channel have a request , no matter request from software or peripheral, but operation mode of channel descriptor table is idle state, or channel has finished current transfer and next table operation mode is idle state for PDMA Scatter-Gather mode
N     * |        |          |User can write 1 to clear these bits.
N     * |        |          |0 = PDMA channel scatter-gather table is not empty.
N     * |        |          |1 = PDMA channel scatter-gather table is empty and PDMA SWREQ has be set.
N     * |[3]     |TEMPTYF3  |Table Empty Flag Register
N     * |        |          |T This bit indicates which PDMA channel table is empty when channel have a request , no matter request from software or peripheral, but operation mode of channel descriptor table is idle state, or channel has finished current transfer and next table operation mode is idle state for PDMA Scatter-Gather mode
N     * |        |          |User can write 1 to clear these bits.
N     * |        |          |0 = PDMA channel scatter-gather table is not empty.
N     * |        |          |1 = PDMA channel scatter-gather table is empty and PDMA SWREQ has be set.
N     * |[4]     |TEMPTYF4  |Table Empty Flag Register
N     * |        |          |T This bit indicates which PDMA channel table is empty when channel have a request , no matter request from software or peripheral, but operation mode of channel descriptor table is idle state, or channel has finished current transfer and next table operation mode is idle state for PDMA Scatter-Gather mode
N     * |        |          |User can write 1 to clear these bits.
N     * |        |          |0 = PDMA channel scatter-gather table is not empty.
N     * |        |          |1 = PDMA channel scatter-gather table is empty and PDMA SWREQ has be set.
N     * @var PDMA_T::TACTSTS
N     * Offset: 0x42C  PDMA Transfer Active Flag Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TXACTF0   |PDMA Channel 0 Transfer on Active Flag Register (Read Only)
N     * |        |          |This bit indicates which PDMA channel is in active.
N     * |        |          |0 = PDMA channel is not finished.
N     * |        |          |1 = PDMA channel is active.
N     * |[1]     |TXACTF1   |PDMA Channel 1 Transfer on Active Flag Register (Read Only)
N     * |        |          |This bit indicates which PDMA channel is in active.
N     * |        |          |0 = PDMA channel is not finished.
N     * |        |          |1 = PDMA channel is active.
N     * |[2]     |TXACTF2   |PDMA Channel 2 Transfer on Active Flag Register (Read Only)
N     * |        |          |This bit indicates which PDMA channel is in active.
N     * |        |          |0 = PDMA channel is not finished.
N     * |        |          |1 = PDMA channel is active.
N     * |[3]     |TXACTF3   |PDMA Channel 3 Transfer on Active Flag Register (Read Only)
N     * |        |          |This bit indicates which PDMA channel is in active.
N     * |        |          |0 = PDMA channel is not finished.
N     * |        |          |1 = PDMA channel is active.
N     * |[4]     |TXACTF4   |PDMA Channel 4 Transfer on Active Flag Register (Read Only)
N     * |        |          |This bit indicates which PDMA channel is in active.
N     * |        |          |0 = PDMA channel is not finished.
N     * |        |          |1 = PDMA channel is active.
N     * @var PDMA_T::TOUTPSC
N     * Offset: 0x430  PDMA Time-out Prescaler Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |TOUTPSC0  |PDMA Channel 0 Time-out Clock Source Prescaler Bits
N     * |        |          |000 = PDMA channel 0 time-out clock source is HCLK/2^8.
N     * |        |          |001 = PDMA channel 0 time-out clock source is HCLK/2^9.
N     * |        |          |010 = PDMA channel 0 time-out clock source is HCLK/2^10.
N     * |        |          |011 = PDMA channel 0 time-out clock source is HCLK/2^11.
N     * |        |          |100 = PDMA channel 0 time-out clock source is HCLK/2^12.
N     * |        |          |101 = PDMA channel 0 time-out clock source is HCLK/2^13.
N     * |        |          |110 = PDMA channel 0 time-out clock source is HCLK/2^14.
N     * |        |          |111 = PDMA channel 0 time-out clock source is HCLK/2^15.
N     * |[6:4]   |TOUTPSC1  |PDMA Channel 1 Time-out Clock Source Prescaler Bits
N     * |        |          |000 = PDMA channel 1 time-out clock source is HCLK/2^8.
N     * |        |          |001 = PDMA channel 1 time-out clock source is HCLK/2^9.
N     * |        |          |010 = PDMA channel 1 time-out clock source is HCLK/2^10.
N     * |        |          |011 = PDMA channel 1 time-out clock source is HCLK/2^11.
N     * |        |          |100 = PDMA channel 1 time-out clock source is HCLK/2^12.
N     * |        |          |101 = PDMA channel 1 time-out clock source is HCLK/2^13.
N     * |        |          |110 = PDMA channel 1 time-out clock source is HCLK/2^14.
N     * |        |          |111 = PDMA channel 1 time-out clock source is HCLK/2^15.
N     * @var PDMA_T::TOUTEN
N     * Offset: 0x434  PDMA Time-out Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TOUTEN0   |PDMA Channel 0 Time-out Enable Bit
N     * |        |          |0 = PDMA Channel 0 time-out function Disable.
N     * |        |          |1 = PDMA Channel 0 time-out function Enable.
N     * |[1]     |TOUTEN1   |PDMA Channel 1 Time-out Enable Bit
N     * |        |          |0 = PDMA Channel 1 time-out function Disable.
N     * |        |          |1 = PDMA Channel 1 time-out function Enable.
N     * @var PDMA_T::TOUTIEN
N     * Offset: 0x438  PDMA Time-out Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TOUTIEN0  |PDMA Channel 0 Time-out Interrupt Enable Bit
N     * |        |          |0 = PDMA Channel 0 time-out interrupt Disable.
N     * |        |          |1 = PDMA Channel 0 time-out interrupt Enable.
N     * |[1]     |TOUTIEN1  |PDMA Channel 1 Time-out Interrupt Enable Bit
N     * |        |          |0 = PDMA Channel 1 time-out interrupt Disable.
N     * |        |          |1 = PDMA Channel 1 time-out interrupt Enable.
N     * @var PDMA_T::SCATBA
N     * Offset: 0x43C  PDMA Scatter-Gather Descriptor Table Base Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:16] |SCATBA    |PDMA Scatter-gather Descriptor Table Address Register
N     * |        |          |In Scatter-Gather mode, this is the base address for calculating the next link - list address
N     * |        |          |The next link address equation is
N     * |        |          |Next Link Address = PDMA_SCATBA + PDMA_DSCT_FIRST.
N     * |        |          |Note: Only useful in Scatter-Gather mode.
N     * @var PDMA_T::TOC0_1
N     * Offset: 0x440  PDMA Channel 0 and Channel 1 Time-out Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |TOC0      |Time-out Counter for Channel 0
N     * |        |          |This controls the period of time-out function for channel 0
N     * |        |          |The calculation unit is based on TOUTPSC0 (PDMA_TOUTPSC[2:0]) clock.
N     * |        |          |Time-out period = (Period of time-out clock) * (16-bit TOCn),n = 0,1.
N     * |[31:16] |TOC1      |Time-out Counter for Channel 1
N     * |        |          |This controls the period of time-out function for channel 1
N     * |        |          |The calculation unit is based on TOUTPSC1 (PDMA_TOUTPSC[5:3]) clock
N     * |        |          |The example of time-out period can refer TOC0 bit description.
N     * @var PDMA_T::RESET
N     * Offset: 0x460  PDMA Channel Reset Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RESET0    |PDMA Channel 0 Reset Control Register
N     * |        |          |User can set this bit field to reset the PDMA channel
N     * |        |          |When user sets RESETn bit, the PDMA controller will finish the on-going transfer then clear the channel enable bit CHEN(PDMA_CHCTL [0]) and clear request active flag
N     * |        |          |If re-enable channel after channel reset, PDMA will re-load the channel description table to execute PDMA task.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset PDMA channel 0.
N     * |        |          |Note: This bit will be cleared automatically after finishing reset process.
N     * |[1]     |RESET1    |PDMA Channel 1 Reset Control Register
N     * |        |          |User can set this bit field to reset the PDMA channel
N     * |        |          |When user sets RESETn bit, the PDMA controller will finish the on-going transfer then clear the channel enable bit CHEN(PDMA_CHCTL [1]) and clear request active flag
N     * |        |          |If re-enable channel after channel reset, PDMA will re-load the channel description table to execute PDMA task.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset PDMA channel 1.
N     * |        |          |Note: This bit will be cleared automatically after finishing reset process.
N     * |[2]     |RESET2    |PDMA Channel 2 Reset Control Register
N     * |        |          |User can set this bit field to reset the PDMA channel
N     * |        |          |When user sets RESETn bit, the PDMA controller will finish the on-going transfer then clear the channel enable bit CHEN(PDMA_CHCTL [2]) and clear request active flag
N     * |        |          |If re-enable channel after channel reset, PDMA will re-load the channel description table to execute PDMA task.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset PDMA channel 2.
N     * |        |          |Note: This bit will be cleared automatically after finishing reset process.
N     * |[3]     |RESET3    |PDMA Channel 3 Reset Control Register
N     * |        |          |User can set this bit field to reset the PDMA channel
N     * |        |          |When user sets RESETn bit, the PDMA controller will finish the on-going transfer then clear the channel enable bit CHEN(PDMA_CHCTL [3]) and clear request active flag
N     * |        |          |If re-enable channel after channel reset, PDMA will re-load the channel description table to execute PDMA task.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset PDMA channel 3.
N     * |        |          |Note: This bit will be cleared automatically after finishing reset process.
N     * |[4]     |RESET4    |PDMA Channel 4 Reset Control Register
N     * |        |          |User can set this bit field to reset the PDMA channel
N     * |        |          |When user sets RESETn bit, the PDMA controller will finish the on-going transfer then clear the channel enable bit CHEN(PDMA_CHCTL [4]) and clear request active flag
N     * |        |          |If re-enable channel after channel reset, PDMA will re-load the channel description table to execute PDMA task.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset PDMA channel 4.
N     * |        |          |Note: This bit will be cleared automatically after finishing reset process.
N     * @var PDMA_T::REQSEL0_3
N     * Offset: 0x480  PDMA Channel 0 to Channel 3 Request Source Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |REQSRC0   |Channel 0 Request Source Selection
N     * |        |          |This filed defines which peripheral is connected to PDMA channel 0
N     * |        |          |User can configure the peripheral by setting REQSRC0.
N     * |        |          |0 = Disable PDMA.
N     * |        |          |1 = Reserved.
N     * |        |          |2 = Channel connects to USB_TX.
N     * |        |          |3 = Channel connects to USB_RX.
N     * |        |          |4 = Channel connects to UART0_TX.
N     * |        |          |5 = Channel connects to UART0_RX.
N     * |        |          |6 = Channel connects to UART1_TX.
N     * |        |          |7 = Channel connects to UART1_RX.
N     * |        |          |8 = Channel connects to UART2_TX.
N     * |        |          |9 = Channel connects to UART2_RX.
N     * |        |          |16 = Channel connects to SPI0_TX.
N     * |        |          |17 = Channel connects to SPI0_RX.
N     * |        |          |18 = Channel connects to SPI1_TX.
N     * |        |          |19 = Channel connects to SPI1_RX.
N     * |        |          |20 = Channel connects to ADC_RX.
N     * |        |          |21 = Channel connects to PWM0_P1_RX.
N     * |        |          |22 = Channel connects to PWM0_P2_RX.
N     * |        |          |23 = Channel connects to PWM0_P3_RX.
N     * |        |          |24 = Channel connects to PWM1_P1_RX.
N     * |        |          |25 = Channel connects to PWM1_P2_RX.
N     * |        |          |26 = Channel connects to PWM1_P3_RX.
N     * |        |          |27 = Reserved.
N     * |        |          |28 = Channel connects to I2C0_TX.
N     * |        |          |29 = Channel connects to I2C0_RX.
N     * |        |          |30 = Channel connects to I2C1_TX.
N     * |        |          |31 = Channel connects to I2C1_RX.
N     * |        |          |32 = Channel connects to TMR0.
N     * |        |          |33 = Channel connects to TMR1.
N     * |        |          |34 = Channel connects to TMR2.
N     * |        |          |35 = Channel connects to TMR3.
N     * |        |          |Others = Reserved.
N     * |        |          |Note 1: A request source cannot assign to two channels at the same time.
N     * |        |          |Note 2: This field is useless when transfer between memory and memory.
N     * |[13:8]  |REQSRC1   |Channel 1 Request Source Selection
N     * |        |          |This filed defines which peripheral is connected to PDMA channel 1
N     * |        |          |User can configure the peripheral setting by REQSRC1.
N     * |        |          |Note: The channel configuration is the same as REQSRC0 field
N     * |        |          |Please refer to the explanation of REQSRC0.
N     * |[21:16] |REQSRC2   |Channel 2 Request Source Selection
N     * |        |          |This filed defines which peripheral is connected to PDMA channel 2
N     * |        |          |User can configure the peripheral setting by REQSRC2.
N     * |        |          |Note: The channel configuration is the same as REQSRC0 field
N     * |        |          |Please refer to the explanation of REQSRC0.
N     * |[29:24] |REQSRC3   |Channel 3 Request Source Selection
N     * |        |          |This filed defines which peripheral is connected to PDMA channel 3
N     * |        |          |User can configure the peripheral setting by REQSRC3.
N     * |        |          |Note: The channel configuration is the same as REQSRC0 field
N     * |        |          |Please refer to the explanation of REQSRC0.
N     * @var PDMA_T::REQSEL4
N     * Offset: 0x484  PDMA Channel 4 Request Source Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |REQSRC4   |Channel 4 Request Source Selection
N     * |        |          |This filed defines which peripheral is connected to PDMA channel 4
N     * |        |          |User can configure the peripheral setting by REQSRC4.
N     * |        |          |Note: The channel configuration is the same as REQSRC0 field
N     * |        |          |Please refer to the explanation of REQSRC0.
N     */
N
N    DSCT_T        DSCT[5];               /*!< [0x0000 ~ 0x004C] DMA Embedded Description Table 0~4                      */
N    __I  uint32_t CURSCAT[5];            /*!< [0x0050~0x0060] Current Scatter-Gather Descriptor Table Address of PDMA Channel 0~4 */
X    volatile const  uint32_t CURSCAT[5];             
N    __I  uint32_t RESERVE0[231];
X    volatile const  uint32_t RESERVE0[231];
N    __IO uint32_t CHCTL;                 /*!< [0x0400] PDMA Channel Control Register                                    */
X    volatile uint32_t CHCTL;                  
N    __O  uint32_t PAUSE;                 /*!< [0x0404] PDMA Transfer Pause Control Register                             */
X    volatile  uint32_t PAUSE;                  
N    __O  uint32_t SWREQ;                 /*!< [0x0408] PDMA Software Request Register                                   */
X    volatile  uint32_t SWREQ;                  
N    __I  uint32_t TRGSTS;                /*!< [0x040c] PDMA Channel Request Status Register                             */
X    volatile const  uint32_t TRGSTS;                 
N    __IO uint32_t PRISET;                /*!< [0x0410] PDMA Fixed Priority Setting Register                             */
X    volatile uint32_t PRISET;                 
N    __O  uint32_t PRICLR;                /*!< [0x0414] PDMA Fixed Priority Clear Register                               */
X    volatile  uint32_t PRICLR;                 
N    __IO uint32_t INTEN;                 /*!< [0x0418] PDMA Interrupt Enable Register                                   */
X    volatile uint32_t INTEN;                  
N    __IO uint32_t INTSTS;                /*!< [0x041c] PDMA Interrupt Status Register                                   */
X    volatile uint32_t INTSTS;                 
N    __IO uint32_t ABTSTS;                /*!< [0x0420] PDMA Channel Read/Write Target Abort Flag Register               */
X    volatile uint32_t ABTSTS;                 
N    __IO uint32_t TDSTS;                 /*!< [0x0424] PDMA Channel Transfer Done Flag Register                         */
X    volatile uint32_t TDSTS;                  
N    __IO uint32_t SCATSTS;               /*!< [0x0428] PDMA Scatter-Gather Table Empty Status Register                  */
X    volatile uint32_t SCATSTS;                
N    __I  uint32_t TACTSTS;               /*!< [0x042c] PDMA Transfer Active Flag Register                               */
X    volatile const  uint32_t TACTSTS;                
N    __IO uint32_t TOUTPSC;               /*!< [0x0430] PDMA Time-out Prescaler Register                                 */
X    volatile uint32_t TOUTPSC;                
N    __IO uint32_t TOUTEN;                /*!< [0x0434] PDMA Time-out Enable Register                                    */
X    volatile uint32_t TOUTEN;                 
N    __IO uint32_t TOUTIEN;               /*!< [0x0438] PDMA Time-out Interrupt Enable Register                          */
X    volatile uint32_t TOUTIEN;                
N    __IO uint32_t SCATBA;                /*!< [0x043c] PDMA Scatter-Gather Descriptor Table Base Address Register       */
X    volatile uint32_t SCATBA;                 
N    __IO uint32_t TOC0_1;                /*!< [0x0440] PDMA Channel 0 and Channel 1 Time-out Counter Register           */
X    volatile uint32_t TOC0_1;                 
N    __I  uint32_t RESERVE1[7];
X    volatile const  uint32_t RESERVE1[7];
N    __IO uint32_t RESET;                 /*!< [0x0460] PDMA Channel Reset Control Register                              */
X    volatile uint32_t RESET;                  
N    __I  uint32_t RESERVE2[7];
X    volatile const  uint32_t RESERVE2[7];
N    __IO uint32_t REQSEL0_3;             /*!< [0x0480] PDMA Channel 0 to Channel 3 Request Source Select Register       */
X    volatile uint32_t REQSEL0_3;              
N    __IO uint32_t REQSEL4;               /*!< [0x0484] PDMA Channel 4 Request Source Select Register                    */
X    volatile uint32_t REQSEL4;                
N
N} PDMA_T;
N
N
N
N
N/**
N    @addtogroup PDMA_CONST PDMA Bit Field Definition
N    Constant Definitions for PDMA Controller
N@{ */
N
N#define PDMA_DSCT_CTL_OPMODE_Pos         (0)                                               /*!< PDMA_T::DSCT_CTL: OPMODE Position     */
N#define PDMA_DSCT_CTL_OPMODE_Msk         (0x3ul << PDMA_DSCT_CTL_OPMODE_Pos)               /*!< PDMA_T::DSCT_CTL: OPMODE Mask         */
N
N#define PDMA_DSCT_CTL_TXTYPE_Pos         (2)                                               /*!< PDMA_T::DSCT_CTL: TXTYPE Position     */
N#define PDMA_DSCT_CTL_TXTYPE_Msk         (0x1ul << PDMA_DSCT_CTL_TXTYPE_Pos)               /*!< PDMA_T::DSCT_CTL: TXTYPE Mask         */
N
N#define PDMA_DSCT_CTL_BURSIZE_Pos        (4)                                               /*!< PDMA_T::DSCT_CTL: BURSIZE Position    */
N#define PDMA_DSCT_CTL_BURSIZE_Msk        (0x7ul << PDMA_DSCT_CTL_BURSIZE_Pos)              /*!< PDMA_T::DSCT_CTL: BURSIZE Mask        */
N
N#define PDMA_DSCT_CTL_TBINTDIS_Pos       (7)                                               /*!< PDMA_T::DSCT_CTL: TBINTDIS Position   */
N#define PDMA_DSCT_CTL_TBINTDIS_Msk       (0x1ul << PDMA_DSCT_CTL_TBINTDIS_Pos)             /*!< PDMA_T::DSCT_CTL: TBINTDIS Mask       */
N
N#define PDMA_DSCT_CTL_SAINC_Pos          (8)                                               /*!< PDMA_T::DSCT_CTL: SAINC Position      */
N#define PDMA_DSCT_CTL_SAINC_Msk          (0x3ul << PDMA_DSCT_CTL_SAINC_Pos)                /*!< PDMA_T::DSCT_CTL: SAINC Mask          */
N
N#define PDMA_DSCT_CTL_DAINC_Pos          (10)                                              /*!< PDMA_T::DSCT_CTL: DAINC Position      */
N#define PDMA_DSCT_CTL_DAINC_Msk          (0x3ul << PDMA_DSCT_CTL_DAINC_Pos)                /*!< PDMA_T::DSCT_CTL: DAINC Mask          */
N
N#define PDMA_DSCT_CTL_TXWIDTH_Pos        (12)                                              /*!< PDMA_T::DSCT_CTL: TXWIDTH Position    */
N#define PDMA_DSCT_CTL_TXWIDTH_Msk        (0x3ul << PDMA_DSCT_CTL_TXWIDTH_Pos)              /*!< PDMA_T::DSCT_CTL: TXWIDTH Mask        */
N
N#define PDMA_DSCT_CTL_TXCNT_Pos          (16)                                              /*!< PDMA_T::DSCT_CTL: TXCNT Position      */
N#define PDMA_DSCT_CTL_TXCNT_Msk          (0x3ffful << PDMA_DSCT_CTL_TXCNT_Pos)             /*!< PDMA_T::DSCT_CTL: TXCNT Mask          */
N
N#define PDMA_DSCT_SA_SA_Pos              (0)                                               /*!< PDMA_T::DSCT_SA: SA Position          */
N#define PDMA_DSCT_SA_SA_Msk              (0xfffffffful << PDMA_DSCT_SA_SA_Pos)             /*!< PDMA_T::DSCT_SA: SA Mask              */
N
N#define PDMA_DSCT_DA_DA_Pos              (0)                                               /*!< PDMA_T::DSCT_DA: DA Position          */
N#define PDMA_DSCT_DA_DA_Msk              (0xfffffffful << PDMA_DSCT_DA_DA_Pos)             /*!< PDMA_T::DSCT_DA: DA Mask              */
N
N#define PDMA_DSCT_FIRST_FIRST_Pos        (0)                                               /*!< PDMA_T::DSCT_FIRST: FIRST Position    */
N#define PDMA_DSCT_FIRST_FIRST_Msk        (0xfffful << PDMA_DSCT_FIRST_FIRST_Pos)           /*!< PDMA_T::DSCT_FIRST: FIRST Mask        */
N
N#define PDMA_DSCT_FIRST_NEXT_Pos         (16)                                              /*!< PDMA_T::DSCT_FIRST: NEXT Position     */
N#define PDMA_DSCT_FIRST_NEXT_Msk         (0xfffful << PDMA_DSCT_FIRST_NEXT_Pos)            /*!< PDMA_T::DSCT_FIRST: NEXT Mask         */
N
N#define PDMA_CURSCAT_CURADDR_Pos         (0)                                               /*!< PDMA_T::CURSCAT: CURADDR Position     */
N#define PDMA_CURSCAT_CURADDR_Msk         (0xfffffffful << PDMA_CURSCAT_CURADDR_Pos)        /*!< PDMA_T::CURSCAT: CURADDR Mask         */
N
N#define PDMA_CHCTL_CHEN0_Pos             (0)                                               /*!< PDMA_T::CHCTL: CHEN0 Position          */
N#define PDMA_CHCTL_CHEN0_Msk             (0x1ul << PDMA_CHCTL_CHEN0_Pos)                   /*!< PDMA_T::CHCTL: CHEN0 Mask              */
N
N#define PDMA_CHCTL_CHEN1_Pos             (1)                                               /*!< PDMA_T::CHCTL: CHEN1 Position          */
N#define PDMA_CHCTL_CHEN1_Msk             (0x1ul << PDMA_CHCTL_CHEN1_Pos)                   /*!< PDMA_T::CHCTL: CHEN1 Mask              */
N
N#define PDMA_CHCTL_CHEN2_Pos             (2)                                               /*!< PDMA_T::CHCTL: CHEN2 Position          */
N#define PDMA_CHCTL_CHEN2_Msk             (0x1ul << PDMA_CHCTL_CHEN2_Pos)                   /*!< PDMA_T::CHCTL: CHEN2 Mask              */
N
N#define PDMA_CHCTL_CHEN3_Pos             (3)                                               /*!< PDMA_T::CHCTL: CHEN3 Position          */
N#define PDMA_CHCTL_CHEN3_Msk             (0x1ul << PDMA_CHCTL_CHEN3_Pos)                   /*!< PDMA_T::CHCTL: CHEN3 Mask              */
N
N#define PDMA_CHCTL_CHEN4_Pos             (4)                                               /*!< PDMA_T::CHCTL: CHEN4 Position          */
N#define PDMA_CHCTL_CHEN4_Msk             (0x1ul << PDMA_CHCTL_CHEN4_Pos)                   /*!< PDMA_T::CHCTL: CHEN4 Mask              */
N
N#define PDMA_PAUSE_PAUSE0_Pos            (0)                                               /*!< PDMA_T::PAUSE: PAUSE0 Position         */
N#define PDMA_PAUSE_PAUSE0_Msk            (0x1ul << PDMA_PAUSE_PAUSE0_Pos)                  /*!< PDMA_T::PAUSE: PAUSE0 Mask             */
N
N#define PDMA_PAUSE_PAUSE1_Pos            (1)                                               /*!< PDMA_T::PAUSE: PAUSE1 Position         */
N#define PDMA_PAUSE_PAUSE1_Msk            (0x1ul << PDMA_PAUSE_PAUSE1_Pos)                  /*!< PDMA_T::PAUSE: PAUSE1 Mask             */
N
N#define PDMA_PAUSE_PAUSE2_Pos            (2)                                               /*!< PDMA_T::PAUSE: PAUSE2 Position         */
N#define PDMA_PAUSE_PAUSE2_Msk            (0x1ul << PDMA_PAUSE_PAUSE2_Pos)                  /*!< PDMA_T::PAUSE: PAUSE2 Mask             */
N
N#define PDMA_PAUSE_PAUSE3_Pos            (3)                                               /*!< PDMA_T::PAUSE: PAUSE3 Position         */
N#define PDMA_PAUSE_PAUSE3_Msk            (0x1ul << PDMA_PAUSE_PAUSE3_Pos)                  /*!< PDMA_T::PAUSE: PAUSE3 Mask             */
N
N#define PDMA_PAUSE_PAUSE4_Pos            (4)                                               /*!< PDMA_T::PAUSE: PAUSE4 Position         */
N#define PDMA_PAUSE_PAUSE4_Msk            (0x1ul << PDMA_PAUSE_PAUSE4_Pos)                  /*!< PDMA_T::PAUSE: PAUSE4 Mask             */
N
N#define PDMA_SWREQ_SWREQ0_Pos            (0)                                               /*!< PDMA_T::SWREQ: SWREQ0 Position         */
N#define PDMA_SWREQ_SWREQ0_Msk            (0x1ul << PDMA_SWREQ_SWREQ0_Pos)                  /*!< PDMA_T::SWREQ: SWREQ0 Mask             */
N
N#define PDMA_SWREQ_SWREQ1_Pos            (1)                                               /*!< PDMA_T::SWREQ: SWREQ1 Position         */
N#define PDMA_SWREQ_SWREQ1_Msk            (0x1ul << PDMA_SWREQ_SWREQ1_Pos)                  /*!< PDMA_T::SWREQ: SWREQ1 Mask             */
N
N#define PDMA_SWREQ_SWREQ2_Pos            (2)                                               /*!< PDMA_T::SWREQ: SWREQ2 Position         */
N#define PDMA_SWREQ_SWREQ2_Msk            (0x1ul << PDMA_SWREQ_SWREQ2_Pos)                  /*!< PDMA_T::SWREQ: SWREQ2 Mask             */
N
N#define PDMA_SWREQ_SWREQ3_Pos            (3)                                               /*!< PDMA_T::SWREQ: SWREQ3 Position         */
N#define PDMA_SWREQ_SWREQ3_Msk            (0x1ul << PDMA_SWREQ_SWREQ3_Pos)                  /*!< PDMA_T::SWREQ: SWREQ3 Mask             */
N
N#define PDMA_SWREQ_SWREQ4_Pos            (4)                                               /*!< PDMA_T::SWREQ: SWREQ4 Position         */
N#define PDMA_SWREQ_SWREQ4_Msk            (0x1ul << PDMA_SWREQ_SWREQ4_Pos)                  /*!< PDMA_T::SWREQ: SWREQ4 Mask             */
N
N#define PDMA_TRGSTS_REQSTS0_Pos          (0)                                               /*!< PDMA_T::TRGSTS: REQSTS0 Position       */
N#define PDMA_TRGSTS_REQSTS0_Msk          (0x1ul << PDMA_TRGSTS_REQSTS0_Pos)                /*!< PDMA_T::TRGSTS: REQSTS0 Mask           */
N
N#define PDMA_TRGSTS_REQSTS1_Pos          (1)                                               /*!< PDMA_T::TRGSTS: REQSTS1 Position       */
N#define PDMA_TRGSTS_REQSTS1_Msk          (0x1ul << PDMA_TRGSTS_REQSTS1_Pos)                /*!< PDMA_T::TRGSTS: REQSTS1 Mask           */
N
N#define PDMA_TRGSTS_REQSTS2_Pos          (2)                                               /*!< PDMA_T::TRGSTS: REQSTS2 Position       */
N#define PDMA_TRGSTS_REQSTS2_Msk          (0x1ul << PDMA_TRGSTS_REQSTS2_Pos)                /*!< PDMA_T::TRGSTS: REQSTS2 Mask           */
N
N#define PDMA_TRGSTS_REQSTS3_Pos          (3)                                               /*!< PDMA_T::TRGSTS: REQSTS3 Position       */
N#define PDMA_TRGSTS_REQSTS3_Msk          (0x1ul << PDMA_TRGSTS_REQSTS3_Pos)                /*!< PDMA_T::TRGSTS: REQSTS3 Mask           */
N
N#define PDMA_TRGSTS_REQSTS4_Pos          (4)                                               /*!< PDMA_T::TRGSTS: REQSTS4 Position       */
N#define PDMA_TRGSTS_REQSTS4_Msk          (0x1ul << PDMA_TRGSTS_REQSTS4_Pos)                /*!< PDMA_T::TRGSTS: REQSTS4 Mask           */
N
N#define PDMA_PRISET_FPRISET0_Pos         (0)                                               /*!< PDMA_T::PRISET: FPRISET0 Position      */
N#define PDMA_PRISET_FPRISET0_Msk         (0x1ul << PDMA_PRISET_FPRISET0_Pos)               /*!< PDMA_T::PRISET: FPRISET0 Mask          */
N
N#define PDMA_PRISET_FPRISET1_Pos         (1)                                               /*!< PDMA_T::PRISET: FPRISET1 Position      */
N#define PDMA_PRISET_FPRISET1_Msk         (0x1ul << PDMA_PRISET_FPRISET1_Pos)               /*!< PDMA_T::PRISET: FPRISET1 Mask          */
N
N#define PDMA_PRISET_FPRISET2_Pos         (2)                                               /*!< PDMA_T::PRISET: FPRISET2 Position      */
N#define PDMA_PRISET_FPRISET2_Msk         (0x1ul << PDMA_PRISET_FPRISET2_Pos)               /*!< PDMA_T::PRISET: FPRISET2 Mask          */
N
N#define PDMA_PRISET_FPRISET3_Pos         (3)                                               /*!< PDMA_T::PRISET: FPRISET3 Position      */
N#define PDMA_PRISET_FPRISET3_Msk         (0x1ul << PDMA_PRISET_FPRISET3_Pos)               /*!< PDMA_T::PRISET: FPRISET3 Mask          */
N
N#define PDMA_PRISET_FPRISET4_Pos         (4)                                               /*!< PDMA_T::PRISET: FPRISET4 Position      */
N#define PDMA_PRISET_FPRISET4_Msk         (0x1ul << PDMA_PRISET_FPRISET4_Pos)               /*!< PDMA_T::PRISET: FPRISET4 Mask          */
N
N#define PDMA_PRICLR_FPRICLR0_Pos         (0)                                               /*!< PDMA_T::PRICLR: FPRICLR0 Position      */
N#define PDMA_PRICLR_FPRICLR0_Msk         (0x1ul << PDMA_PRICLR_FPRICLR0_Pos)               /*!< PDMA_T::PRICLR: FPRICLR0 Mask          */
N
N#define PDMA_PRICLR_FPRICLR1_Pos         (1)                                               /*!< PDMA_T::PRICLR: FPRICLR1 Position      */
N#define PDMA_PRICLR_FPRICLR1_Msk         (0x1ul << PDMA_PRICLR_FPRICLR1_Pos)               /*!< PDMA_T::PRICLR: FPRICLR1 Mask          */
N
N#define PDMA_PRICLR_FPRICLR2_Pos         (2)                                               /*!< PDMA_T::PRICLR: FPRICLR2 Position      */
N#define PDMA_PRICLR_FPRICLR2_Msk         (0x1ul << PDMA_PRICLR_FPRICLR2_Pos)               /*!< PDMA_T::PRICLR: FPRICLR2 Mask          */
N
N#define PDMA_PRICLR_FPRICLR3_Pos         (3)                                               /*!< PDMA_T::PRICLR: FPRICLR3 Position      */
N#define PDMA_PRICLR_FPRICLR3_Msk         (0x1ul << PDMA_PRICLR_FPRICLR3_Pos)               /*!< PDMA_T::PRICLR: FPRICLR3 Mask          */
N
N#define PDMA_PRICLR_FPRICLR4_Pos         (4)                                               /*!< PDMA_T::PRICLR: FPRICLR4 Position      */
N#define PDMA_PRICLR_FPRICLR4_Msk         (0x1ul << PDMA_PRICLR_FPRICLR4_Pos)               /*!< PDMA_T::PRICLR: FPRICLR4 Mask          */
N
N#define PDMA_INTEN_INTEN0_Pos            (0)                                               /*!< PDMA_T::INTEN: INTEN0 Position         */
N#define PDMA_INTEN_INTEN0_Msk            (0x1ul << PDMA_INTEN_INTEN0_Pos)                  /*!< PDMA_T::INTEN: INTEN0 Mask             */
N
N#define PDMA_INTEN_INTEN1_Pos            (1)                                               /*!< PDMA_T::INTEN: INTEN1 Position         */
N#define PDMA_INTEN_INTEN1_Msk            (0x1ul << PDMA_INTEN_INTEN1_Pos)                  /*!< PDMA_T::INTEN: INTEN1 Mask             */
N
N#define PDMA_INTEN_INTEN2_Pos            (2)                                               /*!< PDMA_T::INTEN: INTEN2 Position         */
N#define PDMA_INTEN_INTEN2_Msk            (0x1ul << PDMA_INTEN_INTEN2_Pos)                  /*!< PDMA_T::INTEN: INTEN2 Mask             */
N
N#define PDMA_INTEN_INTEN3_Pos            (3)                                               /*!< PDMA_T::INTEN: INTEN3 Position         */
N#define PDMA_INTEN_INTEN3_Msk            (0x1ul << PDMA_INTEN_INTEN3_Pos)                  /*!< PDMA_T::INTEN: INTEN3 Mask             */
N
N#define PDMA_INTEN_INTEN4_Pos            (4)                                               /*!< PDMA_T::INTEN: INTEN4 Position         */
N#define PDMA_INTEN_INTEN4_Msk            (0x1ul << PDMA_INTEN_INTEN4_Pos)                  /*!< PDMA_T::INTEN: INTEN4 Mask             */
N
N#define PDMA_INTSTS_ABTIF_Pos            (0)                                               /*!< PDMA_T::INTSTS: ABTIF Position         */
N#define PDMA_INTSTS_ABTIF_Msk            (0x1ul << PDMA_INTSTS_ABTIF_Pos)                  /*!< PDMA_T::INTSTS: ABTIF Mask             */
N
N#define PDMA_INTSTS_TDIF_Pos             (1)                                               /*!< PDMA_T::INTSTS: TDIF Position          */
N#define PDMA_INTSTS_TDIF_Msk             (0x1ul << PDMA_INTSTS_TDIF_Pos)                   /*!< PDMA_T::INTSTS: TDIF Mask              */
N
N#define PDMA_INTSTS_TEIF_Pos             (2)                                               /*!< PDMA_T::INTSTS: TEIF Position          */
N#define PDMA_INTSTS_TEIF_Msk             (0x1ul << PDMA_INTSTS_TEIF_Pos)                   /*!< PDMA_T::INTSTS: TEIF Mask              */
N
N#define PDMA_INTSTS_REQTOF0_Pos          (8)                                               /*!< PDMA_T::INTSTS: REQTOF0 Position       */
N#define PDMA_INTSTS_REQTOF0_Msk          (0x1ul << PDMA_INTSTS_REQTOF0_Pos)                /*!< PDMA_T::INTSTS: REQTOF0 Mask           */
N
N#define PDMA_INTSTS_REQTOF1_Pos          (9)                                               /*!< PDMA_T::INTSTS: REQTOF1 Position       */
N#define PDMA_INTSTS_REQTOF1_Msk          (0x1ul << PDMA_INTSTS_REQTOF1_Pos)                /*!< PDMA_T::INTSTS: REQTOF1 Mask           */
N
N#define PDMA_ABTSTS_ABTIF0_Pos           (0)                                               /*!< PDMA_T::ABTSTS: ABTIF0 Position        */
N#define PDMA_ABTSTS_ABTIF0_Msk           (0x1ul << PDMA_ABTSTS_ABTIF0_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF0 Mask            */
N
N#define PDMA_ABTSTS_ABTIF1_Pos           (1)                                               /*!< PDMA_T::ABTSTS: ABTIF1 Position        */
N#define PDMA_ABTSTS_ABTIF1_Msk           (0x1ul << PDMA_ABTSTS_ABTIF1_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF1 Mask            */
N
N#define PDMA_ABTSTS_ABTIF2_Pos           (2)                                               /*!< PDMA_T::ABTSTS: ABTIF2 Position        */
N#define PDMA_ABTSTS_ABTIF2_Msk           (0x1ul << PDMA_ABTSTS_ABTIF2_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF2 Mask            */
N
N#define PDMA_ABTSTS_ABTIF3_Pos           (3)                                               /*!< PDMA_T::ABTSTS: ABTIF3 Position        */
N#define PDMA_ABTSTS_ABTIF3_Msk           (0x1ul << PDMA_ABTSTS_ABTIF3_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF3 Mask            */
N
N#define PDMA_ABTSTS_ABTIF4_Pos           (4)                                               /*!< PDMA_T::ABTSTS: ABTIF4 Position        */
N#define PDMA_ABTSTS_ABTIF4_Msk           (0x1ul << PDMA_ABTSTS_ABTIF4_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF4 Mask            */
N
N#define PDMA_TDSTS_TDIF0_Pos             (0)                                               /*!< PDMA_T::TDSTS: TDIF0 Position          */
N#define PDMA_TDSTS_TDIF0_Msk             (0x1ul << PDMA_TDSTS_TDIF0_Pos)                   /*!< PDMA_T::TDSTS: TDIF0 Mask              */
N
N#define PDMA_TDSTS_TDIF1_Pos             (1)                                               /*!< PDMA_T::TDSTS: TDIF1 Position          */
N#define PDMA_TDSTS_TDIF1_Msk             (0x1ul << PDMA_TDSTS_TDIF1_Pos)                   /*!< PDMA_T::TDSTS: TDIF1 Mask              */
N
N#define PDMA_TDSTS_TDIF2_Pos             (2)                                               /*!< PDMA_T::TDSTS: TDIF2 Position          */
N#define PDMA_TDSTS_TDIF2_Msk             (0x1ul << PDMA_TDSTS_TDIF2_Pos)                   /*!< PDMA_T::TDSTS: TDIF2 Mask              */
N
N#define PDMA_TDSTS_TDIF3_Pos             (3)                                               /*!< PDMA_T::TDSTS: TDIF3 Position          */
N#define PDMA_TDSTS_TDIF3_Msk             (0x1ul << PDMA_TDSTS_TDIF3_Pos)                   /*!< PDMA_T::TDSTS: TDIF3 Mask              */
N
N#define PDMA_TDSTS_TDIF4_Pos             (4)                                               /*!< PDMA_T::TDSTS: TDIF4 Position          */
N#define PDMA_TDSTS_TDIF4_Msk             (0x1ul << PDMA_TDSTS_TDIF4_Pos)                   /*!< PDMA_T::TDSTS: TDIF4 Mask              */
N
N#define PDMA_SCATSTS_TEMPTYF0_Pos        (0)                                               /*!< PDMA_T::SCATSTS: TEMPTYF0 Position     */
N#define PDMA_SCATSTS_TEMPTYF0_Msk        (0x1ul << PDMA_SCATSTS_TEMPTYF0_Pos)              /*!< PDMA_T::SCATSTS: TEMPTYF0 Mask         */
N
N#define PDMA_SCATSTS_TEMPTYF1_Pos        (1)                                               /*!< PDMA_T::SCATSTS: TEMPTYF1 Position     */
N#define PDMA_SCATSTS_TEMPTYF1_Msk        (0x1ul << PDMA_SCATSTS_TEMPTYF1_Pos)              /*!< PDMA_T::SCATSTS: TEMPTYF1 Mask         */
N
N#define PDMA_SCATSTS_TEMPTYF2_Pos        (2)                                               /*!< PDMA_T::SCATSTS: TEMPTYF2 Position     */
N#define PDMA_SCATSTS_TEMPTYF2_Msk        (0x1ul << PDMA_SCATSTS_TEMPTYF2_Pos)              /*!< PDMA_T::SCATSTS: TEMPTYF2 Mask         */
N
N#define PDMA_SCATSTS_TEMPTYF3_Pos        (3)                                               /*!< PDMA_T::SCATSTS: TEMPTYF3 Position     */
N#define PDMA_SCATSTS_TEMPTYF3_Msk        (0x1ul << PDMA_SCATSTS_TEMPTYF3_Pos)              /*!< PDMA_T::SCATSTS: TEMPTYF3 Mask         */
N
N#define PDMA_SCATSTS_TEMPTYF4_Pos        (4)                                               /*!< PDMA_T::SCATSTS: TEMPTYF4 Position     */
N#define PDMA_SCATSTS_TEMPTYF4_Msk        (0x1ul << PDMA_SCATSTS_TEMPTYF4_Pos)              /*!< PDMA_T::SCATSTS: TEMPTYF4 Mask         */
N
N#define PDMA_TACTSTS_TXACTF0_Pos         (0)                                               /*!< PDMA_T::TACTSTS: TXACTF0 Position      */
N#define PDMA_TACTSTS_TXACTF0_Msk         (0x1ul << PDMA_TACTSTS_TXACTF0_Pos)               /*!< PDMA_T::TACTSTS: TXACTF0 Mask          */
N
N#define PDMA_TACTSTS_TXACTF1_Pos         (1)                                               /*!< PDMA_T::TACTSTS: TXACTF1 Position      */
N#define PDMA_TACTSTS_TXACTF1_Msk         (0x1ul << PDMA_TACTSTS_TXACTF1_Pos)               /*!< PDMA_T::TACTSTS: TXACTF1 Mask          */
N
N#define PDMA_TACTSTS_TXACTF2_Pos         (2)                                               /*!< PDMA_T::TACTSTS: TXACTF2 Position      */
N#define PDMA_TACTSTS_TXACTF2_Msk         (0x1ul << PDMA_TACTSTS_TXACTF2_Pos)               /*!< PDMA_T::TACTSTS: TXACTF2 Mask          */
N
N#define PDMA_TACTSTS_TXACTF3_Pos         (3)                                               /*!< PDMA_T::TACTSTS: TXACTF3 Position      */
N#define PDMA_TACTSTS_TXACTF3_Msk         (0x1ul << PDMA_TACTSTS_TXACTF3_Pos)               /*!< PDMA_T::TACTSTS: TXACTF3 Mask          */
N
N#define PDMA_TACTSTS_TXACTF4_Pos         (4)                                               /*!< PDMA_T::TACTSTS: TXACTF4 Position      */
N#define PDMA_TACTSTS_TXACTF4_Msk         (0x1ul << PDMA_TACTSTS_TXACTF4_Pos)               /*!< PDMA_T::TACTSTS: TXACTF4 Mask          */
N
N#define PDMA_TOUTPSC_TOUTPSC0_Pos        (0)                                               /*!< PDMA_T::TOUTPSC: TOUTPSC0 Position     */
N#define PDMA_TOUTPSC_TOUTPSC0_Msk        (0x7ul << PDMA_TOUTPSC_TOUTPSC0_Pos)              /*!< PDMA_T::TOUTPSC: TOUTPSC0 Mask         */
N
N#define PDMA_TOUTPSC_TOUTPSC1_Pos        (4)                                               /*!< PDMA_T::TOUTPSC: TOUTPSC1 Position     */
N#define PDMA_TOUTPSC_TOUTPSC1_Msk        (0x7ul << PDMA_TOUTPSC_TOUTPSC1_Pos)              /*!< PDMA_T::TOUTPSC: TOUTPSC1 Mask         */
N
N#define PDMA_TOUTEN_TOUTEN0_Pos          (0)                                               /*!< PDMA_T::TOUTEN: TOUTEN0 Position       */
N#define PDMA_TOUTEN_TOUTEN0_Msk          (0x1ul << PDMA_TOUTEN_TOUTEN0_Pos)                /*!< PDMA_T::TOUTEN: TOUTEN0 Mask           */
N
N#define PDMA_TOUTEN_TOUTEN1_Pos          (1)                                               /*!< PDMA_T::TOUTEN: TOUTEN1 Position       */
N#define PDMA_TOUTEN_TOUTEN1_Msk          (0x1ul << PDMA_TOUTEN_TOUTEN1_Pos)                /*!< PDMA_T::TOUTEN: TOUTEN1 Mask           */
N
N#define PDMA_TOUTIEN_TOUTIEN0_Pos        (0)                                               /*!< PDMA_T::TOUTIEN: TOUTIEN0 Position     */
N#define PDMA_TOUTIEN_TOUTIEN0_Msk        (0x1ul << PDMA_TOUTIEN_TOUTIEN0_Pos)              /*!< PDMA_T::TOUTIEN: TOUTIEN0 Mask         */
N
N#define PDMA_TOUTIEN_TOUTIEN1_Pos        (1)                                               /*!< PDMA_T::TOUTIEN: TOUTIEN1 Position     */
N#define PDMA_TOUTIEN_TOUTIEN1_Msk        (0x1ul << PDMA_TOUTIEN_TOUTIEN1_Pos)              /*!< PDMA_T::TOUTIEN: TOUTIEN1 Mask         */
N
N#define PDMA_SCATBA_SCATBA_Pos           (16)                                              /*!< PDMA_T::SCATBA: SCATBA Position        */
N#define PDMA_SCATBA_SCATBA_Msk           (0xfffful << PDMA_SCATBA_SCATBA_Pos)              /*!< PDMA_T::SCATBA: SCATBA Mask            */
N
N#define PDMA_TOC0_1_TOC0_Pos             (0)                                               /*!< PDMA_T::TOC0_1: TOC0 Position          */
N#define PDMA_TOC0_1_TOC0_Msk             (0xfffful << PDMA_TOC0_1_TOC0_Pos)                /*!< PDMA_T::TOC0_1: TOC0 Mask              */
N
N#define PDMA_TOC0_1_TOC1_Pos             (16)                                              /*!< PDMA_T::TOC0_1: TOC1 Position          */
N#define PDMA_TOC0_1_TOC1_Msk             (0xfffful << PDMA_TOC0_1_TOC1_Pos)                /*!< PDMA_T::TOC0_1: TOC1 Mask              */
N
N#define PDMA_RESET_RESET0_Pos            (0)                                               /*!< PDMA_T::RESET: RESET0 Position         */
N#define PDMA_RESET_RESET0_Msk            (0x1ul << PDMA_RESET_RESET0_Pos)                  /*!< PDMA_T::RESET: RESET0 Mask             */
N
N#define PDMA_RESET_RESET1_Pos            (1)                                               /*!< PDMA_T::RESET: RESET1 Position         */
N#define PDMA_RESET_RESET1_Msk            (0x1ul << PDMA_RESET_RESET1_Pos)                  /*!< PDMA_T::RESET: RESET1 Mask             */
N
N#define PDMA_RESET_RESET2_Pos            (2)                                               /*!< PDMA_T::RESET: RESET2 Position         */
N#define PDMA_RESET_RESET2_Msk            (0x1ul << PDMA_RESET_RESET2_Pos)                  /*!< PDMA_T::RESET: RESET2 Mask             */
N
N#define PDMA_RESET_RESET3_Pos            (3)                                               /*!< PDMA_T::RESET: RESET3 Position         */
N#define PDMA_RESET_RESET3_Msk            (0x1ul << PDMA_RESET_RESET3_Pos)                  /*!< PDMA_T::RESET: RESET3 Mask             */
N
N#define PDMA_RESET_RESET4_Pos            (4)                                               /*!< PDMA_T::RESET: RESET4 Position         */
N#define PDMA_RESET_RESET4_Msk            (0x1ul << PDMA_RESET_RESET4_Pos)                  /*!< PDMA_T::RESET: RESET4 Mask             */
N
N#define PDMA_REQSEL0_3_REQSRC0_Pos       (0)                                               /*!< PDMA_T::REQSEL0_3: REQSRC0 Position    */
N#define PDMA_REQSEL0_3_REQSRC0_Msk       (0x3ful << PDMA_REQSEL0_3_REQSRC0_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC0 Mask        */
N
N#define PDMA_REQSEL0_3_REQSRC1_Pos       (8)                                               /*!< PDMA_T::REQSEL0_3: REQSRC1 Position    */
N#define PDMA_REQSEL0_3_REQSRC1_Msk       (0x3ful << PDMA_REQSEL0_3_REQSRC1_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC1 Mask        */
N
N#define PDMA_REQSEL0_3_REQSRC2_Pos       (16)                                              /*!< PDMA_T::REQSEL0_3: REQSRC2 Position    */
N#define PDMA_REQSEL0_3_REQSRC2_Msk       (0x3ful << PDMA_REQSEL0_3_REQSRC2_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC2 Mask        */
N
N#define PDMA_REQSEL0_3_REQSRC3_Pos       (24)                                              /*!< PDMA_T::REQSEL0_3: REQSRC3 Position    */
N#define PDMA_REQSEL0_3_REQSRC3_Msk       (0x3ful << PDMA_REQSEL0_3_REQSRC3_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC3 Mask        */
N
N#define PDMA_REQSEL4_REQSRC4_Pos         (0)                                               /*!< PDMA_T::REQSEL4: REQSRC4 Position      */
N#define PDMA_REQSEL4_REQSRC4_Msk         (0x3ful << PDMA_REQSEL4_REQSRC4_Pos)              /*!< PDMA_T::REQSEL4: REQSRC4 Mask          */
N
N/**@}*/ /* PDMA_CONST */
N/**@}*/ /* end of PDMA register group */
N
N
N/*---------------------- Pulse Width Modulation Controller -------------------------*/
N/**
N    @addtogroup PWM Pulse Width Modulation Controller(PWM)
N    Memory Mapped Structure for PWM Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var PWM_T::CTL0
N     * Offset: 0x00  PWM Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CTRLD0    |Center Re-load
N     * |        |          |Bit 0 controls the PWM channel 0.
N     * |        |          |In up-down counter type, PERIOD0 register will load to PBUF0 register at the end point of each period.
N     * |        |          |CMPDAT0 register will load to CMPBUF0 register at the center point of a period.
N     * |[1]     |CTRLD1    |Center Re-load
N     * |        |          |Bit 1 controls the PWM channel 1.
N     * |        |          |In up-down counter type, PERIOD1 register will load to PBUF1 register at the end point of each period.
N     * |        |          |CMPDAT1 register will load to CMPBUF1 register at the center point of a period.
N     * |[2]     |CTRLD2    |Center Re-load
N     * |        |          |Bit 2 controls the PWM channel 2.
N     * |        |          |In up-down counter type, PERIOD2 register will load to PBUF2 register at the end point of each period.
N     * |        |          |CMPDAT2 register will load to CMPBUF2 register at the center point of a period.
N     * |[3]     |CTRLD3    |Center Re-load
N     * |        |          |Bit 3 controls the PWM channel 3.
N     * |        |          |In up-down counter type, PERIOD3 register will load to PBUF3 register at the end point of each period.
N     * |        |          |CMPDAT3 register will load to CMPBUF3 register at the center point of a period.
N     * |[4]     |CTRLD4    |Center Re-load
N     * |        |          |Bit 4 controls the PWM channel 4.
N     * |        |          |In up-down counter type, PERIOD4 register will load to PBUF4 register at the end point of each period.
N     * |        |          |CMPDAT4 register will load to CMPBUF4 register at the center point of a period.
N     * |[5]     |CTRLD5    |Center Re-load
N     * |        |          |Bit 5 controls the PWM channel 5.
N     * |        |          |In up-down counter type, PERIOD5 register will load to PBUF5 register at the end point of each period.
N     * |        |          |CMPDAT5 register will load to CMPBUF5 register at the center point of a period.
N     * |[8]     |WINLDEN0  |Window Load Enable Bits
N     * |        |          |Bit 0 controls the PWM channel 0.
N     * |        |          |0 = PERIOD0 register will load to PBUF0 register at the end point of each period.
N     * |        |          |CMPDAT0 register will load to CMPBUF0 register at the end point or center point of each period by setting CTRLD0 bit.
N     * |        |          |1 = PERIOD0 register will load to PBUF0 and CMPDAT0 registers will load to CMPBUF0 register at the end point of each period when valid reload window is set.
N     * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register, and cleared by hardware after load success.
N     * |[9]     |WINLDEN1  |Window Load Enable Bits
N     * |        |          |Bit 1 controls the PWM channel 1.
N     * |        |          |0 = PERIOD1 register will load to PBUF1 register at the end point of each period.
N     * |        |          |CMPDAT1 register will load to CMPBUF1 register at the end point or center point of each period by setting CTRLD1 bit.
N     * |        |          |1 = PERIOD1 register will load to PBUF1 and CMPDAT1 registers will load to CMPBUF1 register at the end point of each period when valid reload window is set.
N     * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register, and cleared by hardware after load success.
N     * |[10]    |WINLDEN2  |Window Load Enable Bits
N     * |        |          |Bit 2 controls the PWM channel 2.
N     * |        |          |0 = PERIOD2 register will load to PBUF2 register at the end point of each period.
N     * |        |          |CMPDAT2 register will load to CMPBUF2 register at the end point or center point of each period by setting CTRLD2 bit.
N     * |        |          |1 = PERIOD2 register will load to PBUF2 and CMPDAT2 registers will load to CMPBUF2 register at the end point of each period when valid reload window is set.
N     * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register, and cleared by hardware after load success.
N     * |[11]    |WINLDEN3  |Window Load Enable Bits
N     * |        |          |Bit 3 controls the PWM channel 3.
N     * |        |          |0 = PERIOD3 register will load to PBUF3 register at the end point of each period.
N     * |        |          |CMPDAT3 register will load to CMPBUF3 register at the end point or center point of each period by setting CTRLD3 bit.
N     * |        |          |1 = PERIOD3 register will load to PBUF3 and CMPDAT3 registers will load to CMPBUF3 register at the end point of each period when valid reload window is set.
N     * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register, and cleared by hardware after load success.
N     * |[12]    |WINLDEN4  |Window Load Enable Bits
N     * |        |          |Bit 4 controls the PWM channel 4.
N     * |        |          |0 = PERIOD4 register will load to PBUF4 register at the end point of each period.
N     * |        |          |CMPDAT4 register will load to CMPBUF4 register at the end point or center point of each period by setting CTRLD4 bit.
N     * |        |          |1 = PERIOD4 register will load to PBUF4 and CMPDAT4 registers will load to CMPBUF4 register at the end point of each period when valid reload window is set.
N     * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register, and cleared by hardware after load success.
N     * |[13]    |WINLDEN5  |Window Load Enable Bits
N     * |        |          |Bit 5 controls the PWM channel 5.
N     * |        |          |0 = PERIOD5 register will load to PBUF5 register at the end point of each period.
N     * |        |          |CMPDAT5 register will load to CMPBUF5 register at the end point or center point of each period by setting CTRLD5 bit.
N     * |        |          |1 = PERIOD5 register will load to PBUF5 and CMPDAT5 registers will load to CMPBUF5 register at the end point of each period when valid reload window is set.
N     * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register, and cleared by hardware after load success.
N     * |[16]    |IMMLDEN0  |Immediately Load Enable Bits
N     * |        |          |Bit 0 controls the PWM channel 0.
N     * |        |          |0 = PERIOD0 register will load to PBUF0 register at the end point of each period.
N     * |        |          |CMPDAT0 register will load to CMPBUF0 register at the end point or center point of each period by setting CTRLD0 bit.
N     * |        |          |1 = PERIOD0/CMPDAT0 registers will load to PBUF0 and CMPBUF0 register immediately when software update PERIOD0/CMPDAT0 register.
N     * |        |          |Note: If IMMLDEN0 bit is enabled, WINLDEN0 bit and CTRLD0 bits will be invalid.
N     * |[17]    |IMMLDEN1  |Immediately Load Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PERIODn register will load to PBUFn register at the end point of each period.
N     * |        |          |CMPDAT n register will load to CMPBUFn register at the end point or center point of each period by setting CTRLDn bit.
N     * |        |          |1 = PERIODn/CMPDATn registers will load to PBUFn and CMPBUFn register immediately when software update PERIODn/CMPDATn register.
N     * |        |          |Note: If IMMLDENn bit is enabled, WINLDENn bit and CTRLDn bits will be invalid.
N     * |[18]    |IMMLDEN2  |Immediately Load Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PERIODn register will load to PBUFn register at the end point of each period.
N     * |        |          |CMPDAT n register will load to CMPBUFn register at the end point or center point of each period by setting CTRLDn bit.
N     * |        |          |1 = PERIODn/CMPDATn registers will load to PBUFn and CMPBUFn register immediately when software update PERIODn/CMPDATn register.
N     * |        |          |Note: If IMMLDENn bit is enabled, WINLDENn bit and CTRLDn bits will be invalid.
N     * |[19]    |IMMLDEN3  |Immediately Load Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PERIODn register will load to PBUFn register at the end point of each period.
N     * |        |          |CMPDAT n register will load to CMPBUFn register at the end point or center point of each period by setting CTRLDn bit.
N     * |        |          |1 = PERIODn/CMPDATn registers will load to PBUFn and CMPBUFn register immediately when software update PERIODn/CMPDATn register.
N     * |        |          |Note: If IMMLDENn bit is enabled, WINLDENn bit and CTRLDn bits will be invalid.
N     * |[20]    |IMMLDEN4  |Immediately Load Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PERIODn register will load to PBUFn register at the end point of each period.
N     * |        |          |CMPDAT n register will load to CMPBUFn register at the end point or center point of each period by setting CTRLDn bit.
N     * |        |          |1 = PERIODn/CMPDATn registers will load to PBUFn and CMPBUFn register immediately when software update PERIODn/CMPDATn register.
N     * |        |          |Note: If IMMLDENn bit is enabled, WINLDENn bit and CTRLDn bits will be invalid.
N     * |[21]    |IMMLDEN5  |Immediately Load Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PERIODn register will load to PBUFn register at the end point of each period.
N     * |        |          |CMPDAT n register will load to CMPBUFn register at the end point or center point of each period by setting CTRLDn bit.
N     * |        |          |1 = PERIODn/CMPDATn registers will load to PBUFn and CMPBUFn register immediately when software update PERIODn/CMPDATn register.
N     * |        |          |Note: If IMMLDENn bit is enabled, WINLDENn bit and CTRLDn bits will be invalid.
N     * |[24]    |GROUPEN   |Group Function Enable Bit
N     * |        |          |0 = The output waveform of each PWM channel are independent.
N     * |        |          |1 = Unify the PWMx_CH2 and PWMx_CH4 to output the same waveform as PWMx_CH0 and unify the PWMx_CH3 and PWMx_CH5 to output the same waveform as PWMx_CH1.
N     * |[30]    |DBGHALT   |ICE Debug Mode Counter Halt (Write Protect)
N     * |        |          |If counter halt is enabled, PWM all counters will keep current value until exit ICE debug mode.
N     * |        |          |0 = ICE debug mode counter halt disable.
N     * |        |          |1 = ICE debug mode counter halt enable.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[31]    |DBGTRIOFF |ICE Debug Mode Acknowledge Disable (Write Protect)
N     * |        |          |0 = ICE debug mode acknowledgement effects PWM output.
N     * |        |          |PWM pin will be forced as tri-state while ICE debug mode acknowledged.
N     * |        |          |1 = ICE debug mode acknowledgement disabled.
N     * |        |          |PWM pin will keep output no matter ICE debug mode acknowledged or not.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * @var PWM_T::CTL1
N     * Offset: 0x04  PWM Control Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |CNTTYPE0  |PWM Counter Behavior Type
N     * |        |          |Each bit n controls corresponding PWM channel n.
N     * |        |          |00 = Up counter type (supports in capture mode).
N     * |        |          |01 = Down count type (supports in capture mode).
N     * |        |          |10 = Up-down counter type.
N     * |        |          |11 = Reserved.
N     * |[3:2]   |CNTTYPE1  |PWM Counter Behavior Type
N     * |        |          |Each bit n controls corresponding PWM channel n.
N     * |        |          |00 = Up counter type (supports in capture mode).
N     * |        |          |01 = Down count type (supports in capture mode).
N     * |        |          |10 = Up-down counter type.
N     * |        |          |11 = Reserved.
N     * |[5:4]   |CNTTYPE2  |PWM Counter Behavior Type
N     * |        |          |Each bit n controls corresponding PWM channel n.
N     * |        |          |00 = Up counter type (supports in capture mode).
N     * |        |          |01 = Down count type (supports in capture mode).
N     * |        |          |10 = Up-down counter type.
N     * |        |          |11 = Reserved.
N     * |[7:6]   |CNTTYPE3  |PWM Counter Behavior Type
N     * |        |          |Each bit n controls corresponding PWM channel n.
N     * |        |          |00 = Up counter type (supports in capture mode).
N     * |        |          |01 = Down count type (supports in capture mode).
N     * |        |          |10 = Up-down counter type.
N     * |        |          |11 = Reserved.
N     * |[9:8]   |CNTTYPE4  |PWM Counter Behavior Type
N     * |        |          |Each bit n controls corresponding PWM channel n.
N     * |        |          |00 = Up counter type (supports in capture mode).
N     * |        |          |01 = Down count type (supports in capture mode).
N     * |        |          |10 = Up-down counter type.
N     * |        |          |11 = Reserved.
N     * |[11:10] |CNTTYPE5  |PWM Counter Behavior Type
N     * |        |          |Each bit n controls corresponding PWM channel n.
N     * |        |          |00 = Up counter type (supports in capture mode).
N     * |        |          |01 = Down count type (supports in capture mode).
N     * |        |          |10 = Up-down counter type.
N     * |        |          |11 = Reserved.
N     * |[16]    |CNTMODE0  |PWM Counter Mode
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Auto-reload mode.
N     * |        |          |1 = One-shot mode.
N     * |[17]    |CNTMODE1  |PWM Counter Mode
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Auto-reload mode.
N     * |        |          |1 = One-shot mode.
N     * |[18]    |CNTMODE2  |PWM Counter Mode
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Auto-reload mode.
N     * |        |          |1 = One-shot mode.
N     * |[19]    |CNTMODE3  |PWM Counter Mode
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Auto-reload mode.
N     * |        |          |1 = One-shot mode.
N     * |[20]    |CNTMODE4  |PWM Counter Mode
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Auto-reload mode.
N     * |        |          |1 = One-shot mode.
N     * |[21]    |CNTMODE5  |PWM Counter Mode
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Auto-reload mode.
N     * |        |          |1 = One-shot mode.
N     * |[24]    |OUTMODE0  |PWM Output Mode
N     * |        |          |Each bit n controls the output mode of corresponding PWM channel n.
N     * |        |          |0 = PWM independent mode.
N     * |        |          |1 = PWM complementary mode.
N     * |        |          |Note: When operating in group function, these bits must all set to the same mode.
N     * |[25]    |OUTMODE2  |PWM Output Mode
N     * |        |          |Each bit n controls the output mode of corresponding PWM channel n.
N     * |        |          |0 = PWM independent mode.
N     * |        |          |1 = PWM complementary mode.
N     * |        |          |Note: When operating in group function, these bits must all set to the same mode.
N     * |[26]    |OUTMODE4  |PWM Output Mode
N     * |        |          |Each bit n controls the output mode of corresponding PWM channel n.
N     * |        |          |0 = PWM independent mode.
N     * |        |          |1 = PWM complementary mode.
N     * |        |          |Note: When operating in group function, these bits must all set to the same mode.
N     * @var PWM_T::SYNC
N     * Offset: 0x08  PWM Synchronization Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PHSEN0    |SYNC Phase Enable Bits
N     * |        |          |Each bit n denotes controls corresponding PWM channel 0,2,4 and m denotes channel 1,3,5.
N     * |        |          |0 = PWM counter disable to load value of PHS(PWM_PHSn_m[15:0]) bits.
N     * |        |          |1 = PWM counter enable to load value of PHS(PWM_PHSn_m[15:0]) bits.
N     * |[1]     |PHSEN2    |SYNC Phase Enable Bits
N     * |        |          |Each bit n denotes controls corresponding PWM channel 0,2,4 and m denotes channel 1,3,5.
N     * |        |          |0 = PWM counter disable to load value of PHS(PWM_PHSn_m[15:0]) bits.
N     * |        |          |1 = PWM counter enable to load value of PHS(PWM_PHSn_m[15:0]) bits.
N     * |[2]     |PHSEN4    |SYNC Phase Enable Bits
N     * |        |          |Each bit n denotes controls corresponding PWM channel 0,2,4 and m denotes channel 1,3,5.
N     * |        |          |0 = PWM counter disable to load value of PHS(PWM_PHSn_m[15:0]) bits.
N     * |        |          |1 = PWM counter enable to load value of PHS(PWM_PHSn_m[15:0]) bits.
N     * |[9:8]   |SINSRC0   |PWM0_SYNC_IN Source Selection
N     * |        |          |Each bit n controls corresponding PWM channel n.
N     * |        |          |00 = Synchronize source from SYNC_IN or SWSYNC.
N     * |        |          |01 = Counter equal to 0.
N     * |        |          |10 = Counter equal to PWM_CMPDATm, m denotes 1, 3, 5.
N     * |        |          |11 = SYNC_OUT signal will not be generated.
N     * |[11:10] |SINSRC2   |PWM0_SYNC_IN Source Selection
N     * |        |          |Each bit n controls corresponding PWM channel n.
N     * |        |          |00 = Synchronize source from SYNC_IN or SWSYNC.
N     * |        |          |01 = Counter equal to 0.
N     * |        |          |10 = Counter equal to PWM_CMPDATm, m denotes 1, 3, 5.
N     * |        |          |11 = SYNC_OUT signal will not be generated.
N     * |[13:12] |SINSRC4   |PWM0_SYNC_IN Source Selection
N     * |        |          |Each bit n controls corresponding PWM channel n.
N     * |        |          |00 = Synchronize source from SYNC_IN or SWSYNC.
N     * |        |          |01 = Counter equal to 0.
N     * |        |          |10 = Counter equal to PWM_CMPDATm, m denotes 1, 3, 5.
N     * |        |          |11 = SYNC_OUT signal will not be generated.
N     * |[16]    |SNFLTEN   |PWM0_SYNC_IN Noise Filter Enable Bit
N     * |        |          |0 = Noise filter of input PWM0_SYNC_IN pin is Disabled.
N     * |        |          |1 = Noise filter of input PWM0_SYNC_IN pin is Enabled.
N     * |[19:17] |SFLTCSEL  |SYNC Edge Detector Filter Clock Selection
N     * |        |          |000 = Filter clock = HCLK.
N     * |        |          |001 = Filter clock = HCLK/2.
N     * |        |          |010 = Filter clock = HCLK/4.
N     * |        |          |011 = Filter clock = HCLK/8.
N     * |        |          |100 = Filter clock = HCLK/16.
N     * |        |          |101 = Filter clock = HCLK/32.
N     * |        |          |110 = Filter clock = HCLK/64.
N     * |        |          |111 = Filter clock = HCLK/128.
N     * |[22:20] |SFLTCNT   |SYNC Edge Detector Filter Count
N     * |        |          |The register bits control the counter number of edge detector.
N     * |[23]    |SINPINV   |SYNC Input Pin Inverse
N     * |        |          |0 = The state of PWM0_SYNC_IN pin is passed to the negative edge detector.
N     * |        |          |1 = The inversed state of PWM0_SYNC_IN pin is passed to the negative edge detector.
N     * |[24]    |PHSDIR0   |PWM Phase Direction Control
N     * |        |          |Each bit n controls corresponding PWM channel n.
N     * |        |          |0 = Control PWM counter count decrement after synchronizing.
N     * |        |          |1 = Control PWM counter count increment after synchronizing.
N     * |[25]    |PHSDIR2   |PWM Phase Direction Control
N     * |        |          |Each bit n controls corresponding PWM channel n.
N     * |        |          |0 = Control PWM counter count decrement after synchronizing.
N     * |        |          |1 = Control PWM counter count increment after synchronizing.
N     * |[26]    |PHSDIR4   |PWM Phase Direction Control
N     * |        |          |Each bit n controls corresponding PWM channel n.
N     * |        |          |0 = Control PWM counter count decrement after synchronizing.
N     * |        |          |1 = Control PWM counter count increment after synchronizing.
N     * @var PWM_T::SWSYNC
N     * Offset: 0x0C  PWM Software Control Synchronization Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SWSYNC0   |Software SYNC Function
N     * |        |          |Each bit n controls corresponding PWM channel n.
N     * |        |          |When SINSRCn (PWM_SYNC[13:8]) is selected to 0, SYNC_OUT source is come from SYNC_IN or this bit.
N     * |[1]     |SWSYNC2   |Software SYNC Function
N     * |        |          |Each bit n controls corresponding PWM channel n.
N     * |        |          |When SINSRCn (PWM_SYNC[13:8]) is selected to 0, SYNC_OUT source is come from SYNC_IN or this bit.
N     * |[2]     |SWSYNC4   |Software SYNC Function
N     * |        |          |Each bit n controls corresponding PWM channel n.
N     * |        |          |When SINSRCn (PWM_SYNC[13:8]) is selected to 0, SYNC_OUT source is come from SYNC_IN or this bit.
N     * @var PWM_T::CLKSRC
N     * Offset: 0x10  PWM Clock Source Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |ECLKSRC0  |PWMx_CH0/1 External Clock Source Select
N     * |        |          |000 = PWMx_CLK, x denotes 0 or 1.
N     * |        |          |001 = TIMER0 time-out event.
N     * |        |          |010 = TIMER1 time-out event.
N     * |        |          |011 = TIMER2 time-out event.
N     * |        |          |100 = TIMER3 time-out event.
N     * |        |          |Others = Reserved.
N     * |[10:8]  |ECLKSRC2  |PWMx_CH2/3 External Clock Source Select
N     * |        |          |000 = PWMx_CLK, x denotes 0 or 1.
N     * |        |          |001 = TIMER0 time-out event.
N     * |        |          |010 = TIMER1 time-out event.
N     * |        |          |011 = TIMER2 time-out event.
N     * |        |          |100 = TIMER3 time-out event.
N     * |        |          |Others = Reserved.
N     * |[18:16] |ECLKSRC4  |PWMx_CH4/5 External Clock Source Select
N     * |        |          |000 = PWMx_CLK, x denotes 0 or 1.
N     * |        |          |001 = TIMER0 time-out event.
N     * |        |          |010 = TIMER1 time-out event.
N     * |        |          |011 = TIMER2 time-out event.
N     * |        |          |100 = TIMER3 time-out event.
N     * |        |          |Others = Reserved.
N     * @var PWM_T::CLKPSC0_1
N     * Offset: 0x14  PWM Clock Pre-scale Register 0/1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-scale
N     * |        |          |The clock of PWM counter is decided by clock prescaler.
N     * |        |          |Each PWM pair share one PWM counter clock prescaler.
N     * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1).
N     * @var PWM_T::CLKPSC2_3
N     * Offset: 0x18  PWM Clock Pre-scale Register 2/3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-scale
N     * |        |          |The clock of PWM counter is decided by clock prescaler.
N     * |        |          |Each PWM pair share one PWM counter clock prescaler.
N     * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1).
N     * @var PWM_T::CLKPSC4_5
N     * Offset: 0x1C  PWM Clock Pre-scale Register 4/5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-scale
N     * |        |          |The clock of PWM counter is decided by clock prescaler.
N     * |        |          |Each PWM pair share one PWM counter clock prescaler.
N     * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1).
N     * @var PWM_T::CNTEN
N     * Offset: 0x20  PWM Counter Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CNTEN0    |PWM Counter Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM Counter and clock prescaler Stop Running.
N     * |        |          |1 = PWM Counter and clock prescaler Start Running.
N     * |[1]     |CNTEN1    |PWM Counter Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM Counter and clock prescaler Stop Running.
N     * |        |          |1 = PWM Counter and clock prescaler Start Running.
N     * |[2]     |CNTEN2    |PWM Counter Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM Counter and clock prescaler Stop Running.
N     * |        |          |1 = PWM Counter and clock prescaler Start Running.
N     * |[3]     |CNTEN3    |PWM Counter Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM Counter and clock prescaler Stop Running.
N     * |        |          |1 = PWM Counter and clock prescaler Start Running.
N     * |[4]     |CNTEN4    |PWM Counter Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM Counter and clock prescaler Stop Running.
N     * |        |          |1 = PWM Counter and clock prescaler Start Running.
N     * |[5]     |CNTEN5    |PWM Counter Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM Counter and clock prescaler Stop Running.
N     * |        |          |1 = PWM Counter and clock prescaler Start Running.
N     * @var PWM_T::CNTCLR
N     * Offset: 0x24  PWM Clear Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CNTCLR0   |Clear PWM Counter Control Bit
N     * |        |          |It is automatically cleared by hardware. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear 16-bit PWM counter to 0x0000(CNT(PWM_CNTn[15:0])).
N     * |[1]     |CNTCLR1   |Clear PWM Counter Control Bit
N     * |        |          |It is automatically cleared by hardware. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear 16-bit PWM counter to 0x0000(CNT(PWM_CNTn[15:0])).
N     * |[2]     |CNTCLR2   |Clear PWM Counter Control Bit
N     * |        |          |It is automatically cleared by hardware. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear 16-bit PWM counter to 0x0000(CNT(PWM_CNTn[15:0])).
N     * |[3]     |CNTCLR3   |Clear PWM Counter Control Bit
N     * |        |          |It is automatically cleared by hardware. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear 16-bit PWM counter to 0x0000(CNT(PWM_CNTn[15:0])).
N     * |[4]     |CNTCLR4   |Clear PWM Counter Control Bit
N     * |        |          |It is automatically cleared by hardware. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear 16-bit PWM counter to 0x0000(CNT(PWM_CNTn[15:0])).
N     * |[5]     |CNTCLR5   |Clear PWM Counter Control Bit
N     * |        |          |It is automatically cleared by hardware. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear 16-bit PWM counter to 0x0000(CNT(PWM_CNTn[15:0])).
N     * @var PWM_T::LOAD
N     * Offset: 0x28  PWM Load Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |LOAD0     |Re-load PWM Comparator Register (CMPDAT) Control Bit
N     * |        |          |This bit is software write, and hardware clear when current PWM period end
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Set load window of window loading mode.
N     * |        |          |Read Operation:
N     * |        |          |0 = No load window is set.
N     * |        |          |1 = Load window is set.
N     * |        |          |Note: This bit only use in window loading mode, WINLDENn(PWM_CTL0[13:8]) = 1.
N     * |[1]     |LOAD1     |Re-load PWM Comparator Register (CMPDAT) Control Bit
N     * |        |          |This bit is software write, and hardware clear when current PWM period end
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Set load window of window loading mode.
N     * |        |          |Read Operation:
N     * |        |          |0 = No load window is set.
N     * |        |          |1 = Load window is set.
N     * |        |          |Note: This bit only use in window loading mode, WINLDENn(PWM_CTL0[13:8]) = 1.
N     * |[2]     |LOAD2     |Re-load PWM Comparator Register (CMPDAT) Control Bit
N     * |        |          |This bit is software write, and hardware clear when current PWM period end
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Set load window of window loading mode.
N     * |        |          |Read Operation:
N     * |        |          |0 = No load window is set.
N     * |        |          |1 = Load window is set.
N     * |        |          |Note: This bit only use in window loading mode, WINLDENn(PWM_CTL0[13:8]) = 1.
N     * |[3]     |LOAD3     |Re-load PWM Comparator Register (CMPDAT) Control Bit
N     * |        |          |This bit is software write, and hardware clear when current PWM period end
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Set load window of window loading mode.
N     * |        |          |Read Operation:
N     * |        |          |0 = No load window is set.
N     * |        |          |1 = Load window is set.
N     * |        |          |Note: This bit only use in window loading mode, WINLDENn(PWM_CTL0[13:8]) = 1.
N     * |[4]     |LOAD4     |Re-load PWM Comparator Register (CMPDAT) Control Bit
N     * |        |          |This bit is software write, and hardware clear when current PWM period end
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Set load window of window loading mode.
N     * |        |          |Read Operation:
N     * |        |          |0 = No load window is set.
N     * |        |          |1 = Load window is set.
N     * |        |          |Note: This bit only use in window loading mode, WINLDENn(PWM_CTL0[13:8]) = 1.
N     * |[5]     |LOAD5     |Re-load PWM Comparator Register (CMPDAT) Control Bit
N     * |        |          |This bit is software write, and hardware clear when current PWM period end
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Set load window of window loading mode.
N     * |        |          |Read Operation:
N     * |        |          |0 = No load window is set.
N     * |        |          |1 = Load window is set.
N     * |        |          |Note: This bit only use in window loading mode, WINLDENn(PWM_CTL0[13:8]) = 1.
N     * @var PWM_T::PERIOD
N     * Offset: 0x30/0x34/0x38/0x3C/0x40/0x44  PWM Period Register 0~5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PERIOD    |PWM Period Register
N     * |        |          |Up-Count mode:
N     * |        |          |In this mode, PWM counter counts from 0 to PERIOD, and restarts from 0.
N     * |        |          |PWM period time = (PERIOD+1) * (CLKPSC+1) * PWMx_CLK.
N     * |        |          |Down-Count mode:
N     * |        |          |In this mode, PWM counter counts from PERIOD to 0, and restarts from PERIOD.
N     * |        |          |PWM period time = (PERIOD+1) * (CLKPSC+1) * PWMx_CLK.
N     * |        |          |Up-Down-Count mode:
N     * |        |          |In this mode, PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
N     * |        |          |PWM period time = (2 * PERIOD) * (CLKPSC+1) * PWMx_CLK.
N     * @var PWM_T::CMPDAT
N     * Offset: 0x50/0x54/0x58/0x5C/0x60/0x64  PWM Comparator Register 0~5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMP       |PWM Comparator Register
N     * |        |          |CMP bits use to compare with CNTR(PWM_CNTn[15:0]) bits to generate PWM waveform, interrupt and trigger ADC.
N     * |        |          |In independent mode, CMPDAT0~5 registers denote as 6 independent PWMx_CH0~5 compared point.
N     * |        |          |In complementary mode, CMPDAT0, 2, 4 registers denote as first compared point, and CMPDAT1, 3, 5 register denote as second compared point for the corresponding 3 complementary pairs PWMx_CH0 and PWMx_CH1, PWMx_CH2 and PWMx_CH3, PWMx_CH4 and PWMx_CH5.
N     * @var PWM_T::DTCTL0_1
N     * Offset: 0x70  PWM Dead-Time Control Register 0/1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |DTCNT     |Dead-time Counter (Write Protect)
N     * |        |          |The dead-time can be calculated from the following formula:
N     * |        |          |Dead-time = (DTCNT+1) * PWMx_CLK period, if DTCKSEL bit is 0.
N     * |        |          |Dead-time = (DTCNT+1) * (CLKPSC (PWM_CLKPSCn [11:0])+1)*PWMx_CLK period, if DTCKSEL bit is 1.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * |[16]    |DTEN      |Enable Dead-time Insertion for PWM Pair (PWMx_CH0, PWMx_CH1) (PWMx_CH2, PWMx_CH3) (PWMx_CH4, PWMx_CH5) (Write Protect)
N     * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled.
N     * |        |          |If dead- time insertion is inactive, the outputs of pin pair are complementary without any delay.
N     * |        |          |0 = Dead-time insertion Disabled on the pin pair.
N     * |        |          |1 = Dead-time insertion Enabled on the pin pair.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * |[24]    |DTCKSEL   |Dead-time Clock Select (Write Protect)
N     * |        |          |0 = Dead-time clock source from PWMx_CLK without counter clock prescale.
N     * |        |          |1 = Dead-time clock source from prescaler output with counter clock prescale.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * @var PWM_T::DTCTL2_3
N     * Offset: 0x74  PWM Dead-Time Control Register 2/3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |DTCNT     |Dead-time Counter (Write Protect)
N     * |        |          |The dead-time can be calculated from the following formula:
N     * |        |          |Dead-time = (DTCNT+1) * PWMx_CLK period, if DTCKSEL bit is 0.
N     * |        |          |Dead-time = (DTCNT+1) * (CLKPSC (PWM_CLKPSCn [11:0])+1)*PWMx_CLK period, if DTCKSEL bit is 1.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * |[16]    |DTEN      |Enable Dead-time Insertion for PWM Pair (PWMx_CH0, PWMx_CH1) (PWMx_CH2, PWMx_CH3) (PWMx_CH4, PWMx_CH5) (Write Protect)
N     * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled.
N     * |        |          |If dead- time insertion is inactive, the outputs of pin pair are complementary without any delay.
N     * |        |          |0 = Dead-time insertion Disabled on the pin pair.
N     * |        |          |1 = Dead-time insertion Enabled on the pin pair.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * |[24]    |DTCKSEL   |Dead-time Clock Select (Write Protect)
N     * |        |          |0 = Dead-time clock source from PWMx_CLK without counter clock prescale.
N     * |        |          |1 = Dead-time clock source from prescaler output with counter clock prescale.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * @var PWM_T::DTCTL4_5
N     * Offset: 0x78  PWM Dead-Time Control Register 4/5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |DTCNT     |Dead-time Counter (Write Protect)
N     * |        |          |The dead-time can be calculated from the following formula:
N     * |        |          |Dead-time = (DTCNT+1) * PWMx_CLK period, if DTCKSEL bit is 0.
N     * |        |          |Dead-time = (DTCNT+1) * (CLKPSC (PWM_CLKPSCn [11:0])+1)*PWMx_CLK period, if DTCKSEL bit is 1.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * |[16]    |DTEN      |Enable Dead-time Insertion for PWM Pair (PWMx_CH0, PWMx_CH1) (PWMx_CH2, PWMx_CH3) (PWMx_CH4, PWMx_CH5) (Write Protect)
N     * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled.
N     * |        |          |If dead- time insertion is inactive, the outputs of pin pair are complementary without any delay.
N     * |        |          |0 = Dead-time insertion Disabled on the pin pair.
N     * |        |          |1 = Dead-time insertion Enabled on the pin pair.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * |[24]    |DTCKSEL   |Dead-time Clock Select (Write Protect)
N     * |        |          |0 = Dead-time clock source from PWMx_CLK without counter clock prescale.
N     * |        |          |1 = Dead-time clock source from prescaler output with counter clock prescale.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * @var PWM_T::PHS0_1
N     * Offset: 0x80  PWM Counter Phase Register 0/1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PHS       |PWM Synchronous Start Phase Bits
N     * |        |          |PHS bits determines the PWM synchronous start phase value. These bits only use in synchronous function.
N     * @var PWM_T::PHS2_3
N     * Offset: 0x84  PWM Counter Phase Register 2/3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PHS       |PWM Synchronous Start Phase Bits
N     * |        |          |PHS bits determines the PWM synchronous start phase value. These bits only use in synchronous function.
N     * @var PWM_T::PHS4_5
N     * Offset: 0x88  PWM Counter Phase Register 4/5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PHS       |PWM Synchronous Start Phase Bits
N     * |        |          |PHS bits determines the PWM synchronous start phase value. These bits only use in synchronous function.
N     * @var PWM_T::CNT
N     * Offset: 0x90/0x94/0x98/0x9C/0xA0/0xA4  PWM Counter Register 0~5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CNT       |PWM Counter Data Bits (Read Only)
N     * |        |          |User can monitor CNT to know the current value in 16-bit period counter.
N     * |[16]    |DIRF      |PWM Direction Indicator Flag (Read Only)
N     * |        |          |0 = Counter is Down count.
N     * |        |          |1 = Counter is UP count.
N     * @var PWM_T::WGCTL0
N     * Offset: 0xB0  PWM Generation Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |ZPCTL0    |PWM Zero Point Control
N     * |        |          |PWM can control output level on zero point event. Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM zero point output Low.
N     * |        |          |10 = PWM zero point output High.
N     * |        |          |11 = PWM zero point output Toggle.
N     * |[3:2]   |ZPCTL1    |PWM Zero Point Control
N     * |        |          |PWM can control output level on zero point event. Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM zero point output Low.
N     * |        |          |10 = PWM zero point output High.
N     * |        |          |11 = PWM zero point output Toggle.
N     * |[5:4]   |ZPCTL2    |PWM Zero Point Control
N     * |        |          |PWM can control output level on zero point event. Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM zero point output Low.
N     * |        |          |10 = PWM zero point output High.
N     * |        |          |11 = PWM zero point output Toggle.
N     * |[7:6]   |ZPCTL3    |PWM Zero Point Control
N     * |        |          |PWM can control output level on zero point event. Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM zero point output Low.
N     * |        |          |10 = PWM zero point output High.
N     * |        |          |11 = PWM zero point output Toggle.
N     * |[9:8]   |ZPCTL4    |PWM Zero Point Control
N     * |        |          |PWM can control output level on zero point event. Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM zero point output Low.
N     * |        |          |10 = PWM zero point output High.
N     * |        |          |11 = PWM zero point output Toggle.
N     * |[11:10] |ZPCTL5    |PWM Zero Point Control
N     * |        |          |PWM can control output level on zero point event. Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM zero point output Low.
N     * |        |          |10 = PWM zero point output High.
N     * |        |          |11 = PWM zero point output Toggle.
N     * |[17:16] |PRDPCTL0  |PWM Period (Center) Point Control
N     * |        |          |PWM can control output level on period(center) point event
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM period (center) point output Low.
N     * |        |          |10 = PWM period (center) point output High.
N     * |        |          |11 = PWM period (center) point output Toggle.
N     * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
N     * |[19:18] |PRDPCTL1  |PWM Period (Center) Point Control
N     * |        |          |PWM can control output level on period(center) point event
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM period (center) point output Low.
N     * |        |          |10 = PWM period (center) point output High.
N     * |        |          |11 = PWM period (center) point output Toggle.
N     * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
N     * |[21:20] |PRDPCTL2  |PWM Period (Center) Point Control
N     * |        |          |PWM can control output level on period(center) point event
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM period (center) point output Low.
N     * |        |          |10 = PWM period (center) point output High.
N     * |        |          |11 = PWM period (center) point output Toggle.
N     * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
N     * |[23:22] |PRDPCTL3  |PWM Period (Center) Point Control
N     * |        |          |PWM can control output level on period(center) point event
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM period (center) point output Low.
N     * |        |          |10 = PWM period (center) point output High.
N     * |        |          |11 = PWM period (center) point output Toggle.
N     * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
N     * |[25:24] |PRDPCTL4  |PWM Period (Center) Point Control
N     * |        |          |PWM can control output level on period(center) point event
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM period (center) point output Low.
N     * |        |          |10 = PWM period (center) point output High.
N     * |        |          |11 = PWM period (center) point output Toggle.
N     * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
N     * |[27:26] |PRDPCTL5  |PWM Period (Center) Point Control
N     * |        |          |PWM can control output level on period(center) point event
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM period (center) point output Low.
N     * |        |          |10 = PWM period (center) point output High.
N     * |        |          |11 = PWM period (center) point output Toggle.
N     * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
N     * @var PWM_T::WGCTL1
N     * Offset: 0xB4  PWM Generation Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |CMPUCTL0  |PWM Compare Up Point Control
N     * |        |          |PWM can control output level on compare up point event
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM compare up point output Low.
N     * |        |          |10 = PWM compare up point output High.
N     * |        |          |11 = PWM compare up point output Toggle.
N     * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
N     * |[3:2]   |CMPUCTL1  |PWM Compare Up Point Control
N     * |        |          |PWM can control output level on compare up point event
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM compare up point output Low.
N     * |        |          |10 = PWM compare up point output High.
N     * |        |          |11 = PWM compare up point output Toggle.
N     * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
N     * |[5:4]   |CMPUCTL2  |PWM Compare Up Point Control
N     * |        |          |PWM can control output level on compare up point event
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM compare up point output Low.
N     * |        |          |10 = PWM compare up point output High.
N     * |        |          |11 = PWM compare up point output Toggle.
N     * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
N     * |[7:6]   |CMPUCTL3  |PWM Compare Up Point Control
N     * |        |          |PWM can control output level on compare up point event
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM compare up point output Low.
N     * |        |          |10 = PWM compare up point output High.
N     * |        |          |11 = PWM compare up point output Toggle.
N     * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
N     * |[9:8]   |CMPUCTL4  |PWM Compare Up Point Control
N     * |        |          |PWM can control output level on compare up point event
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM compare up point output Low.
N     * |        |          |10 = PWM compare up point output High.
N     * |        |          |11 = PWM compare up point output Toggle.
N     * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
N     * |[11:10] |CMPUCTL5  |PWM Compare Up Point Control
N     * |        |          |PWM can control output level on compare up point event
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM compare up point output Low.
N     * |        |          |10 = PWM compare up point output High.
N     * |        |          |11 = PWM compare up point output Toggle.
N     * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
N     * |[17:16] |CMPDCTL0  |PWM Compare Down Point Control
N     * |        |          |PWM can control output level on compare down point event
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM compare down point output Low.
N     * |        |          |10 = PWM compare down point output High.
N     * |        |          |11 = PWM compare down point output Toggle.
N     * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
N     * |[19:18] |CMPDCTL1  |PWM Compare Down Point Control
N     * |        |          |PWM can control output level on compare down point event
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM compare down point output Low.
N     * |        |          |10 = PWM compare down point output High.
N     * |        |          |11 = PWM compare down point output Toggle.
N     * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
N     * |[21:20] |CMPDCTL2  |PWM Compare Down Point Control
N     * |        |          |PWM can control output level on compare down point event
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM compare down point output Low.
N     * |        |          |10 = PWM compare down point output High.
N     * |        |          |11 = PWM compare down point output Toggle.
N     * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
N     * |[23:22] |CMPDCTL3  |PWM Compare Down Point Control
N     * |        |          |PWM can control output level on compare down point event
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM compare down point output Low.
N     * |        |          |10 = PWM compare down point output High.
N     * |        |          |11 = PWM compare down point output Toggle.
N     * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
N     * |[25:24] |CMPDCTL4  |PWM Compare Down Point Control
N     * |        |          |PWM can control output level on compare down point event
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM compare down point output Low.
N     * |        |          |10 = PWM compare down point output High.
N     * |        |          |11 = PWM compare down point output Toggle.
N     * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
N     * |[27:26] |CMPDCTL5  |PWM Compare Down Point Control
N     * |        |          |PWM can control output level on compare down point event
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM compare down point output Low.
N     * |        |          |10 = PWM compare down point output High.
N     * |        |          |11 = PWM compare down point output Toggle.
N     * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
N     * @var PWM_T::MSKEN
N     * Offset: 0xB8  PWM Mask Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |MSKEN0    |PWM Mask Enable Bits
N     * |        |          |The PWM output signal will be masked when this bit is enabled.
N     * |        |          |The corresponding PWM channel n will output MSKDATn (PWM_MSK[5:0]) data.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM output signal is non-masked.
N     * |        |          |1 = PWM output signal is masked and output MSKDATn data.
N     * |[1]     |MSKEN1    |PWM Mask Enable Bits
N     * |        |          |The PWM output signal will be masked when this bit is enabled.
N     * |        |          |The corresponding PWM channel n will output MSKDATn (PWM_MSK[5:0]) data.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM output signal is non-masked.
N     * |        |          |1 = PWM output signal is masked and output MSKDATn data.
N     * |[2]     |MSKEN2    |PWM Mask Enable Bits
N     * |        |          |The PWM output signal will be masked when this bit is enabled.
N     * |        |          |The corresponding PWM channel n will output MSKDATn (PWM_MSK[5:0]) data.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM output signal is non-masked.
N     * |        |          |1 = PWM output signal is masked and output MSKDATn data.
N     * |[3]     |MSKEN3    |PWM Mask Enable Bits
N     * |        |          |The PWM output signal will be masked when this bit is enabled.
N     * |        |          |The corresponding PWM channel n will output MSKDATn (PWM_MSK[5:0]) data.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM output signal is non-masked.
N     * |        |          |1 = PWM output signal is masked and output MSKDATn data.
N     * |[4]     |MSKEN4    |PWM Mask Enable Bits
N     * |        |          |The PWM output signal will be masked when this bit is enabled.
N     * |        |          |The corresponding PWM channel n will output MSKDATn (PWM_MSK[5:0]) data.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM output signal is non-masked.
N     * |        |          |1 = PWM output signal is masked and output MSKDATn data.
N     * |[5]     |MSKEN5    |PWM Mask Enable Bits
N     * |        |          |The PWM output signal will be masked when this bit is enabled.
N     * |        |          |The corresponding PWM channel n will output MSKDATn (PWM_MSK[5:0]) data.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM output signal is non-masked.
N     * |        |          |1 = PWM output signal is masked and output MSKDATn data.
N     * @var PWM_T::MSK
N     * Offset: 0xBC  PWM Mask Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |MSKDAT0   |PWM Mask Data Bit
N     * |        |          |This data bit control the state of PWMx_CHn output pin, if corresponding mask function is enabled.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Output logic low to PWMx_CHn.
N     * |        |          |1 = Output logic high to PWMx_CHn.
N     * |[1]     |MSKDAT1   |PWM Mask Data Bit
N     * |        |          |This data bit control the state of PWMx_CHn output pin, if corresponding mask function is enabled.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Output logic low to PWMx_CHn.
N     * |        |          |1 = Output logic high to PWMx_CHn.
N     * |[2]     |MSKDAT2   |PWM Mask Data Bit
N     * |        |          |This data bit control the state of PWMx_CHn output pin, if corresponding mask function is enabled.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Output logic low to PWMx_CHn.
N     * |        |          |1 = Output logic high to PWMx_CHn.
N     * |[3]     |MSKDAT3   |PWM Mask Data Bit
N     * |        |          |This data bit control the state of PWMx_CHn output pin, if corresponding mask function is enabled.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Output logic low to PWMx_CHn.
N     * |        |          |1 = Output logic high to PWMx_CHn.
N     * |[4]     |MSKDAT4   |PWM Mask Data Bit
N     * |        |          |This data bit control the state of PWMx_CHn output pin, if corresponding mask function is enabled.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Output logic low to PWMx_CHn.
N     * |        |          |1 = Output logic high to PWMx_CHn.
N     * |[5]     |MSKDAT5   |PWM Mask Data Bit
N     * |        |          |This data bit control the state of PWMx_CHn output pin, if corresponding mask function is enabled.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Output logic low to PWMx_CHn.
N     * |        |          |1 = Output logic high to PWMx_CHn.
N     * @var PWM_T::BNF
N     * Offset: 0xC0  PWM Brake Noise Filter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BRK0NFEN  |PWM Brake 0 Noise Filter Enable Bit
N     * |        |          |0 = Noise filter of PWM Brake 0 Disabled.
N     * |        |          |1 = Noise filter of PWM Brake 0 Enabled.
N     * |[3:1]   |BRK0NFSEL |Brake 0 Edge Detector Filter Clock Selection
N     * |        |          |000 = Filter clock = HCLK.
N     * |        |          |001 = Filter clock = HCLK/2.
N     * |        |          |010 = Filter clock = HCLK/4.
N     * |        |          |011 = Filter clock = HCLK/8.
N     * |        |          |100 = Filter clock = HCLK/16.
N     * |        |          |101 = Filter clock = HCLK/32.
N     * |        |          |110 = Filter clock = HCLK/64.
N     * |        |          |111 = Filter clock = HCLK/128.
N     * |[6:4]   |BRK0FCNT  |Brake 0 Edge Detector Filter Count
N     * |        |          |The register bits control the Brake0 filter counter to count from 0 to BRK0FCNT.
N     * |[7]     |BRK0PINV  |Brake 0 Pin Inverse
N     * |        |          |0 = Brake pin event will be detected if PWM0_BRAKEx pin status transfer from low to high in edge-detect, or pin status is high in level-detect.
N     * |        |          |1 = Brake pin event will be detected if PWM0_BRAKEx pin status transfer from high to low in edge-detect, or pin status is low in level-detect.
N     * |[8]     |BRK1NFEN  |PWM Brake 1 Noise Filter Enable Bit
N     * |        |          |0 = Noise filter of PWM Brake 1 Disabled.
N     * |        |          |1 = Noise filter of PWM Brake 1 Enabled.
N     * |[11:9]  |BRK1NFSEL |Brake 1 Edge Detector Filter Clock Selection
N     * |        |          |000 = Filter clock = HCLK.
N     * |        |          |001 = Filter clock = HCLK/2.
N     * |        |          |010 = Filter clock = HCLK/4.
N     * |        |          |011 = Filter clock = HCLK/8.
N     * |        |          |100 = Filter clock = HCLK/16.
N     * |        |          |101 = Filter clock = HCLK/32.
N     * |        |          |110 = Filter clock = HCLK/64.
N     * |        |          |111 = Filter clock = HCLK/128.
N     * |[14:12] |BRK1FCNT  |Brake 1 Edge Detector Filter Count
N     * |        |          |The register bits control the Brake1 filter counter to count from 0 to BRK1FCNT.
N     * |[15]    |BRK1PINV  |Brake 1 Pin Inverse
N     * |        |          |0 = Brake pin event will be detected if PWM1_BRAKEx pin status transfer from low to high in edge-detect, or pin status is high in level-detect.
N     * |        |          |1 = Brake pin event will be detected if PWM1_BRAKEx pin status transfer from high to low in edge-detect, or pin status is low in level-detect.
N     * |[16]    |BK0SRC    |Brake 0 Pin Source Select
N     * |        |          |For PWM0 setting:
N     * |        |          |0 = Brake 0 pin source come from PWM0_BRAKE0.
N     * |        |          |1 = Brake 0 pin source come from PWM1_BRAKE0.
N     * |        |          |For PWM1 setting:
N     * |        |          |0 = Brake 0 pin source come from PWM1_BRAKE0.
N     * |        |          |1 = Brake 0 pin source come from PWM0_BRAKE0.
N     * |[24]    |BK1SRC    |Brake 1 Pin Source Select
N     * |        |          |For PWM0 setting:
N     * |        |          |0 = Brake 1 pin source come from PWM0_BRAKE1.
N     * |        |          |1 = Brake 1 pin source come from PWM1_BRAKE1.
N     * |        |          |For PWM1 setting:
N     * |        |          |0 = Brake 1 pin source come from PWM1_BRAKE1.
N     * |        |          |1 = Brake 1 pin source come from PWM0_BRAKE1.
N     * @var PWM_T::FAILBRK
N     * Offset: 0xC4  PWM System Fail Brake Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CSSBRKEN  |Clock Security System Detection Trigger PWM Brake Function Enable Bit
N     * |        |          |0 = Brake Function triggered by clock fail detection Disabled.
N     * |        |          |1 = Brake Function triggered by clock fail detection Enabled.
N     * |[1]     |BODBRKEN  |Brown-out Detection Trigger PWM Brake Function Enable Bit
N     * |        |          |0 = Brake Function triggered by BOD event Disabled.
N     * |        |          |1 = Brake Function triggered by BOD event Enabled.
N     * |[3]     |CORBRKEN  |Core Lockup Detection Trigger PWM Brake Function Enable Bit
N     * |        |          |0 = Brake Function triggered by Core lockup event Disabled.
N     * |        |          |1 = Brake Function triggered by Core lockup event Enabled.
N     * @var PWM_T::BRKCTL0_1
N     * Offset: 0xC8  PWM Brake Edge Detect Control Register 0/1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CPO0EBEN  |Enable ACMP0_O Digital Output As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = ACMP0_O as edge-detect brake source Disabled.
N     * |        |          |1 = ACMP0_O as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[1]     |CPO1EBEN  |Enable ACMP1_O Digital Output As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = ACMP1_O as edge-detect brake source Disabled.
N     * |        |          |1 = ACMP1_O as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[4]     |BRKP0EEN  |Enable PWMx_BRAKE0 Pin As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = PWMx_BRAKE0 pin as edge-detect brake source Disabled.
N     * |        |          |1 = PWMx_BRAKE0 pin as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[5]     |BRKP1EEN  |Enable PWMx_BRAKE1 Pin As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = PWMx_BRAKE1 pin as edge-detect brake source Disabled.
N     * |        |          |1 = PWMx_BRAKE1 pin as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[7]     |SYSEBEN   |Enable System Fail As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
N     * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[8]     |CPO0LBEN  |Enable ACMP0_O Digital Output As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = ACMP0_O as level-detect brake source Disabled.
N     * |        |          |1 = ACMP0_O as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[9]     |CPO1LBEN  |Enable ACMP1_O Digital Output As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = ACMP1_O as level-detect brake source Disabled.
N     * |        |          |1 = ACMP1_O as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = PWMx_BRAKE0 pin as level-detect brake source Disabled.
N     * |        |          |1 = PWMx_BRAKE0 pin as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = PWMx_BRAKE1 pin as level-detect brake source Disabled.
N     * |        |          |1 = PWMx_BRAKE1 pin as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[15]    |SYSLBEN   |Enable System Fail As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = System Fail condition as level-detect brake source Disabled.
N     * |        |          |1 = System Fail condition as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[17:16] |BRKAEVEN  |PWM Brake Action Select for Even Channel (Write Protect)
N     * |        |          |00 = PWMx brake event will not affect even channels output.
N     * |        |          |01 = PWM even channel output tri-state when PWMx brake event happened.
N     * |        |          |10 = PWM even channel output low level when PWMx brake event happened.
N     * |        |          |11 = PWM even channel output high level when PWMx brake event happened.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[19:18] |BRKAODD   |PWM Brake Action Select for Odd Channel (Write Protect)
N     * |        |          |00 = PWMx brake event will not affect odd channels output.
N     * |        |          |01 = PWM odd channel output tri-state when PWMx brake event happened.
N     * |        |          |10 = PWM odd channel output low level when PWMx brake event happened.
N     * |        |          |11 = PWM odd channel output high level when PWMx brake event happened.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[20]    |ADCEBEN   |Enable ADC Result Monitor (ADCRM) As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = ADCRM as edge-detect brake source Disabled.
N     * |        |          |1 = ADCRM as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[28]    |ADCLBEN   |Enable ADC Result Monitor (ADCRM) As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = ADCRM as level-detect brake source Disabled.
N     * |        |          |1 = ADCRM as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * @var PWM_T::BRKCTL2_3
N     * Offset: 0xCC  PWM Brake Edge Detect Control Register 2/3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CPO0EBEN  |Enable ACMP0_O Digital Output As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = ACMP0_O as edge-detect brake source Disabled.
N     * |        |          |1 = ACMP0_O as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[1]     |CPO1EBEN  |Enable ACMP1_O Digital Output As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = ACMP1_O as edge-detect brake source Disabled.
N     * |        |          |1 = ACMP1_O as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[4]     |BRKP0EEN  |Enable PWMx_BRAKE0 Pin As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = PWMx_BRAKE0 pin as edge-detect brake source Disabled.
N     * |        |          |1 = PWMx_BRAKE0 pin as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[5]     |BRKP1EEN  |Enable PWMx_BRAKE1 Pin As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = PWMx_BRAKE1 pin as edge-detect brake source Disabled.
N     * |        |          |1 = PWMx_BRAKE1 pin as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[7]     |SYSEBEN   |Enable System Fail As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
N     * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[8]     |CPO0LBEN  |Enable ACMP0_O Digital Output As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = ACMP0_O as level-detect brake source Disabled.
N     * |        |          |1 = ACMP0_O as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[9]     |CPO1LBEN  |Enable ACMP1_O Digital Output As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = ACMP1_O as level-detect brake source Disabled.
N     * |        |          |1 = ACMP1_O as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = PWMx_BRAKE0 pin as level-detect brake source Disabled.
N     * |        |          |1 = PWMx_BRAKE0 pin as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = PWMx_BRAKE1 pin as level-detect brake source Disabled.
N     * |        |          |1 = PWMx_BRAKE1 pin as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[15]    |SYSLBEN   |Enable System Fail As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = System Fail condition as level-detect brake source Disabled.
N     * |        |          |1 = System Fail condition as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[17:16] |BRKAEVEN  |PWM Brake Action Select for Even Channel (Write Protect)
N     * |        |          |00 = PWMx brake event will not affect even channels output.
N     * |        |          |01 = PWM even channel output tri-state when PWMx brake event happened.
N     * |        |          |10 = PWM even channel output low level when PWMx brake event happened.
N     * |        |          |11 = PWM even channel output high level when PWMx brake event happened.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[19:18] |BRKAODD   |PWM Brake Action Select for Odd Channel (Write Protect)
N     * |        |          |00 = PWMx brake event will not affect odd channels output.
N     * |        |          |01 = PWM odd channel output tri-state when PWMx brake event happened.
N     * |        |          |10 = PWM odd channel output low level when PWMx brake event happened.
N     * |        |          |11 = PWM odd channel output high level when PWMx brake event happened.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[20]    |ADCEBEN   |Enable ADC Result Monitor (ADCRM) As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = ADCRM as edge-detect brake source Disabled.
N     * |        |          |1 = ADCRM as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[28]    |ADCLBEN   |Enable ADC Result Monitor (ADCRM) As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = ADCRM as level-detect brake source Disabled.
N     * |        |          |1 = ADCRM as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * @var PWM_T::BRKCTL4_5
N     * Offset: 0xD0  PWM Brake Edge Detect Control Register 4/5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CPO0EBEN  |Enable ACMP0_O Digital Output As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = ACMP0_O as edge-detect brake source Disabled.
N     * |        |          |1 = ACMP0_O as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[1]     |CPO1EBEN  |Enable ACMP1_O Digital Output As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = ACMP1_O as edge-detect brake source Disabled.
N     * |        |          |1 = ACMP1_O as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[4]     |BRKP0EEN  |Enable PWMx_BRAKE0 Pin As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = PWMx_BRAKE0 pin as edge-detect brake source Disabled.
N     * |        |          |1 = PWMx_BRAKE0 pin as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[5]     |BRKP1EEN  |Enable PWMx_BRAKE1 Pin As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = PWMx_BRAKE1 pin as edge-detect brake source Disabled.
N     * |        |          |1 = PWMx_BRAKE1 pin as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[7]     |SYSEBEN   |Enable System Fail As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
N     * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[8]     |CPO0LBEN  |Enable ACMP0_O Digital Output As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = ACMP0_O as level-detect brake source Disabled.
N     * |        |          |1 = ACMP0_O as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[9]     |CPO1LBEN  |Enable ACMP1_O Digital Output As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = ACMP1_O as level-detect brake source Disabled.
N     * |        |          |1 = ACMP1_O as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = PWMx_BRAKE0 pin as level-detect brake source Disabled.
N     * |        |          |1 = PWMx_BRAKE0 pin as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = PWMx_BRAKE1 pin as level-detect brake source Disabled.
N     * |        |          |1 = PWMx_BRAKE1 pin as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[15]    |SYSLBEN   |Enable System Fail As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = System Fail condition as level-detect brake source Disabled.
N     * |        |          |1 = System Fail condition as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[17:16] |BRKAEVEN  |PWM Brake Action Select for Even Channel (Write Protect)
N     * |        |          |00 = PWMx brake event will not affect even channels output.
N     * |        |          |01 = PWM even channel output tri-state when PWMx brake event happened.
N     * |        |          |10 = PWM even channel output low level when PWMx brake event happened.
N     * |        |          |11 = PWM even channel output high level when PWMx brake event happened.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[19:18] |BRKAODD   |PWM Brake Action Select for Odd Channel (Write Protect)
N     * |        |          |00 = PWMx brake event will not affect odd channels output.
N     * |        |          |01 = PWM odd channel output tri-state when PWMx brake event happened.
N     * |        |          |10 = PWM odd channel output low level when PWMx brake event happened.
N     * |        |          |11 = PWM odd channel output high level when PWMx brake event happened.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[20]    |ADCEBEN   |Enable ADC Result Monitor (ADCRM) As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = ADCRM as edge-detect brake source Disabled.
N     * |        |          |1 = ADCRM as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[28]    |ADCLBEN   |Enable ADC Result Monitor (ADCRM) As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = ADCRM as level-detect brake source Disabled.
N     * |        |          |1 = ADCRM as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * @var PWM_T::POLCTL
N     * Offset: 0xD4  PWM Pin Polar Inverse Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PINV0     |PWM PIN Polar Inverse Control
N     * |        |          |The register controls polarity state of PWMx_CHn output pin
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWMx_CHn output pin polar inverse Disabled.
N     * |        |          |1 = PWMx_CHn output pin polar inverse Enabled.
N     * |[1]     |PINV1     |PWM PIN Polar Inverse Control
N     * |        |          |The register controls polarity state of PWMx_CHn output pin
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWMx_CHn output pin polar inverse Disabled.
N     * |        |          |1 = PWMx_CHn output pin polar inverse Enabled.
N     * |[2]     |PINV2     |PWM PIN Polar Inverse Control
N     * |        |          |The register controls polarity state of PWMx_CHn output pin
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWMx_CHn output pin polar inverse Disabled.
N     * |        |          |1 = PWMx_CHn output pin polar inverse Enabled.
N     * |[3]     |PINV3     |PWM PIN Polar Inverse Control
N     * |        |          |The register controls polarity state of PWMx_CHn output pin
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWMx_CHn output pin polar inverse Disabled.
N     * |        |          |1 = PWMx_CHn output pin polar inverse Enabled.
N     * |[4]     |PINV4     |PWM PIN Polar Inverse Control
N     * |        |          |The register controls polarity state of PWMx_CHn output pin
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWMx_CHn output pin polar inverse Disabled.
N     * |        |          |1 = PWMx_CHn output pin polar inverse Enabled.
N     * |[5]     |PINV5     |PWM PIN Polar Inverse Control
N     * |        |          |The register controls polarity state of PWMx_CHn output pin
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWMx_CHn output pin polar inverse Disabled.
N     * |        |          |1 = PWMx_CHn output pin polar inverse Enabled.
N     * @var PWM_T::POEN
N     * Offset: 0xD8  PWM Output Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |POEN0     |PWMx_CHn Pin Output Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWMx_CHn pin at tri-state.
N     * |        |          |1 = PWMx_CHn pin in output mode.
N     * |[1]     |POEN1     |PWMx_CHn Pin Output Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWMx_CHn pin at tri-state.
N     * |        |          |1 = PWMx_CHn pin in output mode.
N     * |[2]     |POEN2     |PWMx_CHn Pin Output Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWMx_CHn pin at tri-state.
N     * |        |          |1 = PWMx_CHn pin in output mode.
N     * |[3]     |POEN3     |PWMx_CHn Pin Output Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWMx_CHn pin at tri-state.
N     * |        |          |1 = PWMx_CHn pin in output mode.
N     * |[4]     |POEN4     |PWMx_CHn Pin Output Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWMx_CHn pin at tri-state.
N     * |        |          |1 = PWMx_CHn pin in output mode.
N     * |[5]     |POEN5     |PWMx_CHn Pin Output Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWMx_CHn pin at tri-state.
N     * |        |          |1 = PWMx_CHn pin in output mode.
N     * @var PWM_T::SWBRK
N     * Offset: 0xDC  PWM Software Brake Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BRKETRG0  |PWM Edge Brake Software Trigger (Write Only) (Write Protect)
N     * |        |          |Write 1 to this bit will trigger Edge brake, and set BRKEIFn bits to 1 in PWM_INTSTS1 register.
N     * |        |          |Each bit n controls the corresponding PWM pair n.
N     * |        |          |Note: This register is write protected. Refer toREGWRPROT register.
N     * |[1]     |BRKETRG2  |PWM Edge Brake Software Trigger (Write Only) (Write Protect)
N     * |        |          |Write 1 to this bit will trigger Edge brake, and set BRKEIFn bits to 1 in PWM_INTSTS1 register.
N     * |        |          |Each bit n controls the corresponding PWM pair n.
N     * |        |          |Note: This register is write protected. Refer toREGWRPROT register.
N     * |[2]     |BRKETRG4  |PWM Edge Brake Software Trigger (Write Only) (Write Protect)
N     * |        |          |Write 1 to this bit will trigger Edge brake, and set BRKEIFn bits to 1 in PWM_INTSTS1 register.
N     * |        |          |Each bit n controls the corresponding PWM pair n.
N     * |        |          |Note: This register is write protected. Refer toREGWRPROT register.
N     * |[8]     |BRKLTRG0  |PWM Level Brake Software Trigger (Write Only) (Write Protect)
N     * |        |          |Write 1 to this bit will trigger level brake, and set BRKLIFn bits to 1 in PWM_INTSTS1 register.
N     * |        |          |Each bit n controls the corresponding PWM pair n.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[9]     |BRKLTRG2  |PWM Level Brake Software Trigger (Write Only) (Write Protect)
N     * |        |          |Write 1 to this bit will trigger level brake, and set BRKLIFn bits to 1 in PWM_INTSTS1 register.
N     * |        |          |Each bit n controls the corresponding PWM pair n.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[10]    |BRKLTRG4  |PWM Level Brake Software Trigger (Write Only) (Write Protect)
N     * |        |          |Write 1 to this bit will trigger level brake, and set BRKLIFn bits to 1 in PWM_INTSTS1 register.
N     * |        |          |Each bit n controls the corresponding PWM pair n.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * @var PWM_T::INTEN0
N     * Offset: 0xE0  PWM Interrupt Enable Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ZIEN0     |PWM Zero Point Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Zero point interrupt Disabled.
N     * |        |          |1 = Zero point interrupt Enabled.
N     * |        |          |Note: Odd channels will read always 0 at complementary mode.
N     * |[1]     |ZIEN1     |PWM Zero Point Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Zero point interrupt Disabled.
N     * |        |          |1 = Zero point interrupt Enabled.
N     * |        |          |Note: Odd channels will read always 0 at complementary mode.
N     * |[2]     |ZIEN2     |PWM Zero Point Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Zero point interrupt Disabled.
N     * |        |          |1 = Zero point interrupt Enabled.
N     * |        |          |Note: Odd channels will read always 0 at complementary mode.
N     * |[3]     |ZIEN3     |PWM Zero Point Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Zero point interrupt Disabled.
N     * |        |          |1 = Zero point interrupt Enabled.
N     * |        |          |Note: Odd channels will read always 0 at complementary mode.
N     * |[4]     |ZIEN4     |PWM Zero Point Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Zero point interrupt Disabled.
N     * |        |          |1 = Zero point interrupt Enabled.
N     * |        |          |Note: Odd channels will read always 0 at complementary mode.
N     * |[5]     |ZIEN5     |PWM Zero Point Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Zero point interrupt Disabled.
N     * |        |          |1 = Zero point interrupt Enabled.
N     * |        |          |Note: Odd channels will read always 0 at complementary mode.
N     * |[7]     |IFAIEN0_1 |PWM Channel 0/1 Interrupt Flag Accumulator Interrupt Enable Bit
N     * |        |          |0 = Interrupt Flag accumulator interrupt Disabled.
N     * |        |          |1 = Interrupt Flag accumulator interrupt Enabled.
N     * |[8]     |PIEN0     |PWM Period Point Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Period point interrupt Disabled.
N     * |        |          |1 = Period point interrupt Enabled.
N     * |        |          |Note1: When up-down counter type period point means center point.
N     * |        |          |Note2: Odd channels will read always 0 at complementary mode.
N     * |[9]     |PIEN1     |PWM Period Point Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Period point interrupt Disabled.
N     * |        |          |1 = Period point interrupt Enabled.
N     * |        |          |Note1: When up-down counter type period point means center point.
N     * |        |          |Note2: Odd channels will read always 0 at complementary mode.
N     * |[10]    |PIEN2     |PWM Period Point Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Period point interrupt Disabled.
N     * |        |          |1 = Period point interrupt Enabled.
N     * |        |          |Note1: When up-down counter type period point means center point.
N     * |        |          |Note2: Odd channels will read always 0 at complementary mode.
N     * |[11]    |PIEN3     |PWM Period Point Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Period point interrupt Disabled.
N     * |        |          |1 = Period point interrupt Enabled.
N     * |        |          |Note1: When up-down counter type period point means center point.
N     * |        |          |Note2: Odd channels will read always 0 at complementary mode.
N     * |[12]    |PIEN4     |PWM Period Point Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Period point interrupt Disabled.
N     * |        |          |1 = Period point interrupt Enabled.
N     * |        |          |Note1: When up-down counter type period point means center point.
N     * |        |          |Note2: Odd channels will read always 0 at complementary mode.
N     * |[13]    |PIEN5     |PWM Period Point Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Period point interrupt Disabled.
N     * |        |          |1 = Period point interrupt Enabled.
N     * |        |          |Note1: When up-down counter type period point means center point.
N     * |        |          |Note2: Odd channels will read always 0 at complementary mode.
N     * |[15]    |IFAIEN2_3 |PWM Channel 2/3 Interrupt Flag Accumulator Interrupt Enable Bit
N     * |        |          |0 = Interrupt Flag accumulator interrupt Disabled.
N     * |        |          |1 = Interrupt Flag accumulator interrupt Enabled.
N     * |[16]    |CMPUIEN0  |PWM Compare Up Count Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Compare up count interrupt Disabled.
N     * |        |          |1 = Compare up count interrupt Enabled.
N     * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
N     * |[17]    |CMPUIEN1  |PWM Compare Up Count Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Compare up count interrupt Disabled.
N     * |        |          |1 = Compare up count interrupt Enabled.
N     * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
N     * |[18]    |CMPUIEN2  |PWM Compare Up Count Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Compare up count interrupt Disabled.
N     * |        |          |1 = Compare up count interrupt Enabled.
N     * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
N     * |[19]    |CMPUIEN3  |PWM Compare Up Count Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Compare up count interrupt Disabled.
N     * |        |          |1 = Compare up count interrupt Enabled.
N     * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
N     * |[20]    |CMPUIEN4  |PWM Compare Up Count Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Compare up count interrupt Disabled.
N     * |        |          |1 = Compare up count interrupt Enabled.
N     * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
N     * |[21]    |CMPUIEN5  |PWM Compare Up Count Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Compare up count interrupt Disabled.
N     * |        |          |1 = Compare up count interrupt Enabled.
N     * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
N     * |[23]    |IFAIEN4_5 |PWM Channel 4/5 Interrupt Flag Accumulator Interrupt Enable Bit
N     * |        |          |0 = Interrupt Flag accumulator interrupt Disabled.
N     * |        |          |1 = Interrupt Flag accumulator interrupt Enabled.
N     * |[24]    |CMPDIEN0  |PWM Compare Down Count Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Compare down count interrupt Disabled.
N     * |        |          |1 = Compare down count interrupt Enabled.
N     * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
N     * |[25]    |CMPDIEN1  |PWM Compare Down Count Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Compare down count interrupt Disabled.
N     * |        |          |1 = Compare down count interrupt Enabled.
N     * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
N     * |[26]    |CMPDIEN2  |PWM Compare Down Count Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Compare down count interrupt Disabled.
N     * |        |          |1 = Compare down count interrupt Enabled.
N     * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
N     * |[27]    |CMPDIEN3  |PWM Compare Down Count Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Compare down count interrupt Disabled.
N     * |        |          |1 = Compare down count interrupt Enabled.
N     * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
N     * |[28]    |CMPDIEN4  |PWM Compare Down Count Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Compare down count interrupt Disabled.
N     * |        |          |1 = Compare down count interrupt Enabled.
N     * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
N     * |[29]    |CMPDIEN5  |PWM Compare Down Count Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Compare down count interrupt Disabled.
N     * |        |          |1 = Compare down count interrupt Enabled.
N     * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
N     * @var PWM_T::INTEN1
N     * Offset: 0xE4  PWM Interrupt Enable Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BRKEIEN0_1|PWM Edge-detect Brake Interrupt Enable for Channel0/1 (Write Protect)
N     * |        |          |0 = Edge-detect Brake interrupt for channel0/1 Disabled.
N     * |        |          |1 = Edge-detect Brake interrupt for channel0/1 Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[1]     |BRKEIEN2_3|PWM Edge-detect Brake Interrupt Enable for Channel2/3 (Write Protect)
N     * |        |          |0 = Edge-detect Brake interrupt for channel2/3 Disabled.
N     * |        |          |1 = Edge-detect Brake interrupt for channel2/3 Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[2]     |BRKEIEN4_5|PWM Edge-detect Brake Interrupt Enable for Channel4/5 (Write Protect)
N     * |        |          |0 = Edge-detect Brake interrupt for channel4/5 Disabled.
N     * |        |          |1 = Edge-detect Brake interrupt for channel4/5 Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[8]     |BRKLIEN0_1|PWM Level-detect Brake Interrupt Enable for Channel0/1 (Write Protect)
N     * |        |          |0 = Level-detect Brake interrupt for channel0/1 Disabled.
N     * |        |          |1 = Level-detect Brake interrupt for channel0/1 Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[9]     |BRKLIEN2_3|PWM Level-detect Brake Interrupt Enable for Channel2/3 (Write Protect)
N     * |        |          |0 = Level-detect Brake interrupt for channel2/3 Disabled.
N     * |        |          |1 = Level-detect Brake interrupt for channel2/3 Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[10]    |BRKLIEN4_5|PWM Level-detect Brake Interrupt Enable for Channel4/5 (Write Protect)
N     * |        |          |0 = Level-detect Brake interrupt for channel4/5 Disabled.
N     * |        |          |1 = Level-detect Brake interrupt for channel4/5 Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * @var PWM_T::INTSTS0
N     * Offset: 0xE8  PWM Interrupt Flag Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ZIF0      |PWM Zero Point Interrupt Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
N     * |[1]     |ZIF1      |PWM Zero Point Interrupt Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
N     * |[2]     |ZIF2      |PWM Zero Point Interrupt Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
N     * |[3]     |ZIF3      |PWM Zero Point Interrupt Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
N     * |[4]     |ZIF4      |PWM Zero Point Interrupt Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
N     * |[5]     |ZIF5      |PWM Zero Point Interrupt Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
N     * |[7]     |IFAIF0_1  |PWM Channel 0/1 Interrupt Flag Accumulator Interrupt Flag
N     * |        |          |Flag is set by hardware when condition match IFSEL0_1 bits in PWM_IFA register, software can clear this bit by writing 1 to it.
N     * |[8]     |PIF0      |PWM Period Point Interrupt Flag
N     * |        |          |This bit is set by hardware when PWM counter reaches PERIOD(PWM_PERIODn[15:0]), software can write 1 to clear this bit to zero.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |[9]     |PIF1      |PWM Period Point Interrupt Flag
N     * |        |          |This bit is set by hardware when PWM counter reaches PERIOD(PWM_PERIODn[15:0]), software can write 1 to clear this bit to zero.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |[10]    |PIF2      |PWM Period Point Interrupt Flag
N     * |        |          |This bit is set by hardware when PWM counter reaches PERIOD(PWM_PERIODn[15:0]), software can write 1 to clear this bit to zero.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |[11]    |PIF3      |PWM Period Point Interrupt Flag
N     * |        |          |This bit is set by hardware when PWM counter reaches PERIOD(PWM_PERIODn[15:0]), software can write 1 to clear this bit to zero.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |[12]    |PIF4      |PWM Period Point Interrupt Flag
N     * |        |          |This bit is set by hardware when PWM counter reaches PERIOD(PWM_PERIODn[15:0]), software can write 1 to clear this bit to zero.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |[13]    |PIF5      |PWM Period Point Interrupt Flag
N     * |        |          |This bit is set by hardware when PWM counter reaches PERIOD(PWM_PERIODn[15:0]), software can write 1 to clear this bit to zero.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |[15]    |IFAIF2_3  |PWM Channel 2/3 Interrupt Flag Accumulator Interrupt Flag
N     * |        |          |Flag is set by hardware when condition match IFSEL2_3 bits in PWM_IFA register, software can clear this bit by writing 1 to it.
N     * |[16]    |CMPUIF0   |PWM Compare Up Count Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM counter up count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
N     * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
N     * |[17]    |CMPUIF1   |PWM Compare Up Count Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM counter up count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
N     * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
N     * |[18]    |CMPUIF2   |PWM Compare Up Count Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM counter up count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
N     * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
N     * |[19]    |CMPUIF3   |PWM Compare Up Count Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM counter up count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
N     * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
N     * |[20]    |CMPUIF4   |PWM Compare Up Count Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM counter up count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
N     * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
N     * |[21]    |CMPUIF5   |PWM Compare Up Count Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM counter up count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
N     * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
N     * |[23]    |IFAIF4_5  |PWM_Channel 4/5 Interrupt Flag Accumulator Interrupt Flag
N     * |        |          |Flag is set by hardware when condition match IFSEL4_5 bits in PWM_IFA register, software can clear this bit by writing 1 to it.
N     * |[24]    |CMPDIF0   |PWM Compare Down Count Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM counter down count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note1: If CMP equal to PERIOD, this flag is not working in down counter type selection.
N     * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
N     * |[25]    |CMPDIF1   |PWM Compare Down Count Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM counter down count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note1: If CMP equal to PERIOD, this flag is not working in down counter type selection.
N     * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
N     * |[26]    |CMPDIF2   |PWM Compare Down Count Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM counter down count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note1: If CMP equal to PERIOD, this flag is not working in down counter type selection.
N     * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
N     * |[27]    |CMPDIF3   |PWM Compare Down Count Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM counter down count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note1: If CMP equal to PERIOD, this flag is not working in down counter type selection.
N     * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
N     * |[28]    |CMPDIF4   |PWM Compare Down Count Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM counter down count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note1: If CMP equal to PERIOD, this flag is not working in down counter type selection.
N     * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
N     * |[29]    |CMPDIF5   |PWM Compare Down Count Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM counter down count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note1: If CMP equal to PERIOD, this flag is not working in down counter type selection.
N     * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
N     * @var PWM_T::INTSTS1
N     * Offset: 0xEC  PWM Interrupt Flag Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BRKEIF0   |PWM Channel 0 Edge-detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel 0 edge-detect brake event do not happened.
N     * |        |          |1 = When PWM channel 0 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * |[1]     |BRKEIF1   |PWM Channel 1 Edge-detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel 1 edge-detect brake event do not happened.
N     * |        |          |1 = When PWM channel 1 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * |[2]     |BRKEIF2   |PWM Channel 2 Edge-detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel 2 edge-detect brake event do not happened.
N     * |        |          |1 = When PWM channel 2 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * |[3]     |BRKEIF3   |PWM Channel 3 Edge-detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel 3 edge-detect brake event do not happened.
N     * |        |          |1 = When PWM channel 3 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * |[4]     |BRKEIF4   |PWM Channel 4 Edge-detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel 4 edge-detect brake event do not happened.
N     * |        |          |1 = When PWM channel 4 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * |[5]     |BRKEIF5   |PWM Channel 5 Edge-detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel 5 edge-detect brake event do not happened.
N     * |        |          |1 = When PWM channel 5 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * |[8]     |BRKLIF0   |PWM Channel 0 Level-detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel 0 level-detect brake event do not happened.
N     * |        |          |1 = When PWM channel 0 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * |[9]     |BRKLIF1   |PWM Channel 1 Level-detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel 1 level-detect brake event do not happened.
N     * |        |          |1 = When PWM channel 1 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * |[10]    |BRKLIF2   |PWM Channel 2 Level-detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel 2 level-detect brake event do not happened.
N     * |        |          |1 = When PWM channel 2 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * |[11]    |BRKLIF3   |PWM Channel 3 Level-detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel 3 level-detect brake event do not happened.
N     * |        |          |1 = When PWM channel 3 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * |[12]    |BRKLIF4   |PWM Channel 4 Level-detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel 4 level-detect brake event do not happened.
N     * |        |          |1 = When PWM channel 4 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * |[13]    |BRKLIF5   |PWM Channel 5 Level-detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel 5 level-detect brake event do not happened.
N     * |        |          |1 = When PWM channel 5 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N     * |[16]    |BRKESTS0  |PWM Channel 0 Edge-detect Brake Status
N     * |        |          |0 = PWM channel 0 edge-detect brake state is released.
N     * |        |          |1 = When PWM channel 0 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 0 at brake state, writing 1 to clear.
N     * |[17]    |BRKESTS1  |PWM Channel 1 Edge-detect Brake Status
N     * |        |          |0 = PWM channel 1 edge-detect brake state is released.
N     * |        |          |1 = When PWM channel 1 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 1 at brake state, writing 1 to clear.
N     * |[18]    |BRKESTS2  |PWM Channel 2 Edge-detect Brake Status
N     * |        |          |0 = PWM channel 2 edge-detect brake state is released.
N     * |        |          |1 = When PWM channel 2 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 2 at brake state, writing 1 to clear.
N     * |[19]    |BRKESTS3  |PWM Channel n5 Edge-detect Brake Status
N     * |        |          |0 = PWM channel 3 edge-detect brake state is released.
N     * |        |          |1 = When PWM channel 3 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 3 at brake state, writing 1 to clear.
N     * |[20]    |BRKESTS4  |PWM Channel 4 Edge-detect Brake Status
N     * |        |          |0 = PWM channel 4 edge-detect brake state is released.
N     * |        |          |1 = When PWM channel 4 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 4 at brake state, writing 1 to clear.
N     * |[21]    |BRKESTS5  |PWM Channel 5 Edge-detect Brake Status
N     * |        |          |0 = PWM channel 5 edge-detect brake state is released.
N     * |        |          |1 = When PWM channel 5 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 5 at brake state, writing 1 to clear.
N     * |[24]    |BRKLSTS0  |PWM Channel 0 Level-detect Brake Status (Read Only)
N     * |        |          |0 = PWM channel 0 level-detect brake state is released.
N     * |        |          |1 = When PWM channel 0 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 0 at brake state.
N     * |        |          |Note: This bit is read only and auto cleared by hardware.
N     * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
N     * |        |          |The PWM waveform will start output from next full PWM period.
N     * |[25]    |BRKLSTS1  |PWM Channel 1 Level-detect Brake Status (Read Only)
N     * |        |          |0 = PWM channel 1 level-detect brake state is released.
N     * |        |          |1 = When PWM channel 1 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 1 at brake state.
N     * |        |          |Note: This bit is read only and auto cleared by hardware.
N     * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
N     * |        |          |The PWM waveform will start output from next full PWM period.
N     * |[26]    |BRKLSTS2  |PWM Channel 2 Level-detect Brake Status (Read Only)
N     * |        |          |0 = PWM channel 2 level-detect brake state is released.
N     * |        |          |1 = When PWM channel 2 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 2 at brake state.
N     * |        |          |Note: This bit is read only and auto cleared by hardware.
N     * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
N     * |        |          |The PWM waveform will start output from next full PWM period.
N     * |[27]    |BRKLSTS3  |PWM Channel 3 Level-detect Brake Status (Read Only)
N     * |        |          |0 = PWM channel 3 level-detect brake state is released.
N     * |        |          |1 = When PWM channel 3 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 3 at brake state.
N     * |        |          |Note: This bit is read only and auto cleared by hardware.
N     * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
N     * |        |          |The PWM waveform will start output from next full PWM period.
N     * |[28]    |BRKLSTS4  |PWM Channel 4 Level-detect Brake Status (Read Only)
N     * |        |          |0 = PWM channel 4 level-detect brake state is released.
N     * |        |          |1 = When PWM channel 4 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 4 at brake state.
N     * |        |          |Note: This bit is read only and auto cleared by hardware.
N     * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
N     * |        |          |The PWM waveform will start output from next full PWM period.
N     * |[29]    |BRKLSTS5  |PWM Channel 5 Level-detect Brake Status (Read Only)
N     * |        |          |0 = PWM channel 5 level-detect brake state is released.
N     * |        |          |1 = When PWM channel 5 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 5 at brake state.
N     * |        |          |Note: This bit is read only and auto cleared by hardware.
N     * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
N     * |        |          |The PWM waveform will start output from next full PWM period.
N     * @var PWM_T::IFA
N     * Offset: 0xF0  PWM Interrupt Flag Accumulator Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |IFCNT0_1  |PWM Channel 0/1 Interrupt Flag Counter
N     * |        |          |The register sets the count number which defines how many times of PWM Channel 0/1 period occurs to set IFAIF0_1 bit to request the PWM period interrupt.
N     * |        |          |PWM flag will be set in every IFCNT0_1 [3:0] times of PWM period.
N     * |[6:4]   |IFSEL0_1  |PWM Channel 0/1 Interrupt Flag Accumulator Source Select
N     * |        |          |000 = CNT equal to Zero in channel 0.
N     * |        |          |001 = CNT equal to PERIOD in channel 0.
N     * |        |          |010 = CNT equal to CMPU in channel 0.
N     * |        |          |011 = CNT equal to CMPD in channel 0.
N     * |        |          |100 = CNT equal to Zero in channel 1.
N     * |        |          |101 = CNT equal to PERIOD in channel 1.
N     * |        |          |110 = CNT equal to CMPU in channel 1.
N     * |        |          |111 = CNT equal to CMPD in channel 1.
N     * |[7]     |IFAEN0_1  |PWM Channel 0/1 Interrupt Flag Accumulator Enable Bit
N     * |        |          |0 = PWM Channel 0/1 interrupt flag accumulator disable.
N     * |        |          |1 = PWM Channel 0/1 interrupt flag accumulator enable.
N     * |[11:8]  |IFCNT2_3  |PWM Channel 2/3 Interrupt Flag Counter
N     * |        |          |The register sets the count number which defines how many times of PWM Channel 2/3 period occurs to set IFAIF2_3 bit to request the PWM period interrupt.
N     * |        |          |PWM flag will be set in every IFCNT2_3[3:0] times of PWM period.
N     * |[14:12] |IFSEL2_3  |PWM Channel 2/3 Interrupt Flag Accumulator Source Select
N     * |        |          |000 = CNT equal to Zero in channel 2.
N     * |        |          |001 = CNT equal to PERIOD in channel 2.
N     * |        |          |010 = CNT equal to CMPU in channel 2.
N     * |        |          |011 = CNT equal to CMPD in channel 2.
N     * |        |          |100 = CNT equal to Zero in channel 3.
N     * |        |          |101 = CNT equal to PERIOD in channel 3.
N     * |        |          |110 = CNT equal to CMPU in channel 3.
N     * |        |          |111 = CNT equal to CMPD in channel 3.
N     * |[15]    |IFAEN2_3  |PWM Channel 2/3 Interrupt Flag Accumulator Enable Bit
N     * |        |          |0 = PWM Channel 2/3 interrupt flag accumulator disable.
N     * |        |          |1 = PWM Channel 2/3 interrupt flag accumulator enable.
N     * |[19:16] |IFCNT4_5  |PWM Channel 4/5 Interrupt Flag Counter
N     * |        |          |The register sets the count number which defines how many times of PWM Channel 4/5 period occurs to set IFAIF4_5 bit to request the PWM period interrupt.
N     * |        |          |PWM flag will be set in every IFCNT4_5[3:0] times of PWM period.
N     * |[22:20] |IFSEL4_5  |PWM Channel 4/5 Interrupt Flag Accumulator Source Select
N     * |        |          |000 = CNT equal to Zero in channel 4.
N     * |        |          |001 = CNT equal to PERIOD in channel 4.
N     * |        |          |010 = CNT equal to CMPU in channel 4.
N     * |        |          |011 = CNT equal to CMPD in channel 4.
N     * |        |          |100 = CNT equal to Zero in channel 5.
N     * |        |          |101 = CNT equal to PERIOD in channel 5.
N     * |        |          |110 = CNT equal to CMPU in channel 5.
N     * |        |          |111 = CNT equal to CMPD in channel 5.
N     * |[23]    |IFAEN4_5  |PWM Channel 4/5 Interrupt Flag Accumulator Enable Bit
N     * |        |          |0 = PWM Channel 4/5 interrupt flag accumulator disable.
N     * |        |          |1 = PWM Channel 4/5 interrupt flag accumulator enable.
N     * @var PWM_T::ADCTS0
N     * Offset: 0xF8  PWM Trigger ADC Source Select Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |TRGSEL0   |PWM_CH0 Trigger ADC Source Select
N     * |        |          |0000 = PWM_CH0 zero point.
N     * |        |          |0001 = PWM_CH0 period point.
N     * |        |          |0010 = PWM_CH0 zero or period point.
N     * |        |          |0011 = PWM_CH0 up-count compared point.
N     * |        |          |0100 = PWM_CH0 down-count compared point.
N     * |        |          |0101 = PWM_CH1 zero point.
N     * |        |          |0110 = PWM_CH1 period point.
N     * |        |          |0111 = PWM_CH1 zero or period point.
N     * |        |          |1000 = PWM_CH1 up-count compared point.
N     * |        |          |1001 = PWM_CH1 down-count compared point.
N     * |        |          |1010 = PWM_CH0 up-count free trigger compared point.
N     * |        |          |1011 = PWM_CH0 down-count free trigger compared point.
N     * |        |          |1100 = PWM_CH2 up-count free trigger compared point.
N     * |        |          |1101 = PWM_CH2 down-count free trigger compared point.
N     * |        |          |1110 = PWM_CH4 up-count free trigger compared point.
N     * |        |          |1111 = PWM_CH4 down-count free trigger compared point.
N     * |[7]     |TRGEN0    |PWM_CH0 Trigger ADC enable bit
N     * |[11:8]  |TRGSEL1   |PWM_CH1 Trigger ADC Source Select
N     * |        |          |0000 = PWM_CH0 zero point.
N     * |        |          |0001 = PWM_CH0 period point.
N     * |        |          |0010 = PWM_CH0 zero or period point.
N     * |        |          |0011 = PWM_CH0 up-count compared point.
N     * |        |          |0100 = PWM_CH0 down-count compared point.
N     * |        |          |0101 = PWM_CH1 zero point.
N     * |        |          |0110 = PWM_CH1 period point.
N     * |        |          |0111 = PWM_CH1 zero or period point.
N     * |        |          |1000 = PWM_CH1 up-count compared point.
N     * |        |          |1001 = PWM_CH1 down-count compared point.
N     * |        |          |1010 = PWM_CH0 up-count free trigger compared point.
N     * |        |          |1011 = PWM_CH0 down-count free trigger compared point.
N     * |        |          |1100 = PWM_CH2 up-count free trigger compared point.
N     * |        |          |1101 = PWM_CH2 down-count free trigger compared point.
N     * |        |          |1110 = PWM_CH4 up-count free trigger compared point.
N     * |        |          |1111 = PWM_CH4 down-count free trigger compared point.
N     * |[15]    |TRGEN1    |PWM_CH1 Trigger ADC enable bit
N     * |[19:16] |TRGSEL2   |PWM_CH2 Trigger ADC Source Select
N     * |        |          |0000 = PWM_CH2 zero point.
N     * |        |          |0001 = PWM_CH2 period point.
N     * |        |          |0010 = PWM_CH2 zero or period point.
N     * |        |          |0011 = PWM_CH2 up-count compared point.
N     * |        |          |0100 = PWM_CH2 down-count compared point.
N     * |        |          |0101 = PWM_CH3 zero point.
N     * |        |          |0110 = PWM_CH3 period point.
N     * |        |          |0111 = PWM_CH3 zero or period point.
N     * |        |          |1000 = PWM_CH3 up-count compared point.
N     * |        |          |1001 = PWM_CH3 down-count compared point.
N     * |        |          |1010 = PWM_CH0 up-count free trigger compared point.
N     * |        |          |1011 = PWM_CH0 down-count free trigger compared point.
N     * |        |          |1100 = PWM_CH2 up-count free trigger compared point.
N     * |        |          |1101 = PWM_CH2 down-count free trigger compared point.
N     * |        |          |1110 = PWM_CH4 up-count free trigger compared point.
N     * |        |          |1111 = PWM_CH4 down-count free trigger compared point.
N     * |[23]    |TRGEN2    |PWM_CH2 Trigger ADC enable bit
N     * |[27:24] |TRGSEL3   |PWM_CH3 Trigger ADC Source Select
N     * |        |          |0000 = PWM_CH2 zero point.
N     * |        |          |0001 = PWM_CH2 period point.
N     * |        |          |0010 = PWM_CH2 zero or period point.
N     * |        |          |0011 = PWM_CH2 up-count compared point.
N     * |        |          |0100 = PWM_CH2 down-count compared point.
N     * |        |          |0101 = PWM_CH3 zero point.
N     * |        |          |0110 = PWM_CH3 period point.
N     * |        |          |0111 = PWM_CH3 zero or period point.
N     * |        |          |1000 = PWM_CH3 up-count compared point.
N     * |        |          |1001 = PWM_CH3 down-count compared point.
N     * |        |          |1010 = PWM_CH0 up-count free trigger compared point.
N     * |        |          |1011 = PWM_CH0 down-count free trigger compared point.
N     * |        |          |1100 = PWM_CH2 up-count free trigger compared point.
N     * |        |          |1101 = PWM_CH2 down-count free trigger compared point.
N     * |        |          |1110 = PWM_CH4 up-count free trigger compared point.
N     * |        |          |1111 = PWM_CH4 down-count free trigger compared point.
N     * |[31]    |TRGEN3    |PWM_CH3 Trigger ADC enable bit
N     * @var PWM_T::ADCTS1
N     * Offset: 0xFC  PWM Trigger ADC Source Select Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |TRGSEL4   |PWM_CH4 Trigger ADC Source Select
N     * |        |          |0000 = PWM_CH4 zero point.
N     * |        |          |0001 = PWM_CH4 period point.
N     * |        |          |0010 = PWM_CH4 zero or period point.
N     * |        |          |0011 = PWM_CH4 up-count compared point.
N     * |        |          |0100 = PWM_CH4 down-count compared point.
N     * |        |          |0101 = PWM_CH5 zero point.
N     * |        |          |0110 = PWM_CH5 period point.
N     * |        |          |0111 = PWM_CH5 zero or period point.
N     * |        |          |1000 = PWM_CH5 up-count compared point.
N     * |        |          |1001 = PWM_CH5 down-count compared point.
N     * |        |          |1010 = PWM_CH0 up-count free trigger compared point.
N     * |        |          |1011 = PWM_CH0 down-count free trigger compared point.
N     * |        |          |1100 = PWM_CH2 up-count free trigger compared point.
N     * |        |          |1101 = PWM_CH2 down-count free trigger compared point.
N     * |        |          |1110 = PWM_CH4 up-count free trigger compared point.
N     * |        |          |1111 = PWM_CH4 down-count free trigger compared point.
N     * |[7]     |TRGEN4    |PWM_CH4 Trigger ADC enable bit
N     * |[11:8]  |TRGSEL5   |PWM_CH5 Trigger ADC Source Select
N     * |        |          |0000 = PWM_CH4 zero point.
N     * |        |          |0001 = PWM_CH4 period point.
N     * |        |          |0010 = PWM_CH4 zero or period point.
N     * |        |          |0011 = PWM_CH4 up-count compared point.
N     * |        |          |0100 = PWM_CH4 down-count compared point.
N     * |        |          |0101 = PWM_CH5 zero point.
N     * |        |          |0110 = PWM_CH5 period point.
N     * |        |          |0111 = PWM_CH5 zero or period point.
N     * |        |          |1000 = PWM_CH5 up-count compared point.
N     * |        |          |1001 = PWM_CH5 down-count compared point.
N     * |        |          |1010 = PWM_CH0 up-count free trigger compared point.
N     * |        |          |1011 = PWM_CH0 down-count free trigger compared point.
N     * |        |          |1100 = PWM_CH2 up-count free trigger compared point.
N     * |        |          |1101 = PWM_CH2 down-count free trigger compared point.
N     * |        |          |1110 = PWM_CH4 up-count free trigger compared point.
N     * |        |          |1111 = PWM_CH4 down-count free trigger compared point.
N     * |[15]    |TRGEN5    |PWM_CH5 Trigger ADC enable bit
N     * @var PWM_T::FTCMPDAT0_1
N     * Offset: 0x100  PWM Free Trigger Compare Register 0/1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FTCMP     |PWM Free Trigger Compare Register
N     * |        |          |FTCMP use to compare with even CNT(PWM_CNTm[15:0], m=0,2,4) to trigger ADC
N     * |        |          |FTCMPDAT0, 2, 4 corresponding complementary pairs PWMx_CH0 and PWMx_CH1, PWMx_CH2 and PWMx_CH3, PWMx_CH4 and PWMx_CH5.
N     * @var PWM_T::FTCMPDAT2_3
N     * Offset: 0x104  PWM Free Trigger Compare Register 2/3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FTCMP     |PWM Free Trigger Compare Register
N     * |        |          |FTCMP use to compare with even CNT(PWM_CNTm[15:0], m=0,2,4) to trigger ADC
N     * |        |          |FTCMPDAT0, 2, 4 corresponding complementary pairs PWMx_CH0 and PWMx_CH1, PWMx_CH2 and PWMx_CH3, PWMx_CH4 and PWMx_CH5.
N     * @var PWM_T::FTCMPDAT4_5
N     * Offset: 0x108  PWM Free Trigger Compare Register 4/5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FTCMP     |PWM Free Trigger Compare Register
N     * |        |          |FTCMP use to compare with even CNT(PWM_CNTm[15:0], m=0,2,4) to trigger ADC
N     * |        |          |FTCMPDAT0, 2, 4 corresponding complementary pairs PWMx_CH0 and PWMx_CH1, PWMx_CH2 and PWMx_CH3, PWMx_CH4 and PWMx_CH5.
N     * @var PWM_T::SSCTL
N     * Offset: 0x110  PWM Synchronous Start Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SSEN0     |PWM Synchronous Start Function Enable Bits
N     * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM synchronous start function Disabled.
N     * |        |          |1 = PWM synchronous start function Enabled.
N     * |[1]     |SSEN1     |PWM Synchronous Start Function Enable Bits
N     * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM synchronous start function Disabled.
N     * |        |          |1 = PWM synchronous start function Enabled.
N     * |[2]     |SSEN2     |PWM Synchronous Start Function Enable Bits
N     * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM synchronous start function Disabled.
N     * |        |          |1 = PWM synchronous start function Enabled.
N     * |[3]     |SSEN3     |PWM Synchronous Start Function Enable Bits
N     * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM synchronous start function Disabled.
N     * |        |          |1 = PWM synchronous start function Enabled.
N     * |[4]     |SSEN4     |PWM Synchronous Start Function Enable Bits
N     * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM synchronous start function Disabled.
N     * |        |          |1 = PWM synchronous start function Enabled.
N     * |[5]     |SSEN5     |PWM Synchronous Start Function Enable Bits
N     * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM synchronous start function Disabled.
N     * |        |          |1 = PWM synchronous start function Enabled.
N     * |[8]     |SSRC      |PWM Synchronous Start Source Select Bit
N     * |        |          |0 = Synchronous start source come from PWM0.
N     * |        |          |1 = Synchronous start source come from PWM1.
N     * @var PWM_T::SSTRG
N     * Offset: 0x114  PWM Synchronous Start Trigger Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CNTSEN    |PWM Counter Synchronous Start Enable (Write Only)
N     * |        |          |PMW counter synchronous enable function is used to make selected PWM channels (PWMx_CHn) start counting at the same time.
N     * |        |          |Writing this bit to 1 will also set the counter enable bit (CNTENn, n denotes channel 0 to 5) if correlated PWM channel counter synchronous start function is enabled.
N     * @var PWM_T::LEBCTL
N     * Offset: 0x118  PWM Leading Edge Blanking Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |LEBEN     |PWM Leading Edge Blanking Enable Bit
N     * |        |          |0 = PWM Leading Edge Blanking Disabled.
N     * |        |          |1 = PWM Leading Edge Blanking Enabled.
N     * |[8]     |SRCEN0    |PWM Leading Edge Blanking Source From PWMx_CH0 Enable Bit
N     * |        |          |0 = PWM Leading Edge Blanking Source from PWMx_CH0 Disabled.
N     * |        |          |1 = PWM Leading Edge Blanking Source from PWMx_CH0 Enabled.
N     * |[9]     |SRCEN2    |PWM Leading Edge Blanking Source From PWMx_CH2 Enable Bit
N     * |        |          |0 = PWM Leading Edge Blanking Source from PWMx_CH2 Disabled.
N     * |        |          |1 = PWM Leading Edge Blanking Source from PWMx_CH2 Enabled.
N     * |[10]    |SRCEN4    |PWM Leading Edge Blanking Source From PWMx_CH4 Enable Bit
N     * |        |          |0 = PWM Leading Edge Blanking Source from PWMx_CH4 Disabled.
N     * |        |          |1 = PWM Leading Edge Blanking Source from PWMx_CH4 Enabled.
N     * |[17:16] |TRGTYPE   |PWM Leading Edge Blanking Trigger Type
N     * |        |          |00 = When detect leading edge blanking source rising edge, blanking counter start counting.
N     * |        |          |01 = When detect leading edge blanking source falling edge, blanking counter start counting.
N     * |        |          |10 = When detect leading edge blanking source rising or falling edge, blanking counter start counting.
N     * |        |          |11 = Reserved.
N     * @var PWM_T::LEBCNT
N     * Offset: 0x11C  PWM Leading Edge Blanking Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8:0]   |LEBCNT    |PWM Leading Edge Blanking Counter
N     * |        |          |This counter value decides leading edge blanking window size.
N     * |        |          |Blanking window size = LEBCNT+1, and LEB counter clock base is ECLK.
N     * @var PWM_T::STATUS
N     * Offset: 0x120  PWM Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CNTMAXF0  |Time-base Counter Equal to 0xFFFF Latched Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = indicates the time-base counter(PWM_CNTn[15:0]) never reached its maximum value 0xFFFF.
N     * |        |          |1 = indicates the time-base counter(PWM_CNTn[15:0]) reached its maximum value, software can write 1 to clear this bit.
N     * |[1]     |CNTMAXF1  |Time-base Counter Equal to 0xFFFF Latched Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = indicates the time-base counter(PWM_CNTn[15:0]) never reached its maximum value 0xFFFF.
N     * |        |          |1 = indicates the time-base counter(PWM_CNTn[15:0]) reached its maximum value, software can write 1 to clear this bit.
N     * |[2]     |CNTMAXF2  |Time-base Counter Equal to 0xFFFF Latched Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = indicates the time-base counter(PWM_CNTn[15:0]) never reached its maximum value 0xFFFF.
N     * |        |          |1 = indicates the time-base counter(PWM_CNTn[15:0]) reached its maximum value, software can write 1 to clear this bit.
N     * |[3]     |CNTMAXF3  |Time-base Counter Equal to 0xFFFF Latched Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = indicates the time-base counter(PWM_CNTn[15:0]) never reached its maximum value 0xFFFF.
N     * |        |          |1 = indicates the time-base counter(PWM_CNTn[15:0]) reached its maximum value, software can write 1 to clear this bit.
N     * |[4]     |CNTMAXF4  |Time-base Counter Equal to 0xFFFF Latched Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = indicates the time-base counter(PWM_CNTn[15:0]) never reached its maximum value 0xFFFF.
N     * |        |          |1 = indicates the time-base counter(PWM_CNTn[15:0]) reached its maximum value, software can write 1 to clear this bit.
N     * |[5]     |CNTMAXF5  |Time-base Counter Equal to 0xFFFF Latched Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = indicates the time-base counter(PWM_CNTn[15:0]) never reached its maximum value 0xFFFF.
N     * |        |          |1 = indicates the time-base counter(PWM_CNTn[15:0]) reached its maximum value, software can write 1 to clear this bit.
N     * |[8]     |SYNCINF0  |Input Synchronization Latched Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Indicates no SYNC_IN event has occurred.
N     * |        |          |1 = Indicates an SYNC_IN event has occurred, software can write 1 to clear this bit.
N     * |[9]     |SYNCINF2  |Input Synchronization Latched Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Indicates no SYNC_IN event has occurred.
N     * |        |          |1 = Indicates an SYNC_IN event has occurred, software can write 1 to clear this bit.
N     * |[10]    |SYNCINF4  |Input Synchronization Latched Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Indicates no SYNC_IN event has occurred.
N     * |        |          |1 = Indicates an SYNC_IN event has occurred, software can write 1 to clear this bit.
N     * |[16]    |ADCTRGF0  |ADC Start of Conversion Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Indicates no ADC start of conversion trigger event has occurred.
N     * |        |          |1 = Indicates an ADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
N     * |[17]    |ADCTRGF1  |ADC Start of Conversion Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Indicates no ADC start of conversion trigger event has occurred.
N     * |        |          |1 = Indicates an ADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
N     * |[18]    |ADCTRGF2  |ADC Start of Conversion Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Indicates no ADC start of conversion trigger event has occurred.
N     * |        |          |1 = Indicates an ADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
N     * |[19]    |ADCTRGF3  |ADC Start of Conversion Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Indicates no ADC start of conversion trigger event has occurred.
N     * |        |          |1 = Indicates an ADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
N     * |[20]    |ADCTRGF4  |ADC Start of Conversion Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Indicates no ADC start of conversion trigger event has occurred.
N     * |        |          |1 = Indicates an ADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
N     * |[21]    |ADCTRGF5  |ADC Start of Conversion Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Indicates no ADC start of conversion trigger event has occurred.
N     * |        |          |1 = Indicates an ADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
N     * @var PWM_T::CAPINEN
N     * Offset: 0x200  PWM Capture Input Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CAPINEN0  |Capture Input Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM Channel capture input path Disabled.
N     * |        |          |The input of PWM channel capture function is always regarded as 0.
N     * |        |          |1 = PWM Channel capture input path Enabled.
N     * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
N     * |[1]     |CAPINEN1  |Capture Input Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM Channel capture input path Disabled.
N     * |        |          |The input of PWM channel capture function is always regarded as 0.
N     * |        |          |1 = PWM Channel capture input path Enabled.
N     * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
N     * |[2]     |CAPINEN2  |Capture Input Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM Channel capture input path Disabled.
N     * |        |          |The input of PWM channel capture function is always regarded as 0.
N     * |        |          |1 = PWM Channel capture input path Enabled.
N     * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
N     * |[3]     |CAPINEN3  |Capture Input Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM Channel capture input path Disabled.
N     * |        |          |The input of PWM channel capture function is always regarded as 0.
N     * |        |          |1 = PWM Channel capture input path Enabled.
N     * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
N     * |[4]     |CAPINEN4  |Capture Input Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM Channel capture input path Disabled.
N     * |        |          |The input of PWM channel capture function is always regarded as 0.
N     * |        |          |1 = PWM Channel capture input path Enabled.
N     * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
N     * |[5]     |CAPINEN5  |Capture Input Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM Channel capture input path Disabled.
N     * |        |          |The input of PWM channel capture function is always regarded as 0.
N     * |        |          |1 = PWM Channel capture input path Enabled.
N     * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
N     * @var PWM_T::CAPCTL
N     * Offset: 0x204  PWM Capture Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CAPEN0    |Capture Function Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT registers will not be updated.
N     * |        |          |1 = Capture function Enabled
N     * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch) registers.
N     * |[1]     |CAPEN1    |Capture Function Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT registers will not be updated.
N     * |        |          |1 = Capture function Enabled
N     * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch) registers.
N     * |[2]     |CAPEN2    |Capture Function Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT registers will not be updated.
N     * |        |          |1 = Capture function Enabled
N     * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch) registers.
N     * |[3]     |CAPEN3    |Capture Function Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT registers will not be updated.
N     * |        |          |1 = Capture function Enabled
N     * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch) registers.
N     * |[4]     |CAPEN4    |Capture Function Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT registers will not be updated.
N     * |        |          |1 = Capture function Enabled
N     * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch) registers.
N     * |[5]     |CAPEN5    |Capture Function Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT registers will not be updated.
N     * |        |          |1 = Capture function Enabled
N     * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch) registers.
N     * |[8]     |CAPINV0   |Capture Inverter Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture source inverter Disabled.
N     * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
N     * |[9]     |CAPINV1   |Capture Inverter Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture source inverter Disabled.
N     * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
N     * |[10]    |CAPINV2   |Capture Inverter Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture source inverter Disabled.
N     * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
N     * |[11]    |CAPINV3   |Capture Inverter Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture source inverter Disabled.
N     * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
N     * |[12]    |CAPINV4   |Capture Inverter Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture source inverter Disabled.
N     * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
N     * |[13]    |CAPINV5   |Capture Inverter Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture source inverter Disabled.
N     * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
N     * |[16]    |RCRLDEN0  |Rising Capture Reload Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Rising capture reload counter Disabled.
N     * |        |          |1 = Rising capture reload counter Enabled.
N     * |[17]    |RCRLDEN1  |Rising Capture Reload Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Rising capture reload counter Disabled.
N     * |        |          |1 = Rising capture reload counter Enabled.
N     * |[18]    |RCRLDEN2  |Rising Capture Reload Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Rising capture reload counter Disabled.
N     * |        |          |1 = Rising capture reload counter Enabled.
N     * |[19]    |RCRLDEN3  |Rising Capture Reload Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Rising capture reload counter Disabled.
N     * |        |          |1 = Rising capture reload counter Enabled.
N     * |[20]    |RCRLDEN4  |Rising Capture Reload Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Rising capture reload counter Disabled.
N     * |        |          |1 = Rising capture reload counter Enabled.
N     * |[21]    |RCRLDEN5  |Rising Capture Reload Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Rising capture reload counter Disabled.
N     * |        |          |1 = Rising capture reload counter Enabled.
N     * |[24]    |FCRLDEN0  |Falling Capture Reload Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Falling capture reload counter Disabled.
N     * |        |          |1 = Falling capture reload counter Enabled.
N     * |[25]    |FCRLDEN1  |Falling Capture Reload Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Falling capture reload counter Disabled.
N     * |        |          |1 = Falling capture reload counter Enabled.
N     * |[26]    |FCRLDEN2  |Falling Capture Reload Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Falling capture reload counter Disabled.
N     * |        |          |1 = Falling capture reload counter Enabled.
N     * |[27]    |FCRLDEN3  |Falling Capture Reload Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Falling capture reload counter Disabled.
N     * |        |          |1 = Falling capture reload counter Enabled.
N     * |[28]    |FCRLDEN4  |Falling Capture Reload Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Falling capture reload counter Disabled.
N     * |        |          |1 = Falling capture reload counter Enabled.
N     * |[29]    |FCRLDEN5  |Falling Capture Reload Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Falling capture reload counter Disabled.
N     * |        |          |1 = Falling capture reload counter Enabled.
N     * @var PWM_T::CAPSTS
N     * Offset: 0x208  PWM Capture Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CRLIFOV0  |Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
N     * |        |          |This flag indicates if rising latch happened when the corresponding CRLIFn(PWM_CAPIF[5:0]) bit is 1.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIFn bit.
N     * |[1]     |CRLIFOV1  |Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
N     * |        |          |This flag indicates if rising latch happened when the corresponding CRLIFn(PWM_CAPIF[5:0]) bit is 1.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIFn bit.
N     * |[2]     |CRLIFOV2  |Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
N     * |        |          |This flag indicates if rising latch happened when the corresponding CRLIFn(PWM_CAPIF[5:0]) bit is 1.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIFn bit.
N     * |[3]     |CRLIFOV3  |Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
N     * |        |          |This flag indicates if rising latch happened when the corresponding CRLIFn(PWM_CAPIF[5:0]) bit is 1.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIFn bit.
N     * |[4]     |CRLIFOV4  |Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
N     * |        |          |This flag indicates if rising latch happened when the corresponding CRLIFn(PWM_CAPIF[5:0]) bit is 1.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIFn bit.
N     * |[5]     |CRLIFOV5  |Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
N     * |        |          |This flag indicates if rising latch happened when the corresponding CRLIFn(PWM_CAPIF[5:0]) bit is 1.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIFn bit.
N     * |[8]     |CFLIFOV0  |Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
N     * |        |          |This flag indicates if falling latch happened when the corresponding CFLIFn(PWM_CAPIF[13:8]) bit is 1.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIFn bit.
N     * |[9]     |CFLIFOV1  |Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
N     * |        |          |This flag indicates if falling latch happened when the corresponding CFLIFn(PWM_CAPIF[13:8]) bit is 1.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIFn bit.
N     * |[10]    |CFLIFOV2  |Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
N     * |        |          |This flag indicates if falling latch happened when the corresponding CFLIFn(PWM_CAPIF[13:8]) bit is 1.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIFn bit.
N     * |[11]    |CFLIFOV3  |Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
N     * |        |          |This flag indicates if falling latch happened when the corresponding CFLIFn(PWM_CAPIF[13:8]) bit is 1.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIFn bit.
N     * |[12]    |CFLIFOV4  |Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
N     * |        |          |This flag indicates if falling latch happened when the corresponding CFLIFn(PWM_CAPIF[13:8]) bit is 1.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIFn bit.
N     * |[13]    |CFLIFOV5  |Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
N     * |        |          |This flag indicates if falling latch happened when the corresponding CFLIFn(PWM_CAPIF[13:8]) bit is 1.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIFn bit.
N     * @var PWM_T::RCAPDAT0
N     * Offset: 0x20C  PWM Rising Capture Data Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
N     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
N     * @var PWM_T::FCAPDAT0
N     * Offset: 0x210  PWM Falling Capture Data Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
N     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
N     * @var PWM_T::RCAPDAT1
N     * Offset: 0x214  PWM Rising Capture Data Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
N     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
N     * @var PWM_T::FCAPDAT1
N     * Offset: 0x218  PWM Falling Capture Data Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
N     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
N     * @var PWM_T::RCAPDAT2
N     * Offset: 0x21C  PWM Rising Capture Data Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
N     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
N     * @var PWM_T::FCAPDAT2
N     * Offset: 0x220  PWM Falling Capture Data Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
N     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
N     * @var PWM_T::RCAPDAT3
N     * Offset: 0x224  PWM Rising Capture Data Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
N     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
N     * @var PWM_T::FCAPDAT3
N     * Offset: 0x228  PWM Falling Capture Data Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
N     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
N     * @var PWM_T::RCAPDAT4
N     * Offset: 0x22C  PWM Rising Capture Data Register 4
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
N     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
N     * @var PWM_T::FCAPDAT4
N     * Offset: 0x230  PWM Falling Capture Data Register 4
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
N     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
N     * @var PWM_T::RCAPDAT5
N     * Offset: 0x234  PWM Rising Capture Data Register 5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
N     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
N     * @var PWM_T::FCAPDAT5
N     * Offset: 0x238  PWM Falling Capture Data Register 5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
N     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
N     * @var PWM_T::PDMACTL
N     * Offset: 0x23C  PWM PDMA Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CHEN0_1   |Channel 0/1 PDMA Enable
N     * |        |          |0 = Channel 0/1 PDMA function Disabled.
N     * |        |          |1 = Channel 0/1 PDMA function Enabled for the channel 0/1 captured data and transfer to memory.
N     * |[2:1]   |CAPMOD0_1 |Select PWM_RCAPDAT0/1 or PWM_FCAPDAT0/1 to Do PDMA Transfer
N     * |        |          |00 = Reserved.
N     * |        |          |01 = PWM_RCAPDAT0/1 register.
N     * |        |          |10 = PWM_FCAPDAT0/1 register.
N     * |        |          |11 = Both PWM_RCAPDAT0/1 and PWM_FCAPDAT0/1 registers.
N     * |[3]     |CAPORD0_1 |Capture Channel 0/1 Rising/Falling Order
N     * |        |          |Set this bit to determine whether the PWM_RCAPDAT0/1 or PWM_FCAPDAT0/1 register is the first captured data transferred to memory through PDMA when CAPMOD0_1 bits are set to = 0x3.
N     * |        |          |0 = PWM_FCAPDAT0/1 register is the first captured data to memory.
N     * |        |          |1 = PWM_RCAPDAT0/1 register is the first captured data to memory.
N     * |[4]     |CHSEL0_1  |Select Channel 0/1 to Do PDMA Transfer
N     * |        |          |0 = Channel0.
N     * |        |          |1 = Channel1.
N     * |[8]     |CHEN2_3   |Channel 2/3 PDMA Enable
N     * |        |          |0 = Channel 2/3 PDMA function Disabled.
N     * |        |          |1 = Channel 2/3 PDMA function Enabled for the channel 2/3 captured data and transfer to memory.
N     * |[10:9]  |CAPMOD2_3 |Select PWM_RCAPDAT2/3 or PWM_FCAODAT2/3 to Do PDMA Transfer
N     * |        |          |00 = Reserved.
N     * |        |          |01 = PWM_RCAPDAT2/3 register.
N     * |        |          |10 = PWM_FCAPDAT2/3 register.
N     * |        |          |11 = Both PWM_RCAPDAT2/3 and PWM_FCAPDAT2/3 registers.
N     * |[11]    |CAPORD2_3 |Capture Channel 2/3 Rising/Falling Order
N     * |        |          |Set this bit to determine whether the PWM_RCAPDAT2/3 or PWM_FCAPDAT2/3 register is the first captured data transferred to memory through PDMA when CAPMOD2_3 bits are set to =0x3.
N     * |        |          |0 = PWM_FCAPDAT2/3 register is the first captured data to memory.
N     * |        |          |1 = PWM_RCAPDAT2/3 register is the first captured data to memory.
N     * |[12]    |CHSEL2_3  |Select Channel 2/3 to Do PDMA Transfer
N     * |        |          |0 = Channel2.
N     * |        |          |1 = Channel3.
N     * |[16]    |CHEN4_5   |Channel 4/5 PDMA Enable
N     * |        |          |0 = Channel 4/5 PDMA function Disabled.
N     * |        |          |1 = Channel 4/5 PDMA function Enabled for the channel 4/5 captured data and transfer to memory.
N     * |[18:17] |CAPMOD4_5 |Select PWM_RCAPDAT4/5 or PWM_FCAPDAT4/5 to Do PDMA Transfer
N     * |        |          |00 = Reserved.
N     * |        |          |01 = PWM_RCAPDAT4/5 register.
N     * |        |          |10 = PWM_FCAPDAT4/5 register.
N     * |        |          |11 = Both PWM_RCAPDAT4/5 and PWM_FCAPDAT4/5 registers.
N     * |[19]    |CAPORD4_5 |Capture Channel 4/5 Rising/Falling Order
N     * |        |          |Set this bit to determine whether the PWM_RCAPDAT4/5 or PWM_FCAPDAT4/5 register is the first captured data transferred to memory through PDMA when CAPMOD4_5 bits =are set to 0x3.
N     * |        |          |0 = PWM_FCAPDAT4/5 register is the first captured data to memory.
N     * |        |          |1 = PWM_RCAPDAT4/5 register is the first captured data to memory.
N     * |[20]    |CHSEL4_5  |Select Channel 4/5 to Do PDMA Transfer
N     * |        |          |0 = Channel4.
N     * |        |          |1 = Channel5.
N     * @var PWM_T::PDMACAP0_1
N     * Offset: 0x240  PWM Capture Channel 0/1 PDMA Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CAPBUF    |PWM Capture PDMA Register (Read Only)
N     * |        |          |This register is use as a buffer to transfer PWM capture rising or falling data to memory by PDMA.
N     * @var PWM_T::PDMACAP2_3
N     * Offset: 0x244  PWM Capture Channel 2/3 PDMA Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CAPBUF    |PWM Capture PDMA Register (Read Only)
N     * |        |          |This register is use as a buffer to transfer PWM capture rising or falling data to memory by PDMA.
N     * @var PWM_T::PDMACAP4_5
N     * Offset: 0x248  PWM Capture Channel 4/5 PDMA Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CAPBUF    |PWM Capture PDMA Register (Read Only)
N     * |        |          |This register is use as a buffer to transfer PWM capture rising or falling data to memory by PDMA.
N     * @var PWM_T::CAPIEN
N     * Offset: 0x250  PWM Capture Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CAPRIEN0  |PWM Capture Rising Latch Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture rising edge latch interrupt Disabled.
N     * |        |          |1 = Capture rising edge latch interrupt Enabled.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPRIENn bit must be disabled.
N     * |[1]     |CAPRIEN1  |PWM Capture Rising Latch Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture rising edge latch interrupt Disabled.
N     * |        |          |1 = Capture rising edge latch interrupt Enabled.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPRIENn bit must be disabled.
N     * |[2]     |CAPRIEN2  |PWM Capture Rising Latch Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture rising edge latch interrupt Disabled.
N     * |        |          |1 = Capture rising edge latch interrupt Enabled.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPRIENn bit must be disabled.
N     * |[3]     |CAPRIEN3  |PWM Capture Rising Latch Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture rising edge latch interrupt Disabled.
N     * |        |          |1 = Capture rising edge latch interrupt Enabled.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPRIENn bit must be disabled.
N     * |[4]     |CAPRIEN4  |PWM Capture Rising Latch Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture rising edge latch interrupt Disabled.
N     * |        |          |1 = Capture rising edge latch interrupt Enabled.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPRIENn bit must be disabled.
N     * |[5]     |CAPRIEN5  |PWM Capture Rising Latch Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture rising edge latch interrupt Disabled.
N     * |        |          |1 = Capture rising edge latch interrupt Enabled.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPRIENn bit must be disabled.
N     * |[8]     |CAPFIEN0  |PWM Capture Falling Latch Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture falling edge latch interrupt Disabled.
N     * |        |          |1 = Capture falling edge latch interrupt Enabled.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPFIENn bit must be disabled.
N     * |[9]     |CAPFIEN1  |PWM Capture Falling Latch Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture falling edge latch interrupt Disabled.
N     * |        |          |1 = Capture falling edge latch interrupt Enabled.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPFIENn bit must be disabled.
N     * |[10]    |CAPFIEN2  |PWM Capture Falling Latch Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture falling edge latch interrupt Disabled.
N     * |        |          |1 = Capture falling edge latch interrupt Enabled.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPFIENn bit must be disabled.
N     * |[11]    |CAPFIEN3  |PWM Capture Falling Latch Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture falling edge latch interrupt Disabled.
N     * |        |          |1 = Capture falling edge latch interrupt Enabled.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPFIENn bit must be disabled.
N     * |[12]    |CAPFIEN4  |PWM Capture Falling Latch Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture falling edge latch interrupt Disabled.
N     * |        |          |1 = Capture falling edge latch interrupt Enabled.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPFIENn bit must be disabled.
N     * |[13]    |CAPFIEN5  |PWM Capture Falling Latch Interrupt Enable Bits
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture falling edge latch interrupt Disabled.
N     * |        |          |1 = Capture falling edge latch interrupt Enabled.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPFIENn bit must be disabled.
N     * @var PWM_T::CAPIF
N     * Offset: 0x254  PWM Capture Interrupt Flag Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CRLIF0    |PWM Capture Rising Latch Interrupt Flag
N     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No capture rising latch condition happened.
N     * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CRLIFn bit will cleared by hardware after PDMA transfer data.
N     * |[1]     |CRLIF1    |PWM Capture Rising Latch Interrupt Flag
N     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No capture rising latch condition happened.
N     * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CRLIFn bit will cleared by hardware after PDMA transfer data.
N     * |[2]     |CRLIF2    |PWM Capture Rising Latch Interrupt Flag
N     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No capture rising latch condition happened.
N     * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CRLIFn bit will cleared by hardware after PDMA transfer data.
N     * |[3]     |CRLIF3    |PWM Capture Rising Latch Interrupt Flag
N     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No capture rising latch condition happened.
N     * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CRLIFn bit will cleared by hardware after PDMA transfer data.
N     * |[4]     |CRLIF4    |PWM Capture Rising Latch Interrupt Flag
N     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No capture rising latch condition happened.
N     * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CRLIFn bit will cleared by hardware after PDMA transfer data.
N     * |[5]     |CRLIF5    |PWM Capture Rising Latch Interrupt Flag
N     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No capture rising latch condition happened.
N     * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CRLIFn bit will cleared by hardware after PDMA transfer data.
N     * |[8]     |CFLIF0    |PWM Capture Falling Latch Interrupt Flag
N     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No capture falling latch condition happened.
N     * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CFLIFn bit will cleared by hardware after PDMA transfer data.
N     * |[9]     |CFLIF1    |PWM Capture Falling Latch Interrupt Flag
N     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No capture falling latch condition happened.
N     * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CFLIFn bit will cleared by hardware after PDMA transfer data.
N     * |[10]    |CFLIF2    |PWM Capture Falling Latch Interrupt Flag
N     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No capture falling latch condition happened.
N     * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CFLIFn bit will cleared by hardware after PDMA transfer data.
N     * |[11]    |CFLIF3    |PWM Capture Falling Latch Interrupt Flag
N     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No capture falling latch condition happened.
N     * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CFLIFn bit will cleared by hardware after PDMA transfer data.
N     * |[12]    |CFLIF4    |PWM Capture Falling Latch Interrupt Flag
N     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No capture falling latch condition happened.
N     * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CFLIFn bit will cleared by hardware after PDMA transfer data.
N     * |[13]    |CFLIF5    |PWM Capture Falling Latch Interrupt Flag
N     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No capture falling latch condition happened.
N     * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
N     * |        |          |Note: When Capture with PDMA operating, corresponding channel CFLIFn bit will cleared by hardware after PDMA transfer data.
N     * @var PWM_T::PBUF
N     * Offset: 0x304/0x308/0x30C/0x310/0x314/0x318  PWM PERIOD0/PERIOD1/PERIOD2/PERIOD3/PERIOD4/PERIOD5 Buffer
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PBUF      |PWM Period Register Buffer (Read Only)
N     * |        |          |Used as PERIOD active register.
N     * @var PWM_T::CMPBUF
N     * Offset: 0x31C/0x320/0x324/0x328/0x32C/0x330  PWM CMPDAT0/CMPDAT1/CMPDAT2/CMPDAT3/CMPDAT4/CMPDAT5 Buffer
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMPBUF    |PWM Comparator Register Buffer (Read Only)
N     * |        |          |Used as CMPDAT active register.
N     * @var PWM_T::CPSCBUF0_1
N     * Offset: 0x334  PWM CLKPSC0_1 Buffer
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |CPSCBUF   |PWM Counter Clock Pre-scale Buffer
N     * |        |          |Use as PWM counter clock pre-scare active register.
N     * @var PWM_T::CPSCBUF2_3
N     * Offset: 0x338  PWM CLKPSC2_3 Buffer
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |CPSCBUF   |PWM Counter Clock Pre-scale Buffer
N     * |        |          |Use as PWM counter clock pre-scare active register.
N     * @var PWM_T::CPSCBUF4_5
N     * Offset: 0x33C  PWM CLKPSC4_5 Buffer
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |CPSCBUF   |PWM Counter Clock Pre-scale Buffer
N     * |        |          |Use as PWM counter clock pre-scare active register.
N     * @var PWM_T::FTCBUF0_1
N     * Offset: 0x340  PWM FTCMPDAT0_1 Buffer
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FTCMPBUF  |PWM FTCMPDAT Buffer (Read Only)
N     * |        |          |Used as FTCMPDAT active register.
N     * @var PWM_T::FTCBUF2_3
N     * Offset: 0x344  PWM FTCMPDAT2_3 Buffer
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FTCMPBUF  |PWM FTCMPDAT Buffer (Read Only)
N     * |        |          |Used as FTCMPDAT active register.
N     * @var PWM_T::FTCBUF4_5
N     * Offset: 0x348  PWM FTCMPDAT4_5 Buffer
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FTCMPBUF  |PWM FTCMPDAT Buffer (Read Only)
N     * |        |          |Used as FTCMPDAT active register.
N     * @var PWM_T::FTCI
N     * Offset: 0x34C  PWM FTCMPDAT Indicator Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |FTCMU0    |PWM FTCMPDAT Up Indicator
N     * |        |          |Indicator will be set to high when FTCMPDATn(PWM_CTCMPDATn[15:0]) bits equal to PERIOD(PWM_PERIODn[15:0]) bitsn and DIRF(PWM_CNTn[16])= bit is 1, software can write 1 to clear this bit.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |[1]     |FTCMU2    |PWM FTCMPDAT Up Indicator
N     * |        |          |Indicator will be set to high when FTCMPDATn(PWM_CTCMPDATn[15:0]) bits equal to PERIOD(PWM_PERIODn[15:0]) bitsn and DIRF(PWM_CNTn[16])= bit is 1, software can write 1 to clear this bit.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |[2]     |FTCMU4    |PWM FTCMPDAT Up Indicator
N     * |        |          |Indicator will be set to high when FTCMPDATn(PWM_CTCMPDATn[15:0]) bits equal to PERIOD(PWM_PERIODn[15:0]) bitsn and DIRF(PWM_CNTn[16])= bit is 1, software can write 1 to clear this bit.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |[8]     |FTCMD0    |PWM FTCMPDAT Down Indicator
N     * |        |          |Indicator will be set to high when FTCMPDATn(PWM_FTCMPDATn[15:0]) bits equal to PERIODn(PWM_PERIODn[15:0]) bits and DIRF(PWM_CNTn[16]) bit= is 0, software can write 1 to clear this bit.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |[9]     |FTCMD2    |PWM FTCMPDAT Down Indicator
N     * |        |          |Indicator will be set to high when FTCMPDATn(PWM_FTCMPDATn[15:0]) bits equal to PERIODn(PWM_PERIODn[15:0]) bits and DIRF(PWM_CNTn[16]) bit= is 0, software can write 1 to clear this bit.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |[10]    |FTCMD4    |PWM FTCMPDAT Down Indicator
N     * |        |          |Indicator will be set to high when FTCMPDATn(PWM_FTCMPDATn[15:0]) bits equal to PERIODn(PWM_PERIODn[15:0]) bits and DIRF(PWM_CNTn[16]) bit= is 0, software can write 1 to clear this bit.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     */
N
N    __IO uint32_t CTL0;                  /*!< [0x0000] PWM Control Register 0                                           */
X    volatile uint32_t CTL0;                   
N    __IO uint32_t CTL1;                  /*!< [0x0004] PWM Control Register 1                                           */
X    volatile uint32_t CTL1;                   
N    __IO uint32_t SYNC;                  /*!< [0x0008] PWM Synchronization Register                                     */
X    volatile uint32_t SYNC;                   
N    __IO uint32_t SWSYNC;                /*!< [0x000c] PWM Software Control Synchronization Register                    */
X    volatile uint32_t SWSYNC;                 
N    __IO uint32_t CLKSRC;                /*!< [0x0010] PWM Clock Source Register                                        */
X    volatile uint32_t CLKSRC;                 
N    __IO uint32_t CLKPSC0_1;             /*!< [0x0014] PWM Clock Pre-scale Register 0/1                                 */
X    volatile uint32_t CLKPSC0_1;              
N    __IO uint32_t CLKPSC2_3;             /*!< [0x0018] PWM Clock Pre-scale Register 2/3                                 */
X    volatile uint32_t CLKPSC2_3;              
N    __IO uint32_t CLKPSC4_5;             /*!< [0x001c] PWM Clock Pre-scale Register 4/5                                 */
X    volatile uint32_t CLKPSC4_5;              
N    __IO uint32_t CNTEN;                 /*!< [0x0020] PWM Counter Enable Register                                      */
X    volatile uint32_t CNTEN;                  
N    __IO uint32_t CNTCLR;                /*!< [0x0024] PWM Clear Counter Register                                       */
X    volatile uint32_t CNTCLR;                 
N    __IO uint32_t LOAD;                  /*!< [0x0028] PWM Load Register                                                */
X    volatile uint32_t LOAD;                   
N    __I  uint32_t RESERVE0[1];
X    volatile const  uint32_t RESERVE0[1];
N    __IO uint32_t PERIOD[6];             /*!< [0x0030~0x0044]  PWM Period Register 0~5                                  */
X    volatile uint32_t PERIOD[6];              
N    __I  uint32_t RESERVE1[2];
X    volatile const  uint32_t RESERVE1[2];
N    __IO uint32_t CMPDAT[6];             /*!< [0x0050~0x0064]  PWM Comparator Register 0~5                              */
X    volatile uint32_t CMPDAT[6];              
N    __I  uint32_t RESERVE2[2];
X    volatile const  uint32_t RESERVE2[2];
N    __IO uint32_t DTCTL0_1;              /*!< [0x0070] PWM Dead-Time Control Register 0/1                               */
X    volatile uint32_t DTCTL0_1;               
N    __IO uint32_t DTCTL2_3;              /*!< [0x0074] PWM Dead-Time Control Register 2/3                               */
X    volatile uint32_t DTCTL2_3;               
N    __IO uint32_t DTCTL4_5;              /*!< [0x0078] PWM Dead-Time Control Register 4/5                               */
X    volatile uint32_t DTCTL4_5;               
N    __I  uint32_t RESERVE3[1];
X    volatile const  uint32_t RESERVE3[1];
N    __IO uint32_t PHS0_1;                /*!< [0x0080] PWM Counter Phase Register 0/1                                   */
X    volatile uint32_t PHS0_1;                 
N    __IO uint32_t PHS2_3;                /*!< [0x0084] PWM Counter Phase Register 2/3                                   */
X    volatile uint32_t PHS2_3;                 
N    __IO uint32_t PHS4_5;                /*!< [0x0088] PWM Counter Phase Register 4/5                                   */
X    volatile uint32_t PHS4_5;                 
N    __I  uint32_t RESERVE4[1];
X    volatile const  uint32_t RESERVE4[1];
N    __I  uint32_t CNT[6];                /*!< [0x0090~0x00A4  PWM Counter Register 0~5                                  */
X    volatile const  uint32_t CNT[6];                 
N    __I  uint32_t RESERVE5[2];
X    volatile const  uint32_t RESERVE5[2];
N    __IO uint32_t WGCTL0;                /*!< [0x00b0] PWM Generation Register 0                                        */
X    volatile uint32_t WGCTL0;                 
N    __IO uint32_t WGCTL1;                /*!< [0x00b4] PWM Generation Register 1                                        */
X    volatile uint32_t WGCTL1;                 
N    __IO uint32_t MSKEN;                 /*!< [0x00b8] PWM Mask Enable Register                                         */
X    volatile uint32_t MSKEN;                  
N    __IO uint32_t MSK;                   /*!< [0x00bc] PWM Mask Data Register                                           */
X    volatile uint32_t MSK;                    
N    __IO uint32_t BNF;                   /*!< [0x00c0] PWM Brake Noise Filter Register                                  */
X    volatile uint32_t BNF;                    
N    __IO uint32_t FAILBRK;               /*!< [0x00c4] PWM System Fail Brake Control Register                           */
X    volatile uint32_t FAILBRK;                
N    __IO uint32_t BRKCTL0_1;             /*!< [0x00c8] PWM Brake Edge Detect Control Register 0/1                       */
X    volatile uint32_t BRKCTL0_1;              
N    __IO uint32_t BRKCTL2_3;             /*!< [0x00cc] PWM Brake Edge Detect Control Register 2/3                       */
X    volatile uint32_t BRKCTL2_3;              
N    __IO uint32_t BRKCTL4_5;             /*!< [0x00d0] PWM Brake Edge Detect Control Register 4/5                       */
X    volatile uint32_t BRKCTL4_5;              
N    __IO uint32_t POLCTL;                /*!< [0x00d4] PWM Pin Polar Inverse Register                                   */
X    volatile uint32_t POLCTL;                 
N    __IO uint32_t POEN;                  /*!< [0x00d8] PWM Output Enable Register                                       */
X    volatile uint32_t POEN;                   
N    __O  uint32_t SWBRK;                 /*!< [0x00dc] PWM Software Brake Control Register                              */
X    volatile  uint32_t SWBRK;                  
N    __IO uint32_t INTEN0;                /*!< [0x00e0] PWM Interrupt Enable Register 0                                  */
X    volatile uint32_t INTEN0;                 
N    __IO uint32_t INTEN1;                /*!< [0x00e4] PWM Interrupt Enable Register 1                                  */
X    volatile uint32_t INTEN1;                 
N    __IO uint32_t INTSTS0;               /*!< [0x00e8] PWM Interrupt Flag Register 0                                    */
X    volatile uint32_t INTSTS0;                
N    __IO uint32_t INTSTS1;               /*!< [0x00ec] PWM Interrupt Flag Register 1                                    */
X    volatile uint32_t INTSTS1;                
N    __IO uint32_t IFA;                   /*!< [0x00f0] PWM Interrupt Flag Accumulator Register                          */
X    volatile uint32_t IFA;                    
N    __I  uint32_t RESERVE6[1];
X    volatile const  uint32_t RESERVE6[1];
N    __IO uint32_t ADCTS0;                /*!< [0x00f8] PWM Trigger ADC Source Select Register 0                         */
X    volatile uint32_t ADCTS0;                 
N    __IO uint32_t ADCTS1;                /*!< [0x00fc] PWM Trigger ADC Source Select Register 1                         */
X    volatile uint32_t ADCTS1;                 
N    __IO uint32_t FTCMPDAT0_1;           /*!< [0x0100] PWM Free Trigger Compare Register 0/1                            */
X    volatile uint32_t FTCMPDAT0_1;            
N    __IO uint32_t FTCMPDAT2_3;           /*!< [0x0104] PWM Free Trigger Compare Register 2/3                            */
X    volatile uint32_t FTCMPDAT2_3;            
N    __IO uint32_t FTCMPDAT4_5;           /*!< [0x0108] PWM Free Trigger Compare Register 4/5                            */
X    volatile uint32_t FTCMPDAT4_5;            
N    __I  uint32_t RESERVE7[1];
X    volatile const  uint32_t RESERVE7[1];
N    __IO uint32_t SSCTL;                 /*!< [0x0110] PWM Synchronous Start Control Register                           */
X    volatile uint32_t SSCTL;                  
N    __O  uint32_t SSTRG;                 /*!< [0x0114] PWM Synchronous Start Trigger Register                           */
X    volatile  uint32_t SSTRG;                  
N    __IO uint32_t LEBCTL;                /*!< [0x0118] PWM Leading Edge Blanking Control Register                       */
X    volatile uint32_t LEBCTL;                 
N    __IO uint32_t LEBCNT;                /*!< [0x011c] PWM Leading Edge Blanking Counter Register                       */
X    volatile uint32_t LEBCNT;                 
N    __IO uint32_t STATUS;                /*!< [0x0120] PWM Status Register                                              */
X    volatile uint32_t STATUS;                 
N    __I  uint32_t RESERVE8[55];
X    volatile const  uint32_t RESERVE8[55];
N    __IO uint32_t CAPINEN;               /*!< [0x0200] PWM Capture Input Enable Register                                */
X    volatile uint32_t CAPINEN;                
N    __IO uint32_t CAPCTL;                /*!< [0x0204] PWM Capture Control Register                                     */
X    volatile uint32_t CAPCTL;                 
N    __I  uint32_t CAPSTS;                /*!< [0x0208] PWM Capture Status Register                                      */
X    volatile const  uint32_t CAPSTS;                 
N    __I  uint32_t RCAPDAT0;              /*!< [0x020c] PWM Rising Capture Data Register 0                               */
X    volatile const  uint32_t RCAPDAT0;               
N    __I  uint32_t FCAPDAT0;              /*!< [0x0210] PWM Falling Capture Data Register 0                              */
X    volatile const  uint32_t FCAPDAT0;               
N    __I  uint32_t RCAPDAT1;              /*!< [0x0214] PWM Rising Capture Data Register 1                               */
X    volatile const  uint32_t RCAPDAT1;               
N    __I  uint32_t FCAPDAT1;              /*!< [0x0218] PWM Falling Capture Data Register 1                              */
X    volatile const  uint32_t FCAPDAT1;               
N    __I  uint32_t RCAPDAT2;              /*!< [0x021c] PWM Rising Capture Data Register 2                               */
X    volatile const  uint32_t RCAPDAT2;               
N    __I  uint32_t FCAPDAT2;              /*!< [0x0220] PWM Falling Capture Data Register 2                              */
X    volatile const  uint32_t FCAPDAT2;               
N    __I  uint32_t RCAPDAT3;              /*!< [0x0224] PWM Rising Capture Data Register 3                               */
X    volatile const  uint32_t RCAPDAT3;               
N    __I  uint32_t FCAPDAT3;              /*!< [0x0228] PWM Falling Capture Data Register 3                              */
X    volatile const  uint32_t FCAPDAT3;               
N    __I  uint32_t RCAPDAT4;              /*!< [0x022c] PWM Rising Capture Data Register 4                               */
X    volatile const  uint32_t RCAPDAT4;               
N    __I  uint32_t FCAPDAT4;              /*!< [0x0230] PWM Falling Capture Data Register 4                              */
X    volatile const  uint32_t FCAPDAT4;               
N    __I  uint32_t RCAPDAT5;              /*!< [0x0234] PWM Rising Capture Data Register 5                               */
X    volatile const  uint32_t RCAPDAT5;               
N    __I  uint32_t FCAPDAT5;              /*!< [0x0238] PWM Falling Capture Data Register 5                              */
X    volatile const  uint32_t FCAPDAT5;               
N    __IO uint32_t PDMACTL;               /*!< [0x023c] PWM PDMA Control Register                                        */
X    volatile uint32_t PDMACTL;                
N    __I  uint32_t PDMACAP0_1;            /*!< [0x0240] PWM Capture Channel 0/1 PDMA Register                            */
X    volatile const  uint32_t PDMACAP0_1;             
N    __I  uint32_t PDMACAP2_3;            /*!< [0x0244] PWM Capture Channel 2/3 PDMA Register                            */
X    volatile const  uint32_t PDMACAP2_3;             
N    __I  uint32_t PDMACAP4_5;            /*!< [0x0248] PWM Capture Channel 4/5 PDMA Register                            */
X    volatile const  uint32_t PDMACAP4_5;             
N    __I  uint32_t RESERVE9[1];
X    volatile const  uint32_t RESERVE9[1];
N    __IO uint32_t CAPIEN;                /*!< [0x0250] PWM Capture Interrupt Enable Register                            */
X    volatile uint32_t CAPIEN;                 
N    __IO uint32_t CAPIF;                 /*!< [0x0254] PWM Capture Interrupt Flag Register                              */
X    volatile uint32_t CAPIF;                  
N    __I  uint32_t RESERVE10[43];
X    volatile const  uint32_t RESERVE10[43];
N    __I  uint32_t PBUF[6];               /*!< [0x0304~0x0318  PWM PERIOD0~5 Buffer                                      */
X    volatile const  uint32_t PBUF[6];                
N    __I  uint32_t CMPBUF[6];             /*!< [0x031C~0x0330  PWM CMPDAT0~5 Buffer                                      */
X    volatile const  uint32_t CMPBUF[6];              
N    __I  uint32_t CPSCBUF0_1;            /*!< [0x0334] PWM CLKPSC0_1 Buffer                                             */
X    volatile const  uint32_t CPSCBUF0_1;             
N    __I  uint32_t CPSCBUF2_3;            /*!< [0x0338] PWM CLKPSC2_3 Buffer                                             */
X    volatile const  uint32_t CPSCBUF2_3;             
N    __I  uint32_t CPSCBUF4_5;            /*!< [0x033c] PWM CLKPSC4_5 Buffer                                             */
X    volatile const  uint32_t CPSCBUF4_5;             
N    __I  uint32_t FTCBUF0_1;             /*!< [0x0340] PWM FTCMPDAT0_1 Buffer                                           */
X    volatile const  uint32_t FTCBUF0_1;              
N    __I  uint32_t FTCBUF2_3;             /*!< [0x0344] PWM FTCMPDAT2_3 Buffer                                           */
X    volatile const  uint32_t FTCBUF2_3;              
N    __I  uint32_t FTCBUF4_5;             /*!< [0x0348] PWM FTCMPDAT4_5 Buffer                                           */
X    volatile const  uint32_t FTCBUF4_5;              
N    __IO uint32_t FTCI;                  /*!< [0x034c] PWM FTCMPDAT Indicator Register                                  */
X    volatile uint32_t FTCI;                   
N
N
N} PWM_T;
N
N/**
N    @addtogroup PWM_CONST PWM Bit Field Definition
N    Constant Definitions for PWM Controller
N@{ */
N
N#define PWM_CTL0_CTRLD0_Pos              (0)                                               /*!< PWM_T::CTL0: CTRLD0 Position           */
N#define PWM_CTL0_CTRLD0_Msk              (0x1ul << PWM_CTL0_CTRLD0_Pos)                    /*!< PWM_T::CTL0: CTRLD0 Mask               */
N
N#define PWM_CTL0_CTRLD1_Pos              (1)                                               /*!< PWM_T::CTL0: CTRLD1 Position           */
N#define PWM_CTL0_CTRLD1_Msk              (0x1ul << PWM_CTL0_CTRLD1_Pos)                    /*!< PWM_T::CTL0: CTRLD1 Mask               */
N
N#define PWM_CTL0_CTRLD2_Pos              (2)                                               /*!< PWM_T::CTL0: CTRLD2 Position           */
N#define PWM_CTL0_CTRLD2_Msk              (0x1ul << PWM_CTL0_CTRLD2_Pos)                    /*!< PWM_T::CTL0: CTRLD2 Mask               */
N
N#define PWM_CTL0_CTRLD3_Pos              (3)                                               /*!< PWM_T::CTL0: CTRLD3 Position           */
N#define PWM_CTL0_CTRLD3_Msk              (0x1ul << PWM_CTL0_CTRLD3_Pos)                    /*!< PWM_T::CTL0: CTRLD3 Mask               */
N
N#define PWM_CTL0_CTRLD4_Pos              (4)                                               /*!< PWM_T::CTL0: CTRLD4 Position           */
N#define PWM_CTL0_CTRLD4_Msk              (0x1ul << PWM_CTL0_CTRLD4_Pos)                    /*!< PWM_T::CTL0: CTRLD4 Mask               */
N
N#define PWM_CTL0_CTRLD5_Pos              (5)                                               /*!< PWM_T::CTL0: CTRLD5 Position           */
N#define PWM_CTL0_CTRLD5_Msk              (0x1ul << PWM_CTL0_CTRLD5_Pos)                    /*!< PWM_T::CTL0: CTRLD5 Mask               */
N
N#define PWM_CTL0_WINLDEN0_Pos            (8)                                               /*!< PWM_T::CTL0: WINLDEN0 Position         */
N#define PWM_CTL0_WINLDEN0_Msk            (0x1ul << PWM_CTL0_WINLDEN0_Pos)                  /*!< PWM_T::CTL0: WINLDEN0 Mask             */
N
N#define PWM_CTL0_WINLDEN1_Pos            (9)                                               /*!< PWM_T::CTL0: WINLDEN1 Position         */
N#define PWM_CTL0_WINLDEN1_Msk            (0x1ul << PWM_CTL0_WINLDEN1_Pos)                  /*!< PWM_T::CTL0: WINLDEN1 Mask             */
N
N#define PWM_CTL0_WINLDEN2_Pos            (10)                                              /*!< PWM_T::CTL0: WINLDEN2 Position         */
N#define PWM_CTL0_WINLDEN2_Msk            (0x1ul << PWM_CTL0_WINLDEN2_Pos)                  /*!< PWM_T::CTL0: WINLDEN2 Mask             */
N
N#define PWM_CTL0_WINLDEN3_Pos            (11)                                              /*!< PWM_T::CTL0: WINLDEN3 Position         */
N#define PWM_CTL0_WINLDEN3_Msk            (0x1ul << PWM_CTL0_WINLDEN3_Pos)                  /*!< PWM_T::CTL0: WINLDEN3 Mask             */
N
N#define PWM_CTL0_WINLDEN4_Pos            (12)                                              /*!< PWM_T::CTL0: WINLDEN4 Position         */
N#define PWM_CTL0_WINLDEN4_Msk            (0x1ul << PWM_CTL0_WINLDEN4_Pos)                  /*!< PWM_T::CTL0: WINLDEN4 Mask             */
N
N#define PWM_CTL0_WINLDEN5_Pos            (13)                                              /*!< PWM_T::CTL0: WINLDEN5 Position         */
N#define PWM_CTL0_WINLDEN5_Msk            (0x1ul << PWM_CTL0_WINLDEN5_Pos)                  /*!< PWM_T::CTL0: WINLDEN5 Mask             */
N
N#define PWM_CTL0_IMMLDEN0_Pos            (16)                                              /*!< PWM_T::CTL0: IMMLDEN0 Position         */
N#define PWM_CTL0_IMMLDEN0_Msk            (0x1ul << PWM_CTL0_IMMLDEN0_Pos)                  /*!< PWM_T::CTL0: IMMLDEN0 Mask             */
N
N#define PWM_CTL0_IMMLDEN1_Pos            (17)                                              /*!< PWM_T::CTL0: IMMLDEN1 Position         */
N#define PWM_CTL0_IMMLDEN1_Msk            (0x1ul << PWM_CTL0_IMMLDEN1_Pos)                  /*!< PWM_T::CTL0: IMMLDEN1 Mask             */
N
N#define PWM_CTL0_IMMLDEN2_Pos            (18)                                              /*!< PWM_T::CTL0: IMMLDEN2 Position         */
N#define PWM_CTL0_IMMLDEN2_Msk            (0x1ul << PWM_CTL0_IMMLDEN2_Pos)                  /*!< PWM_T::CTL0: IMMLDEN2 Mask             */
N
N#define PWM_CTL0_IMMLDEN3_Pos            (19)                                              /*!< PWM_T::CTL0: IMMLDEN3 Position         */
N#define PWM_CTL0_IMMLDEN3_Msk            (0x1ul << PWM_CTL0_IMMLDEN3_Pos)                  /*!< PWM_T::CTL0: IMMLDEN3 Mask             */
N
N#define PWM_CTL0_IMMLDEN4_Pos            (20)                                              /*!< PWM_T::CTL0: IMMLDEN4 Position         */
N#define PWM_CTL0_IMMLDEN4_Msk            (0x1ul << PWM_CTL0_IMMLDEN4_Pos)                  /*!< PWM_T::CTL0: IMMLDEN4 Mask             */
N
N#define PWM_CTL0_IMMLDEN5_Pos            (21)                                              /*!< PWM_T::CTL0: IMMLDEN5 Position         */
N#define PWM_CTL0_IMMLDEN5_Msk            (0x1ul << PWM_CTL0_IMMLDEN5_Pos)                  /*!< PWM_T::CTL0: IMMLDEN5 Mask             */
N
N#define PWM_CTL0_GROUPEN_Pos             (24)                                              /*!< PWM_T::CTL0: GROUPEN Position          */
N#define PWM_CTL0_GROUPEN_Msk             (0x1ul << PWM_CTL0_GROUPEN_Pos)                   /*!< PWM_T::CTL0: GROUPEN Mask              */
N
N#define PWM_CTL0_DBGHALT_Pos             (30)                                              /*!< PWM_T::CTL0: DBGHALT Position          */
N#define PWM_CTL0_DBGHALT_Msk             (0x1ul << PWM_CTL0_DBGHALT_Pos)                   /*!< PWM_T::CTL0: DBGHALT Mask              */
N
N#define PWM_CTL0_DBGTRIOFF_Pos           (31)                                              /*!< PWM_T::CTL0: DBGTRIOFF Position        */
N#define PWM_CTL0_DBGTRIOFF_Msk           (0x1ul << PWM_CTL0_DBGTRIOFF_Pos)                 /*!< PWM_T::CTL0: DBGTRIOFF Mask            */
N
N#define PWM_CTL1_CNTTYPE0_Pos            (0)                                               /*!< PWM_T::CTL1: CNTTYPE0 Position         */
N#define PWM_CTL1_CNTTYPE0_Msk            (0x3ul << PWM_CTL1_CNTTYPE0_Pos)                  /*!< PWM_T::CTL1: CNTTYPE0 Mask             */
N
N#define PWM_CTL1_CNTTYPE1_Pos            (2)                                               /*!< PWM_T::CTL1: CNTTYPE1 Position         */
N#define PWM_CTL1_CNTTYPE1_Msk            (0x3ul << PWM_CTL1_CNTTYPE1_Pos)                  /*!< PWM_T::CTL1: CNTTYPE1 Mask             */
N
N#define PWM_CTL1_CNTTYPE2_Pos            (4)                                               /*!< PWM_T::CTL1: CNTTYPE2 Position         */
N#define PWM_CTL1_CNTTYPE2_Msk            (0x3ul << PWM_CTL1_CNTTYPE2_Pos)                  /*!< PWM_T::CTL1: CNTTYPE2 Mask             */
N
N#define PWM_CTL1_CNTTYPE3_Pos            (6)                                               /*!< PWM_T::CTL1: CNTTYPE3 Position         */
N#define PWM_CTL1_CNTTYPE3_Msk            (0x3ul << PWM_CTL1_CNTTYPE3_Pos)                  /*!< PWM_T::CTL1: CNTTYPE3 Mask             */
N
N#define PWM_CTL1_CNTTYPE4_Pos            (8)                                               /*!< PWM_T::CTL1: CNTTYPE4 Position         */
N#define PWM_CTL1_CNTTYPE4_Msk            (0x3ul << PWM_CTL1_CNTTYPE4_Pos)                  /*!< PWM_T::CTL1: CNTTYPE4 Mask             */
N
N#define PWM_CTL1_CNTTYPE5_Pos            (10)                                              /*!< PWM_T::CTL1: CNTTYPE5 Position         */
N#define PWM_CTL1_CNTTYPE5_Msk            (0x3ul << PWM_CTL1_CNTTYPE5_Pos)                  /*!< PWM_T::CTL1: CNTTYPE5 Mask             */
N
N#define PWM_CTL1_CNTMODE0_Pos            (16)                                              /*!< PWM_T::CTL1: CNTMODE0 Position         */
N#define PWM_CTL1_CNTMODE0_Msk            (0x1ul << PWM_CTL1_CNTMODE0_Pos)                  /*!< PWM_T::CTL1: CNTMODE0 Mask             */
N
N#define PWM_CTL1_CNTMODE1_Pos            (17)                                              /*!< PWM_T::CTL1: CNTMODE1 Position         */
N#define PWM_CTL1_CNTMODE1_Msk            (0x1ul << PWM_CTL1_CNTMODE1_Pos)                  /*!< PWM_T::CTL1: CNTMODE1 Mask             */
N
N#define PWM_CTL1_CNTMODE2_Pos            (18)                                              /*!< PWM_T::CTL1: CNTMODE2 Position         */
N#define PWM_CTL1_CNTMODE2_Msk            (0x1ul << PWM_CTL1_CNTMODE2_Pos)                  /*!< PWM_T::CTL1: CNTMODE2 Mask             */
N
N#define PWM_CTL1_CNTMODE3_Pos            (19)                                              /*!< PWM_T::CTL1: CNTMODE3 Position         */
N#define PWM_CTL1_CNTMODE3_Msk            (0x1ul << PWM_CTL1_CNTMODE3_Pos)                  /*!< PWM_T::CTL1: CNTMODE3 Mask             */
N
N#define PWM_CTL1_CNTMODE4_Pos            (20)                                              /*!< PWM_T::CTL1: CNTMODE4 Position         */
N#define PWM_CTL1_CNTMODE4_Msk            (0x1ul << PWM_CTL1_CNTMODE4_Pos)                  /*!< PWM_T::CTL1: CNTMODE4 Mask             */
N
N#define PWM_CTL1_CNTMODE5_Pos            (21)                                              /*!< PWM_T::CTL1: CNTMODE5 Position         */
N#define PWM_CTL1_CNTMODE5_Msk            (0x1ul << PWM_CTL1_CNTMODE5_Pos)                  /*!< PWM_T::CTL1: CNTMODE5 Mask             */
N
N#define PWM_CTL1_OUTMODE0_Pos            (24)                                              /*!< PWM_T::CTL1: OUTMODE0 Position         */
N#define PWM_CTL1_OUTMODE0_Msk            (0x1ul << PWM_CTL1_OUTMODE0_Pos)                  /*!< PWM_T::CTL1: OUTMODE0 Mask             */
N
N#define PWM_CTL1_OUTMODE2_Pos            (25)                                              /*!< PWM_T::CTL1: OUTMODE2 Position         */
N#define PWM_CTL1_OUTMODE2_Msk            (0x1ul << PWM_CTL1_OUTMODE2_Pos)                  /*!< PWM_T::CTL1: OUTMODE2 Mask             */
N
N#define PWM_CTL1_OUTMODE4_Pos            (26)                                              /*!< PWM_T::CTL1: OUTMODE4 Position         */
N#define PWM_CTL1_OUTMODE4_Msk            (0x1ul << PWM_CTL1_OUTMODE4_Pos)                  /*!< PWM_T::CTL1: OUTMODE4 Mask             */
N
N#define PWM_SYNC_PHSEN0_Pos              (0)                                               /*!< PWM_T::SYNC: PHSEN0 Position           */
N#define PWM_SYNC_PHSEN0_Msk              (0x1ul << PWM_SYNC_PHSEN0_Pos)                    /*!< PWM_T::SYNC: PHSEN0 Mask               */
N
N#define PWM_SYNC_PHSEN2_Pos              (1)                                               /*!< PWM_T::SYNC: PHSEN2 Position           */
N#define PWM_SYNC_PHSEN2_Msk              (0x1ul << PWM_SYNC_PHSEN2_Pos)                    /*!< PWM_T::SYNC: PHSEN2 Mask               */
N
N#define PWM_SYNC_PHSEN4_Pos              (2)                                               /*!< PWM_T::SYNC: PHSEN4 Position           */
N#define PWM_SYNC_PHSEN4_Msk              (0x1ul << PWM_SYNC_PHSEN4_Pos)                    /*!< PWM_T::SYNC: PHSEN4 Mask               */
N
N#define PWM_SYNC_SINSRC0_Pos             (8)                                               /*!< PWM_T::SYNC: SINSRC0 Position          */
N#define PWM_SYNC_SINSRC0_Msk             (0x3ul << PWM_SYNC_SINSRC0_Pos)                   /*!< PWM_T::SYNC: SINSRC0 Mask              */
N
N#define PWM_SYNC_SINSRC2_Pos             (10)                                              /*!< PWM_T::SYNC: SINSRC2 Position          */
N#define PWM_SYNC_SINSRC2_Msk             (0x3ul << PWM_SYNC_SINSRC2_Pos)                   /*!< PWM_T::SYNC: SINSRC2 Mask              */
N
N#define PWM_SYNC_SINSRC4_Pos             (12)                                              /*!< PWM_T::SYNC: SINSRC4 Position          */
N#define PWM_SYNC_SINSRC4_Msk             (0x3ul << PWM_SYNC_SINSRC4_Pos)                   /*!< PWM_T::SYNC: SINSRC4 Mask              */
N
N#define PWM_SYNC_SNFLTEN_Pos             (16)                                              /*!< PWM_T::SYNC: SNFLTEN Position          */
N#define PWM_SYNC_SNFLTEN_Msk             (0x1ul << PWM_SYNC_SNFLTEN_Pos)                   /*!< PWM_T::SYNC: SNFLTEN Mask              */
N
N#define PWM_SYNC_SFLTCSEL_Pos            (17)                                              /*!< PWM_T::SYNC: SFLTCSEL Position         */
N#define PWM_SYNC_SFLTCSEL_Msk            (0x7ul << PWM_SYNC_SFLTCSEL_Pos)                  /*!< PWM_T::SYNC: SFLTCSEL Mask             */
N
N#define PWM_SYNC_SFLTCNT_Pos             (20)                                              /*!< PWM_T::SYNC: SFLTCNT Position          */
N#define PWM_SYNC_SFLTCNT_Msk             (0x7ul << PWM_SYNC_SFLTCNT_Pos)                   /*!< PWM_T::SYNC: SFLTCNT Mask              */
N
N#define PWM_SYNC_SINPINV_Pos             (23)                                              /*!< PWM_T::SYNC: SINPINV Position          */
N#define PWM_SYNC_SINPINV_Msk             (0x1ul << PWM_SYNC_SINPINV_Pos)                   /*!< PWM_T::SYNC: SINPINV Mask              */
N
N#define PWM_SYNC_PHSDIR0_Pos             (24)                                              /*!< PWM_T::SYNC: PHSDIR0 Position          */
N#define PWM_SYNC_PHSDIR0_Msk             (0x1ul << PWM_SYNC_PHSDIR0_Pos)                   /*!< PWM_T::SYNC: PHSDIR0 Mask              */
N
N#define PWM_SYNC_PHSDIR2_Pos             (25)                                              /*!< PWM_T::SYNC: PHSDIR2 Position          */
N#define PWM_SYNC_PHSDIR2_Msk             (0x1ul << PWM_SYNC_PHSDIR2_Pos)                   /*!< PWM_T::SYNC: PHSDIR2 Mask              */
N
N#define PWM_SYNC_PHSDIR4_Pos             (26)                                              /*!< PWM_T::SYNC: PHSDIR4 Position          */
N#define PWM_SYNC_PHSDIR4_Msk             (0x1ul << PWM_SYNC_PHSDIR4_Pos)                   /*!< PWM_T::SYNC: PHSDIR4 Mask              */
N
N#define PWM_SWSYNC_SWSYNC0_Pos           (0)                                               /*!< PWM_T::SWSYNC: SWSYNC0 Position        */
N#define PWM_SWSYNC_SWSYNC0_Msk           (0x1ul << PWM_SWSYNC_SWSYNC0_Pos)                 /*!< PWM_T::SWSYNC: SWSYNC0 Mask            */
N
N#define PWM_SWSYNC_SWSYNC2_Pos           (1)                                               /*!< PWM_T::SWSYNC: SWSYNC2 Position        */
N#define PWM_SWSYNC_SWSYNC2_Msk           (0x1ul << PWM_SWSYNC_SWSYNC2_Pos)                 /*!< PWM_T::SWSYNC: SWSYNC2 Mask            */
N
N#define PWM_SWSYNC_SWSYNC4_Pos           (2)                                               /*!< PWM_T::SWSYNC: SWSYNC4 Position        */
N#define PWM_SWSYNC_SWSYNC4_Msk           (0x1ul << PWM_SWSYNC_SWSYNC4_Pos)                 /*!< PWM_T::SWSYNC: SWSYNC4 Mask            */
N
N#define PWM_CLKSRC_ECLKSRC0_Pos          (0)                                               /*!< PWM_T::CLKSRC: ECLKSRC0 Position       */
N#define PWM_CLKSRC_ECLKSRC0_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC0_Pos)                /*!< PWM_T::CLKSRC: ECLKSRC0 Mask           */
N
N#define PWM_CLKSRC_ECLKSRC2_Pos          (8)                                               /*!< PWM_T::CLKSRC: ECLKSRC2 Position       */
N#define PWM_CLKSRC_ECLKSRC2_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC2_Pos)                /*!< PWM_T::CLKSRC: ECLKSRC2 Mask           */
N
N#define PWM_CLKSRC_ECLKSRC4_Pos          (16)                                              /*!< PWM_T::CLKSRC: ECLKSRC4 Position       */
N#define PWM_CLKSRC_ECLKSRC4_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC4_Pos)                /*!< PWM_T::CLKSRC: ECLKSRC4 Mask           */
N
N#define PWM_CLKPSC0_1_CLKPSC_Pos         (0)                                               /*!< PWM_T::CLKPSC0_1: CLKPSC Position      */
N#define PWM_CLKPSC0_1_CLKPSC_Msk         (0xffful << PWM_CLKPSC0_1_CLKPSC_Pos)             /*!< PWM_T::CLKPSC0_1: CLKPSC Mask          */
N
N#define PWM_CLKPSC2_3_CLKPSC_Pos         (0)                                               /*!< PWM_T::CLKPSC2_3: CLKPSC Position      */
N#define PWM_CLKPSC2_3_CLKPSC_Msk         (0xffful << PWM_CLKPSC2_3_CLKPSC_Pos)             /*!< PWM_T::CLKPSC2_3: CLKPSC Mask          */
N
N#define PWM_CLKPSC4_5_CLKPSC_Pos         (0)                                               /*!< PWM_T::CLKPSC4_5: CLKPSC Position      */
N#define PWM_CLKPSC4_5_CLKPSC_Msk         (0xffful << PWM_CLKPSC4_5_CLKPSC_Pos)             /*!< PWM_T::CLKPSC4_5: CLKPSC Mask          */
N
N#define PWM_CNTEN_CNTEN0_Pos             (0)                                               /*!< PWM_T::CNTEN: CNTEN0 Position          */
N#define PWM_CNTEN_CNTEN0_Msk             (0x1ul << PWM_CNTEN_CNTEN0_Pos)                   /*!< PWM_T::CNTEN: CNTEN0 Mask              */
N
N#define PWM_CNTEN_CNTEN1_Pos             (1)                                               /*!< PWM_T::CNTEN: CNTEN1 Position          */
N#define PWM_CNTEN_CNTEN1_Msk             (0x1ul << PWM_CNTEN_CNTEN1_Pos)                   /*!< PWM_T::CNTEN: CNTEN1 Mask              */
N
N#define PWM_CNTEN_CNTEN2_Pos             (2)                                               /*!< PWM_T::CNTEN: CNTEN2 Position          */
N#define PWM_CNTEN_CNTEN2_Msk             (0x1ul << PWM_CNTEN_CNTEN2_Pos)                   /*!< PWM_T::CNTEN: CNTEN2 Mask              */
N
N#define PWM_CNTEN_CNTEN3_Pos             (3)                                               /*!< PWM_T::CNTEN: CNTEN3 Position          */
N#define PWM_CNTEN_CNTEN3_Msk             (0x1ul << PWM_CNTEN_CNTEN3_Pos)                   /*!< PWM_T::CNTEN: CNTEN3 Mask              */
N
N#define PWM_CNTEN_CNTEN4_Pos             (4)                                               /*!< PWM_T::CNTEN: CNTEN4 Position          */
N#define PWM_CNTEN_CNTEN4_Msk             (0x1ul << PWM_CNTEN_CNTEN4_Pos)                   /*!< PWM_T::CNTEN: CNTEN4 Mask              */
N
N#define PWM_CNTEN_CNTEN5_Pos             (5)                                               /*!< PWM_T::CNTEN: CNTEN5 Position          */
N#define PWM_CNTEN_CNTEN5_Msk             (0x1ul << PWM_CNTEN_CNTEN5_Pos)                   /*!< PWM_T::CNTEN: CNTEN5 Mask              */
N
N#define PWM_CNTCLR_CNTCLR0_Pos           (0)                                               /*!< PWM_T::CNTCLR: CNTCLR0 Position        */
N#define PWM_CNTCLR_CNTCLR0_Msk           (0x1ul << PWM_CNTCLR_CNTCLR0_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR0 Mask            */
N
N#define PWM_CNTCLR_CNTCLR1_Pos           (1)                                               /*!< PWM_T::CNTCLR: CNTCLR1 Position        */
N#define PWM_CNTCLR_CNTCLR1_Msk           (0x1ul << PWM_CNTCLR_CNTCLR1_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR1 Mask            */
N
N#define PWM_CNTCLR_CNTCLR2_Pos           (2)                                               /*!< PWM_T::CNTCLR: CNTCLR2 Position        */
N#define PWM_CNTCLR_CNTCLR2_Msk           (0x1ul << PWM_CNTCLR_CNTCLR2_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR2 Mask            */
N
N#define PWM_CNTCLR_CNTCLR3_Pos           (3)                                               /*!< PWM_T::CNTCLR: CNTCLR3 Position        */
N#define PWM_CNTCLR_CNTCLR3_Msk           (0x1ul << PWM_CNTCLR_CNTCLR3_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR3 Mask            */
N
N#define PWM_CNTCLR_CNTCLR4_Pos           (4)                                               /*!< PWM_T::CNTCLR: CNTCLR4 Position        */
N#define PWM_CNTCLR_CNTCLR4_Msk           (0x1ul << PWM_CNTCLR_CNTCLR4_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR4 Mask            */
N
N#define PWM_CNTCLR_CNTCLR5_Pos           (5)                                               /*!< PWM_T::CNTCLR: CNTCLR5 Position        */
N#define PWM_CNTCLR_CNTCLR5_Msk           (0x1ul << PWM_CNTCLR_CNTCLR5_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR5 Mask            */
N
N#define PWM_LOAD_LOAD0_Pos               (0)                                               /*!< PWM_T::LOAD: LOAD0 Position            */
N#define PWM_LOAD_LOAD0_Msk               (0x1ul << PWM_LOAD_LOAD0_Pos)                     /*!< PWM_T::LOAD: LOAD0 Mask                */
N
N#define PWM_LOAD_LOAD1_Pos               (1)                                               /*!< PWM_T::LOAD: LOAD1 Position            */
N#define PWM_LOAD_LOAD1_Msk               (0x1ul << PWM_LOAD_LOAD1_Pos)                     /*!< PWM_T::LOAD: LOAD1 Mask                */
N
N#define PWM_LOAD_LOAD2_Pos               (2)                                               /*!< PWM_T::LOAD: LOAD2 Position            */
N#define PWM_LOAD_LOAD2_Msk               (0x1ul << PWM_LOAD_LOAD2_Pos)                     /*!< PWM_T::LOAD: LOAD2 Mask                */
N
N#define PWM_LOAD_LOAD3_Pos               (3)                                               /*!< PWM_T::LOAD: LOAD3 Position            */
N#define PWM_LOAD_LOAD3_Msk               (0x1ul << PWM_LOAD_LOAD3_Pos)                     /*!< PWM_T::LOAD: LOAD3 Mask                */
N
N#define PWM_LOAD_LOAD4_Pos               (4)                                               /*!< PWM_T::LOAD: LOAD4 Position            */
N#define PWM_LOAD_LOAD4_Msk               (0x1ul << PWM_LOAD_LOAD4_Pos)                     /*!< PWM_T::LOAD: LOAD4 Mask                */
N
N#define PWM_LOAD_LOAD5_Pos               (5)                                               /*!< PWM_T::LOAD: LOAD5 Position            */
N#define PWM_LOAD_LOAD5_Msk               (0x1ul << PWM_LOAD_LOAD5_Pos)                     /*!< PWM_T::LOAD: LOAD5 Mask                */
N
N#define PWM_PERIOD_PERIOD_Pos            (0)                                               /*!< PWM_T::PERIOD: PERIOD Position         */
N#define PWM_PERIOD_PERIOD_Msk            (0xfffful << PWM_PERIOD_PERIOD_Pos)               /*!< PWM_T::PERIOD: PERIOD Mask             */
N
N#define PWM_CMPDAT_CMP_Pos               (0)                                               /*!< PWM_T::CMPDAT: CMP Position            */
N#define PWM_CMPDAT_CMP_Msk               (0xfffful << PWM_CMPDAT_CMP_Pos)                  /*!< PWM_T::CMPDAT: CMP Mask                */
N
N#define PWM_DTCTL0_1_DTCNT_Pos           (0)                                               /*!< PWM_T::DTCTL0_1: DTCNT Position        */
N#define PWM_DTCTL0_1_DTCNT_Msk           (0xffful << PWM_DTCTL0_1_DTCNT_Pos)               /*!< PWM_T::DTCTL0_1: DTCNT Mask            */
N
N#define PWM_DTCTL0_1_DTEN_Pos            (16)                                              /*!< PWM_T::DTCTL0_1: DTEN Position         */
N#define PWM_DTCTL0_1_DTEN_Msk            (0x1ul << PWM_DTCTL0_1_DTEN_Pos)                  /*!< PWM_T::DTCTL0_1: DTEN Mask             */
N
N#define PWM_DTCTL0_1_DTCKSEL_Pos         (24)                                              /*!< PWM_T::DTCTL0_1: DTCKSEL Position      */
N#define PWM_DTCTL0_1_DTCKSEL_Msk         (0x1ul << PWM_DTCTL0_1_DTCKSEL_Pos)               /*!< PWM_T::DTCTL0_1: DTCKSEL Mask          */
N
N#define PWM_DTCTL2_3_DTCNT_Pos           (0)                                               /*!< PWM_T::DTCTL2_3: DTCNT Position        */
N#define PWM_DTCTL2_3_DTCNT_Msk           (0xffful << PWM_DTCTL2_3_DTCNT_Pos)               /*!< PWM_T::DTCTL2_3: DTCNT Mask            */
N
N#define PWM_DTCTL2_3_DTEN_Pos            (16)                                              /*!< PWM_T::DTCTL2_3: DTEN Position         */
N#define PWM_DTCTL2_3_DTEN_Msk            (0x1ul << PWM_DTCTL2_3_DTEN_Pos)                  /*!< PWM_T::DTCTL2_3: DTEN Mask             */
N
N#define PWM_DTCTL2_3_DTCKSEL_Pos         (24)                                              /*!< PWM_T::DTCTL2_3: DTCKSEL Position      */
N#define PWM_DTCTL2_3_DTCKSEL_Msk         (0x1ul << PWM_DTCTL2_3_DTCKSEL_Pos)               /*!< PWM_T::DTCTL2_3: DTCKSEL Mask          */
N
N#define PWM_DTCTL4_5_DTCNT_Pos           (0)                                               /*!< PWM_T::DTCTL4_5: DTCNT Position        */
N#define PWM_DTCTL4_5_DTCNT_Msk           (0xffful << PWM_DTCTL4_5_DTCNT_Pos)               /*!< PWM_T::DTCTL4_5: DTCNT Mask            */
N
N#define PWM_DTCTL4_5_DTEN_Pos            (16)                                              /*!< PWM_T::DTCTL4_5: DTEN Position         */
N#define PWM_DTCTL4_5_DTEN_Msk            (0x1ul << PWM_DTCTL4_5_DTEN_Pos)                  /*!< PWM_T::DTCTL4_5: DTEN Mask             */
N
N#define PWM_DTCTL4_5_DTCKSEL_Pos         (24)                                              /*!< PWM_T::DTCTL4_5: DTCKSEL Position      */
N#define PWM_DTCTL4_5_DTCKSEL_Msk         (0x1ul << PWM_DTCTL4_5_DTCKSEL_Pos)               /*!< PWM_T::DTCTL4_5: DTCKSEL Mask          */
N
N#define PWM_PHS0_1_PHS_Pos               (0)                                               /*!< PWM_T::PHS0_1: PHS Position            */
N#define PWM_PHS0_1_PHS_Msk               (0xfffful << PWM_PHS0_1_PHS_Pos)                  /*!< PWM_T::PHS0_1: PHS Mask                */
N
N#define PWM_PHS2_3_PHS_Pos               (0)                                               /*!< PWM_T::PHS2_3: PHS Position            */
N#define PWM_PHS2_3_PHS_Msk               (0xfffful << PWM_PHS2_3_PHS_Pos)                  /*!< PWM_T::PHS2_3: PHS Mask                */
N
N#define PWM_PHS4_5_PHS_Pos               (0)                                               /*!< PWM_T::PHS4_5: PHS Position            */
N#define PWM_PHS4_5_PHS_Msk               (0xfffful << PWM_PHS4_5_PHS_Pos)                  /*!< PWM_T::PHS4_5: PHS Mask                */
N
N#define PWM_CNT_CNT_Pos                  (0)                                               /*!< PWM_T::CNT: CNT Position               */
N#define PWM_CNT_CNT_Msk                  (0xfffful << PWM_CNT_CNT_Pos)                     /*!< PWM_T::CNT: CNT Mask                   */
N
N#define PWM_CNT_DIRF_Pos                 (16)                                              /*!< PWM_T::CNT: DIRF Position              */
N#define PWM_CNT_DIRF_Msk                 (0x1ul << PWM_CNT_DIRF_Pos)                       /*!< PWM_T::CNT: DIRF Mask                  */
N
N#define PWM_WGCTL0_ZPCTL0_Pos            (0)                                               /*!< PWM_T::WGCTL0: ZPCTL0 Position         */
N#define PWM_WGCTL0_ZPCTL0_Msk            (0x3ul << PWM_WGCTL0_ZPCTL0_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL0 Mask             */
N
N#define PWM_WGCTL0_ZPCTL1_Pos            (2)                                               /*!< PWM_T::WGCTL0: ZPCTL1 Position         */
N#define PWM_WGCTL0_ZPCTL1_Msk            (0x3ul << PWM_WGCTL0_ZPCTL1_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL1 Mask             */
N
N#define PWM_WGCTL0_ZPCTL2_Pos            (4)                                               /*!< PWM_T::WGCTL0: ZPCTL2 Position         */
N#define PWM_WGCTL0_ZPCTL2_Msk            (0x3ul << PWM_WGCTL0_ZPCTL2_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL2 Mask             */
N
N#define PWM_WGCTL0_ZPCTL3_Pos            (6)                                               /*!< PWM_T::WGCTL0: ZPCTL3 Position         */
N#define PWM_WGCTL0_ZPCTL3_Msk            (0x3ul << PWM_WGCTL0_ZPCTL3_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL3 Mask             */
N
N#define PWM_WGCTL0_ZPCTL4_Pos            (8)                                               /*!< PWM_T::WGCTL0: ZPCTL4 Position         */
N#define PWM_WGCTL0_ZPCTL4_Msk            (0x3ul << PWM_WGCTL0_ZPCTL4_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL4 Mask             */
N
N#define PWM_WGCTL0_ZPCTL5_Pos            (10)                                              /*!< PWM_T::WGCTL0: ZPCTL5 Position         */
N#define PWM_WGCTL0_ZPCTL5_Msk            (0x3ul << PWM_WGCTL0_ZPCTL5_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL5 Mask             */
N
N#define PWM_WGCTL0_PRDPCTL0_Pos          (16)                                              /*!< PWM_T::WGCTL0: PRDPCTL0 Position       */
N#define PWM_WGCTL0_PRDPCTL0_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL0_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL0 Mask           */
N
N#define PWM_WGCTL0_PRDPCTL1_Pos          (18)                                              /*!< PWM_T::WGCTL0: PRDPCTL1 Position       */
N#define PWM_WGCTL0_PRDPCTL1_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL1_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL1 Mask           */
N
N#define PWM_WGCTL0_PRDPCTL2_Pos          (20)                                              /*!< PWM_T::WGCTL0: PRDPCTL2 Position       */
N#define PWM_WGCTL0_PRDPCTL2_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL2_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL2 Mask           */
N
N#define PWM_WGCTL0_PRDPCTL3_Pos          (22)                                              /*!< PWM_T::WGCTL0: PRDPCTL3 Position       */
N#define PWM_WGCTL0_PRDPCTL3_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL3_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL3 Mask           */
N
N#define PWM_WGCTL0_PRDPCTL4_Pos          (24)                                              /*!< PWM_T::WGCTL0: PRDPCTL4 Position       */
N#define PWM_WGCTL0_PRDPCTL4_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL4_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL4 Mask           */
N
N#define PWM_WGCTL0_PRDPCTL5_Pos          (26)                                              /*!< PWM_T::WGCTL0: PRDPCTL5 Position       */
N#define PWM_WGCTL0_PRDPCTL5_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL5_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL5 Mask           */
N
N#define PWM_WGCTL1_CMPUCTL0_Pos          (0)                                               /*!< PWM_T::WGCTL1: CMPUCTL0 Position       */
N#define PWM_WGCTL1_CMPUCTL0_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL0_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL0 Mask           */
N
N#define PWM_WGCTL1_CMPUCTL1_Pos          (2)                                               /*!< PWM_T::WGCTL1: CMPUCTL1 Position       */
N#define PWM_WGCTL1_CMPUCTL1_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL1_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL1 Mask           */
N
N#define PWM_WGCTL1_CMPUCTL2_Pos          (4)                                               /*!< PWM_T::WGCTL1: CMPUCTL2 Position       */
N#define PWM_WGCTL1_CMPUCTL2_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL2_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL2 Mask           */
N
N#define PWM_WGCTL1_CMPUCTL3_Pos          (6)                                               /*!< PWM_T::WGCTL1: CMPUCTL3 Position       */
N#define PWM_WGCTL1_CMPUCTL3_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL3_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL3 Mask           */
N
N#define PWM_WGCTL1_CMPUCTL4_Pos          (8)                                               /*!< PWM_T::WGCTL1: CMPUCTL4 Position       */
N#define PWM_WGCTL1_CMPUCTL4_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL4_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL4 Mask           */
N
N#define PWM_WGCTL1_CMPUCTL5_Pos          (10)                                              /*!< PWM_T::WGCTL1: CMPUCTL5 Position       */
N#define PWM_WGCTL1_CMPUCTL5_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL5_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL5 Mask           */
N
N#define PWM_WGCTL1_CMPDCTL0_Pos          (16)                                              /*!< PWM_T::WGCTL1: CMPDCTL0 Position       */
N#define PWM_WGCTL1_CMPDCTL0_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL0_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL0 Mask           */
N
N#define PWM_WGCTL1_CMPDCTL1_Pos          (18)                                              /*!< PWM_T::WGCTL1: CMPDCTL1 Position       */
N#define PWM_WGCTL1_CMPDCTL1_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL1_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL1 Mask           */
N
N#define PWM_WGCTL1_CMPDCTL2_Pos          (20)                                              /*!< PWM_T::WGCTL1: CMPDCTL2 Position       */
N#define PWM_WGCTL1_CMPDCTL2_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL2_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL2 Mask           */
N
N#define PWM_WGCTL1_CMPDCTL3_Pos          (22)                                              /*!< PWM_T::WGCTL1: CMPDCTL3 Position       */
N#define PWM_WGCTL1_CMPDCTL3_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL3_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL3 Mask           */
N
N#define PWM_WGCTL1_CMPDCTL4_Pos          (24)                                              /*!< PWM_T::WGCTL1: CMPDCTL4 Position       */
N#define PWM_WGCTL1_CMPDCTL4_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL4_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL4 Mask           */
N
N#define PWM_WGCTL1_CMPDCTL5_Pos          (26)                                              /*!< PWM_T::WGCTL1: CMPDCTL5 Position       */
N#define PWM_WGCTL1_CMPDCTL5_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL5_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL5 Mask           */
N
N#define PWM_MSKEN_MSKEN0_Pos             (0)                                               /*!< PWM_T::MSKEN: MSKEN0 Position          */
N#define PWM_MSKEN_MSKEN0_Msk             (0x1ul << PWM_MSKEN_MSKEN0_Pos)                   /*!< PWM_T::MSKEN: MSKEN0 Mask              */
N
N#define PWM_MSKEN_MSKEN1_Pos             (1)                                               /*!< PWM_T::MSKEN: MSKEN1 Position          */
N#define PWM_MSKEN_MSKEN1_Msk             (0x1ul << PWM_MSKEN_MSKEN1_Pos)                   /*!< PWM_T::MSKEN: MSKEN1 Mask              */
N
N#define PWM_MSKEN_MSKEN2_Pos             (2)                                               /*!< PWM_T::MSKEN: MSKEN2 Position          */
N#define PWM_MSKEN_MSKEN2_Msk             (0x1ul << PWM_MSKEN_MSKEN2_Pos)                   /*!< PWM_T::MSKEN: MSKEN2 Mask              */
N
N#define PWM_MSKEN_MSKEN3_Pos             (3)                                               /*!< PWM_T::MSKEN: MSKEN3 Position          */
N#define PWM_MSKEN_MSKEN3_Msk             (0x1ul << PWM_MSKEN_MSKEN3_Pos)                   /*!< PWM_T::MSKEN: MSKEN3 Mask              */
N
N#define PWM_MSKEN_MSKEN4_Pos             (4)                                               /*!< PWM_T::MSKEN: MSKEN4 Position          */
N#define PWM_MSKEN_MSKEN4_Msk             (0x1ul << PWM_MSKEN_MSKEN4_Pos)                   /*!< PWM_T::MSKEN: MSKEN4 Mask              */
N
N#define PWM_MSKEN_MSKEN5_Pos             (5)                                               /*!< PWM_T::MSKEN: MSKEN5 Position          */
N#define PWM_MSKEN_MSKEN5_Msk             (0x1ul << PWM_MSKEN_MSKEN5_Pos)                   /*!< PWM_T::MSKEN: MSKEN5 Mask              */
N
N#define PWM_MSK_MSKDAT0_Pos              (0)                                               /*!< PWM_T::MSK: MSKDAT0 Position           */
N#define PWM_MSK_MSKDAT0_Msk              (0x1ul << PWM_MSK_MSKDAT0_Pos)                    /*!< PWM_T::MSK: MSKDAT0 Mask               */
N
N#define PWM_MSK_MSKDAT1_Pos              (1)                                               /*!< PWM_T::MSK: MSKDAT1 Position           */
N#define PWM_MSK_MSKDAT1_Msk              (0x1ul << PWM_MSK_MSKDAT1_Pos)                    /*!< PWM_T::MSK: MSKDAT1 Mask               */
N
N#define PWM_MSK_MSKDAT2_Pos              (2)                                               /*!< PWM_T::MSK: MSKDAT2 Position           */
N#define PWM_MSK_MSKDAT2_Msk              (0x1ul << PWM_MSK_MSKDAT2_Pos)                    /*!< PWM_T::MSK: MSKDAT2 Mask               */
N
N#define PWM_MSK_MSKDAT3_Pos              (3)                                               /*!< PWM_T::MSK: MSKDAT3 Position           */
N#define PWM_MSK_MSKDAT3_Msk              (0x1ul << PWM_MSK_MSKDAT3_Pos)                    /*!< PWM_T::MSK: MSKDAT3 Mask               */
N
N#define PWM_MSK_MSKDAT4_Pos              (4)                                               /*!< PWM_T::MSK: MSKDAT4 Position           */
N#define PWM_MSK_MSKDAT4_Msk              (0x1ul << PWM_MSK_MSKDAT4_Pos)                    /*!< PWM_T::MSK: MSKDAT4 Mask               */
N
N#define PWM_MSK_MSKDAT5_Pos              (5)                                               /*!< PWM_T::MSK: MSKDAT5 Position           */
N#define PWM_MSK_MSKDAT5_Msk              (0x1ul << PWM_MSK_MSKDAT5_Pos)                    /*!< PWM_T::MSK: MSKDAT5 Mask               */
N
N#define PWM_BNF_BRK0NFEN_Pos             (0)                                               /*!< PWM_T::BNF: BRK0NFEN Position          */
N#define PWM_BNF_BRK0NFEN_Msk             (0x1ul << PWM_BNF_BRK0NFEN_Pos)                   /*!< PWM_T::BNF: BRK0NFEN Mask              */
N
N#define PWM_BNF_BRK0NFSEL_Pos            (1)                                               /*!< PWM_T::BNF: BRK0NFSEL Position         */
N#define PWM_BNF_BRK0NFSEL_Msk            (0x7ul << PWM_BNF_BRK0NFSEL_Pos)                  /*!< PWM_T::BNF: BRK0NFSEL Mask             */
N
N#define PWM_BNF_BRK0FCNT_Pos             (4)                                               /*!< PWM_T::BNF: BRK0FCNT Position          */
N#define PWM_BNF_BRK0FCNT_Msk             (0x7ul << PWM_BNF_BRK0FCNT_Pos)                   /*!< PWM_T::BNF: BRK0FCNT Mask              */
N
N#define PWM_BNF_BRK0PINV_Pos             (7)                                               /*!< PWM_T::BNF: BRK0PINV Position          */
N#define PWM_BNF_BRK0PINV_Msk             (0x1ul << PWM_BNF_BRK0PINV_Pos)                   /*!< PWM_T::BNF: BRK0PINV Mask              */
N
N#define PWM_BNF_BRK1NFEN_Pos             (8)                                               /*!< PWM_T::BNF: BRK1NFEN Position          */
N#define PWM_BNF_BRK1NFEN_Msk             (0x1ul << PWM_BNF_BRK1NFEN_Pos)                   /*!< PWM_T::BNF: BRK1NFEN Mask              */
N
N#define PWM_BNF_BRK1NFSEL_Pos            (9)                                               /*!< PWM_T::BNF: BRK1NFSEL Position         */
N#define PWM_BNF_BRK1NFSEL_Msk            (0x7ul << PWM_BNF_BRK1NFSEL_Pos)                  /*!< PWM_T::BNF: BRK1NFSEL Mask             */
N
N#define PWM_BNF_BRK1FCNT_Pos             (12)                                              /*!< PWM_T::BNF: BRK1FCNT Position          */
N#define PWM_BNF_BRK1FCNT_Msk             (0x7ul << PWM_BNF_BRK1FCNT_Pos)                   /*!< PWM_T::BNF: BRK1FCNT Mask              */
N
N#define PWM_BNF_BRK1PINV_Pos             (15)                                              /*!< PWM_T::BNF: BRK1PINV Position          */
N#define PWM_BNF_BRK1PINV_Msk             (0x1ul << PWM_BNF_BRK1PINV_Pos)                   /*!< PWM_T::BNF: BRK1PINV Mask              */
N
N#define PWM_BNF_BK0SRC_Pos               (16)                                              /*!< PWM_T::BNF: BK0SRC Position            */
N#define PWM_BNF_BK0SRC_Msk               (0x1ul << PWM_BNF_BK0SRC_Pos)                     /*!< PWM_T::BNF: BK0SRC Mask                */
N
N#define PWM_BNF_BK1SRC_Pos               (24)                                              /*!< PWM_T::BNF: BK1SRC Position            */
N#define PWM_BNF_BK1SRC_Msk               (0x1ul << PWM_BNF_BK1SRC_Pos)                     /*!< PWM_T::BNF: BK1SRC Mask                */
N
N#define PWM_FAILBRK_CSSBRKEN_Pos         (0)                                               /*!< PWM_T::FAILBRK: CSSBRKEN Position      */
N#define PWM_FAILBRK_CSSBRKEN_Msk         (0x1ul << PWM_FAILBRK_CSSBRKEN_Pos)               /*!< PWM_T::FAILBRK: CSSBRKEN Mask          */
N
N#define PWM_FAILBRK_BODBRKEN_Pos         (1)                                               /*!< PWM_T::FAILBRK: BODBRKEN Position      */
N#define PWM_FAILBRK_BODBRKEN_Msk         (0x1ul << PWM_FAILBRK_BODBRKEN_Pos)               /*!< PWM_T::FAILBRK: BODBRKEN Mask          */
N
N#define PWM_FAILBRK_CORBRKEN_Pos         (3)                                               /*!< PWM_T::FAILBRK: CORBRKEN Position      */
N#define PWM_FAILBRK_CORBRKEN_Msk         (0x1ul << PWM_FAILBRK_CORBRKEN_Pos)               /*!< PWM_T::FAILBRK: CORBRKEN Mask          */
N
N#define PWM_BRKCTL0_1_CPO0EBEN_Pos       (0)                                               /*!< PWM_T::BRKCTL0_1: CPO0EBEN Position    */
N#define PWM_BRKCTL0_1_CPO0EBEN_Msk       (0x1ul << PWM_BRKCTL0_1_CPO0EBEN_Pos)             /*!< PWM_T::BRKCTL0_1: CPO0EBEN Mask        */
N
N#define PWM_BRKCTL0_1_CPO1EBEN_Pos       (1)                                               /*!< PWM_T::BRKCTL0_1: CPO1EBEN Position    */
N#define PWM_BRKCTL0_1_CPO1EBEN_Msk       (0x1ul << PWM_BRKCTL0_1_CPO1EBEN_Pos)             /*!< PWM_T::BRKCTL0_1: CPO1EBEN Mask        */
N
N#define PWM_BRKCTL0_1_BRKP0EEN_Pos       (4)                                               /*!< PWM_T::BRKCTL0_1: BRKP0EEN Position    */
N#define PWM_BRKCTL0_1_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP0EEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP0EEN Mask        */
N
N#define PWM_BRKCTL0_1_BRKP1EEN_Pos       (5)                                               /*!< PWM_T::BRKCTL0_1: BRKP1EEN Position    */
N#define PWM_BRKCTL0_1_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP1EEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP1EEN Mask        */
N
N#define PWM_BRKCTL0_1_SYSEBEN_Pos        (7)                                               /*!< PWM_T::BRKCTL0_1: SYSEBEN Position     */
N#define PWM_BRKCTL0_1_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL0_1_SYSEBEN_Pos)              /*!< PWM_T::BRKCTL0_1: SYSEBEN Mask         */
N
N#define PWM_BRKCTL0_1_CPO0LBEN_Pos       (8)                                               /*!< PWM_T::BRKCTL0_1: CPO0LBEN Position    */
N#define PWM_BRKCTL0_1_CPO0LBEN_Msk       (0x1ul << PWM_BRKCTL0_1_CPO0LBEN_Pos)             /*!< PWM_T::BRKCTL0_1: CPO0LBEN Mask        */
N
N#define PWM_BRKCTL0_1_CPO1LBEN_Pos       (9)                                               /*!< PWM_T::BRKCTL0_1: CPO1LBEN Position    */
N#define PWM_BRKCTL0_1_CPO1LBEN_Msk       (0x1ul << PWM_BRKCTL0_1_CPO1LBEN_Pos)             /*!< PWM_T::BRKCTL0_1: CPO1LBEN Mask        */
N
N#define PWM_BRKCTL0_1_BRKP0LEN_Pos       (12)                                              /*!< PWM_T::BRKCTL0_1: BRKP0LEN Position    */
N#define PWM_BRKCTL0_1_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP0LEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP0LEN Mask        */
N
N#define PWM_BRKCTL0_1_BRKP1LEN_Pos       (13)                                              /*!< PWM_T::BRKCTL0_1: BRKP1LEN Position    */
N#define PWM_BRKCTL0_1_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP1LEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP1LEN Mask        */
N
N#define PWM_BRKCTL0_1_SYSLBEN_Pos        (15)                                              /*!< PWM_T::BRKCTL0_1: SYSLBEN Position     */
N#define PWM_BRKCTL0_1_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL0_1_SYSLBEN_Pos)              /*!< PWM_T::BRKCTL0_1: SYSLBEN Mask         */
N
N#define PWM_BRKCTL0_1_BRKAEVEN_Pos       (16)                                              /*!< PWM_T::BRKCTL0_1: BRKAEVEN Position    */
N#define PWM_BRKCTL0_1_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL0_1_BRKAEVEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKAEVEN Mask        */
N
N#define PWM_BRKCTL0_1_BRKAODD_Pos        (18)                                              /*!< PWM_T::BRKCTL0_1: BRKAODD Position     */
N#define PWM_BRKCTL0_1_BRKAODD_Msk        (0x3ul << PWM_BRKCTL0_1_BRKAODD_Pos)              /*!< PWM_T::BRKCTL0_1: BRKAODD Mask         */
N
N#define PWM_BRKCTL0_1_ADCEBEN_Pos        (20)                                              /*!< PWM_T::BRKCTL0_1: ADCEBEN Position     */
N#define PWM_BRKCTL0_1_ADCEBEN_Msk        (0x1ul << PWM_BRKCTL0_1_ADCEBEN_Pos)              /*!< PWM_T::BRKCTL0_1: ADCEBEN Mask         */
N
N#define PWM_BRKCTL0_1_ADCLBEN_Pos        (28)                                              /*!< PWM_T::BRKCTL0_1: ADCLBEN Position     */
N#define PWM_BRKCTL0_1_ADCLBEN_Msk        (0x1ul << PWM_BRKCTL0_1_ADCLBEN_Pos)              /*!< PWM_T::BRKCTL0_1: ADCLBEN Mask         */
N
N#define PWM_BRKCTL2_3_CPO0EBEN_Pos       (0)                                               /*!< PWM_T::BRKCTL2_3: CPO0EBEN Position    */
N#define PWM_BRKCTL2_3_CPO0EBEN_Msk       (0x1ul << PWM_BRKCTL2_3_CPO0EBEN_Pos)             /*!< PWM_T::BRKCTL2_3: CPO0EBEN Mask        */
N
N#define PWM_BRKCTL2_3_CPO1EBEN_Pos       (1)                                               /*!< PWM_T::BRKCTL2_3: CPO1EBEN Position    */
N#define PWM_BRKCTL2_3_CPO1EBEN_Msk       (0x1ul << PWM_BRKCTL2_3_CPO1EBEN_Pos)             /*!< PWM_T::BRKCTL2_3: CPO1EBEN Mask        */
N
N#define PWM_BRKCTL2_3_BRKP0EEN_Pos       (4)                                               /*!< PWM_T::BRKCTL2_3: BRKP0EEN Position    */
N#define PWM_BRKCTL2_3_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP0EEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP0EEN Mask        */
N
N#define PWM_BRKCTL2_3_BRKP1EEN_Pos       (5)                                               /*!< PWM_T::BRKCTL2_3: BRKP1EEN Position    */
N#define PWM_BRKCTL2_3_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP1EEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP1EEN Mask        */
N
N#define PWM_BRKCTL2_3_SYSEBEN_Pos        (7)                                               /*!< PWM_T::BRKCTL2_3: SYSEBEN Position     */
N#define PWM_BRKCTL2_3_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL2_3_SYSEBEN_Pos)              /*!< PWM_T::BRKCTL2_3: SYSEBEN Mask         */
N
N#define PWM_BRKCTL2_3_CPO0LBEN_Pos       (8)                                               /*!< PWM_T::BRKCTL2_3: CPO0LBEN Position    */
N#define PWM_BRKCTL2_3_CPO0LBEN_Msk       (0x1ul << PWM_BRKCTL2_3_CPO0LBEN_Pos)             /*!< PWM_T::BRKCTL2_3: CPO0LBEN Mask        */
N
N#define PWM_BRKCTL2_3_CPO1LBEN_Pos       (9)                                               /*!< PWM_T::BRKCTL2_3: CPO1LBEN Position    */
N#define PWM_BRKCTL2_3_CPO1LBEN_Msk       (0x1ul << PWM_BRKCTL2_3_CPO1LBEN_Pos)             /*!< PWM_T::BRKCTL2_3: CPO1LBEN Mask        */
N
N#define PWM_BRKCTL2_3_BRKP0LEN_Pos       (12)                                              /*!< PWM_T::BRKCTL2_3: BRKP0LEN Position    */
N#define PWM_BRKCTL2_3_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP0LEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP0LEN Mask        */
N
N#define PWM_BRKCTL2_3_BRKP1LEN_Pos       (13)                                              /*!< PWM_T::BRKCTL2_3: BRKP1LEN Position    */
N#define PWM_BRKCTL2_3_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP1LEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP1LEN Mask        */
N
N#define PWM_BRKCTL2_3_SYSLBEN_Pos        (15)                                              /*!< PWM_T::BRKCTL2_3: SYSLBEN Position     */
N#define PWM_BRKCTL2_3_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL2_3_SYSLBEN_Pos)              /*!< PWM_T::BRKCTL2_3: SYSLBEN Mask         */
N
N#define PWM_BRKCTL2_3_BRKAEVEN_Pos       (16)                                              /*!< PWM_T::BRKCTL2_3: BRKAEVEN Position    */
N#define PWM_BRKCTL2_3_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL2_3_BRKAEVEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKAEVEN Mask        */
N
N#define PWM_BRKCTL2_3_BRKAODD_Pos        (18)                                              /*!< PWM_T::BRKCTL2_3: BRKAODD Position     */
N#define PWM_BRKCTL2_3_BRKAODD_Msk        (0x3ul << PWM_BRKCTL2_3_BRKAODD_Pos)              /*!< PWM_T::BRKCTL2_3: BRKAODD Mask         */
N
N#define PWM_BRKCTL2_3_ADCEBEN_Pos        (20)                                              /*!< PWM_T::BRKCTL2_3: ADCEBEN Position     */
N#define PWM_BRKCTL2_3_ADCEBEN_Msk        (0x1ul << PWM_BRKCTL2_3_ADCEBEN_Pos)              /*!< PWM_T::BRKCTL2_3: ADCEBEN Mask         */
N
N#define PWM_BRKCTL2_3_ADCLBEN_Pos        (28)                                              /*!< PWM_T::BRKCTL2_3: ADCLBEN Position     */
N#define PWM_BRKCTL2_3_ADCLBEN_Msk        (0x1ul << PWM_BRKCTL2_3_ADCLBEN_Pos)              /*!< PWM_T::BRKCTL2_3: ADCLBEN Mask         */
N
N#define PWM_BRKCTL4_5_CPO0EBEN_Pos       (0)                                               /*!< PWM_T::BRKCTL4_5: CPO0EBEN Position    */
N#define PWM_BRKCTL4_5_CPO0EBEN_Msk       (0x1ul << PWM_BRKCTL4_5_CPO0EBEN_Pos)             /*!< PWM_T::BRKCTL4_5: CPO0EBEN Mask        */
N
N#define PWM_BRKCTL4_5_CPO1EBEN_Pos       (1)                                               /*!< PWM_T::BRKCTL4_5: CPO1EBEN Position    */
N#define PWM_BRKCTL4_5_CPO1EBEN_Msk       (0x1ul << PWM_BRKCTL4_5_CPO1EBEN_Pos)             /*!< PWM_T::BRKCTL4_5: CPO1EBEN Mask        */
N
N#define PWM_BRKCTL4_5_BRKP0EEN_Pos       (4)                                               /*!< PWM_T::BRKCTL4_5: BRKP0EEN Position    */
N#define PWM_BRKCTL4_5_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP0EEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP0EEN Mask        */
N
N#define PWM_BRKCTL4_5_BRKP1EEN_Pos       (5)                                               /*!< PWM_T::BRKCTL4_5: BRKP1EEN Position    */
N#define PWM_BRKCTL4_5_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP1EEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP1EEN Mask        */
N
N#define PWM_BRKCTL4_5_SYSEBEN_Pos        (7)                                               /*!< PWM_T::BRKCTL4_5: SYSEBEN Position     */
N#define PWM_BRKCTL4_5_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL4_5_SYSEBEN_Pos)              /*!< PWM_T::BRKCTL4_5: SYSEBEN Mask         */
N
N#define PWM_BRKCTL4_5_CPO0LBEN_Pos       (8)                                               /*!< PWM_T::BRKCTL4_5: CPO0LBEN Position    */
N#define PWM_BRKCTL4_5_CPO0LBEN_Msk       (0x1ul << PWM_BRKCTL4_5_CPO0LBEN_Pos)             /*!< PWM_T::BRKCTL4_5: CPO0LBEN Mask        */
N
N#define PWM_BRKCTL4_5_CPO1LBEN_Pos       (9)                                               /*!< PWM_T::BRKCTL4_5: CPO1LBEN Position    */
N#define PWM_BRKCTL4_5_CPO1LBEN_Msk       (0x1ul << PWM_BRKCTL4_5_CPO1LBEN_Pos)             /*!< PWM_T::BRKCTL4_5: CPO1LBEN Mask        */
N
N#define PWM_BRKCTL4_5_BRKP0LEN_Pos       (12)                                              /*!< PWM_T::BRKCTL4_5: BRKP0LEN Position    */
N#define PWM_BRKCTL4_5_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP0LEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP0LEN Mask        */
N
N#define PWM_BRKCTL4_5_BRKP1LEN_Pos       (13)                                              /*!< PWM_T::BRKCTL4_5: BRKP1LEN Position    */
N#define PWM_BRKCTL4_5_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP1LEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP1LEN Mask        */
N
N#define PWM_BRKCTL4_5_SYSLBEN_Pos        (15)                                              /*!< PWM_T::BRKCTL4_5: SYSLBEN Position     */
N#define PWM_BRKCTL4_5_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL4_5_SYSLBEN_Pos)              /*!< PWM_T::BRKCTL4_5: SYSLBEN Mask         */
N
N#define PWM_BRKCTL4_5_BRKAEVEN_Pos       (16)                                              /*!< PWM_T::BRKCTL4_5: BRKAEVEN Position    */
N#define PWM_BRKCTL4_5_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL4_5_BRKAEVEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKAEVEN Mask        */
N
N#define PWM_BRKCTL4_5_BRKAODD_Pos        (18)                                              /*!< PWM_T::BRKCTL4_5: BRKAODD Position     */
N#define PWM_BRKCTL4_5_BRKAODD_Msk        (0x3ul << PWM_BRKCTL4_5_BRKAODD_Pos)              /*!< PWM_T::BRKCTL4_5: BRKAODD Mask         */
N
N#define PWM_BRKCTL4_5_ADCEBEN_Pos        (20)                                              /*!< PWM_T::BRKCTL4_5: ADCEBEN Position     */
N#define PWM_BRKCTL4_5_ADCEBEN_Msk        (0x1ul << PWM_BRKCTL4_5_ADCEBEN_Pos)              /*!< PWM_T::BRKCTL4_5: ADCEBEN Mask         */
N
N#define PWM_BRKCTL4_5_ADCLBEN_Pos        (28)                                              /*!< PWM_T::BRKCTL4_5: ADCLBEN Position     */
N#define PWM_BRKCTL4_5_ADCLBEN_Msk        (0x1ul << PWM_BRKCTL4_5_ADCLBEN_Pos)              /*!< PWM_T::BRKCTL4_5: ADCLBEN Mask         */
N
N#define PWM_POLCTL_PINV0_Pos             (0)                                               /*!< PWM_T::POLCTL: PINV0 Position          */
N#define PWM_POLCTL_PINV0_Msk             (0x1ul << PWM_POLCTL_PINV0_Pos)                   /*!< PWM_T::POLCTL: PINV0 Mask              */
N
N#define PWM_POLCTL_PINV1_Pos             (1)                                               /*!< PWM_T::POLCTL: PINV1 Position          */
N#define PWM_POLCTL_PINV1_Msk             (0x1ul << PWM_POLCTL_PINV1_Pos)                   /*!< PWM_T::POLCTL: PINV1 Mask              */
N
N#define PWM_POLCTL_PINV2_Pos             (2)                                               /*!< PWM_T::POLCTL: PINV2 Position          */
N#define PWM_POLCTL_PINV2_Msk             (0x1ul << PWM_POLCTL_PINV2_Pos)                   /*!< PWM_T::POLCTL: PINV2 Mask              */
N
N#define PWM_POLCTL_PINV3_Pos             (3)                                               /*!< PWM_T::POLCTL: PINV3 Position          */
N#define PWM_POLCTL_PINV3_Msk             (0x1ul << PWM_POLCTL_PINV3_Pos)                   /*!< PWM_T::POLCTL: PINV3 Mask              */
N
N#define PWM_POLCTL_PINV4_Pos             (4)                                               /*!< PWM_T::POLCTL: PINV4 Position          */
N#define PWM_POLCTL_PINV4_Msk             (0x1ul << PWM_POLCTL_PINV4_Pos)                   /*!< PWM_T::POLCTL: PINV4 Mask              */
N
N#define PWM_POLCTL_PINV5_Pos             (5)                                               /*!< PWM_T::POLCTL: PINV5 Position          */
N#define PWM_POLCTL_PINV5_Msk             (0x1ul << PWM_POLCTL_PINV5_Pos)                   /*!< PWM_T::POLCTL: PINV5 Mask              */
N
N#define PWM_POEN_POEN0_Pos               (0)                                               /*!< PWM_T::POEN: POEN0 Position            */
N#define PWM_POEN_POEN0_Msk               (0x1ul << PWM_POEN_POEN0_Pos)                     /*!< PWM_T::POEN: POEN0 Mask                */
N
N#define PWM_POEN_POEN1_Pos               (1)                                               /*!< PWM_T::POEN: POEN1 Position            */
N#define PWM_POEN_POEN1_Msk               (0x1ul << PWM_POEN_POEN1_Pos)                     /*!< PWM_T::POEN: POEN1 Mask                */
N
N#define PWM_POEN_POEN2_Pos               (2)                                               /*!< PWM_T::POEN: POEN2 Position            */
N#define PWM_POEN_POEN2_Msk               (0x1ul << PWM_POEN_POEN2_Pos)                     /*!< PWM_T::POEN: POEN2 Mask                */
N
N#define PWM_POEN_POEN3_Pos               (3)                                               /*!< PWM_T::POEN: POEN3 Position            */
N#define PWM_POEN_POEN3_Msk               (0x1ul << PWM_POEN_POEN3_Pos)                     /*!< PWM_T::POEN: POEN3 Mask                */
N
N#define PWM_POEN_POEN4_Pos               (4)                                               /*!< PWM_T::POEN: POEN4 Position            */
N#define PWM_POEN_POEN4_Msk               (0x1ul << PWM_POEN_POEN4_Pos)                     /*!< PWM_T::POEN: POEN4 Mask                */
N
N#define PWM_POEN_POEN5_Pos               (5)                                               /*!< PWM_T::POEN: POEN5 Position            */
N#define PWM_POEN_POEN5_Msk               (0x1ul << PWM_POEN_POEN5_Pos)                     /*!< PWM_T::POEN: POEN5 Mask                */
N
N#define PWM_SWBRK_BRKETRG0_Pos           (0)                                               /*!< PWM_T::SWBRK: BRKETRG0 Position        */
N#define PWM_SWBRK_BRKETRG0_Msk           (0x1ul << PWM_SWBRK_BRKETRG0_Pos)                 /*!< PWM_T::SWBRK: BRKETRG0 Mask            */
N
N#define PWM_SWBRK_BRKETRG2_Pos           (1)                                               /*!< PWM_T::SWBRK: BRKETRG2 Position        */
N#define PWM_SWBRK_BRKETRG2_Msk           (0x1ul << PWM_SWBRK_BRKETRG2_Pos)                 /*!< PWM_T::SWBRK: BRKETRG2 Mask            */
N
N#define PWM_SWBRK_BRKETRG4_Pos           (2)                                               /*!< PWM_T::SWBRK: BRKETRG4 Position        */
N#define PWM_SWBRK_BRKETRG4_Msk           (0x1ul << PWM_SWBRK_BRKETRG4_Pos)                 /*!< PWM_T::SWBRK: BRKETRG4 Mask            */
N
N#define PWM_SWBRK_BRKLTRG0_Pos           (8)                                               /*!< PWM_T::SWBRK: BRKLTRG0 Position        */
N#define PWM_SWBRK_BRKLTRG0_Msk           (0x1ul << PWM_SWBRK_BRKLTRG0_Pos)                 /*!< PWM_T::SWBRK: BRKLTRG0 Mask            */
N
N#define PWM_SWBRK_BRKLTRG2_Pos           (9)                                               /*!< PWM_T::SWBRK: BRKLTRG2 Position        */
N#define PWM_SWBRK_BRKLTRG2_Msk           (0x1ul << PWM_SWBRK_BRKLTRG2_Pos)                 /*!< PWM_T::SWBRK: BRKLTRG2 Mask            */
N
N#define PWM_SWBRK_BRKLTRG4_Pos           (10)                                              /*!< PWM_T::SWBRK: BRKLTRG4 Position        */
N#define PWM_SWBRK_BRKLTRG4_Msk           (0x1ul << PWM_SWBRK_BRKLTRG4_Pos)                 /*!< PWM_T::SWBRK: BRKLTRG4 Mask            */
N
N#define PWM_INTEN0_ZIEN0_Pos             (0)                                               /*!< PWM_T::INTEN0: ZIEN0 Position          */
N#define PWM_INTEN0_ZIEN0_Msk             (0x1ul << PWM_INTEN0_ZIEN0_Pos)                   /*!< PWM_T::INTEN0: ZIEN0 Mask              */
N
N#define PWM_INTEN0_ZIEN1_Pos             (1)                                               /*!< PWM_T::INTEN0: ZIEN1 Position          */
N#define PWM_INTEN0_ZIEN1_Msk             (0x1ul << PWM_INTEN0_ZIEN1_Pos)                   /*!< PWM_T::INTEN0: ZIEN1 Mask              */
N
N#define PWM_INTEN0_ZIEN2_Pos             (2)                                               /*!< PWM_T::INTEN0: ZIEN2 Position          */
N#define PWM_INTEN0_ZIEN2_Msk             (0x1ul << PWM_INTEN0_ZIEN2_Pos)                   /*!< PWM_T::INTEN0: ZIEN2 Mask              */
N
N#define PWM_INTEN0_ZIEN3_Pos             (3)                                               /*!< PWM_T::INTEN0: ZIEN3 Position          */
N#define PWM_INTEN0_ZIEN3_Msk             (0x1ul << PWM_INTEN0_ZIEN3_Pos)                   /*!< PWM_T::INTEN0: ZIEN3 Mask              */
N
N#define PWM_INTEN0_ZIEN4_Pos             (4)                                               /*!< PWM_T::INTEN0: ZIEN4 Position          */
N#define PWM_INTEN0_ZIEN4_Msk             (0x1ul << PWM_INTEN0_ZIEN4_Pos)                   /*!< PWM_T::INTEN0: ZIEN4 Mask              */
N
N#define PWM_INTEN0_ZIEN5_Pos             (5)                                               /*!< PWM_T::INTEN0: ZIEN5 Position          */
N#define PWM_INTEN0_ZIEN5_Msk             (0x1ul << PWM_INTEN0_ZIEN5_Pos)                   /*!< PWM_T::INTEN0: ZIEN5 Mask              */
N
N#define PWM_INTEN0_IFAIEN0_1_Pos         (7)                                               /*!< PWM_T::INTEN0: IFAIEN0_1 Position      */
N#define PWM_INTEN0_IFAIEN0_1_Msk         (0x1ul << PWM_INTEN0_IFAIEN0_1_Pos)               /*!< PWM_T::INTEN0: IFAIEN0_1 Mask          */
N
N#define PWM_INTEN0_PIEN0_Pos             (8)                                               /*!< PWM_T::INTEN0: PIEN0 Position          */
N#define PWM_INTEN0_PIEN0_Msk             (0x1ul << PWM_INTEN0_PIEN0_Pos)                   /*!< PWM_T::INTEN0: PIEN0 Mask              */
N
N#define PWM_INTEN0_PIEN1_Pos             (9)                                               /*!< PWM_T::INTEN0: PIEN1 Position          */
N#define PWM_INTEN0_PIEN1_Msk             (0x1ul << PWM_INTEN0_PIEN1_Pos)                   /*!< PWM_T::INTEN0: PIEN1 Mask              */
N
N#define PWM_INTEN0_PIEN2_Pos             (10)                                              /*!< PWM_T::INTEN0: PIEN2 Position          */
N#define PWM_INTEN0_PIEN2_Msk             (0x1ul << PWM_INTEN0_PIEN2_Pos)                   /*!< PWM_T::INTEN0: PIEN2 Mask              */
N
N#define PWM_INTEN0_PIEN3_Pos             (11)                                              /*!< PWM_T::INTEN0: PIEN3 Position          */
N#define PWM_INTEN0_PIEN3_Msk             (0x1ul << PWM_INTEN0_PIEN3_Pos)                   /*!< PWM_T::INTEN0: PIEN3 Mask              */
N
N#define PWM_INTEN0_PIEN4_Pos             (12)                                              /*!< PWM_T::INTEN0: PIEN4 Position          */
N#define PWM_INTEN0_PIEN4_Msk             (0x1ul << PWM_INTEN0_PIEN4_Pos)                   /*!< PWM_T::INTEN0: PIEN4 Mask              */
N
N#define PWM_INTEN0_PIEN5_Pos             (13)                                              /*!< PWM_T::INTEN0: PIEN5 Position          */
N#define PWM_INTEN0_PIEN5_Msk             (0x1ul << PWM_INTEN0_PIEN5_Pos)                   /*!< PWM_T::INTEN0: PIEN5 Mask              */
N
N#define PWM_INTEN0_IFAIEN2_3_Pos         (15)                                              /*!< PWM_T::INTEN0: IFAIEN2_3 Position      */
N#define PWM_INTEN0_IFAIEN2_3_Msk         (0x1ul << PWM_INTEN0_IFAIEN2_3_Pos)               /*!< PWM_T::INTEN0: IFAIEN2_3 Mask          */
N
N#define PWM_INTEN0_CMPUIEN0_Pos          (16)                                              /*!< PWM_T::INTEN0: CMPUIEN0 Position       */
N#define PWM_INTEN0_CMPUIEN0_Msk          (0x1ul << PWM_INTEN0_CMPUIEN0_Pos)                /*!< PWM_T::INTEN0: CMPUIEN0 Mask           */
N
N#define PWM_INTEN0_CMPUIEN1_Pos          (17)                                              /*!< PWM_T::INTEN0: CMPUIEN1 Position       */
N#define PWM_INTEN0_CMPUIEN1_Msk          (0x1ul << PWM_INTEN0_CMPUIEN1_Pos)                /*!< PWM_T::INTEN0: CMPUIEN1 Mask           */
N
N#define PWM_INTEN0_CMPUIEN2_Pos          (18)                                              /*!< PWM_T::INTEN0: CMPUIEN2 Position       */
N#define PWM_INTEN0_CMPUIEN2_Msk          (0x1ul << PWM_INTEN0_CMPUIEN2_Pos)                /*!< PWM_T::INTEN0: CMPUIEN2 Mask           */
N
N#define PWM_INTEN0_CMPUIEN3_Pos          (19)                                              /*!< PWM_T::INTEN0: CMPUIEN3 Position       */
N#define PWM_INTEN0_CMPUIEN3_Msk          (0x1ul << PWM_INTEN0_CMPUIEN3_Pos)                /*!< PWM_T::INTEN0: CMPUIEN3 Mask           */
N
N#define PWM_INTEN0_CMPUIEN4_Pos          (20)                                              /*!< PWM_T::INTEN0: CMPUIEN4 Position       */
N#define PWM_INTEN0_CMPUIEN4_Msk          (0x1ul << PWM_INTEN0_CMPUIEN4_Pos)                /*!< PWM_T::INTEN0: CMPUIEN4 Mask           */
N
N#define PWM_INTEN0_CMPUIEN5_Pos          (21)                                              /*!< PWM_T::INTEN0: CMPUIEN5 Position       */
N#define PWM_INTEN0_CMPUIEN5_Msk          (0x1ul << PWM_INTEN0_CMPUIEN5_Pos)                /*!< PWM_T::INTEN0: CMPUIEN5 Mask           */
N
N#define PWM_INTEN0_IFAIEN4_5_Pos         (23)                                              /*!< PWM_T::INTEN0: IFAIEN4_5 Position      */
N#define PWM_INTEN0_IFAIEN4_5_Msk         (0x1ul << PWM_INTEN0_IFAIEN4_5_Pos)               /*!< PWM_T::INTEN0: IFAIEN4_5 Mask          */
N
N#define PWM_INTEN0_CMPDIEN0_Pos          (24)                                              /*!< PWM_T::INTEN0: CMPDIEN0 Position       */
N#define PWM_INTEN0_CMPDIEN0_Msk          (0x1ul << PWM_INTEN0_CMPDIEN0_Pos)                /*!< PWM_T::INTEN0: CMPDIEN0 Mask           */
N
N#define PWM_INTEN0_CMPDIEN1_Pos          (25)                                              /*!< PWM_T::INTEN0: CMPDIEN1 Position       */
N#define PWM_INTEN0_CMPDIEN1_Msk          (0x1ul << PWM_INTEN0_CMPDIEN1_Pos)                /*!< PWM_T::INTEN0: CMPDIEN1 Mask           */
N
N#define PWM_INTEN0_CMPDIEN2_Pos          (26)                                              /*!< PWM_T::INTEN0: CMPDIEN2 Position       */
N#define PWM_INTEN0_CMPDIEN2_Msk          (0x1ul << PWM_INTEN0_CMPDIEN2_Pos)                /*!< PWM_T::INTEN0: CMPDIEN2 Mask           */
N
N#define PWM_INTEN0_CMPDIEN3_Pos          (27)                                              /*!< PWM_T::INTEN0: CMPDIEN3 Position       */
N#define PWM_INTEN0_CMPDIEN3_Msk          (0x1ul << PWM_INTEN0_CMPDIEN3_Pos)                /*!< PWM_T::INTEN0: CMPDIEN3 Mask           */
N
N#define PWM_INTEN0_CMPDIEN4_Pos          (28)                                              /*!< PWM_T::INTEN0: CMPDIEN4 Position       */
N#define PWM_INTEN0_CMPDIEN4_Msk          (0x1ul << PWM_INTEN0_CMPDIEN4_Pos)                /*!< PWM_T::INTEN0: CMPDIEN4 Mask           */
N
N#define PWM_INTEN0_CMPDIEN5_Pos          (29)                                              /*!< PWM_T::INTEN0: CMPDIEN5 Position       */
N#define PWM_INTEN0_CMPDIEN5_Msk          (0x1ul << PWM_INTEN0_CMPDIEN5_Pos)                /*!< PWM_T::INTEN0: CMPDIEN5 Mask           */
N
N#define PWM_INTEN1_BRKEIEN0_1_Pos        (0)                                               /*!< PWM_T::INTEN1: BRKEIEN0_1 Position     */
N#define PWM_INTEN1_BRKEIEN0_1_Msk        (0x1ul << PWM_INTEN1_BRKEIEN0_1_Pos)              /*!< PWM_T::INTEN1: BRKEIEN0_1 Mask         */
N
N#define PWM_INTEN1_BRKEIEN2_3_Pos        (1)                                               /*!< PWM_T::INTEN1: BRKEIEN2_3 Position     */
N#define PWM_INTEN1_BRKEIEN2_3_Msk        (0x1ul << PWM_INTEN1_BRKEIEN2_3_Pos)              /*!< PWM_T::INTEN1: BRKEIEN2_3 Mask         */
N
N#define PWM_INTEN1_BRKEIEN4_5_Pos        (2)                                               /*!< PWM_T::INTEN1: BRKEIEN4_5 Position     */
N#define PWM_INTEN1_BRKEIEN4_5_Msk        (0x1ul << PWM_INTEN1_BRKEIEN4_5_Pos)              /*!< PWM_T::INTEN1: BRKEIEN4_5 Mask         */
N
N#define PWM_INTEN1_BRKLIEN0_1_Pos        (8)                                               /*!< PWM_T::INTEN1: BRKLIEN0_1 Position     */
N#define PWM_INTEN1_BRKLIEN0_1_Msk        (0x1ul << PWM_INTEN1_BRKLIEN0_1_Pos)              /*!< PWM_T::INTEN1: BRKLIEN0_1 Mask         */
N
N#define PWM_INTEN1_BRKLIEN2_3_Pos        (9)                                               /*!< PWM_T::INTEN1: BRKLIEN2_3 Position     */
N#define PWM_INTEN1_BRKLIEN2_3_Msk        (0x1ul << PWM_INTEN1_BRKLIEN2_3_Pos)              /*!< PWM_T::INTEN1: BRKLIEN2_3 Mask         */
N
N#define PWM_INTEN1_BRKLIEN4_5_Pos        (10)                                              /*!< PWM_T::INTEN1: BRKLIEN4_5 Position     */
N#define PWM_INTEN1_BRKLIEN4_5_Msk        (0x1ul << PWM_INTEN1_BRKLIEN4_5_Pos)              /*!< PWM_T::INTEN1: BRKLIEN4_5 Mask         */
N
N#define PWM_INTSTS0_ZIF0_Pos             (0)                                               /*!< PWM_T::INTSTS0: ZIF0 Position          */
N#define PWM_INTSTS0_ZIF0_Msk             (0x1ul << PWM_INTSTS0_ZIF0_Pos)                   /*!< PWM_T::INTSTS0: ZIF0 Mask              */
N
N#define PWM_INTSTS0_ZIF1_Pos             (1)                                               /*!< PWM_T::INTSTS0: ZIF1 Position          */
N#define PWM_INTSTS0_ZIF1_Msk             (0x1ul << PWM_INTSTS0_ZIF1_Pos)                   /*!< PWM_T::INTSTS0: ZIF1 Mask              */
N
N#define PWM_INTSTS0_ZIF2_Pos             (2)                                               /*!< PWM_T::INTSTS0: ZIF2 Position          */
N#define PWM_INTSTS0_ZIF2_Msk             (0x1ul << PWM_INTSTS0_ZIF2_Pos)                   /*!< PWM_T::INTSTS0: ZIF2 Mask              */
N
N#define PWM_INTSTS0_ZIF3_Pos             (3)                                               /*!< PWM_T::INTSTS0: ZIF3 Position          */
N#define PWM_INTSTS0_ZIF3_Msk             (0x1ul << PWM_INTSTS0_ZIF3_Pos)                   /*!< PWM_T::INTSTS0: ZIF3 Mask              */
N
N#define PWM_INTSTS0_ZIF4_Pos             (4)                                               /*!< PWM_T::INTSTS0: ZIF4 Position          */
N#define PWM_INTSTS0_ZIF4_Msk             (0x1ul << PWM_INTSTS0_ZIF4_Pos)                   /*!< PWM_T::INTSTS0: ZIF4 Mask              */
N
N#define PWM_INTSTS0_ZIF5_Pos             (5)                                               /*!< PWM_T::INTSTS0: ZIF5 Position          */
N#define PWM_INTSTS0_ZIF5_Msk             (0x1ul << PWM_INTSTS0_ZIF5_Pos)                   /*!< PWM_T::INTSTS0: ZIF5 Mask              */
N
N#define PWM_INTSTS0_IFAIF0_1_Pos         (7)                                               /*!< PWM_T::INTSTS0: IFAIF0_1 Position      */
N#define PWM_INTSTS0_IFAIF0_1_Msk         (0x1ul << PWM_INTSTS0_IFAIF0_1_Pos)               /*!< PWM_T::INTSTS0: IFAIF0_1 Mask          */
N
N#define PWM_INTSTS0_PIF0_Pos             (8)                                               /*!< PWM_T::INTSTS0: PIF0 Position          */
N#define PWM_INTSTS0_PIF0_Msk             (0x1ul << PWM_INTSTS0_PIF0_Pos)                   /*!< PWM_T::INTSTS0: PIF0 Mask              */
N
N#define PWM_INTSTS0_PIF1_Pos             (9)                                               /*!< PWM_T::INTSTS0: PIF1 Position          */
N#define PWM_INTSTS0_PIF1_Msk             (0x1ul << PWM_INTSTS0_PIF1_Pos)                   /*!< PWM_T::INTSTS0: PIF1 Mask              */
N
N#define PWM_INTSTS0_PIF2_Pos             (10)                                              /*!< PWM_T::INTSTS0: PIF2 Position          */
N#define PWM_INTSTS0_PIF2_Msk             (0x1ul << PWM_INTSTS0_PIF2_Pos)                   /*!< PWM_T::INTSTS0: PIF2 Mask              */
N
N#define PWM_INTSTS0_PIF3_Pos             (11)                                              /*!< PWM_T::INTSTS0: PIF3 Position          */
N#define PWM_INTSTS0_PIF3_Msk             (0x1ul << PWM_INTSTS0_PIF3_Pos)                   /*!< PWM_T::INTSTS0: PIF3 Mask              */
N
N#define PWM_INTSTS0_PIF4_Pos             (12)                                              /*!< PWM_T::INTSTS0: PIF4 Position          */
N#define PWM_INTSTS0_PIF4_Msk             (0x1ul << PWM_INTSTS0_PIF4_Pos)                   /*!< PWM_T::INTSTS0: PIF4 Mask              */
N
N#define PWM_INTSTS0_PIF5_Pos             (13)                                              /*!< PWM_T::INTSTS0: PIF5 Position          */
N#define PWM_INTSTS0_PIF5_Msk             (0x1ul << PWM_INTSTS0_PIF5_Pos)                   /*!< PWM_T::INTSTS0: PIF5 Mask              */
N
N#define PWM_INTSTS0_IFAIF2_3_Pos         (15)                                              /*!< PWM_T::INTSTS0: IFAIF2_3 Position      */
N#define PWM_INTSTS0_IFAIF2_3_Msk         (0x1ul << PWM_INTSTS0_IFAIF2_3_Pos)               /*!< PWM_T::INTSTS0: IFAIF2_3 Mask          */
N
N#define PWM_INTSTS0_CMPUIF0_Pos          (16)                                              /*!< PWM_T::INTSTS0: CMPUIF0 Position       */
N#define PWM_INTSTS0_CMPUIF0_Msk          (0x1ul << PWM_INTSTS0_CMPUIF0_Pos)                /*!< PWM_T::INTSTS0: CMPUIF0 Mask           */
N
N#define PWM_INTSTS0_CMPUIF1_Pos          (17)                                              /*!< PWM_T::INTSTS0: CMPUIF1 Position       */
N#define PWM_INTSTS0_CMPUIF1_Msk          (0x1ul << PWM_INTSTS0_CMPUIF1_Pos)                /*!< PWM_T::INTSTS0: CMPUIF1 Mask           */
N
N#define PWM_INTSTS0_CMPUIF2_Pos          (18)                                              /*!< PWM_T::INTSTS0: CMPUIF2 Position       */
N#define PWM_INTSTS0_CMPUIF2_Msk          (0x1ul << PWM_INTSTS0_CMPUIF2_Pos)                /*!< PWM_T::INTSTS0: CMPUIF2 Mask           */
N
N#define PWM_INTSTS0_CMPUIF3_Pos          (19)                                              /*!< PWM_T::INTSTS0: CMPUIF3 Position       */
N#define PWM_INTSTS0_CMPUIF3_Msk          (0x1ul << PWM_INTSTS0_CMPUIF3_Pos)                /*!< PWM_T::INTSTS0: CMPUIF3 Mask           */
N
N#define PWM_INTSTS0_CMPUIF4_Pos          (20)                                              /*!< PWM_T::INTSTS0: CMPUIF4 Position       */
N#define PWM_INTSTS0_CMPUIF4_Msk          (0x1ul << PWM_INTSTS0_CMPUIF4_Pos)                /*!< PWM_T::INTSTS0: CMPUIF4 Mask           */
N
N#define PWM_INTSTS0_CMPUIF5_Pos          (21)                                              /*!< PWM_T::INTSTS0: CMPUIF5 Position       */
N#define PWM_INTSTS0_CMPUIF5_Msk          (0x1ul << PWM_INTSTS0_CMPUIF5_Pos)                /*!< PWM_T::INTSTS0: CMPUIF5 Mask           */
N
N#define PWM_INTSTS0_IFAIF4_5_Pos         (23)                                              /*!< PWM_T::INTSTS0: IFAIF4_5 Position      */
N#define PWM_INTSTS0_IFAIF4_5_Msk         (0x1ul << PWM_INTSTS0_IFAIF4_5_Pos)               /*!< PWM_T::INTSTS0: IFAIF4_5 Mask          */
N
N#define PWM_INTSTS0_CMPDIF0_Pos          (24)                                              /*!< PWM_T::INTSTS0: CMPDIF0 Position       */
N#define PWM_INTSTS0_CMPDIF0_Msk          (0x1ul << PWM_INTSTS0_CMPDIF0_Pos)                /*!< PWM_T::INTSTS0: CMPDIF0 Mask           */
N
N#define PWM_INTSTS0_CMPDIF1_Pos          (25)                                              /*!< PWM_T::INTSTS0: CMPDIF1 Position       */
N#define PWM_INTSTS0_CMPDIF1_Msk          (0x1ul << PWM_INTSTS0_CMPDIF1_Pos)                /*!< PWM_T::INTSTS0: CMPDIF1 Mask           */
N
N#define PWM_INTSTS0_CMPDIF2_Pos          (26)                                              /*!< PWM_T::INTSTS0: CMPDIF2 Position       */
N#define PWM_INTSTS0_CMPDIF2_Msk          (0x1ul << PWM_INTSTS0_CMPDIF2_Pos)                /*!< PWM_T::INTSTS0: CMPDIF2 Mask           */
N
N#define PWM_INTSTS0_CMPDIF3_Pos          (27)                                              /*!< PWM_T::INTSTS0: CMPDIF3 Position       */
N#define PWM_INTSTS0_CMPDIF3_Msk          (0x1ul << PWM_INTSTS0_CMPDIF3_Pos)                /*!< PWM_T::INTSTS0: CMPDIF3 Mask           */
N
N#define PWM_INTSTS0_CMPDIF4_Pos          (28)                                              /*!< PWM_T::INTSTS0: CMPDIF4 Position       */
N#define PWM_INTSTS0_CMPDIF4_Msk          (0x1ul << PWM_INTSTS0_CMPDIF4_Pos)                /*!< PWM_T::INTSTS0: CMPDIF4 Mask           */
N
N#define PWM_INTSTS0_CMPDIF5_Pos          (29)                                              /*!< PWM_T::INTSTS0: CMPDIF5 Position       */
N#define PWM_INTSTS0_CMPDIF5_Msk          (0x1ul << PWM_INTSTS0_CMPDIF5_Pos)                /*!< PWM_T::INTSTS0: CMPDIF5 Mask           */
N
N#define PWM_INTSTS1_BRKEIF0_Pos          (0)                                               /*!< PWM_T::INTSTS1: BRKEIF0 Position       */
N#define PWM_INTSTS1_BRKEIF0_Msk          (0x1ul << PWM_INTSTS1_BRKEIF0_Pos)                /*!< PWM_T::INTSTS1: BRKEIF0 Mask           */
N
N#define PWM_INTSTS1_BRKEIF1_Pos          (1)                                               /*!< PWM_T::INTSTS1: BRKEIF1 Position       */
N#define PWM_INTSTS1_BRKEIF1_Msk          (0x1ul << PWM_INTSTS1_BRKEIF1_Pos)                /*!< PWM_T::INTSTS1: BRKEIF1 Mask           */
N
N#define PWM_INTSTS1_BRKEIF2_Pos          (2)                                               /*!< PWM_T::INTSTS1: BRKEIF2 Position       */
N#define PWM_INTSTS1_BRKEIF2_Msk          (0x1ul << PWM_INTSTS1_BRKEIF2_Pos)                /*!< PWM_T::INTSTS1: BRKEIF2 Mask           */
N
N#define PWM_INTSTS1_BRKEIF3_Pos          (3)                                               /*!< PWM_T::INTSTS1: BRKEIF3 Position       */
N#define PWM_INTSTS1_BRKEIF3_Msk          (0x1ul << PWM_INTSTS1_BRKEIF3_Pos)                /*!< PWM_T::INTSTS1: BRKEIF3 Mask           */
N
N#define PWM_INTSTS1_BRKEIF4_Pos          (4)                                               /*!< PWM_T::INTSTS1: BRKEIF4 Position       */
N#define PWM_INTSTS1_BRKEIF4_Msk          (0x1ul << PWM_INTSTS1_BRKEIF4_Pos)                /*!< PWM_T::INTSTS1: BRKEIF4 Mask           */
N
N#define PWM_INTSTS1_BRKEIF5_Pos          (5)                                               /*!< PWM_T::INTSTS1: BRKEIF5 Position       */
N#define PWM_INTSTS1_BRKEIF5_Msk          (0x1ul << PWM_INTSTS1_BRKEIF5_Pos)                /*!< PWM_T::INTSTS1: BRKEIF5 Mask           */
N
N#define PWM_INTSTS1_BRKLIFn_Pos          (8)                                               /*!< PWM_T::INTSTS1: BRKLIFn Position       */
N#define PWM_INTSTS1_BRKLIFn_Msk          (0x1ul << PWM_INTSTS1_BRKLIFn_Pos)                /*!< PWM_T::INTSTS1: BRKLIFn Mask           */
N
N#define PWM_INTSTS1_BRKESTS0_Pos         (16)                                              /*!< PWM_T::INTSTS1: BRKESTS0 Position      */
N#define PWM_INTSTS1_BRKESTS0_Msk         (0x1ul << PWM_INTSTS1_BRKESTS0_Pos)               /*!< PWM_T::INTSTS1: BRKESTS0 Mask          */
N
N#define PWM_INTSTS1_BRKESTS1_Pos         (17)                                              /*!< PWM_T::INTSTS1: BRKESTS1 Position      */
N#define PWM_INTSTS1_BRKESTS1_Msk         (0x1ul << PWM_INTSTS1_BRKESTS1_Pos)               /*!< PWM_T::INTSTS1: BRKESTS1 Mask          */
N
N#define PWM_INTSTS1_BRKESTS2_Pos         (18)                                              /*!< PWM_T::INTSTS1: BRKESTS2 Position      */
N#define PWM_INTSTS1_BRKESTS2_Msk         (0x1ul << PWM_INTSTS1_BRKESTS2_Pos)               /*!< PWM_T::INTSTS1: BRKESTS2 Mask          */
N
N#define PWM_INTSTS1_BRKESTS3_Pos         (19)                                              /*!< PWM_T::INTSTS1: BRKESTS3 Position      */
N#define PWM_INTSTS1_BRKESTS3_Msk         (0x1ul << PWM_INTSTS1_BRKESTS3_Pos)               /*!< PWM_T::INTSTS1: BRKESTS3 Mask          */
N
N#define PWM_INTSTS1_BRKESTS4_Pos         (20)                                              /*!< PWM_T::INTSTS1: BRKESTS4 Position      */
N#define PWM_INTSTS1_BRKESTS4_Msk         (0x1ul << PWM_INTSTS1_BRKESTS4_Pos)               /*!< PWM_T::INTSTS1: BRKESTS4 Mask          */
N
N#define PWM_INTSTS1_BRKESTS5_Pos         (21)                                              /*!< PWM_T::INTSTS1: BRKESTS5 Position      */
N#define PWM_INTSTS1_BRKESTS5_Msk         (0x1ul << PWM_INTSTS1_BRKESTS5_Pos)               /*!< PWM_T::INTSTS1: BRKESTS5 Mask          */
N
N#define PWM_INTSTS1_BRKLSTS0_Pos         (24)                                              /*!< PWM_T::INTSTS1: BRKLSTS0 Position      */
N#define PWM_INTSTS1_BRKLSTS0_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS0_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS0 Mask          */
N
N#define PWM_INTSTS1_BRKLSTS1_Pos         (25)                                              /*!< PWM_T::INTSTS1: BRKLSTS1 Position      */
N#define PWM_INTSTS1_BRKLSTS1_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS1_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS1 Mask          */
N
N#define PWM_INTSTS1_BRKLSTS2_Pos         (26)                                              /*!< PWM_T::INTSTS1: BRKLSTS2 Position      */
N#define PWM_INTSTS1_BRKLSTS2_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS2_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS2 Mask          */
N
N#define PWM_INTSTS1_BRKLSTS3_Pos         (27)                                              /*!< PWM_T::INTSTS1: BRKLSTS3 Position      */
N#define PWM_INTSTS1_BRKLSTS3_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS3_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS3 Mask          */
N
N#define PWM_INTSTS1_BRKLSTS4_Pos         (28)                                              /*!< PWM_T::INTSTS1: BRKLSTS4 Position      */
N#define PWM_INTSTS1_BRKLSTS4_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS4_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS4 Mask          */
N
N#define PWM_INTSTS1_BRKLSTS5_Pos         (29)                                              /*!< PWM_T::INTSTS1: BRKLSTS5 Position      */
N#define PWM_INTSTS1_BRKLSTS5_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS5_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS5 Mask          */
N
N#define PWM_IFA_IFCNT0_1_Pos             (0)                                               /*!< PWM_T::IFA: IFCNT0_1 Position          */
N#define PWM_IFA_IFCNT0_1_Msk             (0xful << PWM_IFA_IFCNT0_1_Pos)                   /*!< PWM_T::IFA: IFCNT0_1 Mask              */
N
N#define PWM_IFA_IFSEL0_1_Pos             (4)                                               /*!< PWM_T::IFA: IFSEL0_1 Position          */
N#define PWM_IFA_IFSEL0_1_Msk             (0x7ul << PWM_IFA_IFSEL0_1_Pos)                   /*!< PWM_T::IFA: IFSEL0_1 Mask              */
N
N#define PWM_IFA_IFAEN0_1_Pos             (7)                                               /*!< PWM_T::IFA: IFAEN0_1 Position          */
N#define PWM_IFA_IFAEN0_1_Msk             (0x1ul << PWM_IFA_IFAEN0_1_Pos)                   /*!< PWM_T::IFA: IFAEN0_1 Mask              */
N
N#define PWM_IFA_IFCNT2_3_Pos             (8)                                               /*!< PWM_T::IFA: IFCNT2_3 Position          */
N#define PWM_IFA_IFCNT2_3_Msk             (0xful << PWM_IFA_IFCNT2_3_Pos)                   /*!< PWM_T::IFA: IFCNT2_3 Mask              */
N
N#define PWM_IFA_IFSEL2_3_Pos             (12)                                              /*!< PWM_T::IFA: IFSEL2_3 Position          */
N#define PWM_IFA_IFSEL2_3_Msk             (0x7ul << PWM_IFA_IFSEL2_3_Pos)                   /*!< PWM_T::IFA: IFSEL2_3 Mask              */
N
N#define PWM_IFA_IFAEN2_3_Pos             (15)                                              /*!< PWM_T::IFA: IFAEN2_3 Position          */
N#define PWM_IFA_IFAEN2_3_Msk             (0x1ul << PWM_IFA_IFAEN2_3_Pos)                   /*!< PWM_T::IFA: IFAEN2_3 Mask              */
N
N#define PWM_IFA_IFCNT4_5_Pos             (16)                                              /*!< PWM_T::IFA: IFCNT4_5 Position          */
N#define PWM_IFA_IFCNT4_5_Msk             (0xful << PWM_IFA_IFCNT4_5_Pos)                   /*!< PWM_T::IFA: IFCNT4_5 Mask              */
N
N#define PWM_IFA_IFSEL4_5_Pos             (20)                                              /*!< PWM_T::IFA: IFSEL4_5 Position          */
N#define PWM_IFA_IFSEL4_5_Msk             (0x7ul << PWM_IFA_IFSEL4_5_Pos)                   /*!< PWM_T::IFA: IFSEL4_5 Mask              */
N
N#define PWM_IFA_IFAEN4_5_Pos             (23)                                              /*!< PWM_T::IFA: IFAEN4_5 Position          */
N#define PWM_IFA_IFAEN4_5_Msk             (0x1ul << PWM_IFA_IFAEN4_5_Pos)                   /*!< PWM_T::IFA: IFAEN4_5 Mask              */
N
N#define PWM_ADCTS0_TRGSEL0_Pos           (0)                                               /*!< PWM_T::ADCTS0: TRGSEL0 Position        */
N#define PWM_ADCTS0_TRGSEL0_Msk           (0xful << PWM_ADCTS0_TRGSEL0_Pos)                 /*!< PWM_T::ADCTS0: TRGSEL0 Mask            */
N
N#define PWM_ADCTS0_TRGEN0_Pos            (7)                                               /*!< PWM_T::ADCTS0: TRGEN0 Position         */
N#define PWM_ADCTS0_TRGEN0_Msk            (0x1ul << PWM_ADCTS0_TRGEN0_Pos)                  /*!< PWM_T::ADCTS0: TRGEN0 Mask             */
N
N#define PWM_ADCTS0_TRGSEL1_Pos           (8)                                               /*!< PWM_T::ADCTS0: TRGSEL1 Position        */
N#define PWM_ADCTS0_TRGSEL1_Msk           (0xful << PWM_ADCTS0_TRGSEL1_Pos)                 /*!< PWM_T::ADCTS0: TRGSEL1 Mask            */
N
N#define PWM_ADCTS0_TRGEN1_Pos            (15)                                              /*!< PWM_T::ADCTS0: TRGEN1 Position         */
N#define PWM_ADCTS0_TRGEN1_Msk            (0x1ul << PWM_ADCTS0_TRGEN1_Pos)                  /*!< PWM_T::ADCTS0: TRGEN1 Mask             */
N
N#define PWM_ADCTS0_TRGSEL2_Pos           (16)                                              /*!< PWM_T::ADCTS0: TRGSEL2 Position        */
N#define PWM_ADCTS0_TRGSEL2_Msk           (0xful << PWM_ADCTS0_TRGSEL2_Pos)                 /*!< PWM_T::ADCTS0: TRGSEL2 Mask            */
N
N#define PWM_ADCTS0_TRGEN2_Pos            (23)                                              /*!< PWM_T::ADCTS0: TRGEN2 Position         */
N#define PWM_ADCTS0_TRGEN2_Msk            (0x1ul << PWM_ADCTS0_TRGEN2_Pos)                  /*!< PWM_T::ADCTS0: TRGEN2 Mask             */
N
N#define PWM_ADCTS0_TRGSEL3_Pos           (24)                                              /*!< PWM_T::ADCTS0: TRGSEL3 Position        */
N#define PWM_ADCTS0_TRGSEL3_Msk           (0xful << PWM_ADCTS0_TRGSEL3_Pos)                 /*!< PWM_T::ADCTS0: TRGSEL3 Mask            */
N
N#define PWM_ADCTS0_TRGEN3_Pos            (31)                                              /*!< PWM_T::ADCTS0: TRGEN3 Position         */
N#define PWM_ADCTS0_TRGEN3_Msk            (0x1ul << PWM_ADCTS0_TRGEN3_Pos)                  /*!< PWM_T::ADCTS0: TRGEN3 Mask             */
N
N#define PWM_ADCTS1_TRGSEL4_Pos           (0)                                               /*!< PWM_T::ADCTS1: TRGSEL4 Position        */
N#define PWM_ADCTS1_TRGSEL4_Msk           (0xful << PWM_ADCTS1_TRGSEL4_Pos)                 /*!< PWM_T::ADCTS1: TRGSEL4 Mask            */
N
N#define PWM_ADCTS1_TRGEN4_Pos            (7)                                               /*!< PWM_T::ADCTS1: TRGEN4 Position         */
N#define PWM_ADCTS1_TRGEN4_Msk            (0x1ul << PWM_ADCTS1_TRGEN4_Pos)                  /*!< PWM_T::ADCTS1: TRGEN4 Mask             */
N
N#define PWM_ADCTS1_TRGSEL5_Pos           (8)                                               /*!< PWM_T::ADCTS1: TRGSEL5 Position        */
N#define PWM_ADCTS1_TRGSEL5_Msk           (0xful << PWM_ADCTS1_TRGSEL5_Pos)                 /*!< PWM_T::ADCTS1: TRGSEL5 Mask            */
N
N#define PWM_ADCTS1_TRGEN5_Pos            (15)                                              /*!< PWM_T::ADCTS1: TRGEN5 Position         */
N#define PWM_ADCTS1_TRGEN5_Msk            (0x1ul << PWM_ADCTS1_TRGEN5_Pos)                  /*!< PWM_T::ADCTS1: TRGEN5 Mask             */
N
N#define PWM_FTCMPDAT0_1_FTCMP_Pos        (0)                                               /*!< PWM_T::FTCMPDAT0_1: FTCMP Position     */
N#define PWM_FTCMPDAT0_1_FTCMP_Msk        (0xfffful << PWM_FTCMPDAT0_1_FTCMP_Pos)           /*!< PWM_T::FTCMPDAT0_1: FTCMP Mask         */
N
N#define PWM_FTCMPDAT2_3_FTCMP_Pos        (0)                                               /*!< PWM_T::FTCMPDAT2_3: FTCMP Position     */
N#define PWM_FTCMPDAT2_3_FTCMP_Msk        (0xfffful << PWM_FTCMPDAT2_3_FTCMP_Pos)           /*!< PWM_T::FTCMPDAT2_3: FTCMP Mask         */
N
N#define PWM_FTCMPDAT4_5_FTCMP_Pos        (0)                                               /*!< PWM_T::FTCMPDAT4_5: FTCMP Position     */
N#define PWM_FTCMPDAT4_5_FTCMP_Msk        (0xfffful << PWM_FTCMPDAT4_5_FTCMP_Pos)           /*!< PWM_T::FTCMPDAT4_5: FTCMP Mask         */
N
N#define PWM_SSCTL_SSEN0_Pos              (0)                                               /*!< PWM_T::SSCTL: SSEN0 Position           */
N#define PWM_SSCTL_SSEN0_Msk              (0x1ul << PWM_SSCTL_SSEN0_Pos)                    /*!< PWM_T::SSCTL: SSEN0 Mask               */
N
N#define PWM_SSCTL_SSEN1_Pos              (1)                                               /*!< PWM_T::SSCTL: SSEN1 Position           */
N#define PWM_SSCTL_SSEN1_Msk              (0x1ul << PWM_SSCTL_SSEN1_Pos)                    /*!< PWM_T::SSCTL: SSEN1 Mask               */
N
N#define PWM_SSCTL_SSEN2_Pos              (2)                                               /*!< PWM_T::SSCTL: SSEN2 Position           */
N#define PWM_SSCTL_SSEN2_Msk              (0x1ul << PWM_SSCTL_SSEN2_Pos)                    /*!< PWM_T::SSCTL: SSEN2 Mask               */
N
N#define PWM_SSCTL_SSEN3_Pos              (3)                                               /*!< PWM_T::SSCTL: SSEN3 Position           */
N#define PWM_SSCTL_SSEN3_Msk              (0x1ul << PWM_SSCTL_SSEN3_Pos)                    /*!< PWM_T::SSCTL: SSEN3 Mask               */
N
N#define PWM_SSCTL_SSEN4_Pos              (4)                                               /*!< PWM_T::SSCTL: SSEN4 Position           */
N#define PWM_SSCTL_SSEN4_Msk              (0x1ul << PWM_SSCTL_SSEN4_Pos)                    /*!< PWM_T::SSCTL: SSEN4 Mask               */
N
N#define PWM_SSCTL_SSEN5_Pos              (5)                                               /*!< PWM_T::SSCTL: SSEN5 Position           */
N#define PWM_SSCTL_SSEN5_Msk              (0x1ul << PWM_SSCTL_SSEN5_Pos)                    /*!< PWM_T::SSCTL: SSEN5 Mask               */
N
N#define PWM_SSCTL_SSRC_Pos               (8)                                               /*!< PWM_T::SSCTL: SSRC Position            */
N#define PWM_SSCTL_SSRC_Msk               (0x1ul << PWM_SSCTL_SSRC_Pos)                     /*!< PWM_T::SSCTL: SSRC Mask                */
N
N#define PWM_SSTRG_CNTSEN_Pos             (0)                                               /*!< PWM_T::SSTRG: CNTSEN Position          */
N#define PWM_SSTRG_CNTSEN_Msk             (0x1ul << PWM_SSTRG_CNTSEN_Pos)                   /*!< PWM_T::SSTRG: CNTSEN Mask              */
N
N#define PWM_LEBCTL_LEBEN_Pos             (0)                                               /*!< PWM_T::LEBCTL: LEBEN Position          */
N#define PWM_LEBCTL_LEBEN_Msk             (0x1ul << PWM_LEBCTL_LEBEN_Pos)                   /*!< PWM_T::LEBCTL: LEBEN Mask              */
N
N#define PWM_LEBCTL_SRCEN0_Pos            (8)                                               /*!< PWM_T::LEBCTL: SRCEN0 Position         */
N#define PWM_LEBCTL_SRCEN0_Msk            (0x1ul << PWM_LEBCTL_SRCEN0_Pos)                  /*!< PWM_T::LEBCTL: SRCEN0 Mask             */
N
N#define PWM_LEBCTL_SRCEN2_Pos            (9)                                               /*!< PWM_T::LEBCTL: SRCEN2 Position         */
N#define PWM_LEBCTL_SRCEN2_Msk            (0x1ul << PWM_LEBCTL_SRCEN2_Pos)                  /*!< PWM_T::LEBCTL: SRCEN2 Mask             */
N
N#define PWM_LEBCTL_SRCEN4_Pos            (10)                                              /*!< PWM_T::LEBCTL: SRCEN4 Position         */
N#define PWM_LEBCTL_SRCEN4_Msk            (0x1ul << PWM_LEBCTL_SRCEN4_Pos)                  /*!< PWM_T::LEBCTL: SRCEN4 Mask             */
N
N#define PWM_LEBCTL_TRGTYPE_Pos           (16)                                              /*!< PWM_T::LEBCTL: TRGTYPE Position        */
N#define PWM_LEBCTL_TRGTYPE_Msk           (0x3ul << PWM_LEBCTL_TRGTYPE_Pos)                 /*!< PWM_T::LEBCTL: TRGTYPE Mask            */
N
N#define PWM_LEBCNT_LEBCNT_Pos            (0)                                               /*!< PWM_T::LEBCNT: LEBCNT Position         */
N#define PWM_LEBCNT_LEBCNT_Msk            (0x1fful << PWM_LEBCNT_LEBCNT_Pos)                /*!< PWM_T::LEBCNT: LEBCNT Mask             */
N
N#define PWM_STATUS_CNTMAXF0_Pos          (0)                                               /*!< PWM_T::STATUS: CNTMAXF0 Position       */
N#define PWM_STATUS_CNTMAXF0_Msk          (0x1ul << PWM_STATUS_CNTMAXF0_Pos)                /*!< PWM_T::STATUS: CNTMAXF0 Mask           */
N
N#define PWM_STATUS_CNTMAXF1_Pos          (1)                                               /*!< PWM_T::STATUS: CNTMAXF1 Position       */
N#define PWM_STATUS_CNTMAXF1_Msk          (0x1ul << PWM_STATUS_CNTMAXF1_Pos)                /*!< PWM_T::STATUS: CNTMAXF1 Mask           */
N
N#define PWM_STATUS_CNTMAXF2_Pos          (2)                                               /*!< PWM_T::STATUS: CNTMAXF2 Position       */
N#define PWM_STATUS_CNTMAXF2_Msk          (0x1ul << PWM_STATUS_CNTMAXF2_Pos)                /*!< PWM_T::STATUS: CNTMAXF2 Mask           */
N
N#define PWM_STATUS_CNTMAXF3_Pos          (3)                                               /*!< PWM_T::STATUS: CNTMAXF3 Position       */
N#define PWM_STATUS_CNTMAXF3_Msk          (0x1ul << PWM_STATUS_CNTMAXF3_Pos)                /*!< PWM_T::STATUS: CNTMAXF3 Mask           */
N
N#define PWM_STATUS_CNTMAXF4_Pos          (4)                                               /*!< PWM_T::STATUS: CNTMAXF4 Position       */
N#define PWM_STATUS_CNTMAXF4_Msk          (0x1ul << PWM_STATUS_CNTMAXF4_Pos)                /*!< PWM_T::STATUS: CNTMAXF4 Mask           */
N
N#define PWM_STATUS_CNTMAXF5_Pos          (5)                                               /*!< PWM_T::STATUS: CNTMAXF5 Position       */
N#define PWM_STATUS_CNTMAXF5_Msk          (0x1ul << PWM_STATUS_CNTMAXF5_Pos)                /*!< PWM_T::STATUS: CNTMAXF5 Mask           */
N
N#define PWM_STATUS_SYNCINF0_Pos          (8)                                               /*!< PWM_T::STATUS: SYNCINF0 Position       */
N#define PWM_STATUS_SYNCINF0_Msk          (0x1ul << PWM_STATUS_SYNCINF0_Pos)                /*!< PWM_T::STATUS: SYNCINF0 Mask           */
N
N#define PWM_STATUS_SYNCINF2_Pos          (9)                                               /*!< PWM_T::STATUS: SYNCINF2 Position       */
N#define PWM_STATUS_SYNCINF2_Msk          (0x1ul << PWM_STATUS_SYNCINF2_Pos)                /*!< PWM_T::STATUS: SYNCINF2 Mask           */
N
N#define PWM_STATUS_SYNCINF4_Pos          (10)                                              /*!< PWM_T::STATUS: SYNCINF4 Position       */
N#define PWM_STATUS_SYNCINF4_Msk          (0x1ul << PWM_STATUS_SYNCINF4_Pos)                /*!< PWM_T::STATUS: SYNCINF4 Mask           */
N
N#define PWM_STATUS_ADCTRGF0_Pos          (16)                                              /*!< PWM_T::STATUS: ADCTRGF0 Position       */
N#define PWM_STATUS_ADCTRGF0_Msk          (0x1ul << PWM_STATUS_ADCTRGF0_Pos)                /*!< PWM_T::STATUS: ADCTRGF0 Mask           */
N
N#define PWM_STATUS_ADCTRGF1_Pos          (17)                                              /*!< PWM_T::STATUS: ADCTRGF1 Position       */
N#define PWM_STATUS_ADCTRGF1_Msk          (0x1ul << PWM_STATUS_ADCTRGF1_Pos)                /*!< PWM_T::STATUS: ADCTRGF1 Mask           */
N
N#define PWM_STATUS_ADCTRGF2_Pos          (18)                                              /*!< PWM_T::STATUS: ADCTRGF2 Position       */
N#define PWM_STATUS_ADCTRGF2_Msk          (0x1ul << PWM_STATUS_ADCTRGF2_Pos)                /*!< PWM_T::STATUS: ADCTRGF2 Mask           */
N
N#define PWM_STATUS_ADCTRGF3_Pos          (19)                                              /*!< PWM_T::STATUS: ADCTRGF3 Position       */
N#define PWM_STATUS_ADCTRGF3_Msk          (0x1ul << PWM_STATUS_ADCTRGF3_Pos)                /*!< PWM_T::STATUS: ADCTRGF3 Mask           */
N
N#define PWM_STATUS_ADCTRGF4_Pos          (20)                                              /*!< PWM_T::STATUS: ADCTRGF4 Position       */
N#define PWM_STATUS_ADCTRGF4_Msk          (0x1ul << PWM_STATUS_ADCTRGF4_Pos)                /*!< PWM_T::STATUS: ADCTRGF4 Mask           */
N
N#define PWM_STATUS_ADCTRGF5_Pos          (21)                                              /*!< PWM_T::STATUS: ADCTRGF5 Position       */
N#define PWM_STATUS_ADCTRGF5_Msk          (0x1ul << PWM_STATUS_ADCTRGF5_Pos)                /*!< PWM_T::STATUS: ADCTRGF5 Mask           */
N
N#define PWM_CAPINEN_CAPINEN0_Pos         (0)                                               /*!< PWM_T::CAPINEN: CAPINEN0 Position      */
N#define PWM_CAPINEN_CAPINEN0_Msk         (0x1ul << PWM_CAPINEN_CAPINEN0_Pos)               /*!< PWM_T::CAPINEN: CAPINEN0 Mask          */
N
N#define PWM_CAPINEN_CAPINEN1_Pos         (1)                                               /*!< PWM_T::CAPINEN: CAPINEN1 Position      */
N#define PWM_CAPINEN_CAPINEN1_Msk         (0x1ul << PWM_CAPINEN_CAPINEN1_Pos)               /*!< PWM_T::CAPINEN: CAPINEN1 Mask          */
N
N#define PWM_CAPINEN_CAPINEN2_Pos         (2)                                               /*!< PWM_T::CAPINEN: CAPINEN2 Position      */
N#define PWM_CAPINEN_CAPINEN2_Msk         (0x1ul << PWM_CAPINEN_CAPINEN2_Pos)               /*!< PWM_T::CAPINEN: CAPINEN2 Mask          */
N
N#define PWM_CAPINEN_CAPINEN3_Pos         (3)                                               /*!< PWM_T::CAPINEN: CAPINEN3 Position      */
N#define PWM_CAPINEN_CAPINEN3_Msk         (0x1ul << PWM_CAPINEN_CAPINEN3_Pos)               /*!< PWM_T::CAPINEN: CAPINEN3 Mask          */
N
N#define PWM_CAPINEN_CAPINEN4_Pos         (4)                                               /*!< PWM_T::CAPINEN: CAPINEN4 Position      */
N#define PWM_CAPINEN_CAPINEN4_Msk         (0x1ul << PWM_CAPINEN_CAPINEN4_Pos)               /*!< PWM_T::CAPINEN: CAPINEN4 Mask          */
N
N#define PWM_CAPINEN_CAPINEN5_Pos         (5)                                               /*!< PWM_T::CAPINEN: CAPINEN5 Position      */
N#define PWM_CAPINEN_CAPINEN5_Msk         (0x1ul << PWM_CAPINEN_CAPINEN5_Pos)               /*!< PWM_T::CAPINEN: CAPINEN5 Mask          */
N
N#define PWM_CAPCTL_CAPEN0_Pos            (0)                                               /*!< PWM_T::CAPCTL: CAPEN0 Position         */
N#define PWM_CAPCTL_CAPEN0_Msk            (0x1ul << PWM_CAPCTL_CAPEN0_Pos)                  /*!< PWM_T::CAPCTL: CAPEN0 Mask             */
N
N#define PWM_CAPCTL_CAPEN1_Pos            (1)                                               /*!< PWM_T::CAPCTL: CAPEN1 Position         */
N#define PWM_CAPCTL_CAPEN1_Msk            (0x1ul << PWM_CAPCTL_CAPEN1_Pos)                  /*!< PWM_T::CAPCTL: CAPEN1 Mask             */
N
N#define PWM_CAPCTL_CAPEN2_Pos            (2)                                               /*!< PWM_T::CAPCTL: CAPEN2 Position         */
N#define PWM_CAPCTL_CAPEN2_Msk            (0x1ul << PWM_CAPCTL_CAPEN2_Pos)                  /*!< PWM_T::CAPCTL: CAPEN2 Mask             */
N
N#define PWM_CAPCTL_CAPEN3_Pos            (3)                                               /*!< PWM_T::CAPCTL: CAPEN3 Position         */
N#define PWM_CAPCTL_CAPEN3_Msk            (0x1ul << PWM_CAPCTL_CAPEN3_Pos)                  /*!< PWM_T::CAPCTL: CAPEN3 Mask             */
N
N#define PWM_CAPCTL_CAPEN4_Pos            (4)                                               /*!< PWM_T::CAPCTL: CAPEN4 Position         */
N#define PWM_CAPCTL_CAPEN4_Msk            (0x1ul << PWM_CAPCTL_CAPEN4_Pos)                  /*!< PWM_T::CAPCTL: CAPEN4 Mask             */
N
N#define PWM_CAPCTL_CAPEN5_Pos            (5)                                               /*!< PWM_T::CAPCTL: CAPEN5 Position         */
N#define PWM_CAPCTL_CAPEN5_Msk            (0x1ul << PWM_CAPCTL_CAPEN5_Pos)                  /*!< PWM_T::CAPCTL: CAPEN5 Mask             */
N
N#define PWM_CAPCTL_CAPINV0_Pos           (8)                                               /*!< PWM_T::CAPCTL: CAPINV0 Position        */
N#define PWM_CAPCTL_CAPINV0_Msk           (0x1ul << PWM_CAPCTL_CAPINV0_Pos)                 /*!< PWM_T::CAPCTL: CAPINV0 Mask            */
N
N#define PWM_CAPCTL_CAPINV1_Pos           (9)                                               /*!< PWM_T::CAPCTL: CAPINV1 Position        */
N#define PWM_CAPCTL_CAPINV1_Msk           (0x1ul << PWM_CAPCTL_CAPINV1_Pos)                 /*!< PWM_T::CAPCTL: CAPINV1 Mask            */
N
N#define PWM_CAPCTL_CAPINV2_Pos           (10)                                              /*!< PWM_T::CAPCTL: CAPINV2 Position        */
N#define PWM_CAPCTL_CAPINV2_Msk           (0x1ul << PWM_CAPCTL_CAPINV2_Pos)                 /*!< PWM_T::CAPCTL: CAPINV2 Mask            */
N
N#define PWM_CAPCTL_CAPINV3_Pos           (11)                                              /*!< PWM_T::CAPCTL: CAPINV3 Position        */
N#define PWM_CAPCTL_CAPINV3_Msk           (0x1ul << PWM_CAPCTL_CAPINV3_Pos)                 /*!< PWM_T::CAPCTL: CAPINV3 Mask            */
N
N#define PWM_CAPCTL_CAPINV4_Pos           (12)                                              /*!< PWM_T::CAPCTL: CAPINV4 Position        */
N#define PWM_CAPCTL_CAPINV4_Msk           (0x1ul << PWM_CAPCTL_CAPINV4_Pos)                 /*!< PWM_T::CAPCTL: CAPINV4 Mask            */
N
N#define PWM_CAPCTL_CAPINV5_Pos           (13)                                              /*!< PWM_T::CAPCTL: CAPINV5 Position        */
N#define PWM_CAPCTL_CAPINV5_Msk           (0x1ul << PWM_CAPCTL_CAPINV5_Pos)                 /*!< PWM_T::CAPCTL: CAPINV5 Mask            */
N
N#define PWM_CAPCTL_RCRLDEN0_Pos          (16)                                              /*!< PWM_T::CAPCTL: RCRLDEN0 Position       */
N#define PWM_CAPCTL_RCRLDEN0_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN0_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN0 Mask           */
N
N#define PWM_CAPCTL_RCRLDEN1_Pos          (17)                                              /*!< PWM_T::CAPCTL: RCRLDEN1 Position       */
N#define PWM_CAPCTL_RCRLDEN1_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN1_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN1 Mask           */
N
N#define PWM_CAPCTL_RCRLDEN2_Pos          (18)                                              /*!< PWM_T::CAPCTL: RCRLDEN2 Position       */
N#define PWM_CAPCTL_RCRLDEN2_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN2_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN2 Mask           */
N
N#define PWM_CAPCTL_RCRLDEN3_Pos          (19)                                              /*!< PWM_T::CAPCTL: RCRLDEN3 Position       */
N#define PWM_CAPCTL_RCRLDEN3_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN3_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN3 Mask           */
N
N#define PWM_CAPCTL_RCRLDEN4_Pos          (20)                                              /*!< PWM_T::CAPCTL: RCRLDEN4 Position       */
N#define PWM_CAPCTL_RCRLDEN4_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN4_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN4 Mask           */
N
N#define PWM_CAPCTL_RCRLDEN5_Pos          (21)                                              /*!< PWM_T::CAPCTL: RCRLDEN5 Position       */
N#define PWM_CAPCTL_RCRLDEN5_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN5_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN5 Mask           */
N
N#define PWM_CAPCTL_FCRLDEN0_Pos          (24)                                              /*!< PWM_T::CAPCTL: FCRLDEN0 Position       */
N#define PWM_CAPCTL_FCRLDEN0_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN0_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN0 Mask           */
N
N#define PWM_CAPCTL_FCRLDEN1_Pos          (25)                                              /*!< PWM_T::CAPCTL: FCRLDEN1 Position       */
N#define PWM_CAPCTL_FCRLDEN1_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN1_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN1 Mask           */
N
N#define PWM_CAPCTL_FCRLDEN2_Pos          (26)                                              /*!< PWM_T::CAPCTL: FCRLDEN2 Position       */
N#define PWM_CAPCTL_FCRLDEN2_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN2_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN2 Mask           */
N
N#define PWM_CAPCTL_FCRLDEN3_Pos          (27)                                              /*!< PWM_T::CAPCTL: FCRLDEN3 Position       */
N#define PWM_CAPCTL_FCRLDEN3_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN3_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN3 Mask           */
N
N#define PWM_CAPCTL_FCRLDEN4_Pos          (28)                                              /*!< PWM_T::CAPCTL: FCRLDEN4 Position       */
N#define PWM_CAPCTL_FCRLDEN4_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN4_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN4 Mask           */
N
N#define PWM_CAPCTL_FCRLDEN5_Pos          (29)                                              /*!< PWM_T::CAPCTL: FCRLDEN5 Position       */
N#define PWM_CAPCTL_FCRLDEN5_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN5_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN5 Mask           */
N
N#define PWM_CAPSTS_CRLIFOV0_Pos          (0)                                               /*!< PWM_T::CAPSTS: CRLIFOV0 Position       */
N#define PWM_CAPSTS_CRLIFOV0_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV0_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV0 Mask           */
N
N#define PWM_CAPSTS_CRLIFOV1_Pos          (1)                                               /*!< PWM_T::CAPSTS: CRLIFOV1 Position       */
N#define PWM_CAPSTS_CRLIFOV1_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV1_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV1 Mask           */
N
N#define PWM_CAPSTS_CRLIFOV2_Pos          (2)                                               /*!< PWM_T::CAPSTS: CRLIFOV2 Position       */
N#define PWM_CAPSTS_CRLIFOV2_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV2_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV2 Mask           */
N
N#define PWM_CAPSTS_CRLIFOV3_Pos          (3)                                               /*!< PWM_T::CAPSTS: CRLIFOV3 Position       */
N#define PWM_CAPSTS_CRLIFOV3_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV3_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV3 Mask           */
N
N#define PWM_CAPSTS_CRLIFOV4_Pos          (4)                                               /*!< PWM_T::CAPSTS: CRLIFOV4 Position       */
N#define PWM_CAPSTS_CRLIFOV4_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV4_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV4 Mask           */
N
N#define PWM_CAPSTS_CRLIFOV5_Pos          (5)                                               /*!< PWM_T::CAPSTS: CRLIFOV5 Position       */
N#define PWM_CAPSTS_CRLIFOV5_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV5_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV5 Mask           */
N
N#define PWM_CAPSTS_CFLIFOV0_Pos          (8)                                               /*!< PWM_T::CAPSTS: CFLIFOV0 Position       */
N#define PWM_CAPSTS_CFLIFOV0_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV0_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV0 Mask           */
N
N#define PWM_CAPSTS_CFLIFOV1_Pos          (9)                                               /*!< PWM_T::CAPSTS: CFLIFOV1 Position       */
N#define PWM_CAPSTS_CFLIFOV1_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV1_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV1 Mask           */
N
N#define PWM_CAPSTS_CFLIFOV2_Pos          (10)                                              /*!< PWM_T::CAPSTS: CFLIFOV2 Position       */
N#define PWM_CAPSTS_CFLIFOV2_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV2_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV2 Mask           */
N
N#define PWM_CAPSTS_CFLIFOV3_Pos          (11)                                              /*!< PWM_T::CAPSTS: CFLIFOV3 Position       */
N#define PWM_CAPSTS_CFLIFOV3_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV3_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV3 Mask           */
N
N#define PWM_CAPSTS_CFLIFOV4_Pos          (12)                                              /*!< PWM_T::CAPSTS: CFLIFOV4 Position       */
N#define PWM_CAPSTS_CFLIFOV4_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV4_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV4 Mask           */
N
N#define PWM_CAPSTS_CFLIFOV5_Pos          (13)                                              /*!< PWM_T::CAPSTS: CFLIFOV5 Position       */
N#define PWM_CAPSTS_CFLIFOV5_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV5_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV5 Mask           */
N
N#define PWM_RCAPDAT0_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT0: RCAPDAT Position      */
N#define PWM_RCAPDAT0_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT0_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT0: RCAPDAT Mask          */
N
N#define PWM_FCAPDAT0_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT0: FCAPDAT Position      */
N#define PWM_FCAPDAT0_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT0_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT0: FCAPDAT Mask          */
N
N#define PWM_RCAPDAT1_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT1: RCAPDAT Position      */
N#define PWM_RCAPDAT1_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT1_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT1: RCAPDAT Mask          */
N
N#define PWM_FCAPDAT1_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT1: FCAPDAT Position      */
N#define PWM_FCAPDAT1_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT1_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT1: FCAPDAT Mask          */
N
N#define PWM_RCAPDAT2_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT2: RCAPDAT Position      */
N#define PWM_RCAPDAT2_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT2_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT2: RCAPDAT Mask          */
N
N#define PWM_FCAPDAT2_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT2: FCAPDAT Position      */
N#define PWM_FCAPDAT2_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT2_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT2: FCAPDAT Mask          */
N
N#define PWM_RCAPDAT3_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT3: RCAPDAT Position      */
N#define PWM_RCAPDAT3_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT3_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT3: RCAPDAT Mask          */
N
N#define PWM_FCAPDAT3_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT3: FCAPDAT Position      */
N#define PWM_FCAPDAT3_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT3_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT3: FCAPDAT Mask          */
N
N#define PWM_RCAPDAT4_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT4: RCAPDAT Position      */
N#define PWM_RCAPDAT4_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT4_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT4: RCAPDAT Mask          */
N
N#define PWM_FCAPDAT4_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT4: FCAPDAT Position      */
N#define PWM_FCAPDAT4_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT4_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT4: FCAPDAT Mask          */
N
N#define PWM_RCAPDAT5_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT5: RCAPDAT Position      */
N#define PWM_RCAPDAT5_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT5_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT5: RCAPDAT Mask          */
N
N#define PWM_FCAPDAT5_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT5: FCAPDAT Position      */
N#define PWM_FCAPDAT5_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT5_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT5: FCAPDAT Mask          */
N
N#define PWM_PDMACTL_CHEN0_1_Pos          (0)                                               /*!< PWM_T::PDMACTL: CHEN0_1 Position       */
N#define PWM_PDMACTL_CHEN0_1_Msk          (0x1ul << PWM_PDMACTL_CHEN0_1_Pos)                /*!< PWM_T::PDMACTL: CHEN0_1 Mask           */
N
N#define PWM_PDMACTL_CAPMOD0_1_Pos        (1)                                               /*!< PWM_T::PDMACTL: CAPMOD0_1 Position     */
N#define PWM_PDMACTL_CAPMOD0_1_Msk        (0x3ul << PWM_PDMACTL_CAPMOD0_1_Pos)              /*!< PWM_T::PDMACTL: CAPMOD0_1 Mask         */
N
N#define PWM_PDMACTL_CAPORD0_1_Pos        (3)                                               /*!< PWM_T::PDMACTL: CAPORD0_1 Position     */
N#define PWM_PDMACTL_CAPORD0_1_Msk        (0x1ul << PWM_PDMACTL_CAPORD0_1_Pos)              /*!< PWM_T::PDMACTL: CAPORD0_1 Mask         */
N
N#define PWM_PDMACTL_CHSEL0_1_Pos         (4)                                               /*!< PWM_T::PDMACTL: CHSEL0_1 Position      */
N#define PWM_PDMACTL_CHSEL0_1_Msk         (0x1ul << PWM_PDMACTL_CHSEL0_1_Pos)               /*!< PWM_T::PDMACTL: CHSEL0_1 Mask          */
N
N#define PWM_PDMACTL_CHEN2_3_Pos          (8)                                               /*!< PWM_T::PDMACTL: CHEN2_3 Position       */
N#define PWM_PDMACTL_CHEN2_3_Msk          (0x1ul << PWM_PDMACTL_CHEN2_3_Pos)                /*!< PWM_T::PDMACTL: CHEN2_3 Mask           */
N
N#define PWM_PDMACTL_CAPMOD2_3_Pos        (9)                                               /*!< PWM_T::PDMACTL: CAPMOD2_3 Position     */
N#define PWM_PDMACTL_CAPMOD2_3_Msk        (0x3ul << PWM_PDMACTL_CAPMOD2_3_Pos)              /*!< PWM_T::PDMACTL: CAPMOD2_3 Mask         */
N
N#define PWM_PDMACTL_CAPORD2_3_Pos        (11)                                              /*!< PWM_T::PDMACTL: CAPORD2_3 Position     */
N#define PWM_PDMACTL_CAPORD2_3_Msk        (0x1ul << PWM_PDMACTL_CAPORD2_3_Pos)              /*!< PWM_T::PDMACTL: CAPORD2_3 Mask         */
N
N#define PWM_PDMACTL_CHSEL2_3_Pos         (12)                                              /*!< PWM_T::PDMACTL: CHSEL2_3 Position      */
N#define PWM_PDMACTL_CHSEL2_3_Msk         (0x1ul << PWM_PDMACTL_CHSEL2_3_Pos)               /*!< PWM_T::PDMACTL: CHSEL2_3 Mask          */
N
N#define PWM_PDMACTL_CHEN4_5_Pos          (16)                                              /*!< PWM_T::PDMACTL: CHEN4_5 Position       */
N#define PWM_PDMACTL_CHEN4_5_Msk          (0x1ul << PWM_PDMACTL_CHEN4_5_Pos)                /*!< PWM_T::PDMACTL: CHEN4_5 Mask           */
N
N#define PWM_PDMACTL_CAPMOD4_5_Pos        (17)                                              /*!< PWM_T::PDMACTL: CAPMOD4_5 Position     */
N#define PWM_PDMACTL_CAPMOD4_5_Msk        (0x3ul << PWM_PDMACTL_CAPMOD4_5_Pos)              /*!< PWM_T::PDMACTL: CAPMOD4_5 Mask         */
N
N#define PWM_PDMACTL_CAPORD4_5_Pos        (19)                                              /*!< PWM_T::PDMACTL: CAPORD4_5 Position     */
N#define PWM_PDMACTL_CAPORD4_5_Msk        (0x1ul << PWM_PDMACTL_CAPORD4_5_Pos)              /*!< PWM_T::PDMACTL: CAPORD4_5 Mask         */
N
N#define PWM_PDMACTL_CHSEL4_5_Pos         (20)                                              /*!< PWM_T::PDMACTL: CHSEL4_5 Position      */
N#define PWM_PDMACTL_CHSEL4_5_Msk         (0x1ul << PWM_PDMACTL_CHSEL4_5_Pos)               /*!< PWM_T::PDMACTL: CHSEL4_5 Mask          */
N
N#define PWM_PDMACAP0_1_CAPBUF_Pos        (0)                                               /*!< PWM_T::PDMACAP0_1: CAPBUF Position     */
N#define PWM_PDMACAP0_1_CAPBUF_Msk        (0xfffful << PWM_PDMACAP0_1_CAPBUF_Pos)           /*!< PWM_T::PDMACAP0_1: CAPBUF Mask         */
N
N#define PWM_PDMACAP2_3_CAPBUF_Pos        (0)                                               /*!< PWM_T::PDMACAP2_3: CAPBUF Position     */
N#define PWM_PDMACAP2_3_CAPBUF_Msk        (0xfffful << PWM_PDMACAP2_3_CAPBUF_Pos)           /*!< PWM_T::PDMACAP2_3: CAPBUF Mask         */
N
N#define PWM_PDMACAP4_5_CAPBUF_Pos        (0)                                               /*!< PWM_T::PDMACAP4_5: CAPBUF Position     */
N#define PWM_PDMACAP4_5_CAPBUF_Msk        (0xfffful << PWM_PDMACAP4_5_CAPBUF_Pos)           /*!< PWM_T::PDMACAP4_5: CAPBUF Mask         */
N
N#define PWM_CAPIEN_CAPRIEN0_Pos          (0)                                               /*!< PWM_T::CAPIEN: CAPRIEN0 Position       */
N#define PWM_CAPIEN_CAPRIEN0_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN0_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN0 Mask           */
N
N#define PWM_CAPIEN_CAPRIEN1_Pos          (1)                                               /*!< PWM_T::CAPIEN: CAPRIEN1 Position       */
N#define PWM_CAPIEN_CAPRIEN1_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN1_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN1 Mask           */
N
N#define PWM_CAPIEN_CAPRIEN2_Pos          (2)                                               /*!< PWM_T::CAPIEN: CAPRIEN2 Position       */
N#define PWM_CAPIEN_CAPRIEN2_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN2_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN2 Mask           */
N
N#define PWM_CAPIEN_CAPRIEN3_Pos          (3)                                               /*!< PWM_T::CAPIEN: CAPRIEN3 Position       */
N#define PWM_CAPIEN_CAPRIEN3_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN3_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN3 Mask           */
N
N#define PWM_CAPIEN_CAPRIEN4_Pos          (4)                                               /*!< PWM_T::CAPIEN: CAPRIEN4 Position       */
N#define PWM_CAPIEN_CAPRIEN4_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN4_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN4 Mask           */
N
N#define PWM_CAPIEN_CAPRIEN5_Pos          (5)                                               /*!< PWM_T::CAPIEN: CAPRIEN5 Position       */
N#define PWM_CAPIEN_CAPRIEN5_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN5_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN5 Mask           */
N
N#define PWM_CAPIEN_CAPFIEN0_Pos          (8)                                               /*!< PWM_T::CAPIEN: CAPFIEN0 Position       */
N#define PWM_CAPIEN_CAPFIEN0_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN0_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN0 Mask           */
N
N#define PWM_CAPIEN_CAPFIEN1_Pos          (9)                                               /*!< PWM_T::CAPIEN: CAPFIEN1 Position       */
N#define PWM_CAPIEN_CAPFIEN1_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN1_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN1 Mask           */
N
N#define PWM_CAPIEN_CAPFIEN2_Pos          (10)                                              /*!< PWM_T::CAPIEN: CAPFIEN2 Position       */
N#define PWM_CAPIEN_CAPFIEN2_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN2_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN2 Mask           */
N
N#define PWM_CAPIEN_CAPFIEN3_Pos          (11)                                              /*!< PWM_T::CAPIEN: CAPFIEN3 Position       */
N#define PWM_CAPIEN_CAPFIEN3_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN3_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN3 Mask           */
N
N#define PWM_CAPIEN_CAPFIEN4_Pos          (12)                                              /*!< PWM_T::CAPIEN: CAPFIEN4 Position       */
N#define PWM_CAPIEN_CAPFIEN4_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN4_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN4 Mask           */
N
N#define PWM_CAPIEN_CAPFIEN5_Pos          (13)                                              /*!< PWM_T::CAPIEN: CAPFIEN5 Position       */
N#define PWM_CAPIEN_CAPFIEN5_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN5_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN5 Mask           */
N
N#define PWM_CAPIF_CRLIF0_Pos             (0)                                               /*!< PWM_T::CAPIF: CRLIF0 Position          */
N#define PWM_CAPIF_CRLIF0_Msk             (0x1ul << PWM_CAPIF_CRLIF0_Pos)                   /*!< PWM_T::CAPIF: CRLIF0 Mask              */
N
N#define PWM_CAPIF_CRLIF1_Pos             (1)                                               /*!< PWM_T::CAPIF: CRLIF1 Position          */
N#define PWM_CAPIF_CRLIF1_Msk             (0x1ul << PWM_CAPIF_CRLIF1_Pos)                   /*!< PWM_T::CAPIF: CRLIF1 Mask              */
N
N#define PWM_CAPIF_CRLIF2_Pos             (2)                                               /*!< PWM_T::CAPIF: CRLIF2 Position          */
N#define PWM_CAPIF_CRLIF2_Msk             (0x1ul << PWM_CAPIF_CRLIF2_Pos)                   /*!< PWM_T::CAPIF: CRLIF2 Mask              */
N
N#define PWM_CAPIF_CRLIF3_Pos             (3)                                               /*!< PWM_T::CAPIF: CRLIF3 Position          */
N#define PWM_CAPIF_CRLIF3_Msk             (0x1ul << PWM_CAPIF_CRLIF3_Pos)                   /*!< PWM_T::CAPIF: CRLIF3 Mask              */
N
N#define PWM_CAPIF_CRLIF4_Pos             (4)                                               /*!< PWM_T::CAPIF: CRLIF4 Position          */
N#define PWM_CAPIF_CRLIF4_Msk             (0x1ul << PWM_CAPIF_CRLIF4_Pos)                   /*!< PWM_T::CAPIF: CRLIF4 Mask              */
N
N#define PWM_CAPIF_CRLIF5_Pos             (5)                                               /*!< PWM_T::CAPIF: CRLIF5 Position          */
N#define PWM_CAPIF_CRLIF5_Msk             (0x1ul << PWM_CAPIF_CRLIF5_Pos)                   /*!< PWM_T::CAPIF: CRLIF5 Mask              */
N
N#define PWM_CAPIF_CFLIF0_Pos             (8)                                               /*!< PWM_T::CAPIF: CFLIF0 Position          */
N#define PWM_CAPIF_CFLIF0_Msk             (0x1ul << PWM_CAPIF_CFLIF0_Pos)                   /*!< PWM_T::CAPIF: CFLIF0 Mask              */
N
N#define PWM_CAPIF_CFLIF1_Pos             (9)                                               /*!< PWM_T::CAPIF: CFLIF1 Position          */
N#define PWM_CAPIF_CFLIF1_Msk             (0x1ul << PWM_CAPIF_CFLIF1_Pos)                   /*!< PWM_T::CAPIF: CFLIF1 Mask              */
N
N#define PWM_CAPIF_CFLIF2_Pos             (10)                                              /*!< PWM_T::CAPIF: CFLIF2 Position          */
N#define PWM_CAPIF_CFLIF2_Msk             (0x1ul << PWM_CAPIF_CFLIF2_Pos)                   /*!< PWM_T::CAPIF: CFLIF2 Mask              */
N
N#define PWM_CAPIF_CFLIF3_Pos             (11)                                              /*!< PWM_T::CAPIF: CFLIF3 Position          */
N#define PWM_CAPIF_CFLIF3_Msk             (0x1ul << PWM_CAPIF_CFLIF3_Pos)                   /*!< PWM_T::CAPIF: CFLIF3 Mask              */
N
N#define PWM_CAPIF_CFLIF4_Pos             (12)                                              /*!< PWM_T::CAPIF: CFLIF4 Position          */
N#define PWM_CAPIF_CFLIF4_Msk             (0x1ul << PWM_CAPIF_CFLIF4_Pos)                   /*!< PWM_T::CAPIF: CFLIF4 Mask              */
N
N#define PWM_CAPIF_CFLIF5_Pos             (13)                                              /*!< PWM_T::CAPIF: CFLIF5 Position          */
N#define PWM_CAPIF_CFLIF5_Msk             (0x1ul << PWM_CAPIF_CFLIF5_Pos)                   /*!< PWM_T::CAPIF: CFLIF5 Mask              */
N
N#define PWM_PBUF_PBUF_Pos                (0)                                               /*!< PWM_T::PBUF: PBUF Position             */
N#define PWM_PBUF_PBUF_Msk                (0xfffful << PWM_PBUF_PBUF_Pos)                   /*!< PWM_T::PBUF: PBUF Mask                 */
N
N#define PWM_CMPBUF_CMPBUF_Pos            (0)                                               /*!< PWM_T::CMPBUF: CMPBUF Position         */
N#define PWM_CMPBUF_CMPBUF_Msk            (0xfffful << PWM_CMPBUF_CMPBUF_Pos)               /*!< PWM_T::CMPBUF: CMPBUF Mask             */
N
N#define PWM_CPSCBUF0_1_CPSCBUF_Pos       (0)                                               /*!< PWM_T::CPSCBUF0_1: CPSCBUF Position    */
N#define PWM_CPSCBUF0_1_CPSCBUF_Msk       (0xffful << PWM_CPSCBUF0_1_CPSCBUF_Pos)           /*!< PWM_T::CPSCBUF0_1: CPSCBUF Mask        */
N
N#define PWM_CPSCBUF2_3_CPSCBUF_Pos       (0)                                               /*!< PWM_T::CPSCBUF2_3: CPSCBUF Position    */
N#define PWM_CPSCBUF2_3_CPSCBUF_Msk       (0xffful << PWM_CPSCBUF2_3_CPSCBUF_Pos)           /*!< PWM_T::CPSCBUF2_3: CPSCBUF Mask        */
N
N#define PWM_CPSCBUF4_5_CPSCBUF_Pos       (0)                                               /*!< PWM_T::CPSCBUF4_5: CPSCBUF Position    */
N#define PWM_CPSCBUF4_5_CPSCBUF_Msk       (0xffful << PWM_CPSCBUF4_5_CPSCBUF_Pos)           /*!< PWM_T::CPSCBUF4_5: CPSCBUF Mask        */
N
N#define PWM_FTCBUF0_1_FTCMPBUF_Pos       (0)                                               /*!< PWM_T::FTCBUF0_1: FTCMPBUF Position    */
N#define PWM_FTCBUF0_1_FTCMPBUF_Msk       (0xfffful << PWM_FTCBUF0_1_FTCMPBUF_Pos)          /*!< PWM_T::FTCBUF0_1: FTCMPBUF Mask        */
N
N#define PWM_FTCBUF2_3_FTCMPBUF_Pos       (0)                                               /*!< PWM_T::FTCBUF2_3: FTCMPBUF Position    */
N#define PWM_FTCBUF2_3_FTCMPBUF_Msk       (0xfffful << PWM_FTCBUF2_3_FTCMPBUF_Pos)          /*!< PWM_T::FTCBUF2_3: FTCMPBUF Mask        */
N
N#define PWM_FTCBUF4_5_FTCMPBUF_Pos       (0)                                               /*!< PWM_T::FTCBUF4_5: FTCMPBUF Position    */
N#define PWM_FTCBUF4_5_FTCMPBUF_Msk       (0xfffful << PWM_FTCBUF4_5_FTCMPBUF_Pos)          /*!< PWM_T::FTCBUF4_5: FTCMPBUF Mask        */
N
N#define PWM_FTCI_FTCMU0_Pos              (0)                                               /*!< PWM_T::FTCI: FTCMU0 Position           */
N#define PWM_FTCI_FTCMU0_Msk              (0x1ul << PWM_FTCI_FTCMU0_Pos)                    /*!< PWM_T::FTCI: FTCMU0 Mask               */
N
N#define PWM_FTCI_FTCMU2_Pos              (1)                                               /*!< PWM_T::FTCI: FTCMU2 Position           */
N#define PWM_FTCI_FTCMU2_Msk              (0x1ul << PWM_FTCI_FTCMU2_Pos)                    /*!< PWM_T::FTCI: FTCMU2 Mask               */
N
N#define PWM_FTCI_FTCMU4_Pos              (2)                                               /*!< PWM_T::FTCI: FTCMU4 Position           */
N#define PWM_FTCI_FTCMU4_Msk              (0x1ul << PWM_FTCI_FTCMU4_Pos)                    /*!< PWM_T::FTCI: FTCMU4 Mask               */
N
N#define PWM_FTCI_FTCMD0_Pos              (8)                                               /*!< PWM_T::FTCI: FTCMD0 Position           */
N#define PWM_FTCI_FTCMD0_Msk              (0x1ul << PWM_FTCI_FTCMD0_Pos)                    /*!< PWM_T::FTCI: FTCMD0 Mask               */
N
N#define PWM_FTCI_FTCMD2_Pos              (9)                                               /*!< PWM_T::FTCI: FTCMD2 Position           */
N#define PWM_FTCI_FTCMD2_Msk              (0x1ul << PWM_FTCI_FTCMD2_Pos)                    /*!< PWM_T::FTCI: FTCMD2 Mask               */
N
N#define PWM_FTCI_FTCMD4_Pos              (10)                                              /*!< PWM_T::FTCI: FTCMD4 Position           */
N#define PWM_FTCI_FTCMD4_Msk              (0x1ul << PWM_FTCI_FTCMD4_Pos)                    /*!< PWM_T::FTCI: FTCMD4 Mask               */
N
N/**@}*/ /* PWM_CONST */
N/**@}*/ /* end of PWM register group */
N
N
N/*---------------------- Real Time Clock Controller -------------------------*/
N/**
N    @addtogroup RTC Real Time Clock Controller(RTC)
N    Memory Mapped Structure for RTC Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var RTC_T::INIT
N     * Offset: 0x00  RTC Initiation Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |INIT_ACTIVE|RTC Active Status (Read Only)
N     * |        |          |0 = RTC is at reset state.
N     * |        |          |1 = RTC is at normal active state.
N     * |[31:1]  |INIT      |RTC Initiation
N     * |        |          |When RTC block is first powered on, RTC is at reset state
N     * |        |          |User has to write a special number (0xA5EB13570x a5eb1357) to INIT to make RTC leaving reset state
N     * |        |          |Once the INIT is written as 0xa5eb13570xA5EB1357, the RTC will be in un-resetat normal active state permanently.
N     * |        |          |The INIT[31:1] is a write-only field and read value will be always 0.
N     * @var RTC_T::RWEN
N     * Offset: 0x04  RTC Access Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RWEN      |RTC Register Access Enable Password (Write Only)
N     * |        |          |Writing 0xA965 to this field register will enable RTC register access period and keep 1024 RTC clocks.
N     * |        |          |Note: Writing others vaule will clear RWENF and disable RTC register access function immediately.
N     * |[16]    |RWENF     |RTC Register Access Enable Flag (Read Only)
N     * |        |          |0 = RTC register read/write Disabled.
N     * |        |          |1 = RTC register read/write Enabled.
N     * |        |          |This bit will be set after RWEN RTC_RWEN[15:0] register is load a 0xA965, and be cleared automatically after 1024 RTC clocks expired.
N     * |        |          |Note: RWENF will be mask to u201C0u201D during RTCBUSY is= 1, and first turn on RTCCKEN (CLK_APBCLK[1]) also.
N     * |[24]    |RTCBUSY   |RTC Write Busy Flag
N     * |        |          |This bit indicates RTC registers are writable or not.
N     * |        |          |0: RTC register write canu2019t writeaccess enable .
N     * |        |          |1: RTC register are writablewrite access disable , RTC under Busy Status..
N     * |        |          |Note: RTCBUSY falg will be set when execute write RTC register command exceed 6 times within By Exceed RTC IP Prcessing Write Counter Capacity ( 6 counts Per 1 1120 PCLK cycles.).
N     * @var RTC_T::FREQADJ
N     * Offset: 0x08  RTC Frequency Compensation Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[21:0]  |FREQADJ   |Frequency Compensation RegisterValue
N     * |        |          |User must to get actual clock freqency of LXT, LXT frequency.
N     * |        |          |When CLK_CLKSEL2[18] = 0.
N     * |        |          |FCR = 0x200000 * (32768 / LXT freqency period).
N     * |        |          |LXT Note: This formula is suitable only when RTCSEL (CLK_CLKSEL2[18]) is 0, RTC clock source is from LXT.period: the clock period (Hz) of LXT.
N     * |        |          |uLIRC period: the clock period (Hz) of LIRC.
N     * |        |          |Note : LIRC can measure by softwaremethod.
N     * @var RTC_T::TIME
N     * Offset: 0x0C  RTC Time Loading Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |SEC       |1-Sec Time Digit (0~9)
N     * |[6:4]   |TENSEC    |10-Sec Time Digit (0~5)
N     * |[11:8]  |MIN       |1-Min Time Digit (0~9)
N     * |[14:12] |TENMIN    |10-Min Time Digit (0~5)
N     * |[19:16] |HR        |1-Hour Time Digit (0~9)
N     * |[21:20] |TENHR     |10-Hour Time Digit (0~2)
N     * |        |          |Note: When RTC runs as 12-hour time scale mode, RTC_TIME[21] (the high bit of TENHR[1:0]) means AM/PM indication, RTC_TIME[21] is 0 means AM hour and RTC_TIME[21] is 1 means PM hour (If RTC_TIME[21] is 1, it indicates PM time message.).
N     * @var RTC_T::CAL
N     * Offset: 0x10  RTC Calendar Loading Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |DAY       |1-Day Calendar Digit (0~9)
N     * |[5:4]   |TENDAY    |10-Day Calendar Digit (0~3)
N     * |[11:8]  |MON       |1-Month Calendar Digit (0~9)
N     * |[12]    |TENMON    |10-Month Calendar Digit (0~1)
N     * |[19:16] |YEAR      |1-Year Calendar Digit (0~9)
N     * |[23:20] |TENYEAR   |10-Year Calendar Digit (0~9)
N     * @var RTC_T::CLKFMT
N     * Offset: 0x14  RTC Time Scale Selection Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |24HEN     |24-hour / 12-hour Time Scale Selection
N     * |        |          |Indicates that RTC_TIME and RTC_TALM register are in 24-hour time scale or 12-hour time scale
N     * |        |          |0 = 12-hour time scale with AM and PM indication selected.
N     * |        |          |1 = 24-hour time scale selected.
N     * @var RTC_T::WEEKDAY
N     * Offset: 0x18  RTC Day of the Week Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |WEEKDAY   |Day of the Week Register
N     * |        |          |000 = Sunday.
N     * |        |          |001 = Monday.
N     * |        |          |010 = Tuesday.
N     * |        |          |011 = Wednesday.
N     * |        |          |100 = Thursday.
N     * |        |          |101 = Friday.
N     * |        |          |110 = Saturday.
N     * |        |          |111 = Reserved.
N     * |        |          |Note: RTC will not check WEEKDAY setting with RTC_CAL is reasonable or not.
N     * @var RTC_T::TALM
N     * Offset: 0x1C  RTC Time Alarm Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |SEC       |1-Sec Time Digit of Alarm Setting (0~9)
N     * |[6:4]   |TENSEC    |10-Sec Time Digit of Alarm Setting (0~5)
N     * |[11:8]  |MIN       |1-Min Time Digit of Alarm Setting (0~9)
N     * |[14:12] |TENMIN    |10-Min Time Digit of Alarm Setting (0~5)
N     * |[19:16] |HR        |1-Hour Time Digit of Alarm Setting (0~9)
N     * |[21:20] |TENHR     |10-Hour Time Digit of Alarm Setting (0~2) When RTC runs as 12-hour time scale mode, RTC_TIME[21] (the high bit of TENHR[1:0]) means AM/PM indication (If RTC_TIME[21] is 1, it indicates PM time message.)
N     * @var RTC_T::CALM
N     * Offset: 0x20  RTC Calendar Alarm Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |DAY       |1-Day Calendar Digit of Alarm Setting (0~9)
N     * |[5:4]   |TENDAY    |10-Day Calendar Digit of Alarm Setting (0~3)
N     * |[11:8]  |MON       |1-Month Calendar Digit of Alarm Setting (0~9)
N     * |[12]    |TENMON    |10-Month Calendar Digit of Alarm Setting (0~1)
N     * |[19:16] |YEAR      |1-Year Calendar Digit of Alarm Setting (0~9)
N     * |[23:20] |TENYEAR   |10-Year Calendar Digit of Alarm Setting (0~9)
N     * @var RTC_T::LEAPYEAR
N     * Offset: 0x24  RTC Leap Year Indicaton Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |LEAPYEAR  |Leap Year Indication Register (Read Only)
N     * |        |          |0 = This year is not a leap year.
N     * |        |          |1 = This year is leap year.
N     * @var RTC_T::INTEN
N     * Offset: 0x28  RTC Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ALMIEN    |Alarm Interrupt Enable Bit
N     * |        |          |0 = RTC aAlarm interrupt Disabled.
N     * |        |          |1 = RTC aAlarm interrupt Enabled.
N     * |[1]     |TICKIEN   |Time Tick Interrupt Enable Bit
N     * |        |          |0 = RTC tTime tTick interrupt Disabled.
N     * |        |          |1 = RTC tTime tTick interrupt Enabled.
N     * @var RTC_T::INTSTS
N     * Offset: 0x2C  RTC Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ALMIF     |RTC Alarm Interrupt Flag
N     * |        |          |When RTC current RTC counter in time counters RTC_TIME and RTC_CAL are matched the alarm setting time registers RTC alarm settings in RTC_TALM and RTC_CALM, ALMIFthis bit will be set to 1 and an alarm interrupt signal will be generated if RTC Alarm Interrupt enabled ALMIEN (RTC_INTEN[0]) is enabledset to 1.
N     * |        |          |Chip will also be waken up if RTC Alarm when alarm interrupt signal occurred Interrupt if chip is running at Power-down modeis enabled when chip is at Power-down mode.
N     * |        |          |0 = Alarm condition is not matched.
N     * |        |          |1 = Alarm condition is matched.
N     * |        |          |Note: Write Writing 1 to clear this bit.
N     * |[1]     |TICKIF    |RTC Time Tick Interrupt Flag
N     * |        |          |When RTC time tick event happened, this bit TICKIF will be set to 1 and an time tick interrupt signal will be generated if RTC Tick Interrupt enabled TICKIEN (RTC_INTEN[1]) is enabledset to 1
N     * |        |          |Chip will also be waken up when time tick interrupt signal occurred if RTC Tick Interrupt is enabled and this bit is set to 1 ifwhen chip is running at Power-down mode.
N     * |        |          |0 = Tick condition does not occur.
N     * |        |          |1 = Tick condition occurred.
N     * |        |          |Note: Writing Write 1 to clear to clear this bit.
N     * @var RTC_T::TICK
N     * Offset: 0x30  RTC Time Tick Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |TICK      |Time Tick Register
N     * |        |          |These bits are used to select RTC time tick period for pPeriodic tTime tTick iInterrupt request.
N     * |        |          |000 = Time tick is 1 second.
N     * |        |          |001 = Time tick is 1/2 second.
N     * |        |          |010 = Time tick is 1/4 second.
N     * |        |          |011 = Time tick is 1/8 second.
N     * |        |          |100 = Time tick is 1/16 second.
N     * |        |          |101 = Time tick is 1/32 second.
N     * |        |          |110 = Time tick is 1/64 second.
N     * |        |          |111 = Time tick is 1/128 second.
N     * |        |          |Note: This register can be read back after the RTC register access enable bit RWENF (RTC_RWEN[16]) is active.
N     * @var RTC_T::TAMSK
N     * Offset: 0x34  RTC Time Alarm Mask Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |MSEC      |Mask 1-Sec Time Digit of aAlarm sSetting (0~9)
N     * |[1]     |MTENSEC   |Mask 10-Sec Time Digit of aAlarm sSetting (0~5)
N     * |[2]     |MMIN      |Mask 1-Min Time Digit of aAlarm sSetting (0~9)
N     * |[3]     |MTENMIN   |Mask 10-Min Time Digit of aAlarm sSetting (0~5)
N     * |[4]     |MHR       |Mask 1-Hour Time Digit of aAlarm sSetting (0~9)
N     * |        |          |Note: MHR function is only for 24-hour time scale mode.
N     * |[5]     |MTENHR    |Mask 10-Hour Time Digit of aAlarm sSetting (0~2)
N     * |        |          |Note: MTENHR function is only for 24-hour time scale mode.
N     * @var RTC_T::CAMSK
N     * Offset: 0x38  RTC Calendar Alarm Mask Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |MDAY      |Mask 1-Day Calendar Digit of Alarm alarm Setting setting (0~9)
N     * |[1]     |MTENDAY   |Mask 10-Day Calendar Digit of Alarm alarm Setting setting (0~3)
N     * |[2]     |MMON      |Mask 1-Month Calendar Digit of Alarm alarm Setting setting (0~9)
N     * |[3]     |MTENMON   |Mask 10-Month Calendar Digit of A alarm Setting setting (0~1)
N     * |[4]     |MYEAR     |Mask 1-Year Calendar Digit of Alarm alarm Setting setting (0~9)
N     * |[5]     |MTENYEAR  |Mask 10-Year Calendar Digit of A alarm Setting setting (0~9)
N     * @var RTC_T::LXTCTL
N     * Offset: 0x100  RTC 32 kHz Oscillator Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:1]   |GAIN      |Oscillator Gain Option
N     * |        |          |User can select oscillator gain according to crystal external loading and operating temperature range
N     * |        |          |The larger gain value corresponding to stronger driving capability and higher power consumption.
N     * |        |          |000 = L0 mode.
N     * |        |          |001 = L1 mode.
N     * |        |          |010 = L2 mode.
N     * |        |          |011 = L3 mode.
N     * |        |          |100 = L4 mode.
N     * |        |          |101 = L5 mode.
N     * |        |          |110 = L6 mode.
N     * |        |          |111 = L7 mode (Default).
N     * @var RTC_T::LXTOCTL
N     * Offset: 0x104  RTC X32KO Pin Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |OPMODE    |GPF0 IO Pin Operation Mode
N     * |        |          |00 = X32KO (P5.0) is in Iinput only mode, without pull-up resistor.
N     * |        |          |01 = X32KO (P5.0) is in output pPush- pull output mode.
N     * |        |          |10 = X32KO (P5.0) is in Oopen- drain output mode.
N     * |        |          |11 = X32KO (P5.0) is in Quasi-bidirectional modeinput only mode with internal pull up.
N     * |[2]     |DOUT      |IO Pin Output Data
N     * |        |          |0 = X32KO (P5.0) will driver output low in output mode.
N     * |        |          |1 = X32KO (P5.0) will driver high in output mode output high.
N     * |[3]     |CTLSEL    |IO Pin State Backup Selection
N     * |        |          |When low speed 32 kHz oscillator (LXT) is disabled, X32KO (P5.0) pin can be used as GPIO P5.0 function
N     * |        |          |User can program CTLSEL bit to decide X32KO (P5.0) I/O function is controlled by system power domain GPIO module or VBAT power domain RTC_LXTOCTL control register.
N     * |        |          |0 = X32KO (P5.0) pin I/O function is controlled by GPIO module
N     * |        |          |Hardware auto becomes CTLSEL =1 when system power is turned off..
N     * |        |          |1 = X32KO (P5.0) pin I/O function is controlled by OPMODE and DOUT in RTC_LXTOCT at VBAT power domain, X32KO (P5.0) pin function and I/O status are controlled by OPMODE[1:0] and DOUT after CTLSEL it set to 1.
N     * |        |          |Note: CTLSEL (this bit) will automatically be set to 1 automatically by hardware to 1 when system power is turned off andoff RTC is at normal active state, ACTIVE (RTC_INIT[0]) is 1 and RTC Active Status = 1.
N     * @var RTC_T::LXTICTL
N     * Offset: 0x108  RTC X32KI Pin Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |OPMODE    |IO Pin Operation Mode
N     * |        |          |00 = X32KI (P5.1) is in Input mode without pull-up resistor.
N     * |        |          |01 = X32KI (P5.1) is in Push-pull output mode.
N     * |        |          |10 = X32KI (P5.1) is in Open-drain output mode.
N     * |        |          |11 = X32KI (P5.1) is in Quasi-bidirectional mode.00 = X32KI (P5.1) is input only mode, without pull-up resistor.
N     * |        |          |01 = X32KI (P5.1) is output push pull mode.
N     * |        |          |10 = X32KI (P5.1) is open drain mode.
N     * |        |          |11 = X32KI (P5.1) is input only mode with internal pull up.
N     * |[2]     |DOUT      |IO Pin Output Data
N     * |        |          |0 = X32KI (P5.1) will driver low in output mode.
N     * |        |          |1 = X32KI (P5.1) will driver high in output mode.0 = X32KI (P5.1) output low.
N     * |        |          |1 = X32KI (P5.1) output high.
N     * |[3]     |CTLSEL    |IO Pin State Backup Selection
N     * |        |          |When low speed 32 kHz oscillator (LXT) is disabled, X32KO pin can be used as GPIO P5.1 function
N     * |        |          |User can program CTLSEL to decide X32KI (P5.1) I/O function is controlled by system power domain GPIO module or VBAT power domain RTC_LXTICTL register.
N     * |        |          |0 = X32KI (P5.1) pin I/O function is controlled by GPIO module.
N     * |        |          |1 = X32KI (P5.1) pin I/O function is controlled by OPMODE and DOUT in RTC_LXTICTL at VBAT power domain.
N     * |        |          |Note: CTLSEL will be set to 1 automatically by hardware when system power is turned off and RTC is at normal active state, ACTIVE (RTC_INIT[0]) is 1.When low speed 32 kHz oscillator is disabled, X32KI (P5.1) pin can be used as GPIO function
N     * |        |          |User can program CTLSEL bit to decide X32KI (P5.1) I/O function is controlled by system power domain GPIO module or VBAT power domain RTC_LXTICTL control register.
N     * |        |          |0 = X32KI (P5.1) pin I/O function is controlled by GPIO module
N     * |        |          |Hardware auto becomes CTLSEL =1 when system power is turned off.
N     * |        |          |1 = X32KI (P5.1) pin I/O function is controlled by VBAT power domain, X32KI (P5.1) pin function and I/O status are controlled by OPMODE[1:0] and DOUT after CTLSEL it set to 1.
N     * |        |          |Note:CTLSEL (this bit) will automatically be set by hardware to 1 when system power is off and RTC Active Status = 1.
N     * @var RTC_T::P52CTL
N     * Offset: 0x10C  RTC P52 Pin Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |OPMODE    |IO Pin Operation Mode
N     * |        |          |00 = P5.2 is in Input mode without pull-up resistor.
N     * |        |          |01 = P5.2 is in Push-pull output mode.
N     * |        |          |10 = P5.2 is in Open-drain output mode.
N     * |        |          |11 = P5.2 is in Quasi-bidirectional mode.00 = GPIO(P5.2) is input only mode, without pull-up resistor.
N     * |        |          |01 = GPIO(P5.2) is output push pull mode.
N     * |        |          |10 = GPIO(P5.2) is open drain mode.
N     * |        |          |11 = GPIO(P5.2) is input only mode with internal pull up.
N     * |[2]     |DOUT      |IO Pin Output Data
N     * |        |          |0 = GPIO P5.2 will driver low in output mode.
N     * |        |          |1 = GPIO P5.2 will driver high in output mode.0 = GPIO(P5.2) output low.
N     * |        |          |1 = GPIO (P5.2) output high.
N     * |[3]     |CTLSEL    |IO Pin State Backup Selection
N     * |        |          |User can program CTLSEL to decide GPIO P5.2 I/O function is controlled by system power domain GPIO module or VBAT power domain RTC_LXTICTL register.
N     * |        |          |0 = GPIO P5.2 pin I/O function is controlled by GPIO module.
N     * |        |          |1 = GPIO P5.2 pin I/O function is controlled by OPMODE and DOUT in RTC_P52CTL at VBAT power domain.
N     * |        |          |Note: CTLSEL will be set to 1 automatically by hardware when system power is turned off and RTC is at normal active state, ACTIVE (RTC_INIT[0]) is 1.User can program CTLSEL bit to decide GPIO (P5.2) I/O function is controlled by system power domain GPIO module or VBAT power domain RTC_GPIOCTL control register.
N     * |        |          |0 = GPIO (P5.2) pin I/O function is controlled by GPIO module
N     * |        |          |Hardware auto becomes CTLSEL =1 when system power is turned off.
N     * |        |          |1 = GPIO (P5.2) pin I/O function is controlled by VBAT power domain, GPIO (P5.2) pin function and I/O status are controlled by OPMODE[1:0] and DOUT after CTLSEL it set to 1.
N     * |        |          |Note:CTLSEL (this bit) will automatically be set by hardware to 1 when system power is off and RTC Active Status = 1.
N     * @var RTC_T::DSTCTL
N     * Offset: 0x110  RTC Daylight Saving Time Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ADDHR     |Add 1 Hour
N     * |        |          |0 = No effect.
N     * |        |          |1 = Indicates RTC hour digit has been addedAdds 1 one hour for summer time change.
N     * |[1]     |SUBHR     |Subtract 1 Hour
N     * |        |          |0 = No effect.
N     * |        |          |1 = Indicates RTC hour digit has been sSubtractsed one1 hour for winter time change.
N     * |        |          |Note: Writing this bit has no effect when RTC_TIME[21:16] is 0x00 in 24-hour time scale mode and RTC_TIME[21:16] is 0x12 in 12-hour time scale mode.
N     * |[2]     |DSBAK     |Daylight Saving Back
N     * |        |          |0= Daylight Saving Time function isChange is not performed.
N     * |        |          |1= Daylight Saving Time function Change is performed.
N     */
N
N    __IO uint32_t INIT;                  /*!< [0x0000] RTC Initiation Register                                          */
X    volatile uint32_t INIT;                   
N    __IO uint32_t RWEN;                  /*!< [0x0004] RTC Access Enable Register                                       */
X    volatile uint32_t RWEN;                   
N    __IO uint32_t FREQADJ;               /*!< [0x0008] RTC Frequency Compensation Register                              */
X    volatile uint32_t FREQADJ;                
N    __IO uint32_t TIME;                  /*!< [0x000c] RTC Time Loading Register                                        */
X    volatile uint32_t TIME;                   
N    __IO uint32_t CAL;                   /*!< [0x0010] RTC Calendar Loading Register                                    */
X    volatile uint32_t CAL;                    
N    __IO uint32_t CLKFMT;                /*!< [0x0014] RTC Time Scale Selection Register                                */
X    volatile uint32_t CLKFMT;                 
N    __IO uint32_t WEEKDAY;               /*!< [0x0018] RTC Day of the Week Register                                     */
X    volatile uint32_t WEEKDAY;                
N    __IO uint32_t TALM;                  /*!< [0x001c] RTC Time Alarm Register                                          */
X    volatile uint32_t TALM;                   
N    __IO uint32_t CALM;                  /*!< [0x0020] RTC Calendar Alarm Register                                      */
X    volatile uint32_t CALM;                   
N    __I  uint32_t LEAPYEAR;              /*!< [0x0024] RTC Leap Year Indicaton Register                                 */
X    volatile const  uint32_t LEAPYEAR;               
N    __IO uint32_t INTEN;                 /*!< [0x0028] RTC Interrupt Enable Register                                    */
X    volatile uint32_t INTEN;                  
N    __IO uint32_t INTSTS;                /*!< [0x002c] RTC Interrupt Status Register                                    */
X    volatile uint32_t INTSTS;                 
N    __IO uint32_t TICK;                  /*!< [0x0030] RTC Time Tick Register                                           */
X    volatile uint32_t TICK;                   
N    __IO uint32_t TAMSK;                 /*!< [0x0034] RTC Time Alarm Mask Register                                     */
X    volatile uint32_t TAMSK;                  
N    __IO uint32_t CAMSK;                 /*!< [0x0038] RTC Calendar Alarm Mask Register                                 */
X    volatile uint32_t CAMSK;                  
N    __I  uint32_t RESERVE0[49];
X    volatile const  uint32_t RESERVE0[49];
N    __IO uint32_t LXTCTL;                /*!< [0x0100] RTC 32 kHz Oscillator Control Register                           */
X    volatile uint32_t LXTCTL;                 
N    __IO uint32_t LXTOCTL;               /*!< [0x0104] RTC X32KO Pin Control Register                                   */
X    volatile uint32_t LXTOCTL;                
N    __IO uint32_t LXTICTL;               /*!< [0x0108] RTC X32KI Pin Control Register                                   */
X    volatile uint32_t LXTICTL;                
N    __IO uint32_t P52CTL;                /*!< [0x010c] RTC P52 Pin Control Register                                     */
X    volatile uint32_t P52CTL;                 
N    __IO uint32_t DSTCTL;                /*!< [0x0110] RTC Daylight Saving Time Control Register                        */
X    volatile uint32_t DSTCTL;                 
N
N} RTC_T;
N
N/**
N    @addtogroup RTC_CONST RTC Bit Field Definition
N    Constant Definitions for RTC Controller
N@{ */
N
N#define RTC_INIT_ACTIVE_Pos              (0)                                               /*!< RTC_T::INIT: ACTIVE Position           */
N#define RTC_INIT_ACTIVE_Msk              (0x1ul << RTC_INIT_ACTIVE_Pos)                    /*!< RTC_T::INIT: ACTIVE Mask               */
N
N#define RTC_INIT_INIT_Pos                (1)                                               /*!< RTC_T::INIT: INIT Position             */
N#define RTC_INIT_INIT_Msk                (0x7ffffffful << RTC_INIT_INIT_Pos)               /*!< RTC_T::INIT: INIT Mask                 */
N
N#define RTC_RWEN_RWEN_Pos                (0)                                               /*!< RTC_T::RWEN: RWEN Position             */
N#define RTC_RWEN_RWEN_Msk                (0xfffful << RTC_RWEN_RWEN_Pos)                   /*!< RTC_T::RWEN: RWEN Mask                 */
N
N#define RTC_RWEN_RWENF_Pos               (16)                                              /*!< RTC_T::RWEN: RWENF Position            */
N#define RTC_RWEN_RWENF_Msk               (0x1ul << RTC_RWEN_RWENF_Pos)                     /*!< RTC_T::RWEN: RWENF Mask                */
N
N#define RTC_RWEN_RTCBUSY_Pos             (24)                                              /*!< RTC_T::RWEN: RTCBUSY Position          */
N#define RTC_RWEN_RTCBUSY_Msk             (0x1ul << RTC_RWEN_RTCBUSY_Pos)                   /*!< RTC_T::RWEN: RTCBUSY Mask              */
N
N#define RTC_FREQADJ_FREQADJ_Pos          (0)                                               /*!< RTC_T::FREQADJ: FREQADJ Position       */
N#define RTC_FREQADJ_FREQADJ_Msk          (0x3ffffful << RTC_FREQADJ_FREQADJ_Pos)           /*!< RTC_T::FREQADJ: FREQADJ Mask           */
N
N#define RTC_TIME_SEC_Pos                 (0)                                               /*!< RTC_T::TIME: SEC Position              */
N#define RTC_TIME_SEC_Msk                 (0xful << RTC_TIME_SEC_Pos)                       /*!< RTC_T::TIME: SEC Mask                  */
N
N#define RTC_TIME_TENSEC_Pos              (4)                                               /*!< RTC_T::TIME: TENSEC Position           */
N#define RTC_TIME_TENSEC_Msk              (0x7ul << RTC_TIME_TENSEC_Pos)                    /*!< RTC_T::TIME: TENSEC Mask               */
N
N#define RTC_TIME_MIN_Pos                 (8)                                               /*!< RTC_T::TIME: MIN Position              */
N#define RTC_TIME_MIN_Msk                 (0xful << RTC_TIME_MIN_Pos)                       /*!< RTC_T::TIME: MIN Mask                  */
N
N#define RTC_TIME_TENMIN_Pos              (12)                                              /*!< RTC_T::TIME: TENMIN Position           */
N#define RTC_TIME_TENMIN_Msk              (0x7ul << RTC_TIME_TENMIN_Pos)                    /*!< RTC_T::TIME: TENMIN Mask               */
N
N#define RTC_TIME_HR_Pos                  (16)                                              /*!< RTC_T::TIME: HR Position               */
N#define RTC_TIME_HR_Msk                  (0xful << RTC_TIME_HR_Pos)                        /*!< RTC_T::TIME: HR Mask                   */
N
N#define RTC_TIME_TENHR_Pos               (20)                                              /*!< RTC_T::TIME: TENHR Position            */
N#define RTC_TIME_TENHR_Msk               (0x3ul << RTC_TIME_TENHR_Pos)                     /*!< RTC_T::TIME: TENHR Mask                */
N
N#define RTC_CAL_DAY_Pos                  (0)                                               /*!< RTC_T::CAL: DAY Position               */
N#define RTC_CAL_DAY_Msk                  (0xful << RTC_CAL_DAY_Pos)                        /*!< RTC_T::CAL: DAY Mask                   */
N
N#define RTC_CAL_TENDAY_Pos               (4)                                               /*!< RTC_T::CAL: TENDAY Position            */
N#define RTC_CAL_TENDAY_Msk               (0x3ul << RTC_CAL_TENDAY_Pos)                     /*!< RTC_T::CAL: TENDAY Mask                */
N
N#define RTC_CAL_MON_Pos                  (8)                                               /*!< RTC_T::CAL: MON Position               */
N#define RTC_CAL_MON_Msk                  (0xful << RTC_CAL_MON_Pos)                        /*!< RTC_T::CAL: MON Mask                   */
N
N#define RTC_CAL_TENMON_Pos               (12)                                              /*!< RTC_T::CAL: TENMON Position            */
N#define RTC_CAL_TENMON_Msk               (0x1ul << RTC_CAL_TENMON_Pos)                     /*!< RTC_T::CAL: TENMON Mask                */
N
N#define RTC_CAL_YEAR_Pos                 (16)                                              /*!< RTC_T::CAL: YEAR Position              */
N#define RTC_CAL_YEAR_Msk                 (0xful << RTC_CAL_YEAR_Pos)                       /*!< RTC_T::CAL: YEAR Mask                  */
N
N#define RTC_CAL_TENYEAR_Pos              (20)                                              /*!< RTC_T::CAL: TENYEAR Position           */
N#define RTC_CAL_TENYEAR_Msk              (0xful << RTC_CAL_TENYEAR_Pos)                    /*!< RTC_T::CAL: TENYEAR Mask               */
N
N#define RTC_CLKFMT_24HEN_Pos             (0)                                               /*!< RTC_T::CLKFMT: 24HEN Position          */
N#define RTC_CLKFMT_24HEN_Msk             (0x1ul << RTC_CLKFMT_24HEN_Pos)                   /*!< RTC_T::CLKFMT: 24HEN Mask              */
N
N#define RTC_WEEKDAY_WEEKDAY_Pos          (0)                                               /*!< RTC_T::WEEKDAY: WEEKDAY Position       */
N#define RTC_WEEKDAY_WEEKDAY_Msk          (0x7ul << RTC_WEEKDAY_WEEKDAY_Pos)                /*!< RTC_T::WEEKDAY: WEEKDAY Mask           */
N
N#define RTC_TALM_SEC_Pos                 (0)                                               /*!< RTC_T::TALM: SEC Position              */
N#define RTC_TALM_SEC_Msk                 (0xful << RTC_TALM_SEC_Pos)                       /*!< RTC_T::TALM: SEC Mask                  */
N
N#define RTC_TALM_TENSEC_Pos              (4)                                               /*!< RTC_T::TALM: TENSEC Position           */
N#define RTC_TALM_TENSEC_Msk              (0x7ul << RTC_TALM_TENSEC_Pos)                    /*!< RTC_T::TALM: TENSEC Mask               */
N
N#define RTC_TALM_MIN_Pos                 (8)                                               /*!< RTC_T::TALM: MIN Position              */
N#define RTC_TALM_MIN_Msk                 (0xful << RTC_TALM_MIN_Pos)                       /*!< RTC_T::TALM: MIN Mask                  */
N
N#define RTC_TALM_TENMIN_Pos              (12)                                              /*!< RTC_T::TALM: TENMIN Position           */
N#define RTC_TALM_TENMIN_Msk              (0x7ul << RTC_TALM_TENMIN_Pos)                    /*!< RTC_T::TALM: TENMIN Mask               */
N
N#define RTC_TALM_HR_Pos                  (16)                                              /*!< RTC_T::TALM: HR Position               */
N#define RTC_TALM_HR_Msk                  (0xful << RTC_TALM_HR_Pos)                        /*!< RTC_T::TALM: HR Mask                   */
N
N#define RTC_TALM_TENHR_Pos               (20)                                              /*!< RTC_T::TALM: TENHR Position            */
N#define RTC_TALM_TENHR_Msk               (0x3ul << RTC_TALM_TENHR_Pos)                     /*!< RTC_T::TALM: TENHR Mask                */
N
N#define RTC_CALM_DAY_Pos                 (0)                                               /*!< RTC_T::CALM: DAY Position              */
N#define RTC_CALM_DAY_Msk                 (0xful << RTC_CALM_DAY_Pos)                       /*!< RTC_T::CALM: DAY Mask                  */
N
N#define RTC_CALM_TENDAY_Pos              (4)                                               /*!< RTC_T::CALM: TENDAY Position           */
N#define RTC_CALM_TENDAY_Msk              (0x3ul << RTC_CALM_TENDAY_Pos)                    /*!< RTC_T::CALM: TENDAY Mask               */
N
N#define RTC_CALM_MON_Pos                 (8)                                               /*!< RTC_T::CALM: MON Position              */
N#define RTC_CALM_MON_Msk                 (0xful << RTC_CALM_MON_Pos)                       /*!< RTC_T::CALM: MON Mask                  */
N
N#define RTC_CALM_TENMON_Pos              (12)                                              /*!< RTC_T::CALM: TENMON Position           */
N#define RTC_CALM_TENMON_Msk              (0x1ul << RTC_CALM_TENMON_Pos)                    /*!< RTC_T::CALM: TENMON Mask               */
N
N#define RTC_CALM_YEAR_Pos                (16)                                              /*!< RTC_T::CALM: YEAR Position             */
N#define RTC_CALM_YEAR_Msk                (0xful << RTC_CALM_YEAR_Pos)                      /*!< RTC_T::CALM: YEAR Mask                 */
N
N#define RTC_CALM_TENYEAR_Pos             (20)                                              /*!< RTC_T::CALM: TENYEAR Position          */
N#define RTC_CALM_TENYEAR_Msk             (0xful << RTC_CALM_TENYEAR_Pos)                   /*!< RTC_T::CALM: TENYEAR Mask              */
N
N#define RTC_LEAPYEAR_LEAPYEAR_Pos        (0)                                               /*!< RTC_T::LEAPYEAR: LEAPYEAR Position     */
N#define RTC_LEAPYEAR_LEAPYEAR_Msk        (0x1ul << RTC_LEAPYEAR_LEAPYEAR_Pos)              /*!< RTC_T::LEAPYEAR: LEAPYEAR Mask         */
N
N#define RTC_INTEN_ALMIEN_Pos             (0)                                               /*!< RTC_T::INTEN: ALMIEN Position          */
N#define RTC_INTEN_ALMIEN_Msk             (0x1ul << RTC_INTEN_ALMIEN_Pos)                   /*!< RTC_T::INTEN: ALMIEN Mask              */
N
N#define RTC_INTEN_TICKIEN_Pos            (1)                                               /*!< RTC_T::INTEN: TICKIEN Position         */
N#define RTC_INTEN_TICKIEN_Msk            (0x1ul << RTC_INTEN_TICKIEN_Pos)                  /*!< RTC_T::INTEN: TICKIEN Mask             */
N
N#define RTC_INTSTS_ALMIF_Pos             (0)                                               /*!< RTC_T::INTSTS: ALMIF Position          */
N#define RTC_INTSTS_ALMIF_Msk             (0x1ul << RTC_INTSTS_ALMIF_Pos)                   /*!< RTC_T::INTSTS: ALMIF Mask              */
N
N#define RTC_INTSTS_TICKIF_Pos            (1)                                               /*!< RTC_T::INTSTS: TICKIF Position         */
N#define RTC_INTSTS_TICKIF_Msk            (0x1ul << RTC_INTSTS_TICKIF_Pos)                  /*!< RTC_T::INTSTS: TICKIF Mask             */
N
N#define RTC_TICK_TICK_Pos                (0)                                               /*!< RTC_T::TICK: TICK Position             */
N#define RTC_TICK_TICK_Msk                (0x7ul << RTC_TICK_TICK_Pos)                      /*!< RTC_T::TICK: TICK Mask                 */
N
N#define RTC_TAMSK_MSEC_Pos               (0)                                               /*!< RTC_T::TAMSK: MSEC Position            */
N#define RTC_TAMSK_MSEC_Msk               (0x1ul << RTC_TAMSK_MSEC_Pos)                     /*!< RTC_T::TAMSK: MSEC Mask                */
N
N#define RTC_TAMSK_MTENSEC_Pos            (1)                                               /*!< RTC_T::TAMSK: MTENSEC Position         */
N#define RTC_TAMSK_MTENSEC_Msk            (0x1ul << RTC_TAMSK_MTENSEC_Pos)                  /*!< RTC_T::TAMSK: MTENSEC Mask             */
N
N#define RTC_TAMSK_MMIN_Pos               (2)                                               /*!< RTC_T::TAMSK: MMIN Position            */
N#define RTC_TAMSK_MMIN_Msk               (0x1ul << RTC_TAMSK_MMIN_Pos)                     /*!< RTC_T::TAMSK: MMIN Mask                */
N
N#define RTC_TAMSK_MTENMIN_Pos            (3)                                               /*!< RTC_T::TAMSK: MTENMIN Position         */
N#define RTC_TAMSK_MTENMIN_Msk            (0x1ul << RTC_TAMSK_MTENMIN_Pos)                  /*!< RTC_T::TAMSK: MTENMIN Mask             */
N
N#define RTC_TAMSK_MHR_Pos                (4)                                               /*!< RTC_T::TAMSK: MHR Position             */
N#define RTC_TAMSK_MHR_Msk                (0x1ul << RTC_TAMSK_MHR_Pos)                      /*!< RTC_T::TAMSK: MHR Mask                 */
N
N#define RTC_TAMSK_MTENHR_Pos             (5)                                               /*!< RTC_T::TAMSK: MTENHR Position          */
N#define RTC_TAMSK_MTENHR_Msk             (0x1ul << RTC_TAMSK_MTENHR_Pos)                   /*!< RTC_T::TAMSK: MTENHR Mask              */
N
N#define RTC_CAMSK_MDAY_Pos               (0)                                               /*!< RTC_T::CAMSK: MDAY Position            */
N#define RTC_CAMSK_MDAY_Msk               (0x1ul << RTC_CAMSK_MDAY_Pos)                     /*!< RTC_T::CAMSK: MDAY Mask                */
N
N#define RTC_CAMSK_MTENDAY_Pos            (1)                                               /*!< RTC_T::CAMSK: MTENDAY Position         */
N#define RTC_CAMSK_MTENDAY_Msk            (0x1ul << RTC_CAMSK_MTENDAY_Pos)                  /*!< RTC_T::CAMSK: MTENDAY Mask             */
N
N#define RTC_CAMSK_MMON_Pos               (2)                                               /*!< RTC_T::CAMSK: MMON Position            */
N#define RTC_CAMSK_MMON_Msk               (0x1ul << RTC_CAMSK_MMON_Pos)                     /*!< RTC_T::CAMSK: MMON Mask                */
N
N#define RTC_CAMSK_MTENMON_Pos            (3)                                               /*!< RTC_T::CAMSK: MTENMON Position         */
N#define RTC_CAMSK_MTENMON_Msk            (0x1ul << RTC_CAMSK_MTENMON_Pos)                  /*!< RTC_T::CAMSK: MTENMON Mask             */
N
N#define RTC_CAMSK_MYEAR_Pos              (4)                                               /*!< RTC_T::CAMSK: MYEAR Position           */
N#define RTC_CAMSK_MYEAR_Msk              (0x1ul << RTC_CAMSK_MYEAR_Pos)                    /*!< RTC_T::CAMSK: MYEAR Mask               */
N
N#define RTC_CAMSK_MTENYEAR_Pos           (5)                                               /*!< RTC_T::CAMSK: MTENYEAR Position        */
N#define RTC_CAMSK_MTENYEAR_Msk           (0x1ul << RTC_CAMSK_MTENYEAR_Pos)                 /*!< RTC_T::CAMSK: MTENYEAR Mask            */
N
N#define RTC_LXTCTL_GAIN_Pos              (1)                                               /*!< RTC_T::LXTCTL: GAIN Position           */
N#define RTC_LXTCTL_GAIN_Msk              (0x7ul << RTC_LXTCTL_GAIN_Pos)                    /*!< RTC_T::LXTCTL: GAIN Mask               */
N
N#define RTC_LXTOCTL_OPMODE_Pos           (0)                                               /*!< RTC_T::LXTOCTL: OPMODE Position        */
N#define RTC_LXTOCTL_OPMODE_Msk           (0x3ul << RTC_LXTOCTL_OPMODE_Pos)                 /*!< RTC_T::LXTOCTL: OPMODE Mask            */
N
N#define RTC_LXTOCTL_DOUT_Pos             (2)                                               /*!< RTC_T::LXTOCTL: DOUT Position          */
N#define RTC_LXTOCTL_DOUT_Msk             (0x1ul << RTC_LXTOCTL_DOUT_Pos)                   /*!< RTC_T::LXTOCTL: DOUT Mask              */
N
N#define RTC_LXTOCTL_CTLSEL_Pos           (3)                                               /*!< RTC_T::LXTOCTL: CTLSEL Position        */
N#define RTC_LXTOCTL_CTLSEL_Msk           (0x1ul << RTC_LXTOCTL_CTLSEL_Pos)                 /*!< RTC_T::LXTOCTL: CTLSEL Mask            */
N
N#define RTC_LXTICTL_OPMODE_Pos           (0)                                               /*!< RTC_T::LXTICTL: OPMODE Position        */
N#define RTC_LXTICTL_OPMODE_Msk           (0x3ul << RTC_LXTICTL_OPMODE_Pos)                 /*!< RTC_T::LXTICTL: OPMODE Mask            */
N
N#define RTC_LXTICTL_DOUT_Pos             (2)                                               /*!< RTC_T::LXTICTL: DOUT Position          */
N#define RTC_LXTICTL_DOUT_Msk             (0x1ul << RTC_LXTICTL_DOUT_Pos)                   /*!< RTC_T::LXTICTL: DOUT Mask              */
N
N#define RTC_LXTICTL_CTLSEL_Pos           (3)                                               /*!< RTC_T::LXTICTL: CTLSEL Position        */
N#define RTC_LXTICTL_CTLSEL_Msk           (0x1ul << RTC_LXTICTL_CTLSEL_Pos)                 /*!< RTC_T::LXTICTL: CTLSEL Mask            */
N
N#define RTC_P52CTL_OPMODE_Pos            (0)                                               /*!< RTC_T::P52CTL: OPMODE Position         */
N#define RTC_P52CTL_OPMODE_Msk            (0x3ul << RTC_P52CTL_OPMODE_Pos)                  /*!< RTC_T::P52CTL: OPMODE Mask             */
N
N#define RTC_P52CTL_DOUT_Pos              (2)                                               /*!< RTC_T::P52CTL: DOUT Position           */
N#define RTC_P52CTL_DOUT_Msk              (0x1ul << RTC_P52CTL_DOUT_Pos)                    /*!< RTC_T::P52CTL: DOUT Mask               */
N
N#define RTC_P52CTL_CTLSEL_Pos            (3)                                               /*!< RTC_T::P52CTL: CTLSEL Position         */
N#define RTC_P52CTL_CTLSEL_Msk            (0x1ul << RTC_P52CTL_CTLSEL_Pos)                  /*!< RTC_T::P52CTL: CTLSEL Mask             */
N
N#define RTC_DSTCTL_ADDHR_Pos             (0)                                               /*!< RTC_T::DSTCTL: ADDHR Position          */
N#define RTC_DSTCTL_ADDHR_Msk             (0x1ul << RTC_DSTCTL_ADDHR_Pos)                   /*!< RTC_T::DSTCTL: ADDHR Mask              */
N
N#define RTC_DSTCTL_SUBHR_Pos             (1)                                               /*!< RTC_T::DSTCTL: SUBHR Position          */
N#define RTC_DSTCTL_SUBHR_Msk             (0x1ul << RTC_DSTCTL_SUBHR_Pos)                   /*!< RTC_T::DSTCTL: SUBHR Mask              */
N
N#define RTC_DSTCTL_DSBAK_Pos             (2)                                               /*!< RTC_T::DSTCTL: DSBAK Position          */
N#define RTC_DSTCTL_DSBAK_Msk             (0x1ul << RTC_DSTCTL_DSBAK_Pos)                   /*!< RTC_T::DSTCTL: DSBAK Mask              */
N
N/**@}*/ /* RTC_CONST */
N/**@}*/ /* end of RTC register group */
N
N
N/*---------------------- Smart Card Host Interface Controller -------------------------*/
N/**
N    @addtogroup SC Smart Card Host Interface Controller(SC)
N    Memory Mapped Structure for SC Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var SC_T::DAT
N     * Offset: 0x00  SC Receive/Transmit Holding Buffer Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |DAT       |Receive/Transmit Holding Buffer
N     * |        |          |Write Operation:
N     * |        |          |By writing data to DAT, the SC will send out an 8-bit data.
N     * |        |          |Note: If SCEN (SC_SCn_CTL[0]) is not enabled, DAT cannot be programmed.
N     * |        |          |Read Operation:
N     * |        |          |By reading DAT, the SC will return an 8-bit received data.[WH1]
N     * |        |          |Note: If SCEN (SC_CTL[0]) is not enabled, DAT cannot be programmed.
N     * |        |          |[WH1]Tag59
N     * @var SC_T::CTL
N     * Offset: 0x04  SC Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SCEN      |SC Controller Enable Bit
N     * |        |          |Set this bit to 1 to enable SC operation function. If this bit is cleared,
N     * |        |          |0 = SC will force all transition to IDLE state.
N     * |        |          |1 = SC controller is enabled and all function can work correctly.
N     * |        |          |Note1: SCEN must be set to 1 before filling in other SC registers, or smart card will not work properly.[WH1]
N     * |        |          |[WH1]Tag66
N     * |[1]     |RXOFF     |RX Transition Disable Control Bit
N     * |        |          |This bit is used for disable Rx receive transition function.
N     * |        |          |0 = The receiver Enabled.
N     * |        |          |1 = The receiver Disabled.
N     * |        |          |Note1: If AUTOCEN (SC_SCn_CTL[3]) is enabled, this field is ignored.[WH1]
N     * |        |          |[WH1]Tag65
N     * |[2]     |TXOFF     |TX Transition Disable Control Bit
N     * |        |          |This bit is used for disable Tx transmit ftransition function.
N     * |        |          |0 = The transceiver Enabled.
N     * |        |          |1 = The transceiver Disabled.[WH1]
N     * |        |          |[WH1]Tag64
N     * |[3]     |AUTOCEN   |Auto Convention Enable Bit
N     * |        |          |This bit is used for enable auto convention function.
N     * |        |          |0 = Auto-convention Disabled.
N     * |        |          |1 = Auto-convention Enabled.
N     * |        |          |If user enables auto convention function, the setting step must be done before Answer to Reset (ATR) state and the first data must be 0x3B or 0x3F
N     * |        |          |After hardware received first data and stored it at buffer, hardware will decided the convention and change the CONSEL (SC_SCn_CTL[5:4]) bits automatically when received first data is 0x3B or 0x3F
N     * |        |          |If received first byte is 0x3B, TS is direct convention, CONSEL (SC_SCn_CTL[5:4]) will be set to 00 automatically, otherwise the TS is inverse convention, and CONSEL (SC_SCn_CTL[5:4]) will be set to 11.
N     * |        |          |If the first data is not 0x3B or 0x3F, hardware will set ACERRIF (SC_SCn_INTSTS[10]) and generate an interrupt signal to inform CPU when ACERRIEN (SC_SCn_INTEN[10]) is enabled.[WH1]
N     * |        |          |[WH1]Tag10, 33, 34, 35
N     * |[5:4]   |CONSEL    |Convention Selection
N     * |        |          |00 = Direct convention.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = Reserved.
N     * |        |          |11 = Inverse convention.
N     * |        |          |Note: If AUTOCEN (SC_SCn_CTL[3]) is enabled, this field is ignored.[WH1]
N     * |        |          |[WH1]Tag10, 33, 34, 35
N     * |[7:6]   |RXTRGLV   |Rx Buffer Trigger Level
N     * |        |          |When the number of bytes in the receiving buffer equals the RXTRGLV, the RDAIF (SC_INTSTS[0]) will be set
N     * |        |          |If RDAIEN (SC_SCn_INTEN[0]) is enabled, an interrupt signal will be generated to inform CPU.
N     * |        |          |00 = Rx Buffer Trigger Level with 01 bytes.
N     * |        |          |01 = Rx Buffer Trigger Level with 02 bytes.
N     * |        |          |10 = Rx Buffer Trigger Level with 03 bytes.
N     * |        |          |11 = Reserved. [WH1]
N     * |        |          |[WH1]Tag7
N     * |[12:8]  |BGT       |Block Guard Time (BGT)
N     * |        |          |Block guard time means the minimum interval between the leading edges of two consecutive characters between different transfer directions
N     * |        |          |This field indicates the counter for the bit length of block guard time
N     * |        |          |According to ISO7816-3, in T = 0 mode, user must fill 15 (real block guard time = 16.5) to this field; in T = 1 mode, user must fill 21 (real block guard time = 22.5) to it.
N     * |        |          |Note: The real block guard time is BGT + 1.[WH1]
N     * |        |          |[WH1]Tag8
N     * |[14:13] |TMRSEL    |Timer Channel Selection
N     * |        |          |00 = All internal timer function Disabled.[WH1]
N     * |        |          |.
N     * |        |          |11 = Internal 24- bit Timer0timer and two 8- bit Timer0 and Timer1 are etimers Enabled
N     * |        |          |User can configure them by setting SC_SCn_TMRCTL0[23:0], SC_SCn_TMRCTL1[7:0] and SC_SCn_TMRCTL2[7:0].
N     * |        |          |Other configurations are reserved[WH2]
N     * |        |          |[WH1]Tag9
N     * |        |          |[WH2]Tag9
N     * |[15]    |NSB       |Stop Bit Length
N     * |        |          |This field indicates the length of stop bit.
N     * |        |          |0 = The stop bit length is 2 ETU.
N     * |        |          |1 = The stop bit length is 1 ETU.
N     * |        |          |Note1: The default stop bit length is 2. SC and UART adopts NSB to program the stop bit length.
N     * |        |          |Note2: In UART mode, RX can receive the data sequence in 1 stop bit or 2 stop bits with NSB is set to 0.[WH1]
N     * |        |          |[WH1]Tag22
N     * |[18:16] |RXRTY     |RX Error Retry Count Number
N     * |        |          |This field indicates the maximum number of receiver retries that are allowed when parity error has occurred
N     * |        |          |Note1: The real retry number is RXRTY + 1, so 8 is the maximum retry number.
N     * |        |          |Note2: This field cannot be changed when RXRTYEN enabled
N     * |        |          |The change flow is to disable RXRTYEN first and then fill in new retry value.[WH1]
N     * |        |          |[WH1]Tag11
N     * |[19]    |RXRTYEN   |RX Error Retry Enable Bit
N     * |        |          |This bit enables receiver retry function when parity error has occurred.
N     * |        |          |0 = RX error retry function Disabled.
N     * |        |          |1 = RX error retry function Enabled.
N     * |        |          |Note: User must fill in the RXRTY value before enabling this bit.
N     * |[22:20] |TXRTY     |TX Error Retry Count Number
N     * |        |          |This field indicates the maximum number of transmitter retries that are allowed when parity error has occurred.
N     * |        |          |Note1: The real retry number is TXRTY + 1, so 8 is the maximum retry number.
N     * |        |          |Note2: This field cannot be changed when TXRTYEN enabled
N     * |        |          |The change flow is to disable TXRTYEN first and then fill in new retry value.[WH1]
N     * |        |          |[WH1]Tag11
N     * |[23]    |TXRTYEN   |TX Error Retry Enable Bit
N     * |        |          |This bit enables transmitter retry function when parity error has occurred.
N     * |        |          |0 = TX error retry function Disabled.
N     * |        |          |1 = TX error retry function Enabled.
N     * |[25:24] |CDDBSEL   |Card Detect De-bounce Selection
N     * |        |          |This field indicates the card detect de-bounce selection.
N     * |        |          |00 = De-bounce sample card insert once per 384 (128 * 3) SC modue clocks and de-bounce sample card removal once per 128 SC modue clocks.[WH1]
N     * |        |          |Other configurations are reserved.[WH2]
N     * |        |          |[WH1]Tag63
N     * |        |          |[WH2]Tag63
N     * |[26]    |CDLV      |Card Detect Level Selection
N     * |        |          |0 = When hardware detects the card detect pin (SC_SCn_CD) from high to low, it indicates a card is detected.
N     * |        |          |1 = When hardware detects the card detect pin (SC_SCn_CD) from low to high, it indicates a card is detected.
N     * |        |          |Note: User must select card detect level before Smart Card controller enabled. [WH1]
N     * |        |          |[WH1]Tag2
N     * |[30]    |SYNC      |SYNC Flag Indicator (Read Only)
N     * |        |          |Due to synchronization, user should check this bit before writing a new value to RXRTY and TXRTY fields.
N     * |        |          |0 = Synchronizing is completion, user can write new data to RXRTY and TXRTY.
N     * |        |          |1 = Last value is synchronizing. [WH1]
N     * |        |          |[WH1]Tag62
N     * @var SC_T::ALTCTL
N     * Offset: 0x08  SC Alternate Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TXRST     |TX Software Reset
N     * |        |          |When TXRST is set, all the bytes in the transmit buffer and TX Tx internal state machine will be cleared.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the TX Tx internal state machine and pointers.
N     * |        |          |Note: This bit will be auto cleared after reset is complete.[WH1]
N     * |        |          |[WH1]Tag71
N     * |[1]     |RXRST     |Rx RX Software Reset
N     * |        |          |When RXRST is set, all the bytes in the receive buffer and Rx internal state machine will be cleared.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the Rx internal state machine and pointers.
N     * |        |          |Note: This bit will be auto cleared after reset is complete.[WH1]
N     * |        |          |[WH1]Tag70
N     * |[2]     |DACTEN    |Deactivation Sequence Generator Enable Bit
N     * |        |          |This bit enables SC controller to initiate the card by deactivation sequence.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Deactivation sequence generator Enabled.
N     * |        |          |Note1: When the deactivation sequence completed, this bit will be cleared automatically and the INITIF (SC_SCn_INTSTS[8]) will be set to 1.
N     * |        |          |Note2: This field will be cleared by setT TXRST (SC_SCn_ALTCTL[0]) and or RXRST (SC_SCn_ALTCTL[1])
N     * |        |          |Thus, do not fill in this bit DACTEN, TXRST and or RXRST at the same time.
N     * |        |          |Note3: If SCEN (SC_SCn_CTL[0]) is not enabled, this filed cannot be programmed.[WH1]
N     * |        |          |[WH1]Tag14, 65
N     * |[3]     |ACTEN     |Activation Sequence Generator Enable Bit
N     * |        |          |This bit enables SC controller to initiate the card by activation sequence.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Activation sequence generator Enabled.
N     * |        |          |Note1: When the activation sequence completed, this bit will be cleared automatically and the INITIF (SC_SCn_INTSTS[8]) will be set to 1.
N     * |        |          |Note2: This field will be cleared by set TXRST (SC_SCn_ALTCTL[0]) and or RXRST (SC_SCn_ALTCTL[1])
N     * |        |          |Thus, do not fill in this bit ACTEN, TXRST and or RXRST at the same time.
N     * |        |          |Note3: If SCEN (SC_SCn_CTL[0]) is not enabled, this filed cannot be programmed.[WH1]
N     * |        |          |[WH1]Tag12, 65
N     * |[4]     |WARSTEN   |Warm Reset Sequence Generator Enable Bit
N     * |        |          |This bit enables SC controller to initiate the card by warm reset sequence.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Warm reset sequence generator Enabled.
N     * |        |          |Note1: When the warm reset sequence completed, this bit will be cleared automatically and the INITIF (SC_SCn_INTSTS[8]) will be set to 1.
N     * |        |          |Note2: This field will be cleared by set TXRST (SC_SCn_ALTCTL[0]) and or RXRST (SC_SCn_ALTCTL[1])
N     * |        |          |Thus, do not fill in this bit WARSTEN, TXRST and or RXRST at the same time.
N     * |        |          |Note3: If SCEN (SC_SCn_CTL[0]) is not enabled, this filed cannot be programmed.[WH1]
N     * |        |          |[WH1]Tag13, 65
N     * |[5]     |CNTEN0    |Internal Timer0 Start Enable Bit
N     * |        |          |This bit enables Timer 0 to start counting
N     * |        |          |User can fill 0 to stop count it and set 1 to reload and start count
N     * |        |          |The counter unit is ETU base.
N     * |        |          |0 = Stops counting.
N     * |        |          |1 = Start counting.
N     * |        |          |Note1: This field is used for internal 24- bit timer when TMRSEL (SC_SCn_CTL[14:13]) is 11 only
N     * |        |          |Do not fill CNTEN0 when TMRSEL (SC_CTL[14:13]) is not equale to 11.
N     * |        |          |Note2: If the operation mode is not in auto-reload mode (SC_SCn_TMRCTL0[26] = 0), this bit will be auto-cleared by hardware.
N     * |        |          |Note3: If SCEN (SC_SCn_CTL[0]) is not enabled, this filed cannot be programmed.[WH1]
N     * |        |          |[WH1]Tag37
N     * |[6]     |CNTEN1    |Internal Timer1 Start Enable Bit
N     * |        |          |This bit enables Timer 1 to start counting
N     * |        |          |User can fill 0 to stop count it and set 1 to reload and start count
N     * |        |          |The counter unit is ETU base.
N     * |        |          |0 = Stops counting.
N     * |        |          |1 = Start counting.
N     * |        |          |Note1: This field is used for internal 8- bit timer when TMRSEL (SC_SCn_CTL[14:13]) is 11 only
N     * |        |          |Do not fill CNTEN1 when TMRSEL (SC_SCn_CTL[14:13]) is not equale to 11.
N     * |        |          |Note2: If the operation mode is not in auto-reload mode (SC_SCn_TMRCTL1[26] = 0), this bit will be auto-cleared by hardware.
N     * |        |          |Note3: If SCEN (SC_SCn_CTL[0]) is not enabled, this filed cannot be programmed.
N     * |[7]     |CNTEN2    |Internal Timer2 Start Enable Bit
N     * |        |          |This bit enables Timer 2 to start counting
N     * |        |          |User can fill 0 to stop it count and set 1 to reload and start count
N     * |        |          |The counter unit is ETU base.
N     * |        |          |0 = Stops counting.
N     * |        |          |1 = Start counting.
N     * |        |          |Note1: This field is used for internal 8- bit timer when TMRSEL (SC_SCn_CTL[14:13]) is 11 only
N     * |        |          |Do not fill in CNTEN2 when TMRSEL (SC_SCn_CTL[14:13]) is not equale to 11.
N     * |        |          |Note2: If the operation mode is not in auto-reload mode (SC_SCn_TMRCTL2[26] = = 0), this bit will be auto-cleared by hardware.
N     * |        |          |Note3: If SCEN (SC_SCn_CTL[0]) is not enabled, this filed cannot be programmed.
N     * |[9:8]   |INITSEL   |Initial Timing Selection
N     * |        |          |This fields indicates the initial timing of hardware activation, warm-reset or deactivation.
N     * |        |          |The unit of initial timing is SC module clock.
N     * |        |          |Activation: refer to SC Activation Sequence in Figure 1.1-4 Figure 1.1-4.
N     * |        |          |Warm-reset: refer to Warm-Reset Sequence in Figure 1.1-5 Figure 1.1-5.
N     * |        |          |Deactivation: refer to Deactivation Sequence in Figure 1.1-6 Figure 1.1-6.
N     * |        |          |Note: When set activation and warm reset in Timer0 operation mode 0011, it may have deviation at most 128 SC module clock cycles.[WH1]
N     * |        |          |[WH1]Tag12~15
N     * |[11]    |ADACEN    |Auto Deactivation When Card Removal
N     * |        |          |This bit is usde for enable hardware auto deactivation when smart card is removed.
N     * |        |          |0 = Auto deactivation Disabled.
N     * |        |          |1 = Auto deactivation Enabled.
N     * |        |          |Note: When the card is removed, hardware will stop any process and then do deactivation sequence if this bit is set
N     * |        |          |If auto deactivation process completes, hardware will set INITIF (SC_SCn_INTSTS[8]) also.[WH1]
N     * |        |          |[WH1]Tag15
N     * |[12]    |RXBGTEN   |Receiver Block Guard Time Function Enable Bit
N     * |        |          |This bit enables the receiver block guard time function.
N     * |        |          |0 = Receiver block guard time function Disabled.
N     * |        |          |1 = Receiver block guard time function Enabled.[WH1]
N     * |        |          |[WH1]Tag69
N     * |[13]    |ACTSTS0   |Internal Timer0 Active Status (Read Only)
N     * |        |          |This bit indicates the timer counter status of timer0.
N     * |        |          |0 = Timer0 is not active.
N     * |        |          |1 = Timer0 is active.
N     * |        |          |Note: Timer0 is active does not always mean timer0 is counting the CNT (SC_SCn_TMRCTL0[23:0]).[WH1]
N     * |        |          |[WH1]Tag68
N     * |[14]    |ACTSTS1   |Internal Timer1 Active Status (Read Only)
N     * |        |          |This bit indicates the timer counter status of timer1.
N     * |        |          |0 = Timer1 is not active.
N     * |        |          |1 = Timer1 is active.
N     * |        |          |Note: Timer1 is active does not always mean timer1 is counting the CNT (SC_SCn_TMRCTL1[7:0]).
N     * |[15]    |ACTSTS2   |Internal Timer2 Active Status (Read Only)
N     * |        |          |This bit indicates the timer counter status of timer2.
N     * |        |          |0 = Timer2 is not active.
N     * |        |          |1 = Timer2 is active.
N     * |        |          |Note: Timer2 is active does not always mean timer2 is counting the CNT (SC_SCn_TMRCTL2[7:0]).
N     * |[31]    |SYNC      |SYNC Flag Indicator (Read Only)
N     * |        |          |Due to synchronization, user should check this bit when writing a new value to SC_SCn_ALTCTL register.
N     * |        |          |0 = Synchronizing is completion, user can write new data to SC_SCn_ALTCTL register.
N     * |        |          |1 = Last value is synchronizing. [WH1]
N     * |        |          |[WH1]Tag67
N     * @var SC_T::EGT
N     * Offset: 0x0C  SC Extra Guard Time Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |EGT       |Extra Guard Time
N     * |        |          |This field indicates the extra guard time value.
N     * |        |          |Note: The extra guard time unit is ETU base.[WH1]
N     * |        |          |[WH1]Tag53
N     * @var SC_T::RXTOUT
N     * Offset: 0x10  SC Receive Buffer Time-out Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8:0]   |RFTM      |SC Receiver FIFO Time-out Counter
N     * |        |          |The time-out down counter resets and starts counting whenever the RX Rx buffer received a new data
N     * |        |          |Once the counter decrease to 1 and no new data is received or CPU does not read data by reading SC_SCn_DAT (SC_DAT[7:0]), a receiver time-out flag RBXTOIF (SC_SCn_INTSTS[9]) will be set, and hardware will generate an interrupt signal to inform CPU when RXBTOIEN (SC_SCn_INTEN[9]) is enabled.
N     * |        |          |Note1: The counter unit is ETU based and the interval of time-out is (RFTM + 0.5) ETU time.
N     * |        |          |Note2: Filling in all 0 to this field indicates willto disable this function.[WH1]
N     * |        |          |[WH1]Tag72
N     * @var SC_T::ETUCTL
N     * Offset: 0x14  SC Element Time Unit Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |ETURDIV   |ETU Rate Divider
N     * |        |          |The field is used for define ETU time unit.clock rate divider.
N     * |        |          |The real ETU time unit is (ETURDIV + 1) * SC clock time.[WH1]
N     * |        |          |Note: User can configure this field, but this field must be greater than 0x004.[WH2]
N     * |        |          |[WH1]Tag6
N     * |        |          |[WH2]Tag74
N     * @var SC_T::INTEN
N     * Offset: 0x18  SC Interrupt Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDAIEN    |Receive Data Reach Interrupt Enable Bit
N     * |        |          |This field is used to enable received data bytes in Rx buffer reaching trigger level RXTRGLV (SC_SCn_CTL[7:6]) interrupt.
N     * |        |          |0 = Received data bytes in Rx buffer reach trigger level interrupt Disabled.
N     * |        |          |1 = Received data bytes in Rx buffer reach trigger level interrupt Enabled.[WH1]
N     * |        |          |[WH1]Tag7
N     * |[1]     |TXEIEN    |Transmit Buffer Empty Interrupt Enable Bit
N     * |        |          |This field is used to enable transmit buffer empty interrupt.
N     * |        |          |0 = Transmit buffer empty interrupt Disabled.
N     * |        |          |1 = Transmit buffer empty interrupt Enabled.[WH1]
N     * |        |          |[WH1]Tag64, 71
N     * |[2]     |TERRIEN   |Transfer Error Interrupt Enable Bit
N     * |        |          |This field is used to enable transfer error interrupt
N     * |        |          |The transfer error status states is at SC_SCn_STATUS register which includes receiver break error BEF (SC_SCn_STATUS[6]), frame error FEF (SC_SCn_STATUS[5]), parity error PEF (SC_SCn_STATUS[4]), receive buffer overflow error RXOV (SC_SCn_STATUS[0]), transmit buffer overflow error TXOV (SC_SCn_STATUS[8]), receiver retry over limit error RXOVERR (SC_SCn_STATUS[22]) and or transmitter retry over limit error TXOVERR (SC_SCn_STATUS[30]).
N     * |        |          |0 = Transfer error interrupt Disabled.
N     * |        |          |1 = Transfer error interrupt Enabled.[WH1]
N     * |        |          |[WH1]Tag11, 36
N     * |[3]     |TMR0IEN   |Timer0 Interrupt Enable Bit
N     * |        |          |This field is used to enable Timer0 interrupt function.
N     * |        |          |0 = Timer0 interrupt Disabled.
N     * |        |          |1 = Timer0 interrupt Enabled.[WH1]
N     * |        |          |[WH1]Tag76
N     * |[4]     |TMR1IEN   |Timer1 Interrupt Enable Bit
N     * |        |          |This field is used to enable the Timer1 interrupt function.
N     * |        |          |0 = Timer1 interrupt Disabled.
N     * |        |          |1 = Timer1 interrupt Enabled.
N     * |[5]     |TMR2IEN   |Timer2 Interrupt Enable Bit
N     * |        |          |This field is used to enable Timer2 interrupt function.
N     * |        |          |0 = Timer2 interrupt Disabled.
N     * |        |          |1 = Timer2 interrupt Enabled.
N     * |[6]     |BGTIEN    |Block Guard Time Interrupt Enable Bit
N     * |        |          |This field is used to enable block guard time interrupt in recevive direction.
N     * |        |          |0 = Block guard time interrupt Disabled.
N     * |        |          |1 = Block guard time interrupt Enabled.
N     * |        |          |Note: This bit is valid only for recvive receive direction block guard time.[WH1]
N     * |        |          |[WH1]Tag8, 50~53
N     * |[7]     |CDIEN     |Card Detect Interrupt Enable Bit
N     * |        |          |This field is used to enable card detect interrupt
N     * |        |          |The card detect status is CDPINSTS (SC_SCn_STATUS[13]).
N     * |        |          |0 = Card detect interrupt Disabled.
N     * |        |          |1 = Card detect interrupt Enabled.[WH1]
N     * |        |          |Note: Either cared insert or card remove event will generate crad detect event.
N     * |        |          |[WH1]Tag75
N     * |[8]     |INITIEN   |Initial End Interrupt Enable Bit
N     * |        |          |This field is used to enable activation (ACTEN (SC_SCn_ALTCTL[3] = 1)), deactivation (DACTEN (SC_SCn_ALTCTL[2] = 1)) and warm reset (WARSTEN (SC_SCn_ALTCTL [4])) sequence complete interrupt.
N     * |        |          |0 = Initial end interrupt Disabled.
N     * |        |          |1 = Initial end interrupt Enabled.[WH1]
N     * |        |          |[WH1]Tag12~15
N     * |[9]     |RXTOIEN   |Receiver Buffer Time-out Interrupt Enable Bit
N     * |        |          |This field is used to enable receiver buffer time-out interrupt.
N     * |        |          |0 = Receiver buffer time-out interrupt Disabled.
N     * |        |          |1 = Receiver buffer time-out interrupt Enabled.[WH1]
N     * |        |          |[WH1]Tag72
N     * |[10]    |ACERRIEN  |Auto Convention Error Interrupt Enable Bit
N     * |        |          |This field is used to enable auto-convention error interrupt.
N     * |        |          |0 = Auto-convention error interrupt Disabled.
N     * |        |          |1 = Auto-convention error interrupt Enabled.[WH1]
N     * |        |          |[WH1]Tag10
N     * @var SC_T::INTSTS
N     * Offset: 0x1C  SC Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDAIF     |Receive Data Reach Interrupt Status Flag (Read Only)
N     * |        |          |This field is used for received data bytes in Rx buffer reaching trigger level RXTRGLV (SC_SCn_CTL[7:6]) interrupt status flag.
N     * |        |          |0 = Number of receive buffer is less than RXTRGLV setting.
N     * |        |          |1 = Number of receive buffer data equals the RXTRGLV setting.
N     * |        |          |Note: This bit is read only
N     * |        |          |If user reads data from DAT (SC_SCn_DAT[7:0]) and remains receiver buffer data byte number is less than RXTRGLV, this bit will be cleared automatically.[WH1]
N     * |        |          |[WH1]Tag7
N     * |[1]     |TXEIF     |Transmit Buffer Empty Interrupt Status Flag (Read Only)
N     * |        |          |This field is used for transmit buffer empty interrupt status flag.
N     * |        |          |0 = Transmit buffer is not empty.
N     * |        |          |1 = Transmit buffer is empty.
N     * |        |          |Note: This bit is read only
N     * |        |          |If user wants to clear this bit, user must write data to DAT (SC_SCn_DAT[7:0]) and then this bit will be cleared automatically.[WH1]
N     * |        |          |[WH1]Tag64, 71
N     * |[2]     |TERRIF    |Transfer Error Interrupt Status Flag
N     * |        |          |This field is used for indicate transfer error interrupt status flag
N     * |        |          |The transfer error states status is at SC_SCn_STATUS register which includes receiver break error BEF (SC_SCn_STATUS[6]), frame error FEF (SC_SCn_STATUS[5]), parity error PEF (SC_SCn_STATUS[4]), and receive buffer overflow error RXOV (SC_SCn_STATUS[0]), transmit buffer overflow error TXOV (SC_SCn_STATUS[8]), receiver retry over limit error RXOVERR (SC_SCn_STATUS[22]) or transmitter retry over limit error TXOVERR (SC_SCn_STATUS[30]).
N     * |        |          |0 = Transfer error interrupt did not occur.
N     * |        |          |1 = Transfer error interrupt occurred.
N     * |        |          |Note1: This field is the status flag of BEF, FEF, PEF, RXOV, TXOV, RXOVERR or TXOVERR.
N     * |        |          |Note2: This bit can be cleared by writing 1 to it.[WH1]
N     * |        |          |[WH1]Tag11, 36
N     * |[3]     |TMR0IF    |Timer0 Interrupt Status Flag
N     * |        |          |This field is used for Timer0 interrupt status flag.
N     * |        |          |0 = Timer0 interrupt did not occur.
N     * |        |          |1 = Timer0 interrupt occurred.
N     * |        |          |Note: This bit can be cleared by writing 1 to it.[WH1]
N     * |        |          |[WH1]Tag76
N     * |[4]     |TMR1IF    |Timer1 Interrupt Status Flag
N     * |        |          |This field is used for Timer1 interrupt status flag.
N     * |        |          |0 = Timer1 interrupt did not occur.
N     * |        |          |1 = Timer1 interrupt occurred.
N     * |        |          |Note: This bit can be cleared by writing 1 to it.
N     * |[5]     |TMR2IF    |Timer2 Interrupt Status Flag
N     * |        |          |This field is used for Timer2 interrupt status flag.
N     * |        |          |0 = Timer2 interrupt did not occur.
N     * |        |          |1 = Timer2 interrupt occurred.
N     * |        |          |Note: This bit can be cleared by writing 1 to it.
N     * |[6]     |BGTIF     |Block   Guard Time Interrupt Status Flag
N     * |        |          |This field is   used for indicate block guard time interrupt status flag in recvive receive direction.
N     * |        |          |0 = Block   guard time interrupt did not occur.
N     * |        |          |1 = Block   guard time interrupt occurred.
N     * |        |          |Note1: This bit is valid only when RXBGTEN (SC_SCn_ALTCTL[12])   is enabled.
N     * |        |          |Note2: This bit can be cleared by writing 1 to   it.
N     * |[7]     |CDIF      |Card Detect Interrupt Status Flag (Read Only)
N     * |        |          |This field is used for card detect interrupt status flag
N     * |        |          |The actual card detect status is in CINSERT (SC_SCn_STATUS[12]) and CREMOVE (SC_SCn_STATUS[11]).
N     * |        |          |0 = Card detect event did not occur.
N     * |        |          |1 = Card detect event occurred.
N     * |        |          |Note1: This bit is read only, and will be cleared after user must to clear CINSERT or CREMOVE [WH1]status has been clearedto clear it.
N     * |        |          |Note2: Either cared insert or card remove event will generate crad detect event.
N     * |        |          |[WH1]Tag75
N     * |[8]     |INITIF    |Initial End Interrupt Status Flag
N     * |        |          |This field is used for activation (ACTEN (SC_SCn_ALTCTL[3])), deactivation (DACTEN (SC_SCn_ALTCTL[2])) and warm reset (WARSTEN (SC_SCn_ALTCTL[4])) sequence interrupt status flag.
N     * |        |          |0 = Initial sequence is not complete.
N     * |        |          |1 = Initial sequence is completed.
N     * |        |          |Note: This bit can be cleared by writing 1 to it.[WH1]
N     * |        |          |[WH1]Tag12~15
N     * |[9]     |RXTOIF    |Receive Buffer Time-out Interrupt Status Flag (Read Only)
N     * |        |          |This field is used for indicate receive buffer time-out interrupt status flag.
N     * |        |          |0 = Receive buffer time-out interrupt did not occur.
N     * |        |          |1 = Receive buffer time-out interrupt occurred.
N     * |        |          |Note: This bit is read only, user must read all receive buffer remaining data by reading SC_SCn_DAT (SC_DAT[7:0])register to clear it.[WH1]
N     * |        |          |[WH1]Tag72
N     * |[10]    |ACERRIF   |Auto Convention Error Interrupt Status Flag
N     * |        |          |This field indicates auto convention sequence error.
N     * |        |          |0 = Received TS at ATR state is 0x3B or 0x3F.
N     * |        |          |1 = Received TS at ATR state is neither 0x3B nor 0x3F.
N     * |        |          |Note: This bit can be cleared by writing 1 to it.[WH1]
N     * |        |          |[WH1]Tag10
N     * @var SC_T::STATUS
N     * Offset: 0x20  SC Transfer Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RXOV      |Receive Overflow Error Status Flag
N     * |        |          |This bit is set when Rx buffer overflow.
N     * |        |          |0 = Rx buffer is not overflow.
N     * |        |          |1 = Rx buffer is overflow when the number of received bytes is greater than Rx buffer size (4 bytes).
N     * |        |          |Note: This bit can be cleared by writing 1 to it.[WH1]
N     * |        |          |[WH1]Tag5
N     * |[1]     |RXEMPTY   |Receive Buffer Empty Status Flag (Read Only)
N     * |        |          |This bit indicates Rx buffer is empty or not.
N     * |        |          |0 = Rx buffer is not empty.
N     * |        |          |1 = Rx buffer is empty, it means the last byte of in Rx buffer has been read from DAT (SC_SCn_DAT[7:0]) by CPU.
N     * |[2]     |RXFULL    |Receive Buffer Full Status Flag (Read Only)
N     * |        |          |This bit indicates Rx buffer is full or not.
N     * |        |          |0 = Rx buffer count is less than 4.
N     * |        |          |1 = Rx buffer count equals to 4.
N     * |[4]     |PEF       |Receiver Parity Error Status Flag
N     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid u201Cparity bitu201D.
N     * |        |          |0 = Receiver parity error flag did not occur.
N     * |        |          |1 = Receiver parity error flag occurred.
N     * |        |          |Note1: This bit can be cleared by writing 1 to it.
N     * |        |          |Note2: If user CPU sets receiver retries function by setting RXRTYEN (SC_SCn_CTL[19]), hardware will not set this flag.[WH1]
N     * |        |          |[WH1]Tag80
N     * |[5]     |FEF       |Receiver Frame Error Status Flag
N     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid u201Cstop bitu201D (that is, the stop bit following the last data bit or parity bit is detected as logic 0).
N     * |        |          |0 = Receiver frame error flag did not occur.
N     * |        |          |1 = Receiver frame error flag occurred.
N     * |        |          |Note1: This bit can be cleared by writing 1 to it.
N     * |        |          |Note2: If user CPU sets receiver retries function by setting RXRTYEN (SC_SCn_CTL[19]), hardware will not set this flag.[WH1]
N     * |        |          |[WH1]Tag79
N     * |[6]     |BEF       |Receiver Break Error Status Flag
N     * |        |          |This bit is set to logic 1 whenever the received data input (Rx) held in the u201Cspacing stateu201D (logic 0) is longer than a full word transmission time (that is, the total time of u201Cstart bitu201D + u201Cdata bitsu201D + u201Cparity bitu201D + u201Cstop bitsu201D).
N     * |        |          |0 = Receiver break error flag did not occur.
N     * |        |          |1 = Receiver break error flag occurred.
N     * |        |          |Note1: This bit can be cleared by writing 1 to it.
N     * |        |          |Note2: If CPU user sets receiver retries function by setting RXRTYEN (SC_SCn_CTL[19]), hardware will not set this flag.[WH1]
N     * |        |          |[WH1]Tag78
N     * |[8]     |TXOV      |Transmit Overflow Error Interrupt Status Flag
N     * |        |          |This bit is set when Tx buffer overflow.
N     * |        |          |0 = Tx buffer is not overflow.
N     * |        |          |1 = Tx buffer is overflow, it means when Tx buffer is full and an additional write operation to DAT (SC_SCn_DAT[7:0]) when Tx buffer is already full.
N     * |        |          |Note: This bit can be cleared by writing 1 to it.[WH1]
N     * |        |          |[WH1]Tag5
N     * |[9]     |TXEMPTY   |Transmit Buffer Empty Status Flag (Read Only)
N     * |        |          |This bit indicates TX buffer is empty or not.
N     * |        |          |0 = Tx buffer is not empty.
N     * |        |          |1 = Tx buffer is empty, it means the last byte of Tx buffer has been transferred to Transmitter Shift Register.
N     * |        |          |Note: This bit will be cleared when writing data into DAT (SC_SCn_DAT[7:0]).
N     * |[10]    |TXFULL    |Transmit Buffer Full Status Flag (Read Only)
N     * |        |          |This bit indicates Tx buffer is full or not.
N     * |        |          |0 = Tx buffer count is less than 4.
N     * |        |          |1 = Tx buffer count equals to 4.
N     * |[11]    |CREMOVE   |Card Removal Status of SC_SCn_CD Pin
N     * |        |          |This bit is set whenever card has been removal.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Card removed.
N     * |        |          |Note1: This bit can be cleared by writing u201C1u201D to it.
N     * |        |          |Note2: Card detect function will start after SCEN (SC_SCn_CTL[0]) is set.[WH1]
N     * |        |          |[WH1]Tag2
N     * |[12]    |CINSERT   |Card Insert Status of SC_SCn_CD Pin
N     * |        |          |This bit is set whenever card has been inserted.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Card insert.
N     * |        |          |Note1: This bit can be cleared by writing u201C1u201D to it.
N     * |        |          |Note2: The card detect function will start after SCEN (SC_SCn_CTL[0]) setis set.
N     * |[13]    |CDPINSTS  |Card Detect Pin Status (Read Only)
N     * |        |          |This bit is the pin status of SC_SCn_CD.
N     * |        |          |0 = The SC_SCn_CD pin state at low.
N     * |        |          |1 = The SC_SCn_CD pin state at high.
N     * |[18:16] |RXPOINT   |Receive Buffer Pointer Status (Read Only)
N     * |        |          |This field indicates the Rx buffer pointer status
N     * |        |          |When SC controller receives one byte from external device, RXPOINT increases one
N     * |        |          |When one byte of in Rx buffer is read by CPUreading DAT (SC_DAT[7:0]), RXPOINT decreases one.[WH1]
N     * |        |          |[WH1]Tag5
N     * |[21]    |RXRTYERR  |Receiver Retry ErrorRetry Error
N     * |        |          |This bit is used for indicate receiver error retry error retry and set by hardware.
N     * |        |          |0 = No Rx retry transfer.
N     * |        |          |1 = Rx has any error and retries transfer.
N     * |        |          |Note1: This bit can be cleared by writing 1 to it.
N     * |        |          |Note2: This bit is a flag and cannot generate any interrupt signal to CPU.
N     * |        |          |Note3: If CPU user enables receiver retries function by setting RXRTYEN (SC_SCn_CTL[19]), the PEF (SC_STATUS[4]) bit hardware will not set this flag.[WH1]
N     * |        |          |[WH1]Tag11
N     * |[22]    |RXOVERR   |Receiver Oover Retry Error
N     * |        |          |This bit is used for indicate receiver retry counts over than retry number limitation.
N     * |        |          |0 = Receiver retries counts is not over than RXRTY (SC_SCn_CTL[18:16]) + 1.
N     * |        |          |1 = Receiver retries counts over than RXRTY (SC_SCn_CTL[18:16]) + 1.
N     * |        |          |Note1: This bit can be cleared by writing 1 to it.
N     * |        |          |Note2: If CPU user enables receiver retries function by setting RXRTYEN (SC_SCn_CTL[19]), the PEF (SC_STATUS[4]) bit will not set hardware will not set this flag.
N     * |[23]    |RXACT     |Receiver in Active Status Flag (Read Only)
N     * |        |          |This bit indicates Rx transfer status.
N     * |        |          |0 = This bit is cleared automatically when Rx transfer is finished.
N     * |        |          |1 = This bit is set by hardware when Rx transfer is in active.
N     * |        |          |Note: This bit is read only.[WH1]
N     * |        |          |[WH1]Tag78
N     * |[26:24] |TXPOINT   |Transmit Buffer Pointer Status (Read Only)
N     * |        |          |This field indicates the Tx buffer pointer status
N     * |        |          |When CPU writes data into DAT (SC_SCn_DAT[7:0]), TXPOINT increases one
N     * |        |          |When one byte of Tx buffer is transferred to Transmitter Shift Registertransmitter shift register, TXPOINT decreases one.[WH1]
N     * |        |          |[WH1]Tag5
N     * |[29]    |TXRTYERR  |Transmitter Retry ErrorRetry Error
N     * |        |          |This bit is used for indicate transmitter error retry and set by hardware..
N     * |        |          |0 = No Tx retry transfer.
N     * |        |          |1 = Tx has any error and retries transfer.
N     * |        |          |Note1: This bit can be cleared by writing 1 to it.
N     * |        |          |Note2: This bit is a flag and cannot generate any interrupt signal to CPU.[WH1]
N     * |        |          |[WH1]Tag11
N     * |[30]    |TXOVERR   |Transmitter Oover Retry Error
N     * |        |          |This bit is used for transmitter retry counts over than retry number limitation.
N     * |        |          |0 = Transmitter retries counts is not over than TXRTY (SC_SCn_CTL[22:20]) + 1.
N     * |        |          |1 = Transmitter retries counts over than TXRTY (SC_SCn_CTL[22:20]) + 1.
N     * |        |          |Note: This bit can be cleared by writing 1 to it.
N     * |[31]    |TXACT     |Transmit in Active Status Flag (Read Only)
N     * |        |          |This bit indicates Tx transmit status.
N     * |        |          |0 = This bit is cleared automatically when Tx transfer is finished or the last byte transmission has completed.
N     * |        |          |1 = Transmit is active or the STOP bit of last byte has not been transmitted when Tx transfer is in active.and this bit is set by hardware when Tx transfer is in active and the STOP bit of the last byte has not been transmitted.
N     * |        |          |Note: This bit is read only.[WH1]
N     * |        |          |[WH1]Tag77
N     * @var SC_T::PINCTL
N     * Offset: 0x24  SC Pin Control State Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PWREN     |SC_SCn_PWR Pin Signal
N     * |        |          |User can set PWRINV (SC_SCn_PINCTL[11]) and PWREN (SC_SCn_PINCTL[0]) to decide SC_SCn_PWR pin is in high or low level.
N     * |        |          |Write this field bit can to drive SC_SCn_PWR pin
N     * |        |          |Refer PWRINV (SC_SCn_PINCTL[11]) description for programming SC_SCn_PWR pin voltage level.
N     * |        |          |Read this field bit to get SC_SCn_PWR signal status.
N     * |        |          |0 = SC_SCn_PWR signal status is low.
N     * |        |          |1 = SC_SCn_PWR signal status is high.
N     * |        |          |Note: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically
N     * |        |          |Thus, do not fill in this field when operating in these modes.[WH1]
N     * |        |          |[WH1]Tag84
N     * |[1]     |SCRST     |SC_SCn_RST Pin Signal
N     * |        |          |This bit is the signal status of SC_SCn_RST but user can drive SC_SCn_RST pin to high or low by setting control this bit.
N     * |        |          |Write this bit can field to drive SC_SCn_RST pin.
N     * |        |          |0 = Drive SC_SCn_RST pin to low.
N     * |        |          |1 = Drive SC_SCn_RST pin to high.
N     * |        |          |Read this bit field to get SC_SCn_RST signal status.
N     * |        |          |0 = SC_SCn_RST signal status is low.
N     * |        |          |1 = SC_SCn_RST signal status is high.
N     * |        |          |Note: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically
N     * |        |          |Thus, do not fill in this field when operating in these modes.[WH1]
N     * |        |          |[WH1]Tag84
N     * |[6]     |CLKKEEP   |SC Clock Enable Bit
N     * |        |          |0 = SC clock generation Disabled.
N     * |        |          |1 = SC clock always keeps free running.
N     * |        |          |Note: When operating in activation, warm reset or deactivation mode, this bit will be changed automatically
N     * |        |          |Thus, do not fill in this field when operating in these modes.[WH1]
N     * |        |          |[WH1]Tag66
N     * |[9]     |SCDATA    |SC_SCn_DATA Pin Signal
N     * |        |          |This bit is the signal status of SC_SCn_DATA but user can also drive SC_SCn_DATA pin to high or low by control this setting this bit.
N     * |        |          |Write this bit can drive SC_RST pin.
N     * |        |          |0 = Drive SC_SCn_DATA pin to low.
N     * |        |          |1 = Drive SC_SCn_DATA pin to high.
N     * |        |          |Read this bit field to get SC_SCn_DATA signal status.
N     * |        |          |0 = SC_SCn_DATA signal status is low.
N     * |        |          |1 = SC_SCn_DATA signal status is high.
N     * |        |          |Note: When SC is at activation, warm reset or deactivation mode, this bit will be changed automatically
N     * |        |          |Thus, do not fill in this field when SC is in these modes.[WH1]
N     * |        |          |[WH1]Tag85
N     * |[11]    |PWRINV    |SC_SCn_PWR Pin Inverse
N     * |        |          |This bit is used for inverse the SC_SCn_PWR pin.
N     * |        |          |There are four kinds of combination for SC_SCn_PWR pin setting by PWRINV (SC_SCn_PINCTL[11]) and PWREN (SC_SCn_PINCTL[0])
N     * |        |          |A
N     * |        |          |PWRINV (SC_SCn_PINCTL[11]) is bit 1 and PWREN (SC_SCn_PINCTL[0]) is bit 0 and all conditions as below list.,
N     * |        |          |00 = SC_SCn_PWR pin is 0.
N     * |        |          |01 = SC_SCn_PWR pin is 1.
N     * |        |          |10 = SC_SCn_PWR pin is 1.
N     * |        |          |11 = SC_SCn_PWR pin is 0.
N     * |        |          |Note: User must select PWRINV (SC_SCn_PINCTL[11]) before smart card is enabled by SCEN (SC_SCn_CTL[0]).[WH1]
N     * |        |          |[WH1]Tag84
N     * |[16]    |DATSTS    |SC_SCn_DATA Pin Status (Read Only)
N     * |        |          |This bit is the pin status of SC_SCn_DATA.
N     * |        |          |0 = The SC_SCn_DATA pin status is low.
N     * |        |          |1 = The SC_SCn_DATA pin status is high.
N     * |[17]    |PWRSTS    |SCn_PWR Pin Status (Read Only)
N     * |        |          |This bit is the pin status of SC_SCn_PWR.
N     * |        |          |0 = SC_SCn_PWR pin to low.
N     * |        |          |1 = SC_SCn_PWR pin to high.[WH1]
N     * |        |          |[WH1]Tag84
N     * |[18]    |RSTSTS    |SC_SCn_RST Pin Status (Read Only)
N     * |        |          |This bit is the pin status of SC_SCn_RST.
N     * |        |          |0 = SC_SCn_RST pin is low.
N     * |        |          |1 = SC_SCn_RST pin is high. [WH1]
N     * |        |          |[WH1]Tag83
N     * |[30]    |SYNC      |SYNC Flag Indicator (Read Only)
N     * |        |          |Due to synchronization, user should check this bit when writing a new value to SC_SCn_PINCTL register.
N     * |        |          |0 = Synchronizing is completion, user can write new data to SC_SCn_PINCTL register.
N     * |        |          |1 = Last value is synchronizing. [WH1]
N     * |        |          |[WH1]Tag82
N     * @var SC_T::TMRCTL0
N     * Offset: 0x28  SC Timer0 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |CNT       |Timer 0 Counter Value
N     * |        |          |This field indicates the internal Timer0 counter values.
N     * |        |          |Note: Unit of Timer01 counter is ETU base.[WH1]
N     * |        |          |[WH1]Tag9, 37~49
N     * |[27:24] |OPMODE    |Timer 0 Operation Mode Selection
N     * |        |          |This field indicates the internal 824-bit Timer0 operation selection.
N     * |        |          |Refer to Table 1.1-3 Table 1.1-3 for programming Timer0.[WH1]
N     * |        |          |[WH1]Tag9, 37~49
N     * |[31]    |SYNC      |SYNC Flag Indicator (Read Only)
N     * |        |          |Due to synchronization, softwareuser should check this bit when writing a new value to SCn_TMRCTL0 register.
N     * |        |          |0 = Synchronizing is completion, user can write new data to SCn_TMRCTL0 register.
N     * |        |          |1 = Last value is synchronizing. [WH1]
N     * |        |          |[WH1]Tag88
N     * @var SC_T::TMRCTL1
N     * Offset: 0x2C  SC Timer1 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |CNT       |Timer 1 Counter Value
N     * |        |          |This field indicates the internal Timer1 counter values.
N     * |        |          |Note: Unit of Timer1 counter is ETU base.[WH1]
N     * |        |          |[WH1]Tag9, 37~49
N     * |[27:24] |OPMODE    |Timer 1 Operation Mode Selection
N     * |        |          |This field indicates the internal 8-bit Timer1 operation selection.
N     * |        |          |Refer to Table 1.1-3 Table 1.1-3 for programming Timer1.[WH1]
N     * |        |          |[WH1]Tag9, 37~49
N     * |[31]    |SYNC      |SYNC Flag Indicator (Read Only)
N     * |        |          |Due to synchronization, softwareuser should check this bit when writing a new value to SCn_TMRCTL1 register.
N     * |        |          |0 = Synchronizing is completion, user can write new data to SCn_TMRCTL1 register.
N     * |        |          |1 = Last value is synchronizing. [WH1]
N     * |        |          |[WH1]Tag88
N     * @var SC_T::TMRCTL2
N     * Offset: 0x30  SC Timer2 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |CNT       |Timer 2 Counter Value
N     * |        |          |This field indicates the internal Timer2 counter values.
N     * |        |          |Note: Unit of Timer2 counter is ETU base.[WH1]
N     * |        |          |[WH1]Tag9, 37~49
N     * |[27:24] |OPMODE    |Timer 2 Operation Mode Selection
N     * |        |          |This field indicates the internal 8-bit Timer2 operation selection
N     * |        |          |Refer to Table 1.1-3 Table 1.1-3 for programming Timer2.[WH1]
N     * |        |          |[WH1]Tag9, 37~49
N     * |[31]    |SYNC      |SYNC Flag Indicator (Read Only)
N     * |        |          |Due to synchronization, user should check this bit when writing a new value to SCn_TMRCTL2 register.
N     * |        |          |0 = Synchronizing is completion, user can write new data to SCn_TMRCTL2 register.
N     * |        |          |1 = Last value is synchronizing. [WH1]
N     * |        |          |[WH1]Tag88
N     * @var SC_T::UARTCTL
N     * Offset: 0x34  SC UART Mode Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |UARTEN    |UART Mode Enable Bit
N     * |        |          |Sets this bit to enable UART mode function.
N     * |        |          |0 = Smart Card mode.
N     * |        |          |1 = UART mode.
N     * |        |          |Note1: When operating in UART mode, user must set CONSEL (SC_SCn_CTL[5:4]) = 00 and AUTOCEN (SC_SCn_CTL[3]) = 0.
N     * |        |          |Note2: When operating in Smart Card mode, user must set UARTEN (SC_SCn_UARTCTL[0]) = 0.
N     * |        |          |Note3: When UART mode is enabled, hardware will generate a reset SC event to reset FIFO and internal state machine.[WH1]
N     * |        |          |[WH1]Tag94
N     * |[5:4]   |WLS       |Word Length Selection
N     * |        |          |This field is used for select uart UART data transfer length.
N     * |        |          |00 = Word length is 8 bits.
N     * |        |          |01 = Word length is 7 bits.
N     * |        |          |10 = Word length is 6 bits.
N     * |        |          |11 = Word length is 5 bits.
N     * |        |          |Note: In smart card mode, this WLS field must be u201800u2019.[WH1]
N     * |        |          |[WH1]Tag93
N     * |[6]     |PBOFF     |Parity Bit Disable Control
N     * |        |          |Sets tThis bit is used for disable parity check function.
N     * |        |          |0 = Parity bit is generated or checked between the u201Clast data word bitu201D and u201Cstop bitu201D of the serial data.
N     * |        |          |1 = Parity bit is not generated (transmitting data) or checked (receiving data) during transfer.
N     * |        |          |Note: In smart card mode, this field bit must be u20180u2019 (default setting is with parity bit)[WH1].
N     * |        |          |[WH1]Tag21
N     * |[7]     |OPE       |Odd Parity Enable Bit
N     * |        |          |This is used for odd/even parity selection.
N     * |        |          |0 = Even number of logic 1u2019s are transmitted or check the data word and parity bits in receiving mode.
N     * |        |          |1 = Odd number of logic 1u2019s are transmitted or check the data word and parity bits in receiving mode.
N     * |        |          |Note: This bit has effect only when PBOFF bit is u20180u2019.
N     * @var SC_T::TMRDAT0
N     * Offset: 0x38  SC Timer0 Current Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |CNT0      |Timer0 Current Data Value (Read Only)
N     * |        |          |This field indicates the current counter values of Timer0.[WH1]
N     * |        |          |[WH1]Tag37
N     * @var SC_T::TMRDAT12
N     * Offset: 0x3C  SC Timer1/2 Current Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |CNT1      |Timer1 Current Data Value (Read Only)
N     * |        |          |This field indicates the current counter values of Timer1.[WH1]
N     * |        |          |[WH1]Tag37
N     * |[15:8]  |CNT2      |Timer2 Current Data Value (Read Only)
N     * |        |          |This field indicates the current counter values of Timer2.
N     * @var SC_T::ACTCTL
N     * Offset: 0x4C  SC Activation Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4:0]   |T1EXT     |T1 Extend Time of Hardware Activation
N     * |        |          |This field provide the configurable cycles to extend the activation time T1 period.
N     * |        |          |Please refer to SC activation sequence in Figure 1.1-4.
N     * |        |          |The cycle scaling factor is 2048 and .
N     * |        |          |Extend cycles = (filled valueT1EXT * 2048) cycles.
N     * |        |          |Refer to SC activation sequence in Figure 1.1-4 SC Activation Sequence.
N     * |        |          |For example:,
N     * |        |          |If SCLK is= 4MHz, each clock cycle cyiscle = 0.25us.,.
N     * |        |          |Filled 20 to this T1EXT, thenfield
N     * |        |          |Extend time == 20 * 2048 * 0.25us = 10.24 ms.
N     * |        |          |Note: Setting 0 to this field conforms to the protocol ISO/IEC 7816-3[WH1].
N     * |        |          |[WH1]Tag98
N     */
N
N    __IO uint32_t DAT;                   /*!< [0x0000] SC Receive/Transmit Holding Buffer Register                      */
X    volatile uint32_t DAT;                    
N    __IO uint32_t CTL;                   /*!< [0x0004] SC Control Register                                              */
X    volatile uint32_t CTL;                    
N    __IO uint32_t ALTCTL;                /*!< [0x0008] SC Alternate Control Register                                    */
X    volatile uint32_t ALTCTL;                 
N    __IO uint32_t EGT;                   /*!< [0x000c] SC Extra Guard Time Register                                     */
X    volatile uint32_t EGT;                    
N    __IO uint32_t RXTOUT;                /*!< [0x0010] SC Receive Buffer Time-out Counter Register                      */
X    volatile uint32_t RXTOUT;                 
N    __IO uint32_t ETUCTL;                /*!< [0x0014] SC Element Time Unit Control Register                            */
X    volatile uint32_t ETUCTL;                 
N    __IO uint32_t INTEN;                 /*!< [0x0018] SC Interrupt Enable Control Register                             */
X    volatile uint32_t INTEN;                  
N    __IO uint32_t INTSTS;                /*!< [0x001c] SC Interrupt Status Register                                     */
X    volatile uint32_t INTSTS;                 
N    __IO uint32_t STATUS;                /*!< [0x0020] SC Transfer Status Register                                      */
X    volatile uint32_t STATUS;                 
N    __IO uint32_t PINCTL;                /*!< [0x0024] SC Pin Control State Register                                    */
X    volatile uint32_t PINCTL;                 
N    __IO uint32_t TMRCTL0;               /*!< [0x0028] SC Timer0 Control Register                                       */
X    volatile uint32_t TMRCTL0;                
N    __IO uint32_t TMRCTL1;               /*!< [0x002c] SC Timer1 Control Register                                       */
X    volatile uint32_t TMRCTL1;                
N    __IO uint32_t TMRCTL2;               /*!< [0x0030] SC Timer2 Control Register                                       */
X    volatile uint32_t TMRCTL2;                
N    __IO uint32_t UARTCTL;               /*!< [0x0034] SC UART Mode Control Register                                    */
X    volatile uint32_t UARTCTL;                
N    __I  uint32_t TMRDAT0;               /*!< [0x0038] SC Timer0 Current Data Register                                  */
X    volatile const  uint32_t TMRDAT0;                
N    __I  uint32_t TMRDAT12;              /*!< [0x003c] SC Timer1/2 Current Data Register                                */
X    volatile const  uint32_t TMRDAT12;               
N    __I  uint32_t RESERVE0[3];
X    volatile const  uint32_t RESERVE0[3];
N    __IO uint32_t ACTCTL;                /*!< [0x004c] SC Activation Control Register                                   */
X    volatile uint32_t ACTCTL;                 
N
N////    __IO uint32_t DAT;           /* Offset: 0x00  SC Receiving/Transmit Holding Buffer Register.                     */
N////    __IO uint32_t CTL;           /* Offset: 0x04  SC Control Register.                                               */
N////    __IO uint32_t ALTCTL;        /* Offset: 0x08  SC Alternate Control Register.                                     */
N////    __IO uint32_t EGT;           /* Offset: 0x0C  SC Extend Guard Time Register.                                     */
N////    __IO uint32_t RXTOUT;        /* Offset: 0x10  SC Receive buffer Time-out Register.                               */
N////    __IO uint32_t ETUCTL;        /* Offset: 0x14  SC ETU Control Register.                                           */
N////    __IO uint32_t INTEN;         /* Offset: 0x18  SC Interrupt Enable Control Register.                              */
N////    __IO uint32_t INTSTS;        /* Offset: 0x1C  SC Interrupt Status Register.                                      */
N////    __IO uint32_t STATUS;        /* Offset: 0x20  SC Status Register.                                                */
N////    __IO uint32_t PINCTL;        /* Offset: 0x24  SC Pin Control State Register.                                     */
N////    __IO uint32_t TMRCTL0;       /* Offset: 0x28  SC Internal Timer Control Register 0.                              */
N////    __IO uint32_t TMRCTL1;       /* Offset: 0x2C  SC Internal Timer Control Register 1.                              */
N////    __IO uint32_t TMRCTL2;       /* Offset: 0x30  SC Internal Timer Control Register 2.                              */
N////    __IO uint32_t UARTCTL;       /* Offset: 0x34  SC UART Mode Control Register.                                     */
N////    __I  uint32_t TMRDAT0;       /* Offset: 0x38  SC Timer0 Current Data Register.                                   */
N////    __I  uint32_t TMRDAT1_2;     /* Offset: 0x3C  SC Timer1/2 Current Data Register.                                 */
N//////    __I  uint32_t RESERVE[3];
N////        /* Not released in TRM */
N////        __IO  uint32_t  PETCTL; /*!< Offset: 0x0040  SC Parity Error Timing Setting Register                     */
N////        __IO  uint32_t  BGTEXT; /*!< Offset: 0x0044  SC Block Guard Timing Extent  Register                  */
N////        __IO  uint32_t  EGTADJ; /*!< Offset: 0x0048  SC Block Guard Timing Extent  Register                 */
N////    __IO uint32_t ACTCTL;        /* Offset: 0x4C  SC Activation Control Register.                                    */
N////
N
N} SC_T;
N
N/**
N    @addtogroup SC_CONST SC Bit Field Definition
N    Constant Definitions for SC Controller
N@{ */
N
N#define SC_DAT_DAT_Pos                   (0)                                               /*!< SC_T::DAT: DAT Position                */
N#define SC_DAT_DAT_Msk                   (0xfful << SC_DAT_DAT_Pos)                        /*!< SC_T::DAT: DAT Mask                    */
N
N#define SC_CTL_SCEN_Pos                  (0)                                               /*!< SC_T::CTL: SCEN Position               */
N#define SC_CTL_SCEN_Msk                  (0x1ul << SC_CTL_SCEN_Pos)                        /*!< SC_T::CTL: SCEN Mask                   */
N
N#define SC_CTL_RXOFF_Pos                 (1)                                               /*!< SC_T::CTL: RXOFF Position              */
N#define SC_CTL_RXOFF_Msk                 (0x1ul << SC_CTL_RXOFF_Pos)                       /*!< SC_T::CTL: RXOFF Mask                  */
N
N#define SC_CTL_TXOFF_Pos                 (2)                                               /*!< SC_T::CTL: TXOFF Position              */
N#define SC_CTL_TXOFF_Msk                 (0x1ul << SC_CTL_TXOFF_Pos)                       /*!< SC_T::CTL: TXOFF Mask                  */
N
N#define SC_CTL_AUTOCEN_Pos               (3)                                               /*!< SC_T::CTL: AUTOCEN Position            */
N#define SC_CTL_AUTOCEN_Msk               (0x1ul << SC_CTL_AUTOCEN_Pos)                     /*!< SC_T::CTL: AUTOCEN Mask                */
N
N#define SC_CTL_CONSEL_Pos                (4)                                               /*!< SC_T::CTL: CONSEL Position             */
N#define SC_CTL_CONSEL_Msk                (0x3ul << SC_CTL_CONSEL_Pos)                      /*!< SC_T::CTL: CONSEL Mask                 */
N
N#define SC_CTL_RXTRGLV_Pos               (6)                                               /*!< SC_T::CTL: RXTRGLV Position            */
N#define SC_CTL_RXTRGLV_Msk               (0x3ul << SC_CTL_RXTRGLV_Pos)                     /*!< SC_T::CTL: RXTRGLV Mask                */
N
N#define SC_CTL_BGT_Pos                   (8)                                               /*!< SC_T::CTL: BGT Position                */
N#define SC_CTL_BGT_Msk                   (0x1ful << SC_CTL_BGT_Pos)                        /*!< SC_T::CTL: BGT Mask                    */
N
N#define SC_CTL_TMRSEL_Pos                (13)                                              /*!< SC_T::CTL: TMRSEL Position             */
N#define SC_CTL_TMRSEL_Msk                (0x3ul << SC_CTL_TMRSEL_Pos)                      /*!< SC_T::CTL: TMRSEL Mask                 */
N
N#define SC_CTL_NSB_Pos                   (15)                                              /*!< SC_T::CTL: NSB Position                */
N#define SC_CTL_NSB_Msk                   (0x1ul << SC_CTL_NSB_Pos)                         /*!< SC_T::CTL: NSB Mask                    */
N
N#define SC_CTL_RXRTY_Pos                 (16)                                              /*!< SC_T::CTL: RXRTY Position              */
N#define SC_CTL_RXRTY_Msk                 (0x7ul << SC_CTL_RXRTY_Pos)                       /*!< SC_T::CTL: RXRTY Mask                  */
N
N#define SC_CTL_RXRTYEN_Pos               (19)                                              /*!< SC_T::CTL: RXRTYEN Position            */
N#define SC_CTL_RXRTYEN_Msk               (0x1ul << SC_CTL_RXRTYEN_Pos)                     /*!< SC_T::CTL: RXRTYEN Mask                */
N
N#define SC_CTL_TXRTY_Pos                 (20)                                              /*!< SC_T::CTL: TXRTY Position              */
N#define SC_CTL_TXRTY_Msk                 (0x7ul << SC_CTL_TXRTY_Pos)                       /*!< SC_T::CTL: TXRTY Mask                  */
N
N#define SC_CTL_TXRTYEN_Pos               (23)                                              /*!< SC_T::CTL: TXRTYEN Position            */
N#define SC_CTL_TXRTYEN_Msk               (0x1ul << SC_CTL_TXRTYEN_Pos)                     /*!< SC_T::CTL: TXRTYEN Mask                */
N
N#define SC_CTL_CDDBSEL_Pos               (24)                                              /*!< SC_T::CTL: CDDBSEL Position            */
N#define SC_CTL_CDDBSEL_Msk               (0x3ul << SC_CTL_CDDBSEL_Pos)                     /*!< SC_T::CTL: CDDBSEL Mask                */
N
N#define SC_CTL_CDLV_Pos                  (26)                                              /*!< SC_T::CTL: CDLV Position               */
N#define SC_CTL_CDLV_Msk                  (0x1ul << SC_CTL_CDLV_Pos)                        /*!< SC_T::CTL: CDLV Mask                   */
N
N#define SC_CTL_SYNC_Pos                  (30)                                              /*!< SC_T::CTL: SYNC Position               */
N#define SC_CTL_SYNC_Msk                  (0x1ul << SC_CTL_SYNC_Pos)                        /*!< SC_T::CTL: SYNC Mask                   */
N
N#define SC_ALTCTL_TXRST_Pos              (0)                                               /*!< SC_T::ALTCTL: TXRST Position           */
N#define SC_ALTCTL_TXRST_Msk              (0x1ul << SC_ALTCTL_TXRST_Pos)                    /*!< SC_T::ALTCTL: TXRST Mask               */
N
N#define SC_ALTCTL_RXRST_Pos              (1)                                               /*!< SC_T::ALTCTL: RXRST Position           */
N#define SC_ALTCTL_RXRST_Msk              (0x1ul << SC_ALTCTL_RXRST_Pos)                    /*!< SC_T::ALTCTL: RXRST Mask               */
N
N#define SC_ALTCTL_DACTEN_Pos             (2)                                               /*!< SC_T::ALTCTL: DACTEN Position          */
N#define SC_ALTCTL_DACTEN_Msk             (0x1ul << SC_ALTCTL_DACTEN_Pos)                   /*!< SC_T::ALTCTL: DACTEN Mask              */
N
N#define SC_ALTCTL_ACTEN_Pos              (3)                                               /*!< SC_T::ALTCTL: ACTEN Position           */
N#define SC_ALTCTL_ACTEN_Msk              (0x1ul << SC_ALTCTL_ACTEN_Pos)                    /*!< SC_T::ALTCTL: ACTEN Mask               */
N
N#define SC_ALTCTL_WARSTEN_Pos            (4)                                               /*!< SC_T::ALTCTL: WARSTEN Position         */
N#define SC_ALTCTL_WARSTEN_Msk            (0x1ul << SC_ALTCTL_WARSTEN_Pos)                  /*!< SC_T::ALTCTL: WARSTEN Mask             */
N
N#define SC_ALTCTL_CNTEN0_Pos             (5)                                               /*!< SC_T::ALTCTL: CNTEN0 Position          */
N#define SC_ALTCTL_CNTEN0_Msk             (0x1ul << SC_ALTCTL_CNTEN0_Pos)                   /*!< SC_T::ALTCTL: CNTEN0 Mask              */
N
N#define SC_ALTCTL_CNTEN1_Pos             (6)                                               /*!< SC_T::ALTCTL: CNTEN1 Position          */
N#define SC_ALTCTL_CNTEN1_Msk             (0x1ul << SC_ALTCTL_CNTEN1_Pos)                   /*!< SC_T::ALTCTL: CNTEN1 Mask              */
N
N#define SC_ALTCTL_CNTEN2_Pos             (7)                                               /*!< SC_T::ALTCTL: CNTEN2 Position          */
N#define SC_ALTCTL_CNTEN2_Msk             (0x1ul << SC_ALTCTL_CNTEN2_Pos)                   /*!< SC_T::ALTCTL: CNTEN2 Mask              */
N
N#define SC_ALTCTL_INITSEL_Pos            (8)                                               /*!< SC_T::ALTCTL: INITSEL Position         */
N#define SC_ALTCTL_INITSEL_Msk            (0x3ul << SC_ALTCTL_INITSEL_Pos)                  /*!< SC_T::ALTCTL: INITSEL Mask             */
N
N#define SC_ALTCTL_ADACEN_Pos             (11)                                              /*!< SC_T::ALTCTL: ADACEN Position          */
N#define SC_ALTCTL_ADACEN_Msk             (0x1ul << SC_ALTCTL_ADACEN_Pos)                   /*!< SC_T::ALTCTL: ADACEN Mask              */
N
N#define SC_ALTCTL_RXBGTEN_Pos            (12)                                              /*!< SC_T::ALTCTL: RXBGTEN Position         */
N#define SC_ALTCTL_RXBGTEN_Msk            (0x1ul << SC_ALTCTL_RXBGTEN_Pos)                  /*!< SC_T::ALTCTL: RXBGTEN Mask             */
N
N#define SC_ALTCTL_ACTSTS0_Pos            (13)                                              /*!< SC_T::ALTCTL: ACTSTS0 Position         */
N#define SC_ALTCTL_ACTSTS0_Msk            (0x1ul << SC_ALTCTL_ACTSTS0_Pos)                  /*!< SC_T::ALTCTL: ACTSTS0 Mask             */
N
N#define SC_ALTCTL_ACTSTS1_Pos            (14)                                              /*!< SC_T::ALTCTL: ACTSTS1 Position         */
N#define SC_ALTCTL_ACTSTS1_Msk            (0x1ul << SC_ALTCTL_ACTSTS1_Pos)                  /*!< SC_T::ALTCTL: ACTSTS1 Mask             */
N
N#define SC_ALTCTL_ACTSTS2_Pos            (15)                                              /*!< SC_T::ALTCTL: ACTSTS2 Position         */
N#define SC_ALTCTL_ACTSTS2_Msk            (0x1ul << SC_ALTCTL_ACTSTS2_Pos)                  /*!< SC_T::ALTCTL: ACTSTS2 Mask             */
N
N#define SC_ALTCTL_SYNC_Pos               (31)                                              /*!< SC_T::ALTCTL: SYNC Position            */
N#define SC_ALTCTL_SYNC_Msk               (0x1ul << SC_ALTCTL_SYNC_Pos)                     /*!< SC_T::ALTCTL: SYNC Mask                */
N
N#define SC_EGT_EGT_Pos                   (0)                                               /*!< SC_T::EGT: EGT Position                */
N#define SC_EGT_EGT_Msk                   (0xfful << SC_EGT_EGT_Pos)                        /*!< SC_T::EGT: EGT Mask                    */
N
N#define SC_RXTOUT_RFTM_Pos               (0)                                               /*!< SC_T::RXTOUT: RFTM Position            */
N#define SC_RXTOUT_RFTM_Msk               (0x1fful << SC_RXTOUT_RFTM_Pos)                   /*!< SC_T::RXTOUT: RFTM Mask                */
N
N#define SC_ETUCTL_ETURDIV_Pos            (0)                                               /*!< SC_T::ETUCTL: ETURDIV Position         */
N#define SC_ETUCTL_ETURDIV_Msk            (0xffful << SC_ETUCTL_ETURDIV_Pos)                /*!< SC_T::ETUCTL: ETURDIV Mask             */
N
N#define SC_INTEN_RDAIEN_Pos              (0)                                               /*!< SC_T::INTEN: RDAIEN Position           */
N#define SC_INTEN_RDAIEN_Msk              (0x1ul << SC_INTEN_RDAIEN_Pos)                    /*!< SC_T::INTEN: RDAIEN Mask               */
N
N#define SC_INTEN_TXEIEN_Pos              (1)                                               /*!< SC_T::INTEN: TXEIEN Position           */
N#define SC_INTEN_TXEIEN_Msk              (0x1ul << SC_INTEN_TXEIEN_Pos)                    /*!< SC_T::INTEN: TXEIEN Mask               */
N
N#define SC_INTEN_TERRIEN_Pos             (2)                                               /*!< SC_T::INTEN: TERRIEN Position          */
N#define SC_INTEN_TERRIEN_Msk             (0x1ul << SC_INTEN_TERRIEN_Pos)                   /*!< SC_T::INTEN: TERRIEN Mask              */
N
N#define SC_INTEN_TMR0IEN_Pos             (3)                                               /*!< SC_T::INTEN: TMR0IEN Position          */
N#define SC_INTEN_TMR0IEN_Msk             (0x1ul << SC_INTEN_TMR0IEN_Pos)                   /*!< SC_T::INTEN: TMR0IEN Mask              */
N
N#define SC_INTEN_TMR1IEN_Pos             (4)                                               /*!< SC_T::INTEN: TMR1IEN Position          */
N#define SC_INTEN_TMR1IEN_Msk             (0x1ul << SC_INTEN_TMR1IEN_Pos)                   /*!< SC_T::INTEN: TMR1IEN Mask              */
N
N#define SC_INTEN_TMR2IEN_Pos             (5)                                               /*!< SC_T::INTEN: TMR2IEN Position          */
N#define SC_INTEN_TMR2IEN_Msk             (0x1ul << SC_INTEN_TMR2IEN_Pos)                   /*!< SC_T::INTEN: TMR2IEN Mask              */
N
N#define SC_INTEN_BGTIEN_Pos              (6)                                               /*!< SC_T::INTEN: BGTIEN Position           */
N#define SC_INTEN_BGTIEN_Msk              (0x1ul << SC_INTEN_BGTIEN_Pos)                    /*!< SC_T::INTEN: BGTIEN Mask               */
N
N#define SC_INTEN_CDIEN_Pos               (7)                                               /*!< SC_T::INTEN: CDIEN Position            */
N#define SC_INTEN_CDIEN_Msk               (0x1ul << SC_INTEN_CDIEN_Pos)                     /*!< SC_T::INTEN: CDIEN Mask                */
N
N#define SC_INTEN_INITIEN_Pos             (8)                                               /*!< SC_T::INTEN: INITIEN Position          */
N#define SC_INTEN_INITIEN_Msk             (0x1ul << SC_INTEN_INITIEN_Pos)                   /*!< SC_T::INTEN: INITIEN Mask              */
N
N#define SC_INTEN_RXTOIEN_Pos             (9)                                               /*!< SC_T::INTEN: RXTOIEN Position          */
N#define SC_INTEN_RXTOIEN_Msk             (0x1ul << SC_INTEN_RXTOIEN_Pos)                   /*!< SC_T::INTEN: RXTOIEN Mask              */
N
N#define SC_INTEN_ACERRIEN_Pos            (10)                                              /*!< SC_T::INTEN: ACERRIEN Position         */
N#define SC_INTEN_ACERRIEN_Msk            (0x1ul << SC_INTEN_ACERRIEN_Pos)                  /*!< SC_T::INTEN: ACERRIEN Mask             */
N
N#define SC_INTSTS_RDAIF_Pos              (0)                                               /*!< SC_T::INTSTS: RDAIF Position           */
N#define SC_INTSTS_RDAIF_Msk              (0x1ul << SC_INTSTS_RDAIF_Pos)                    /*!< SC_T::INTSTS: RDAIF Mask               */
N
N#define SC_INTSTS_TXEIF_Pos              (1)                                               /*!< SC_T::INTSTS: TXEIF Position           */
N#define SC_INTSTS_TXEIF_Msk              (0x1ul << SC_INTSTS_TXEIF_Pos)                    /*!< SC_T::INTSTS: TXEIF Mask               */
N
N#define SC_INTSTS_TERRIF_Pos             (2)                                               /*!< SC_T::INTSTS: TERRIF Position          */
N#define SC_INTSTS_TERRIF_Msk             (0x1ul << SC_INTSTS_TERRIF_Pos)                   /*!< SC_T::INTSTS: TERRIF Mask              */
N
N#define SC_INTSTS_TMR0IF_Pos             (3)                                               /*!< SC_T::INTSTS: TMR0IF Position          */
N#define SC_INTSTS_TMR0IF_Msk             (0x1ul << SC_INTSTS_TMR0IF_Pos)                   /*!< SC_T::INTSTS: TMR0IF Mask              */
N
N#define SC_INTSTS_TMR1IF_Pos             (4)                                               /*!< SC_T::INTSTS: TMR1IF Position          */
N#define SC_INTSTS_TMR1IF_Msk             (0x1ul << SC_INTSTS_TMR1IF_Pos)                   /*!< SC_T::INTSTS: TMR1IF Mask              */
N
N#define SC_INTSTS_TMR2IF_Pos             (5)                                               /*!< SC_T::INTSTS: TMR2IF Position          */
N#define SC_INTSTS_TMR2IF_Msk             (0x1ul << SC_INTSTS_TMR2IF_Pos)                   /*!< SC_T::INTSTS: TMR2IF Mask              */
N
N#define SC_INTSTS_BGTIF_Pos              (6)                                               /*!< SC_T::INTSTS: BGTIF Position           */
N#define SC_INTSTS_BGTIF_Msk              (0x1ul << SC_INTSTS_BGTIF_Pos)                    /*!< SC_T::INTSTS: BGTIF Mask               */
N
N#define SC_INTSTS_CDIF_Pos               (7)                                               /*!< SC_T::INTSTS: CDIF Position            */
N#define SC_INTSTS_CDIF_Msk               (0x1ul << SC_INTSTS_CDIF_Pos)                     /*!< SC_T::INTSTS: CDIF Mask                */
N
N#define SC_INTSTS_INITIF_Pos             (8)                                               /*!< SC_T::INTSTS: INITIF Position          */
N#define SC_INTSTS_INITIF_Msk             (0x1ul << SC_INTSTS_INITIF_Pos)                   /*!< SC_T::INTSTS: INITIF Mask              */
N
N#define SC_INTSTS_RXTOIF_Pos             (9)                                               /*!< SC_T::INTSTS: RXTOIF Position          */
N#define SC_INTSTS_RXTOIF_Msk             (0x1ul << SC_INTSTS_RXTOIF_Pos)                   /*!< SC_T::INTSTS: RXTOIF Mask              */
N
N#define SC_INTSTS_ACERRIF_Pos            (10)                                              /*!< SC_T::INTSTS: ACERRIF Position         */
N#define SC_INTSTS_ACERRIF_Msk            (0x1ul << SC_INTSTS_ACERRIF_Pos)                  /*!< SC_T::INTSTS: ACERRIF Mask             */
N
N#define SC_STATUS_RXOV_Pos               (0)                                               /*!< SC_T::STATUS: RXOV Position            */
N#define SC_STATUS_RXOV_Msk               (0x1ul << SC_STATUS_RXOV_Pos)                     /*!< SC_T::STATUS: RXOV Mask                */
N
N#define SC_STATUS_RXEMPTY_Pos            (1)                                               /*!< SC_T::STATUS: RXEMPTY Position         */
N#define SC_STATUS_RXEMPTY_Msk            (0x1ul << SC_STATUS_RXEMPTY_Pos)                  /*!< SC_T::STATUS: RXEMPTY Mask             */
N
N#define SC_STATUS_RXFULL_Pos             (2)                                               /*!< SC_T::STATUS: RXFULL Position          */
N#define SC_STATUS_RXFULL_Msk             (0x1ul << SC_STATUS_RXFULL_Pos)                   /*!< SC_T::STATUS: RXFULL Mask              */
N
N#define SC_STATUS_PEF_Pos                (4)                                               /*!< SC_T::STATUS: PEF Position             */
N#define SC_STATUS_PEF_Msk                (0x1ul << SC_STATUS_PEF_Pos)                      /*!< SC_T::STATUS: PEF Mask                 */
N
N#define SC_STATUS_FEF_Pos                (5)                                               /*!< SC_T::STATUS: FEF Position             */
N#define SC_STATUS_FEF_Msk                (0x1ul << SC_STATUS_FEF_Pos)                      /*!< SC_T::STATUS: FEF Mask                 */
N
N#define SC_STATUS_BEF_Pos                (6)                                               /*!< SC_T::STATUS: BEF Position             */
N#define SC_STATUS_BEF_Msk                (0x1ul << SC_STATUS_BEF_Pos)                      /*!< SC_T::STATUS: BEF Mask                 */
N
N#define SC_STATUS_TXOV_Pos               (8)                                               /*!< SC_T::STATUS: TXOV Position            */
N#define SC_STATUS_TXOV_Msk               (0x1ul << SC_STATUS_TXOV_Pos)                     /*!< SC_T::STATUS: TXOV Mask                */
N
N#define SC_STATUS_TXEMPTY_Pos            (9)                                               /*!< SC_T::STATUS: TXEMPTY Position         */
N#define SC_STATUS_TXEMPTY_Msk            (0x1ul << SC_STATUS_TXEMPTY_Pos)                  /*!< SC_T::STATUS: TXEMPTY Mask             */
N
N#define SC_STATUS_TXFULL_Pos             (10)                                              /*!< SC_T::STATUS: TXFULL Position          */
N#define SC_STATUS_TXFULL_Msk             (0x1ul << SC_STATUS_TXFULL_Pos)                   /*!< SC_T::STATUS: TXFULL Mask              */
N
N#define SC_STATUS_CREMOVE_Pos            (11)                                              /*!< SC_T::STATUS: CREMOVE Position         */
N#define SC_STATUS_CREMOVE_Msk            (0x1ul << SC_STATUS_CREMOVE_Pos)                  /*!< SC_T::STATUS: CREMOVE Mask             */
N
N#define SC_STATUS_CINSERT_Pos            (12)                                              /*!< SC_T::STATUS: CINSERT Position         */
N#define SC_STATUS_CINSERT_Msk            (0x1ul << SC_STATUS_CINSERT_Pos)                  /*!< SC_T::STATUS: CINSERT Mask             */
N
N#define SC_STATUS_CDPINSTS_Pos           (13)                                              /*!< SC_T::STATUS: CDPINSTS Position        */
N#define SC_STATUS_CDPINSTS_Msk           (0x1ul << SC_STATUS_CDPINSTS_Pos)                 /*!< SC_T::STATUS: CDPINSTS Mask            */
N
N#define SC_STATUS_RXPOINT_Pos            (16)                                              /*!< SC_T::STATUS: RXPOINT Position         */
N#define SC_STATUS_RXPOINT_Msk            (0x7ul << SC_STATUS_RXPOINT_Pos)                  /*!< SC_T::STATUS: RXPOINT Mask             */
N
N#define SC_STATUS_RXRTYERR_Pos           (21)                                              /*!< SC_T::STATUS: RXRTYERR Position        */
N#define SC_STATUS_RXRTYERR_Msk           (0x1ul << SC_STATUS_RXRTYERR_Pos)                 /*!< SC_T::STATUS: RXRTYERR Mask            */
N
N#define SC_STATUS_RXOVERR_Pos            (22)                                              /*!< SC_T::STATUS: RXOVERR Position         */
N#define SC_STATUS_RXOVERR_Msk            (0x1ul << SC_STATUS_RXOVERR_Pos)                  /*!< SC_T::STATUS: RXOVERR Mask             */
N
N#define SC_STATUS_RXACT_Pos              (23)                                              /*!< SC_T::STATUS: RXACT Position           */
N#define SC_STATUS_RXACT_Msk              (0x1ul << SC_STATUS_RXACT_Pos)                    /*!< SC_T::STATUS: RXACT Mask               */
N
N#define SC_STATUS_TXPOINT_Pos            (24)                                              /*!< SC_T::STATUS: TXPOINT Position         */
N#define SC_STATUS_TXPOINT_Msk            (0x7ul << SC_STATUS_TXPOINT_Pos)                  /*!< SC_T::STATUS: TXPOINT Mask             */
N
N#define SC_STATUS_TXRTYERR_Pos           (29)                                              /*!< SC_T::STATUS: TXRTYERR Position        */
N#define SC_STATUS_TXRTYERR_Msk           (0x1ul << SC_STATUS_TXRTYERR_Pos)                 /*!< SC_T::STATUS: TXRTYERR Mask            */
N
N#define SC_STATUS_TXOVERR_Pos            (30)                                              /*!< SC_T::STATUS: TXOVERR Position         */
N#define SC_STATUS_TXOVERR_Msk            (0x1ul << SC_STATUS_TXOVERR_Pos)                  /*!< SC_T::STATUS: TXOVERR Mask             */
N
N#define SC_STATUS_TXACT_Pos              (31)                                              /*!< SC_T::STATUS: TXACT Position           */
N#define SC_STATUS_TXACT_Msk              (0x1ul << SC_STATUS_TXACT_Pos)                    /*!< SC_T::STATUS: TXACT Mask               */
N
N#define SC_PINCTL_PWREN_Pos              (0)                                               /*!< SC_T::PINCTL: PWREN Position           */
N#define SC_PINCTL_PWREN_Msk              (0x1ul << SC_PINCTL_PWREN_Pos)                    /*!< SC_T::PINCTL: PWREN Mask               */
N
N#define SC_PINCTL_SCRST_Pos              (1)                                               /*!< SC_T::PINCTL: SCRST Position           */
N#define SC_PINCTL_SCRST_Msk              (0x1ul << SC_PINCTL_SCRST_Pos)                    /*!< SC_T::PINCTL: SCRST Mask               */
N
N#define SC_PINCTL_CLKKEEP_Pos            (6)                                               /*!< SC_T::PINCTL: CLKKEEP Position         */
N#define SC_PINCTL_CLKKEEP_Msk            (0x1ul << SC_PINCTL_CLKKEEP_Pos)                  /*!< SC_T::PINCTL: CLKKEEP Mask             */
N
N#define SC_PINCTL_SCDATA_Pos             (9)                                               /*!< SC_T::PINCTL: SCDATA Position          */
N#define SC_PINCTL_SCDATA_Msk             (0x1ul << SC_PINCTL_SCDATA_Pos)                   /*!< SC_T::PINCTL: SCDATA Mask              */
N
N#define SC_PINCTL_PWRINV_Pos             (11)                                              /*!< SC_T::PINCTL: PWRINV Position          */
N#define SC_PINCTL_PWRINV_Msk             (0x1ul << SC_PINCTL_PWRINV_Pos)                   /*!< SC_T::PINCTL: PWRINV Mask              */
N
N#define SC_PINCTL_DATSTS_Pos             (16)                                              /*!< SC_T::PINCTL: DATSTS Position          */
N#define SC_PINCTL_DATSTS_Msk             (0x1ul << SC_PINCTL_DATSTS_Pos)                   /*!< SC_T::PINCTL: DATSTS Mask              */
N
N#define SC_PINCTL_PWRSTS_Pos             (17)                                              /*!< SC_T::PINCTL: PWRSTS Position          */
N#define SC_PINCTL_PWRSTS_Msk             (0x1ul << SC_PINCTL_PWRSTS_Pos)                   /*!< SC_T::PINCTL: PWRSTS Mask              */
N
N#define SC_PINCTL_RSTSTS_Pos             (18)                                              /*!< SC_T::PINCTL: RSTSTS Position          */
N#define SC_PINCTL_RSTSTS_Msk             (0x1ul << SC_PINCTL_RSTSTS_Pos)                   /*!< SC_T::PINCTL: RSTSTS Mask              */
N
N#define SC_PINCTL_SYNC_Pos               (30)                                              /*!< SC_T::PINCTL: SYNC Position            */
N#define SC_PINCTL_SYNC_Msk               (0x1ul << SC_PINCTL_SYNC_Pos)                     /*!< SC_T::PINCTL: SYNC Mask                */
N
N#define SC_TMRCTL0_CNT_Pos               (0)                                               /*!< SC_T::TMRCTL0: CNT Position            */
N#define SC_TMRCTL0_CNT_Msk               (0xfffffful << SC_TMRCTL0_CNT_Pos)                /*!< SC_T::TMRCTL0: CNT Mask                */
N
N#define SC_TMRCTL0_OPMODE_Pos            (24)                                              /*!< SC_T::TMRCTL0: OPMODE Position         */
N#define SC_TMRCTL0_OPMODE_Msk            (0xful << SC_TMRCTL0_OPMODE_Pos)                  /*!< SC_T::TMRCTL0: OPMODE Mask             */
N
N#define SC_TMRCTL0_SYNC_Pos              (31)                                              /*!< SC_T::TMRCTL0: SYNC Position           */
N#define SC_TMRCTL0_SYNC_Msk              (0x1ul << SC_TMRCTL0_SYNC_Pos)                    /*!< SC_T::TMRCTL0: SYNC Mask               */
N
N#define SC_TMRCTL1_CNT_Pos               (0)                                               /*!< SC_T::TMRCTL1: CNT Position            */
N#define SC_TMRCTL1_CNT_Msk               (0xfful << SC_TMRCTL1_CNT_Pos)                    /*!< SC_T::TMRCTL1: CNT Mask                */
N
N#define SC_TMRCTL1_OPMODE_Pos            (24)                                              /*!< SC_T::TMRCTL1: OPMODE Position         */
N#define SC_TMRCTL1_OPMODE_Msk            (0xful << SC_TMRCTL1_OPMODE_Pos)                  /*!< SC_T::TMRCTL1: OPMODE Mask             */
N
N#define SC_TMRCTL1_SYNC_Pos              (31)                                              /*!< SC_T::TMRCTL1: SYNC Position           */
N#define SC_TMRCTL1_SYNC_Msk              (0x1ul << SC_TMRCTL1_SYNC_Pos)                    /*!< SC_T::TMRCTL1: SYNC Mask               */
N
N#define SC_TMRCTL2_CNT_Pos               (0)                                               /*!< SC_T::TMRCTL2: CNT Position            */
N#define SC_TMRCTL2_CNT_Msk               (0xfful << SC_TMRCTL2_CNT_Pos)                    /*!< SC_T::TMRCTL2: CNT Mask                */
N
N#define SC_TMRCTL2_OPMODE_Pos            (24)                                              /*!< SC_T::TMRCTL2: OPMODE Position         */
N#define SC_TMRCTL2_OPMODE_Msk            (0xful << SC_TMRCTL2_OPMODE_Pos)                  /*!< SC_T::TMRCTL2: OPMODE Mask             */
N
N#define SC_TMRCTL2_SYNC_Pos              (31)                                              /*!< SC_T::TMRCTL2: SYNC Position           */
N#define SC_TMRCTL2_SYNC_Msk              (0x1ul << SC_TMRCTL2_SYNC_Pos)                    /*!< SC_T::TMRCTL2: SYNC Mask               */
N
N#define SC_UARTCTL_UARTEN_Pos            (0)                                               /*!< SC_T::UARTCTL: UARTEN Position         */
N#define SC_UARTCTL_UARTEN_Msk            (0x1ul << SC_UARTCTL_UARTEN_Pos)                  /*!< SC_T::UARTCTL: UARTEN Mask             */
N
N#define SC_UARTCTL_WLS_Pos               (4)                                               /*!< SC_T::UARTCTL: WLS Position            */
N#define SC_UARTCTL_WLS_Msk               (0x3ul << SC_UARTCTL_WLS_Pos)                     /*!< SC_T::UARTCTL: WLS Mask                */
N
N#define SC_UARTCTL_PBOFF_Pos             (6)                                               /*!< SC_T::UARTCTL: PBOFF Position          */
N#define SC_UARTCTL_PBOFF_Msk             (0x1ul << SC_UARTCTL_PBOFF_Pos)                   /*!< SC_T::UARTCTL: PBOFF Mask              */
N
N#define SC_UARTCTL_OPE_Pos               (7)                                               /*!< SC_T::UARTCTL: OPE Position            */
N#define SC_UARTCTL_OPE_Msk               (0x1ul << SC_UARTCTL_OPE_Pos)                     /*!< SC_T::UARTCTL: OPE Mask                */
N
N#define SC_TMRDAT0_CNT0_Pos              (0)                                               /*!< SC_T::TMRDAT0: CNT0 Position           */
N#define SC_TMRDAT0_CNT0_Msk              (0xfffffful << SC_TMRDAT0_CNT0_Pos)               /*!< SC_T::TMRDAT0: CNT0 Mask               */
N
N#define SC_TMRDAT12_CNT1_Pos             (0)                                               /*!< SC_T::TMRDAT12: CNT1 Position          */
N#define SC_TMRDAT12_CNT1_Msk             (0xfful << SC_TMRDAT12_CNT1_Pos)                  /*!< SC_T::TMRDAT12: CNT1 Mask              */
N
N#define SC_TMRDAT12_CNT2_Pos             (8)                                               /*!< SC_T::TMRDAT12: CNT2 Position          */
N#define SC_TMRDAT12_CNT2_Msk             (0xfful << SC_TMRDAT12_CNT2_Pos)                  /*!< SC_T::TMRDAT12: CNT2 Mask              */
N
N#define SC_ACTCTL_T1EXT_Pos              (0)                                               /*!< SC_T::ACTCTL: T1EXT Position           */
N#define SC_ACTCTL_T1EXT_Msk              (0x1ful << SC_ACTCTL_T1EXT_Pos)                   /*!< SC_T::ACTCTL: T1EXT Mask               */
N
N/**@}*/ /* SC_CONST */
N/**@}*/ /* end of SC register group */
N
N
N/*---------------------- Serial Peripheral Interface Controller -------------------------*/
N/**
N    @addtogroup SPI Serial Peripheral Interface Controller(SPI)
N    Memory Mapped Structure for SPI Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var SPI_T::CTL
N     * Offset: 0x00  SPI Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SPIEN     |SPI Transfer Control Enable Bit
N     * |        |          |In Master mode, the transfer will start when there is data in the FIFO buffer after this bit is set to 1
N     * |        |          |In Slave mode, this device is ready to receive data when this bit is set to 1.
N     * |        |          |0 = Transfer control Disabled.
N     * |        |          |1 = Transfer control Enabled.
N     * |        |          |Note: Before changing the configurations of SPIx_CTL, SPIx_CLKDIV, SPIx_SSCTL and SPIx_FIFOCTL registers, user shall clear the SPIEN (SPIx_CTL[0]) and confirm the SPIENSTS (SPIx_STATUS[15]) is 0.
N     * |[1]     |RXNEG     |Receive on Negative Edge
N     * |        |          |0 = Received data input signal is latched on the rising edge of SPI bus clock.
N     * |        |          |1 = Received data input signal is latched on the falling edge of SPI bus clock.
N     * |[2]     |TXNEG     |Transmit on Negative Edge
N     * |        |          |0 = Transmitted data output signal is changed on the rising edge of SPI bus clock.
N     * |        |          |1 = Transmitted data output signal is changed on the falling edge of SPI bus clock.
N     * |[3]     |CLKPOL    |Clock Polarity
N     * |        |          |0 = SPI bus clock is idle low.
N     * |        |          |1 = SPI bus clock is idle high.
N     * |[7:4]   |SUSPITV   |Suspend Interval (Master Only)
N     * |        |          |The four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer
N     * |        |          |The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word and the first clock edge of the following transaction word
N     * |        |          |The default value is 0x3
N     * |        |          |The period of the suspend interval is obtained according to the following equation.
N     * |        |          |(SUSPITV[3:0] + 0.5) * period of SPICLK clock cycle
N     * |        |          |Example:
N     * |        |          |SUSPITV = 0x0 u2026. 0.5 SPICLK clock cycle.
N     * |        |          |SUSPITV = 0x1 u2026. 1.5 SPICLK clock cycle.
N     * |        |          |u2026u2026
N     * |        |          |SUSPITV = 0xE u2026. 14.5 SPICLK clock cycle.
N     * |        |          |SUSPITV = 0xF u2026. 15.5 SPICLK clock cycle.
N     * |[12:8]  |DWIDTH    |Data Width
N     * |        |          |This field specifies how many bits can be transmitted / received in one transaction
N     * |        |          |The minimum bit length is 8 bits and can up to 32 bits.
N     * |        |          |DWIDTH = 0x08 u2026. 8 bits.
N     * |        |          |DWIDTH = 0x09 u2026. 9 bits.
N     * |        |          |u2026u2026
N     * |        |          |DWIDTH = 0x1F u2026. 31 bits.
N     * |        |          |DWIDTH = 0x00 u2026. 32 bits.
N     * |[13]    |LSB       |Send LSB First
N     * |        |          |0 = The MSB, which bit of transmit/receive register depends on the setting of DWIDTH, is transmitted/received first.
N     * |        |          |1 = The LSB, bit 0 of the SPI TX register, is sent first to the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the RX register (bit 0 of SPI_RX).
N     * |[14]    |HALFDPX   |SPI Half-duplex duplex TRANSMISSION Transfer Enable Bit
N     * |        |          |This bit is used to select full-duplex or half-duplex for SPI transmissiontransfer
N     * |        |          |The bit field DATDIR (SPIx_CTL[20]) can be used to set the data direction while in half-duplex transmissiontransfer.
N     * |        |          |0 = SPI operates in full-duplex transmissiontransfer.
N     * |        |          |1 = SPI operates in half-duplex transmissiontransfer.
N     * |[15]    |RXONLY    |Receive-only FUNCTION Mode Enable Bit (Master Only)
N     * |        |          |This bit field is only available in Master mode
N     * |        |          |In receive-only mode, SPI Master will generate SPI bus clock continuously for receiving data bit from SPI slave device and assert the BUSY status
N     * |        |          |If both AUTOSS (SPI_SSCTL[3]) and RXONLY are enabled, the output slave select signal will be activated.
N     * |        |          |0 = Receive-only function mode Disabled.
N     * |        |          |1 = Receive-only functionmode Enabled.
N     * |        |          |Note: We suggest users switch to receive-only mode when BUSY (SPI_STATUS[0]) is low.
N     * |[17]    |UNITIEN   |Unit Transfer Interrupt Enable Bit
N     * |        |          |0 = SPI unit transfer interrupt Disabled.
N     * |        |          |1 = SPI unit transfer interrupt Enabled.
N     * |[18]    |SLAVE     |Slave Mode Control
N     * |        |          |0 = Master mode.
N     * |        |          |1 = Slave mode.
N     * |[19]    |REORDER   |Byte Reorder Function Enable Bit
N     * |        |          |0 = Byte Reorder function Disabled.
N     * |        |          |1 = Byte Reorder function Enabled
N     * |        |          |A byte suspend interval will be inserted among each byte
N     * |        |          |The period of the byte suspend interval depends on the setting of SUSPITV.
N     * |        |          |Note:
N     * |        |          |Byte Reorder function is only available if DWIDTH is defined as 16, 24, and 32 bits.
N     * |        |          |Byte Reorder function is not supported when the Quad or Dual I/O mode is enabled.
N     * |[20]    |DATDIR    |Data Port Direction Control
N     * |        |          |This bit is used to select the data input/output direction while in half-duplex transfer.ransmission.
N     * |        |          |0 = SPI data is input direction.
N     * |        |          |1 = SPI data is output direction.
N     * @var SPI_T::CLKDIV
N     * Offset: 0x04  SPI Clock Divider Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |DIVIDER   |Clock Divider
N     * |        |          |The value in this field is the frequency divider for generating the peripheral clock, fspi_eclk, and the SPI bus clock of SPI Master
N     * |        |          |The frequency is obtained according to the following equation.
N     * |        |          |where
N     * |        |          |is the peripheral clock source, which is defined in the clock control register, CLK_CLKSEL2.
N     * |        |          |Note: Not supported in I2S mode.
N     * @var SPI_T::SSCTL
N     * Offset: 0x08  SPI Slave Select Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SS        |Slave Selection Control (Master Only)
N     * |        |          |If AUTOSS bit is cleared to 0,
N     * |        |          |0 = set the SPIx_SS line to inactive state.
N     * |        |          |1 = set the SPIx_SS line to active state.
N     * |        |          |If the AUTOSS bit is set to 1,
N     * |        |          |0 = Keep the SPIx_SS line at inactive state.
N     * |        |          |1 = SPIx_SS line will be automatically driven to active state for the duration of data transfer, and will be driven to inactive state for the rest of the time
N     * |        |          |The active state of SPIx_SS is specified in SSACTPOL (SPIx_SSCTL[2]).
N     * |[2]     |SSACTPOL  |Slave Selection Active Polarity
N     * |        |          |This bit defines the active polarity of slave selection signal (SPIx_SS).
N     * |        |          |0 = The slave selection signal SPIx_SS is active low.
N     * |        |          |1 = The slave selection signal SPIx_SS is active high.
N     * |[3]     |AUTOSS    |Automatic Slave Selection Function Enable Bit (Master Only)
N     * |        |          |0 = Automatic slave selection function Disabled
N     * |        |          |Slave selection signal will be asserted/de-asserted according to SS (SPIx_SSCTL[0]).
N     * |        |          |1 = Automatic slave selection function Enabled.
N     * |[8]     |SLVBEIEN  |Slave Mode Bit Count Error Interrupt Enable Bit
N     * |        |          |0 = Slave mode bit count error interrupt Disabled.
N     * |        |          |1 = Slave mode bit count error interrupt Enabled.
N     * |[9]     |SLVURIEN  |Slave Mode TX Under Run Interrupt Enable Bit
N     * |        |          |0 = Slave mode TX under run interrupt Disabled.
N     * |        |          |1 = Slave mode TX under run interrupt Enabled.
N     * |[12]    |SSACTIEN  |Slave Select Active Interrupt Enable Bit
N     * |        |          |0 = Slave select active interrupt Disabled.
N     * |        |          |1 = Slave select active interrupt Enabled.
N     * |[13]    |SSINAIEN  |Slave Select Inactive Interrupt Enable Bit
N     * |        |          |0 = Slave select inactive interrupt Disabled.
N     * |        |          |1 = Slave select inactive interrupt Enabled.
N     * @var SPI_T::PDMACTL
N     * Offset: 0x0C  SPI PDMA Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TXPDMAEN  |Transmit PDMA Enable Bit
N     * |        |          |0 = Transmit PDMA function Disabled.
N     * |        |          |1 = Transmit PDMA function Enabled.
N     * |        |          |Note: In SPI Master mode with full duplex transfer, if both TX and RX PDMA functions are enabled, RX PDMA function cannot be enabled prior to TX PDMA function
N     * |        |          |User can enable TX PDMA function firstly or enable both functions simultaneously.
N     * |[1]     |RXPDMAEN  |Receive PDMA Enable Bit
N     * |        |          |0 = Receiver PDMA function Disabled.
N     * |        |          |1 = Receiver PDMA function Enabled.
N     * |[2]     |PDMARST   |PDMA Reset
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the PDMA control logic of the SPI controller. This bit will be automatically cleared to 0.
N     * @var SPI_T::FIFOCTL
N     * Offset: 0x10  SPI FIFO Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RXRST     |Receive Reset
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset receive FIFO pointer and receive circuit
N     * |        |          |The RXFULL bit will be cleared to 0 and the RXEMPTY bit will be set to 1
N     * |        |          |This bit will be cleared to 0 by hardware about 3 system clock cycles + 2 peripheral clock cycles after it is set to 1
N     * |        |          |User can read TXRXRST (SPIx_STATUS[23]) to check if reset is accomplished or not.
N     * |        |          |Note: If there is slave receive time-out event, the RXRST will be set 1 when the SLVTORST (SPI_SSCTL[6]) is enabled.
N     * |[1]     |TXRST     |Transmit Reset
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset transmit FIFO pointer and transmit circuit
N     * |        |          |The TXFULL bit will be cleared to 0 and the TXEMPTY bit will be set to 1
N     * |        |          |This bit will be cleared to 0 by hardware about 3 system clock cycles + 2 peripheral clock cycles after it is set to 1
N     * |        |          |User can read TXRXRST (SPIx_STATUS[23]) to check if reset is accomplished or not.
N     * |        |          |Note: If TX under-runflow event occurs in SPI Slave mode, this bit can be used to make SPI return to idle state.Note: If there is slave receive time-out event, the TXRST will be set to 1 when the SLVTORST (SPI_SSCTL[6]) is enabled.
N     * |[2]     |RXTHIEN   |Receive FIFO Threshold Interrupt Enable Bit
N     * |        |          |0 = RX FIFO threshold interrupt Disabled.
N     * |        |          |1 = RX FIFO threshold interrupt Enabled.
N     * |[3]     |TXTHIEN   |Transmit FIFO Threshold Interrupt Enable Bit
N     * |        |          |0 = TX FIFO threshold interrupt Disabled.
N     * |        |          |1 = TX FIFO threshold interrupt Enabled.
N     * |[4]     |RXTOIEN   |Slave Receive Time-out Interrupt Enable Bit
N     * |        |          |0 = Receive time-out interrupt Disabled.
N     * |        |          |1 = Receive time-out interrupt Enabled.
N     * |[5]     |RXOVIEN   |Receive FIFO Overrun Interrupt Enable Bit
N     * |        |          |0 = Receive FIFO overrun interrupt Disabled.
N     * |        |          |1 = Receive FIFO overrun interrupt Enabled.
N     * |[6]     |TXUFPOL   |TX Underflow Data Polarity
N     * |        |          |0 = The SPI data out is keep 0 if there is TX underflow event in Slave mode.
N     * |        |          |1 = The SPI data out is keep 1 if there is TX underflow event in Slave mode.
N     * |        |          |Note:
N     * |        |          |1
N     * |        |          |The TX underflow event occurs if there is not any data in TX FIFO when the slave selection signal is active.
N     * |        |          |2. This bit should be set as 0 in I2S mode.
N     * |        |          |3
N     * |        |          |When TX underflow event occurs, SPIx_MISO pin state will be determined by this setting even though TX FIFO is not empty afterward
N     * |        |          |Data stored in TX FIFO will be sent through SPIx_MISO pin in the next transfer frame.
N     * |[7]     |TXUFIEN   |TX Underflow Interrupt Enable Bit
N     * |        |          |0 = Slave TX underflow interrupt Disabled.
N     * |        |          |1 = Slave TX underflow interrupt Enabled.
N     * |[8]     |RXFBCLR   |Receive FIFO Buffer Clear
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear receive FIFO pointer
N     * |        |          |The RXFULL bit will be cleared to 0 and the RXEMPTY bit will be set to 1
N     * |        |          |This bit will be cleared to 0 by hardware about 1 system clock after it is set to 1.
N     * |        |          |Note: The RX shift register will not be cleared.
N     * |[9]     |TXFBCLR   |Transmit FIFO Buffer Clear
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear transmit FIFO pointer
N     * |        |          |The TXFULL bit will be cleared to 0 and the TXEMPTY bit will be set to 1
N     * |        |          |This bit will be cleared to 0 by hardware about 1 system clock after it is set to 1.
N     * |        |          |Note: The TX shift register will not be cleared.
N     * |[25:24] |RXTH      |Receive FIFO Threshold
N     * |        |          |If the valid data count of the receive FIFO buffer is larger than the RXTH setting, the RXTHIF bit will be set to 1, else the RXTHIF bit will be cleared to 0
N     * |[29:28] |TXTH      |Transmit FIFO Threshold
N     * |        |          |If the valid data count of the transmit FIFO buffer is less than or equal to the TXTH setting, the TXTHIF bit will be set to 1, else the TXTHIF bit will be cleared to 0.
N     * @var SPI_T::STATUS
N     * Offset: 0x14  SPI Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BUSY      |Busy Status (Read Only)
N     * |        |          |0 = SPI controller is in idle state.
N     * |        |          |1 = SPI controller is in busy state.
N     * |        |          |The following listing are the bus busy conditions:
N     * |        |          |a. SPIx_CTL[0] = 1 and the TXEMPTY = 0.
N     * |        |          |b
N     * |        |          |For SPI Master mode, SPIx_CTL[0] = 1 and the TXEMPTY = 1 but the current transaction is not finished yet.
N     * |        |          |c. For SPI Master mode, SPIx_CTL[0] = 1 and RXONLY = 1.
N     * |        |          |d
N     * |        |          |For SPI Slave mode, the SPIx_CTL[0] = 1 and there is serial clock input into the SPI core logic when slave select is active.
N     * |        |          |For SPI Slave mode, the SPIx_CTL[0] = 1 and the transmit buffer or transmit shift register is not empty even if the slave select is inactive.
N     * |[1]     |UNITIF    |Unit Transfer Interrupt Flag
N     * |        |          |0 = No transaction has been finished since this bit was cleared to 0.
N     * |        |          |1 = SPI controller has finished one unit transfer.
N     * |        |          |Note: This bit will be cleared by writing 1 to it.
N     * |[2]     |SSACTIF   |Slave Select Active Interrupt Flag
N     * |        |          |0 = Slave select active interrupt was cleared or not occurred.
N     * |        |          |1 = Slave select active interrupt event occurred.
N     * |        |          |Note: Only available in Slave mode. This bit will be cleared by writing 1 to it.
N     * |[3]     |SSINAIF   |Slave Select Inactive Interrupt Flag
N     * |        |          |0 = Slave select inactive interrupt was cleared or not occurred.
N     * |        |          |1 = Slave select inactive interrupt event occurred.
N     * |        |          |Note: Only available in Slave mode. This bit will be cleared by writing 1 to it.
N     * |[4]     |SSLINE    |Slave Select Line Bus Status (Read Only)
N     * |        |          |0 = The slave select line status is 0.
N     * |        |          |1 = The slave select line status is 1.
N     * |        |          |Note: This bit is only available in Slave mode
N     * |        |          |If SSACTPOL (SPIx_SSCTL[2]) is set 0, and the SSLINE is 1, the SPI slave select is in inactive status.
N     * |[6]     |SLVBEIF   |Slave Mode Bit Count Error Interrupt Flag
N     * |        |          |In Slave mode, when the slave select line goes to inactive state, if bit counter is mismatch with DWIDTH, this interrupt flag will be set to 1.
N     * |        |          |0 = No Slave mode bit count error event.
N     * |        |          |1 = Slave mode bit count error event occurs.
N     * |        |          |Note: If the slave select active but there is no any bus clock input, the SLVBCEEIF also active when the slave select goes to inactive state
N     * |        |          |This bit will be cleared by writing 1 to it.
N     * |[7]     |SLVURIF   |Slave Mode TX Under Run Interrupt Flag
N     * |        |          |In Slave mode, if TX underflow event occurs and the slave select line goes to inactive state, this interrupt flag will be set to 1.
N     * |        |          |0 = No Slave TX under run event.
N     * |        |          |1 = Slave TX under run event occurs.
N     * |        |          |Note: This bit will be cleared by writing 1 to it.
N     * |[8]     |RXEMPTY   |Receive FIFO Buffer Empty Indicator (Read Only)
N     * |        |          |0 = Receive FIFO buffer is not empty.
N     * |        |          |1 = Receive FIFO buffer is empty.
N     * |[9]     |RXFULL    |Receive FIFO Buffer Full Indicator (Read Only)
N     * |        |          |0 = Receive FIFO buffer is not full.
N     * |        |          |1 = Receive FIFO buffer is full.
N     * |[10]    |RXTHIF    |Receive FIFO Threshold Interrupt Flag (Read Only)
N     * |        |          |0 = The valid data count within the RXreceive FIFO buffer is smaller than or equal to the setting value of RXTH.
N     * |        |          |1 = The valid data count within the receive FIFO buffer is larger than the setting value of RXTH.
N     * |[11]    |RXOVIF    |Receive FIFO Overrun Interrupt Flag
N     * |        |          |When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.
N     * |        |          |0 = No FIFO is over run.
N     * |        |          |1 = Receive FIFO is over run.
N     * |        |          |Note: This bit will be cleared by writing 1 to it.
N     * |[12]    |RXTOIF    |Receive Time-out Interrupt Flag
N     * |        |          |0 = No receive FIFO time-out event.
N     * |        |          |1 = Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI peripheral clock periods in Master mode or over 576 SPI peripheral clock periods in Slave mode
N     * |        |          |When the received FIFO buffer is read by software, the time-out status will be cleared automatically.
N     * |        |          |Note: This bit will be cleared by writing 1 to it.
N     * |[15]    |SPIENSTS  |SPI Enable Status (Read Only)
N     * |        |          |0 = The SPI controller is disabled.
N     * |        |          |1 = The SPI controller is enabled.
N     * |        |          |Note: The SPI peripheral clock is asynchronous with the system clock
N     * |        |          |In order to make sure the SPI control logic is disabled, this bit indicates the real status of SPI controller.
N     * |[16]    |TXEMPTY   |Transmit FIFO Buffer Empty Indicator (Read Only)
N     * |        |          |0 = Transmit FIFO buffer is not empty.
N     * |        |          |1 = Transmit FIFO buffer is empty.
N     * |[17]    |TXFULL    |Transmit FIFO Buffer Full Indicator (Read Only)
N     * |        |          |0 = Transmit FIFO buffer is not full.
N     * |        |          |1 = Transmit FIFO buffer is full.
N     * |[18]    |TXTHIF    |Transmit FIFO Threshold Interrupt Flag (Read Only)
N     * |        |          |0 = The valid data count within the transmit FIFO buffer is larger than the setting value of TXTH.
N     * |        |          |1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TXTH.
N     * |[19]    |TXUFIF    |TX Underflow Interrupt Flag
N     * |        |          |When the TX underflow event occurs, this bit will be set to 1, the state of data output pin depends on the setting of TXUFPOL.
N     * |        |          |0 = No effect.
N     * |        |          |1 = No data in Transmit FIFO and TX shift register when the slave selection signal is active.
N     * |        |          |Note 1: This bit will be cleared by writing 1 to it.
N     * |        |          |Note 2: If reset slaveu2019s transmission circuit when slave selection signal is active, this flag will be set to 1 after 2 peripheral clock cycles + 3 system clock cycles since the reset operation is done.
N     * |[23]    |TXRXRST   |TX or RX Reset Status (Read Only)
N     * |        |          |0 = The reset function of TXRST or RXRST is done.
N     * |        |          |1 = Doing the reset function of TXRST or RXRST.
N     * |        |          |Note: Both the reset operations of TXRST and RXRST need 3 system clock cycles + 2 peripheral clock cycles
N     * |        |          |User can check the status of this bit to monitor the reset function is doing or done.
N     * |[27:24] |RXCNT     |Receive FIFO Data Count (Read Only)
N     * |        |          |This bit field indicates the valid data count of receive FIFO buffer.
N     * |[31:28] |TXCNT     |Transmit FIFO Data Count (Read Only)
N     * |        |          |This bit field indicates the valid data count of transmit FIFO buffer.
N     * @var SPI_T::TX
N     * Offset: 0x20  SPI Data Transmit Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |TX        |Data Transmit Register
N     * |        |          |The data transmit registers pass through the transmitted data into the 4-level transmit FIFO buffers
N     * |        |          |The number of valid bits depends on the setting of DWIDTH (SPIx_CTL[12:8]) in SPI mode or WDWIDTH (SPIx_I2SCTL[5:4]) in I2S mode.
N     * |        |          |For exampleIn SPI mode, if DWIDTH is set to 0x08, the bits TX[7:0] will be transmitted
N     * |        |          |If DWIDTH is set to 0x00 , the SPI controller will perform a 32-bit transfer.
N     * |        |          |In I2S mode, if WDWIDTH (SPIx_I2SCTL[5:4]) is set to 0x2, the data width of audio channel is 24-bit and corresponding to TX[243:0]
N     * |        |          |If WDWIDTH is set as 0x0, 0x1, or 0x3, all bits of this field are valid and referred to the data arrangement in I2S mode FIFO operation section
N     * |        |          |Note: In Master mode, SPI controller will start to transfer the SPI bus clock after 1 APB clock and 6 peripheral clock cycles after user writes to this register.
N     * @var SPI_T::RX
N     * Offset: 0x30  SPI Data Receive Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |RX        |Data Receive Register
N     * |        |          |There are 8-/4-level FIFO buffers in this controller
N     * |        |          |The data receive register holds the data received from SPI data input pin
N     * |        |          |If the RXEMPTY (SPIx_STATUS[8] or SPIx_I2SSTS[8]) is not set to 1, the receive FIFO buffers can be accessed through software by reading this register
N     * |        |          |This is a read only register.
N     * @var SPI_T::I2SCTL
N     * Offset: 0x60  I2S Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |I2SEN     |I2S Controller Enable Bit
N     * |        |          |0 = Disabled I2S mode.
N     * |        |          |1 = Enabled I2S mode.
N     * |        |          |Note:
N     * |        |          |1. If enable this bit, I2Sx_BCLK will start to output in master Master mode.
N     * |        |          |2
N     * |        |          |Before changing the configurations of SPIx_I2SCTL, SPIx_I2SCLK, and SPIx_FIFOCTL registers, user shall clear the I2SEN (SPIx_I2SCTL[0]) and confirm the I2SENSTS (SPIx_I2SSTS[15]) is 0.
N     * |[1]     |TXEN      |Transmit Enable Bit
N     * |        |          |0 = Data transmit Disabled.
N     * |        |          |1 = Data transmit Enabled.
N     * |[2]     |RXEN      |Receive Enable Bit
N     * |        |          |0 = Data receiving receive Disabled.
N     * |        |          |1 = Data receiving receive Enabled.
N     * |[3]     |MUTE      |Transmit Mute Enable Bit
N     * |        |          |0 = Transmit data is shifted from buffer.
N     * |        |          |1 = Transmit channel zero.
N     * |[5:4]   |WDWIDTH   |Word Width
N     * |        |          |00 = data size is 8-bit.
N     * |        |          |01 = data size is 16-bit.
N     * |        |          |10 = data size is 24-bit.
N     * |        |          |11 = data size is 32-bit.
N     * |[6]     |MONO      |Monaural Data
N     * |        |          |0 = Data is stereo format.
N     * |        |          |1 = Data is monaural format.
N     * |[7]     |ORDER     |Stereo Data Order in FIFO
N     * |        |          |0 = Left channel data at high byte.
N     * |        |          |1 = Left channel data at low byte.
N     * |[8]     |SLAVE     |Slave Mode
N     * |        |          |I2S can operate as master or slave
N     * |        |          |For Master mode, I2Sx_BCLK and I2Sx_LRCLK pins are output mode and send bit clock from NuMicrou00AEu00E4 NUC200 NUC029xGE series to Audio audio CODEC chip
N     * |        |          |In Slave mode, I2Sx_BCLK and I2Sx_LRCLK pins are input mode and I2Sx_BCLK and I2Sx_LRCLK signals are received from outer Audio audio CODEC chip.
N     * |        |          |0 = Master mode.
N     * |        |          |1 = Slave mode.
N     * |[15]    |MCLKEN    |Master Clock Enable Bit
N     * |        |          |If MCLKEN is set to 1, I2S controller will generate master clock on SPIx_I2SMCLK pin for external audio devices.
N     * |        |          |0 = Master clock Disabled.
N     * |        |          |1 = Master clock Enabled.
N     * |[16]    |RZCEN     |Right Channel Zero Cross Detection Enable Bit
N     * |        |          |If this bit is set to 1, when right channel data sign bit change or next shift data bits are all 0 then RZCIF flag in SPIx_I2SSTS register is set to 1
N     * |        |          |This function is only available in transmit operation.
N     * |        |          |0 = Right channel zero cross detection Disabled.
N     * |        |          |1 = Right channel zero cross detection Enabled.
N     * |[17]    |LZCEN     |Left Channel Zero Cross Detection Enable Bit
N     * |        |          |If this bit is set to 1, when left channel data sign bit changes or next shift data bits are all 0 then LZCIF flag in SPIx_I2SSTS register is set to 1
N     * |        |          |This function is only available in transmit operation.
N     * |        |          |0 = Left channel zero cross detection Disabled.
N     * |        |          |1 = Left channel zero cross detection Enabled.
N     * |[23]    |RXLCH     |Receive Left Channel Enable Bit
N     * |        |          |When monaural format is selected (MONO = 1), I2S controller will receive right channel data if RXLCH is set to 0, and receive left channel data if RXLCH is set to 1.
N     * |        |          |0 = Receive right channel data in Mono mode.
N     * |        |          |1 = Receive left channel data in Mono mode.
N     * |[24]    |RZCIEN    |Right Channel Zero- CCross Interrupt Enable Bit
N     * |        |          |Interrupt occurs if this bit is set to 1 and right channel zero- cross event occurs.
N     * |        |          |0 = Interrupt Disabled.
N     * |        |          |1 = Interrupt Enabled.
N     * |[25]    |LZCIEN    |Left Channel Zero- CCross Interrupt Enable Bit
N     * |        |          |Interrupt occurs if this bit is set to 1 and left channel zero- cross event occurs.
N     * |        |          |0 = Interrupt Disabled.
N     * |        |          |1 = Interrupt Enabled.
N     * |[29:28] |FORMAT    |Data Format Selection
N     * |        |          |00 = I2S data format.
N     * |        |          |01 = MSB justified data format.
N     * |        |          |10 = PCM mode A.
N     * |        |          |11 = PCM mode B.
N     * @var SPI_T::I2SCLK
N     * Offset: 0x64  I2S Clock Divider Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |MCLKDIV   |Master Clock Divider
N     * |        |          |If MCLKEN is set to 1, I2S controller will generate master clock for external audio devices
N     * |        |          |The frequency of master clock rate, fMCLKF_MCLK, is determined by the following expressions:.
N     * |        |          |If MCLKDIV >= 1,. F_MCLK = F_I2SCLK/(2x(MCLKDIV)).
N     * |        |          |If MCLKDIV = 0,. F_MCLK = F_I2SCLK.
N     * |        |          |where
N     * |        |          |is the frequency of I2S peripheral clock source, which is defined in the clock control register CLK_CLKSEL2
N     * |        |          |F_I2SCLK is the frequency of I2S peripheral clock.
N     * |        |          |In general, the master clock rate is 256 times sampling clock rate.
N     * |[16:8]  |BCLKDIV   |Bit Clock Divider
N     * |        |          |The I2S controller will generate bit clock in Master mode
N     * |        |          |The bit clock rate frequency of bit clock , Ff_bclBCLKk, is determined by the following expression:.
N     * |        |          |F_BCLK = F_I2SCLK /(2x(BCLKDIV + 1)) ,
N     * |        |          |where
N     * |        |          |F_I2SCLK is the frequency of I2S peripheral clock source, which is defined in the clock control register CLK_CLKSEL2.
N     * |        |          |In I2S
N     * |        |          |Slave mode, this field is used to define the frequency of peripheral clock and itu2019s determined by .
N     * |        |          |The peripheral clock frequency in I2S Slave mode must be equal to or faster than 6 times of input bit clock.
N     * @var SPI_T::I2SSTS
N     * Offset: 0x68  I2S Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4]     |RIGHT     |Right Channel (Read Only)
N     * |        |          |This bit indicates the current transmit data is belong to which channel.
N     * |        |          |0 = Left channel.
N     * |        |          |1 = Right channel.
N     * |[8]     |RXEMPTY   |Receive FIFO Buffer Empty Indicator (Read Only)
N     * |        |          |0 = Receive FIFO buffer is not empty.
N     * |        |          |1 = Receive FIFO buffer is empty.
N     * |[9]     |RXFULL    |Receive FIFO Buffer Full Indicator (Read Only)
N     * |        |          |0 = Receive FIFO buffer is not full.
N     * |        |          |1 = Receive FIFO buffer is full.
N     * |[10]    |RXTHIF    |Receive FIFO Threshold Interrupt Flag (Read Only)
N     * |        |          |0 = The valid data count within the Rxreceive FIFO buffer is smaller than or equal to the setting value of RXTH.
N     * |        |          |1 = The valid data count within the receive FIFO buffer is larger than the setting value of RXTH.
N     * |        |          |Note: If RXTHIEN = 1 and RXTHIF = 1, the SPI/I2S controller will generate a SPI interrupt request.
N     * |[11]    |RXOVIF    |Receive FIFO Overrun Interrupt Flag
N     * |        |          |When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.
N     * |        |          |Note: This bit will be cleared by writing 1 to it.
N     * |[12]    |RXTOIF    |Receive Time-out Interrupt Flag
N     * |        |          |0 = No receive FIFO time-out event.
N     * |        |          |1 = Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI peripheral clock period in Master mode or over 576 SPI peripheral clock period in Slave mode
N     * |        |          |When the received FIFO buffer is read by software, the time-out status will be cleared automatically.
N     * |        |          |Note: This bit will be cleared by writing 1 to it.
N     * |[15]    |I2SENSTS  |I2S Enable Status (Read Only)
N     * |        |          |0 = The SPI/I2S control logic is disabled.
N     * |        |          |1 = The SPI/I2S control logic is enabled.
N     * |        |          |Note: The SPI peripheral clock is asynchronous with the system clock
N     * |        |          |In order to make sure the SPI/I2S controller logic is disabled, this bit indicates the real status of SPI/I2S controller logic for user.
N     * |[16]    |TXEMPTY   |Transmit FIFO Buffer Empty Indicator (Read Only)
N     * |        |          |0 = Transmit FIFO buffer is not empty.
N     * |        |          |1 = Transmit FIFO buffer is empty.
N     * |[17]    |TXFULL    |Transmit FIFO Buffer Full Indicator (Read Only)
N     * |        |          |0 = Transmit FIFO buffer is not full.
N     * |        |          |1 = Transmit FIFO buffer is full.
N     * |[18]    |TXTHIF    |Transmit FIFO Threshold Interrupt Flag (Read Only)
N     * |        |          |0 = The valid data count within the transmit FIFO buffer is larger than the setting value of TXTH.
N     * |        |          |1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TXTH.
N     * |        |          |Note: If TXTHIEN = 1 and TXTHIF = 1, the SPI/I2S controller will generate a SPI interrupt request.
N     * |[19]    |TXUFIF    |Transmit FIFO Underflow Interrupt Flag
N     * |        |          |When the transmit FIFO buffer is empty and there is no datum written into the FIFO buffer, if there is more bus clock input, this bit will be set to 1.
N     * |        |          |Note: This bit will be cleared by writing 1 to it.
N     * |[20]    |RZCIF     |Right Channel Zero Cross Interrupt Flag
N     * |        |          |0 = No zero cross event occurred on right channel.
N     * |        |          |1 = Zero cross event occurred on right channel.
N     * |[21]    |LZCIF     |Left Channel Zero Cross Interrupt Flag
N     * |        |          |0 = No zero cross event occurred on left channel.
N     * |        |          |1 = Zero cross event occurred on left channel.
N     * |[23]    |TXRXRST   |TX or RX Reset Status (Read Only)
N     * |        |          |0 = The reset function of TXRST or RXRST is done.
N     * |        |          |1 = Doing the reset function of TXRST or RXRST.
N     * |        |          |Note: Both the reset operations of TXRST and RXRST need 3 system clock cycles + 2 peripheral clock cycles
N     * |        |          |User can check the status of this bit to monitor the reset function is doing or done.
N     * |[26:24] |RXCNT     |Receive FIFO Data Count (Read Only)
N     * |        |          |This bit field indicates the valid data count of receive FIFO buffer.
N     * |[30:28] |TXCNT     |Transmit FIFO Data Count (Read Only)
N     * |        |          |This bit field indicates the valid data count of transmit FIFO buffer.
N     */
N
N    __IO uint32_t CTL;                   /*!< [0x0000] SPI Control Register                                             */
X    volatile uint32_t CTL;                    
N    __IO uint32_t CLKDIV;                /*!< [0x0004] SPI Clock Divider Register                                       */
X    volatile uint32_t CLKDIV;                 
N    __IO uint32_t SSCTL;                 /*!< [0x0008] SPI Slave Select Control Register                                */
X    volatile uint32_t SSCTL;                  
N    __IO uint32_t PDMACTL;               /*!< [0x000c] SPI PDMA Control Register                                        */
X    volatile uint32_t PDMACTL;                
N    __IO uint32_t FIFOCTL;               /*!< [0x0010] SPI FIFO Control Register                                        */
X    volatile uint32_t FIFOCTL;                
N    __IO uint32_t STATUS;                /*!< [0x0014] SPI Status Register                                              */
X    volatile uint32_t STATUS;                 
N    __I  uint32_t RESERVE0[2];
X    volatile const  uint32_t RESERVE0[2];
N    __O  uint32_t TX;                    /*!< [0x0020] SPI Data Transmit Register                                       */
X    volatile  uint32_t TX;                     
N    __I  uint32_t RESERVE1[3];
X    volatile const  uint32_t RESERVE1[3];
N    __I  uint32_t RX;                    /*!< [0x0030] SPI Data Receive Register                                        */
X    volatile const  uint32_t RX;                     
N    __I  uint32_t RESERVE2[11];
X    volatile const  uint32_t RESERVE2[11];
N    __IO uint32_t I2SCTL;                /*!< [0x0060] I2S Control Register                                             */
X    volatile uint32_t I2SCTL;                 
N    __IO uint32_t I2SCLK;                /*!< [0x0064] I2S Clock Divider Control Register                               */
X    volatile uint32_t I2SCLK;                 
N    __IO uint32_t I2SSTS;                /*!< [0x0068] I2S Status Register                                              */
X    volatile uint32_t I2SSTS;                 
N
N} SPI_T;
N
N/**
N    @addtogroup SPI_CONST SPI Bit Field Definition
N    Constant Definitions for SPI Controller
N@{ */
N
N#define SPI_CTL_SPIEN_Pos                (0)                                               /*!< SPI_T::CTL: SPIEN Position             */
N#define SPI_CTL_SPIEN_Msk                (0x1ul << SPI_CTL_SPIEN_Pos)                      /*!< SPI_T::CTL: SPIEN Mask                 */
N
N#define SPI_CTL_RXNEG_Pos                (1)                                               /*!< SPI_T::CTL: RXNEG Position             */
N#define SPI_CTL_RXNEG_Msk                (0x1ul << SPI_CTL_RXNEG_Pos)                      /*!< SPI_T::CTL: RXNEG Mask                 */
N
N#define SPI_CTL_TXNEG_Pos                (2)                                               /*!< SPI_T::CTL: TXNEG Position             */
N#define SPI_CTL_TXNEG_Msk                (0x1ul << SPI_CTL_TXNEG_Pos)                      /*!< SPI_T::CTL: TXNEG Mask                 */
N
N#define SPI_CTL_CLKPOL_Pos               (3)                                               /*!< SPI_T::CTL: CLKPOL Position            */
N#define SPI_CTL_CLKPOL_Msk               (0x1ul << SPI_CTL_CLKPOL_Pos)                     /*!< SPI_T::CTL: CLKPOL Mask                */
N
N#define SPI_CTL_SUSPITV_Pos              (4)                                               /*!< SPI_T::CTL: SUSPITV Position           */
N#define SPI_CTL_SUSPITV_Msk              (0xful << SPI_CTL_SUSPITV_Pos)                    /*!< SPI_T::CTL: SUSPITV Mask               */
N
N#define SPI_CTL_DWIDTH_Pos               (8)                                               /*!< SPI_T::CTL: DWIDTH Position            */
N#define SPI_CTL_DWIDTH_Msk               (0x1ful << SPI_CTL_DWIDTH_Pos)                    /*!< SPI_T::CTL: DWIDTH Mask                */
N
N#define SPI_CTL_LSB_Pos                  (13)                                              /*!< SPI_T::CTL: LSB Position               */
N#define SPI_CTL_LSB_Msk                  (0x1ul << SPI_CTL_LSB_Pos)                        /*!< SPI_T::CTL: LSB Mask                   */
N
N#define SPI_CTL_HALFDPX_Pos              (14)                                              /*!< SPI_T::CTL: HALFDPX Position           */
N#define SPI_CTL_HALFDPX_Msk              (0x1ul << SPI_CTL_HALFDPX_Pos)                    /*!< SPI_T::CTL: HALFDPX Mask               */
N
N#define SPI_CTL_RXONLY_Pos               (15)                                              /*!< SPI_T::CTL: RXONLY Position            */
N#define SPI_CTL_RXONLY_Msk               (0x1ul << SPI_CTL_RXONLY_Pos)                     /*!< SPI_T::CTL: RXONLY Mask                */
N
N#define SPI_CTL_UNITIEN_Pos              (17)                                              /*!< SPI_T::CTL: UNITIEN Position           */
N#define SPI_CTL_UNITIEN_Msk              (0x1ul << SPI_CTL_UNITIEN_Pos)                    /*!< SPI_T::CTL: UNITIEN Mask               */
N
N#define SPI_CTL_SLAVE_Pos                (18)                                              /*!< SPI_T::CTL: SLAVE Position             */
N#define SPI_CTL_SLAVE_Msk                (0x1ul << SPI_CTL_SLAVE_Pos)                      /*!< SPI_T::CTL: SLAVE Mask                 */
N
N#define SPI_CTL_REORDER_Pos              (19)                                              /*!< SPI_T::CTL: REORDER Position           */
N#define SPI_CTL_REORDER_Msk              (0x1ul << SPI_CTL_REORDER_Pos)                    /*!< SPI_T::CTL: REORDER Mask               */
N
N#define SPI_CTL_DATDIR_Pos               (20)                                              /*!< SPI_T::CTL: DATDIR Position            */
N#define SPI_CTL_DATDIR_Msk               (0x1ul << SPI_CTL_DATDIR_Pos)                     /*!< SPI_T::CTL: DATDIR Mask                */
N
N#define SPI_CLKDIV_DIVIDER_Pos           (0)                                               /*!< SPI_T::CLKDIV: DIVIDER Position        */
N#define SPI_CLKDIV_DIVIDER_Msk           (0xfful << SPI_CLKDIV_DIVIDER_Pos)                /*!< SPI_T::CLKDIV: DIVIDER Mask            */
N
N#define SPI_SSCTL_SS_Pos                 (0)                                               /*!< SPI_T::SSCTL: SS Position              */
N#define SPI_SSCTL_SS_Msk                 (0x1ul << SPI_SSCTL_SS_Pos)                       /*!< SPI_T::SSCTL: SS Mask                  */
N
N#define SPI_SSCTL_SSACTPOL_Pos           (2)                                               /*!< SPI_T::SSCTL: SSACTPOL Position        */
N#define SPI_SSCTL_SSACTPOL_Msk           (0x1ul << SPI_SSCTL_SSACTPOL_Pos)                 /*!< SPI_T::SSCTL: SSACTPOL Mask            */
N
N#define SPI_SSCTL_AUTOSS_Pos             (3)                                               /*!< SPI_T::SSCTL: AUTOSS Position          */
N#define SPI_SSCTL_AUTOSS_Msk             (0x1ul << SPI_SSCTL_AUTOSS_Pos)                   /*!< SPI_T::SSCTL: AUTOSS Mask              */
N
N#define SPI_SSCTL_SLVBEIEN_Pos           (8)                                               /*!< SPI_T::SSCTL: SLVBEIEN Position        */
N#define SPI_SSCTL_SLVBEIEN_Msk           (0x1ul << SPI_SSCTL_SLVBEIEN_Pos)                 /*!< SPI_T::SSCTL: SLVBEIEN Mask            */
N
N#define SPI_SSCTL_SLVURIEN_Pos           (9)                                               /*!< SPI_T::SSCTL: SLVURIEN Position        */
N#define SPI_SSCTL_SLVURIEN_Msk           (0x1ul << SPI_SSCTL_SLVURIEN_Pos)                 /*!< SPI_T::SSCTL: SLVURIEN Mask            */
N
N#define SPI_SSCTL_SSACTIEN_Pos           (12)                                              /*!< SPI_T::SSCTL: SSACTIEN Position        */
N#define SPI_SSCTL_SSACTIEN_Msk           (0x1ul << SPI_SSCTL_SSACTIEN_Pos)                 /*!< SPI_T::SSCTL: SSACTIEN Mask            */
N
N#define SPI_SSCTL_SSINAIEN_Pos           (13)                                              /*!< SPI_T::SSCTL: SSINAIEN Position        */
N#define SPI_SSCTL_SSINAIEN_Msk           (0x1ul << SPI_SSCTL_SSINAIEN_Pos)                 /*!< SPI_T::SSCTL: SSINAIEN Mask            */
N
N#define SPI_PDMACTL_TXPDMAEN_Pos         (0)                                               /*!< SPI_T::PDMACTL: TXPDMAEN Position      */
N#define SPI_PDMACTL_TXPDMAEN_Msk         (0x1ul << SPI_PDMACTL_TXPDMAEN_Pos)               /*!< SPI_T::PDMACTL: TXPDMAEN Mask          */
N
N#define SPI_PDMACTL_RXPDMAEN_Pos         (1)                                               /*!< SPI_T::PDMACTL: RXPDMAEN Position      */
N#define SPI_PDMACTL_RXPDMAEN_Msk         (0x1ul << SPI_PDMACTL_RXPDMAEN_Pos)               /*!< SPI_T::PDMACTL: RXPDMAEN Mask          */
N
N#define SPI_PDMACTL_PDMARST_Pos          (2)                                               /*!< SPI_T::PDMACTL: PDMARST Position       */
N#define SPI_PDMACTL_PDMARST_Msk          (0x1ul << SPI_PDMACTL_PDMARST_Pos)                /*!< SPI_T::PDMACTL: PDMARST Mask           */
N
N#define SPI_FIFOCTL_RXRST_Pos            (0)                                               /*!< SPI_T::FIFOCTL: RXRST Position         */
N#define SPI_FIFOCTL_RXRST_Msk            (0x1ul << SPI_FIFOCTL_RXRST_Pos)                  /*!< SPI_T::FIFOCTL: RXRST Mask             */
N
N#define SPI_FIFOCTL_TXRST_Pos            (1)                                               /*!< SPI_T::FIFOCTL: TXRST Position         */
N#define SPI_FIFOCTL_TXRST_Msk            (0x1ul << SPI_FIFOCTL_TXRST_Pos)                  /*!< SPI_T::FIFOCTL: TXRST Mask             */
N
N#define SPI_FIFOCTL_RXTHIEN_Pos          (2)                                               /*!< SPI_T::FIFOCTL: RXTHIEN Position       */
N#define SPI_FIFOCTL_RXTHIEN_Msk          (0x1ul << SPI_FIFOCTL_RXTHIEN_Pos)                /*!< SPI_T::FIFOCTL: RXTHIEN Mask           */
N
N#define SPI_FIFOCTL_TXTHIEN_Pos          (3)                                               /*!< SPI_T::FIFOCTL: TXTHIEN Position       */
N#define SPI_FIFOCTL_TXTHIEN_Msk          (0x1ul << SPI_FIFOCTL_TXTHIEN_Pos)                /*!< SPI_T::FIFOCTL: TXTHIEN Mask           */
N
N#define SPI_FIFOCTL_RXTOIEN_Pos          (4)                                               /*!< SPI_T::FIFOCTL: RXTOIEN Position       */
N#define SPI_FIFOCTL_RXTOIEN_Msk          (0x1ul << SPI_FIFOCTL_RXTOIEN_Pos)                /*!< SPI_T::FIFOCTL: RXTOIEN Mask           */
N
N#define SPI_FIFOCTL_RXOVIEN_Pos          (5)                                               /*!< SPI_T::FIFOCTL: RXOVIEN Position       */
N#define SPI_FIFOCTL_RXOVIEN_Msk          (0x1ul << SPI_FIFOCTL_RXOVIEN_Pos)                /*!< SPI_T::FIFOCTL: RXOVIEN Mask           */
N
N#define SPI_FIFOCTL_TXUFPOL_Pos          (6)                                               /*!< SPI_T::FIFOCTL: TXUFPOL Position       */
N#define SPI_FIFOCTL_TXUFPOL_Msk          (0x1ul << SPI_FIFOCTL_TXUFPOL_Pos)                /*!< SPI_T::FIFOCTL: TXUFPOL Mask           */
N
N#define SPI_FIFOCTL_TXUFIEN_Pos          (7)                                               /*!< SPI_T::FIFOCTL: TXUFIEN Position       */
N#define SPI_FIFOCTL_TXUFIEN_Msk          (0x1ul << SPI_FIFOCTL_TXUFIEN_Pos)                /*!< SPI_T::FIFOCTL: TXUFIEN Mask           */
N
N#define SPI_FIFOCTL_RXFBCLR_Pos          (8)                                               /*!< SPI_T::FIFOCTL: RXFBCLR Position       */
N#define SPI_FIFOCTL_RXFBCLR_Msk          (0x1ul << SPI_FIFOCTL_RXFBCLR_Pos)                /*!< SPI_T::FIFOCTL: RXFBCLR Mask           */
N
N#define SPI_FIFOCTL_TXFBCLR_Pos          (9)                                               /*!< SPI_T::FIFOCTL: TXFBCLR Position       */
N#define SPI_FIFOCTL_TXFBCLR_Msk          (0x1ul << SPI_FIFOCTL_TXFBCLR_Pos)                /*!< SPI_T::FIFOCTL: TXFBCLR Mask           */
N
N#define SPI_FIFOCTL_RXTH_Pos             (24)                                              /*!< SPI_T::FIFOCTL: RXTH Position          */
N#define SPI_FIFOCTL_RXTH_Msk             (0x3ul << SPI_FIFOCTL_RXTH_Pos)                   /*!< SPI_T::FIFOCTL: RXTH Mask              */
N
N#define SPI_FIFOCTL_TXTH_Pos             (28)                                              /*!< SPI_T::FIFOCTL: TXTH Position          */
N#define SPI_FIFOCTL_TXTH_Msk             (0x3ul << SPI_FIFOCTL_TXTH_Pos)                   /*!< SPI_T::FIFOCTL: TXTH Mask              */
N
N#define SPI_STATUS_BUSY_Pos              (0)                                               /*!< SPI_T::STATUS: BUSY Position           */
N#define SPI_STATUS_BUSY_Msk              (0x1ul << SPI_STATUS_BUSY_Pos)                    /*!< SPI_T::STATUS: BUSY Mask               */
N
N#define SPI_STATUS_UNITIF_Pos            (1)                                               /*!< SPI_T::STATUS: UNITIF Position         */
N#define SPI_STATUS_UNITIF_Msk            (0x1ul << SPI_STATUS_UNITIF_Pos)                  /*!< SPI_T::STATUS: UNITIF Mask             */
N
N#define SPI_STATUS_SSACTIF_Pos           (2)                                               /*!< SPI_T::STATUS: SSACTIF Position        */
N#define SPI_STATUS_SSACTIF_Msk           (0x1ul << SPI_STATUS_SSACTIF_Pos)                 /*!< SPI_T::STATUS: SSACTIF Mask            */
N
N#define SPI_STATUS_SSINAIF_Pos           (3)                                               /*!< SPI_T::STATUS: SSINAIF Position        */
N#define SPI_STATUS_SSINAIF_Msk           (0x1ul << SPI_STATUS_SSINAIF_Pos)                 /*!< SPI_T::STATUS: SSINAIF Mask            */
N
N#define SPI_STATUS_SSLINE_Pos            (4)                                               /*!< SPI_T::STATUS: SSLINE Position         */
N#define SPI_STATUS_SSLINE_Msk            (0x1ul << SPI_STATUS_SSLINE_Pos)                  /*!< SPI_T::STATUS: SSLINE Mask             */
N
N#define SPI_STATUS_SLVBEIF_Pos           (6)                                               /*!< SPI_T::STATUS: SLVBEIF Position        */
N#define SPI_STATUS_SLVBEIF_Msk           (0x1ul << SPI_STATUS_SLVBEIF_Pos)                 /*!< SPI_T::STATUS: SLVBEIF Mask            */
N
N#define SPI_STATUS_SLVURIF_Pos           (7)                                               /*!< SPI_T::STATUS: SLVURIF Position        */
N#define SPI_STATUS_SLVURIF_Msk           (0x1ul << SPI_STATUS_SLVURIF_Pos)                 /*!< SPI_T::STATUS: SLVURIF Mask            */
N
N#define SPI_STATUS_RXEMPTY_Pos           (8)                                               /*!< SPI_T::STATUS: RXEMPTY Position        */
N#define SPI_STATUS_RXEMPTY_Msk           (0x1ul << SPI_STATUS_RXEMPTY_Pos)                 /*!< SPI_T::STATUS: RXEMPTY Mask            */
N
N#define SPI_STATUS_RXFULL_Pos            (9)                                               /*!< SPI_T::STATUS: RXFULL Position         */
N#define SPI_STATUS_RXFULL_Msk            (0x1ul << SPI_STATUS_RXFULL_Pos)                  /*!< SPI_T::STATUS: RXFULL Mask             */
N
N#define SPI_STATUS_RXTHIF_Pos            (10)                                              /*!< SPI_T::STATUS: RXTHIF Position         */
N#define SPI_STATUS_RXTHIF_Msk            (0x1ul << SPI_STATUS_RXTHIF_Pos)                  /*!< SPI_T::STATUS: RXTHIF Mask             */
N
N#define SPI_STATUS_RXOVIF_Pos            (11)                                              /*!< SPI_T::STATUS: RXOVIF Position         */
N#define SPI_STATUS_RXOVIF_Msk            (0x1ul << SPI_STATUS_RXOVIF_Pos)                  /*!< SPI_T::STATUS: RXOVIF Mask             */
N
N#define SPI_STATUS_RXTOIF_Pos            (12)                                              /*!< SPI_T::STATUS: RXTOIF Position         */
N#define SPI_STATUS_RXTOIF_Msk            (0x1ul << SPI_STATUS_RXTOIF_Pos)                  /*!< SPI_T::STATUS: RXTOIF Mask             */
N
N#define SPI_STATUS_SPIENSTS_Pos          (15)                                              /*!< SPI_T::STATUS: SPIENSTS Position       */
N#define SPI_STATUS_SPIENSTS_Msk          (0x1ul << SPI_STATUS_SPIENSTS_Pos)                /*!< SPI_T::STATUS: SPIENSTS Mask           */
N
N#define SPI_STATUS_TXEMPTY_Pos           (16)                                              /*!< SPI_T::STATUS: TXEMPTY Position        */
N#define SPI_STATUS_TXEMPTY_Msk           (0x1ul << SPI_STATUS_TXEMPTY_Pos)                 /*!< SPI_T::STATUS: TXEMPTY Mask            */
N
N#define SPI_STATUS_TXFULL_Pos            (17)                                              /*!< SPI_T::STATUS: TXFULL Position         */
N#define SPI_STATUS_TXFULL_Msk            (0x1ul << SPI_STATUS_TXFULL_Pos)                  /*!< SPI_T::STATUS: TXFULL Mask             */
N
N#define SPI_STATUS_TXTHIF_Pos            (18)                                              /*!< SPI_T::STATUS: TXTHIF Position         */
N#define SPI_STATUS_TXTHIF_Msk            (0x1ul << SPI_STATUS_TXTHIF_Pos)                  /*!< SPI_T::STATUS: TXTHIF Mask             */
N
N#define SPI_STATUS_TXUFIF_Pos            (19)                                              /*!< SPI_T::STATUS: TXUFIF Position         */
N#define SPI_STATUS_TXUFIF_Msk            (0x1ul << SPI_STATUS_TXUFIF_Pos)                  /*!< SPI_T::STATUS: TXUFIF Mask             */
N
N#define SPI_STATUS_TXRXRST_Pos           (23)                                              /*!< SPI_T::STATUS: TXRXRST Position        */
N#define SPI_STATUS_TXRXRST_Msk           (0x1ul << SPI_STATUS_TXRXRST_Pos)                 /*!< SPI_T::STATUS: TXRXRST Mask            */
N
N#define SPI_STATUS_RXCNT_Pos             (24)                                              /*!< SPI_T::STATUS: RXCNT Position          */
N#define SPI_STATUS_RXCNT_Msk             (0xful << SPI_STATUS_RXCNT_Pos)                   /*!< SPI_T::STATUS: RXCNT Mask              */
N
N#define SPI_STATUS_TXCNT_Pos             (28)                                              /*!< SPI_T::STATUS: TXCNT Position          */
N#define SPI_STATUS_TXCNT_Msk             (0xful << SPI_STATUS_TXCNT_Pos)                   /*!< SPI_T::STATUS: TXCNT Mask              */
N
N#define SPI_TX_TX_Pos                    (0)                                               /*!< SPI_T::TX: TX Position                 */
N#define SPI_TX_TX_Msk                    (0xfffffffful << SPI_TX_TX_Pos)                   /*!< SPI_T::TX: TX Mask                     */
N
N#define SPI_RX_RX_Pos                    (0)                                               /*!< SPI_T::RX: RX Position                 */
N#define SPI_RX_RX_Msk                    (0xfffffffful << SPI_RX_RX_Pos)                   /*!< SPI_T::RX: RX Mask                     */
N
N#define SPI_I2SCTL_I2SEN_Pos             (0)                                               /*!< SPI_T::I2SCTL: I2SEN Position          */
N#define SPI_I2SCTL_I2SEN_Msk             (0x1ul << SPI_I2SCTL_I2SEN_Pos)                   /*!< SPI_T::I2SCTL: I2SEN Mask              */
N
N#define SPI_I2SCTL_TXEN_Pos              (1)                                               /*!< SPI_T::I2SCTL: TXEN Position           */
N#define SPI_I2SCTL_TXEN_Msk              (0x1ul << SPI_I2SCTL_TXEN_Pos)                    /*!< SPI_T::I2SCTL: TXEN Mask               */
N
N#define SPI_I2SCTL_RXEN_Pos              (2)                                               /*!< SPI_T::I2SCTL: RXEN Position           */
N#define SPI_I2SCTL_RXEN_Msk              (0x1ul << SPI_I2SCTL_RXEN_Pos)                    /*!< SPI_T::I2SCTL: RXEN Mask               */
N
N#define SPI_I2SCTL_MUTE_Pos              (3)                                               /*!< SPI_T::I2SCTL: MUTE Position           */
N#define SPI_I2SCTL_MUTE_Msk              (0x1ul << SPI_I2SCTL_MUTE_Pos)                    /*!< SPI_T::I2SCTL: MUTE Mask               */
N
N#define SPI_I2SCTL_WDWIDTH_Pos           (4)                                               /*!< SPI_T::I2SCTL: WDWIDTH Position        */
N#define SPI_I2SCTL_WDWIDTH_Msk           (0x3ul << SPI_I2SCTL_WDWIDTH_Pos)                 /*!< SPI_T::I2SCTL: WDWIDTH Mask            */
N
N#define SPI_I2SCTL_MONO_Pos              (6)                                               /*!< SPI_T::I2SCTL: MONO Position           */
N#define SPI_I2SCTL_MONO_Msk              (0x1ul << SPI_I2SCTL_MONO_Pos)                    /*!< SPI_T::I2SCTL: MONO Mask               */
N
N#define SPI_I2SCTL_ORDER_Pos             (7)                                               /*!< SPI_T::I2SCTL: ORDER Position          */
N#define SPI_I2SCTL_ORDER_Msk             (0x1ul << SPI_I2SCTL_ORDER_Pos)                   /*!< SPI_T::I2SCTL: ORDER Mask              */
N
N#define SPI_I2SCTL_SLAVE_Pos             (8)                                               /*!< SPI_T::I2SCTL: SLAVE Position          */
N#define SPI_I2SCTL_SLAVE_Msk             (0x1ul << SPI_I2SCTL_SLAVE_Pos)                   /*!< SPI_T::I2SCTL: SLAVE Mask              */
N
N#define SPI_I2SCTL_MCLKEN_Pos            (15)                                              /*!< SPI_T::I2SCTL: MCLKEN Position         */
N#define SPI_I2SCTL_MCLKEN_Msk            (0x1ul << SPI_I2SCTL_MCLKEN_Pos)                  /*!< SPI_T::I2SCTL: MCLKEN Mask             */
N
N#define SPI_I2SCTL_RZCEN_Pos             (16)                                              /*!< SPI_T::I2SCTL: RZCEN Position          */
N#define SPI_I2SCTL_RZCEN_Msk             (0x1ul << SPI_I2SCTL_RZCEN_Pos)                   /*!< SPI_T::I2SCTL: RZCEN Mask              */
N
N#define SPI_I2SCTL_LZCEN_Pos             (17)                                              /*!< SPI_T::I2SCTL: LZCEN Position          */
N#define SPI_I2SCTL_LZCEN_Msk             (0x1ul << SPI_I2SCTL_LZCEN_Pos)                   /*!< SPI_T::I2SCTL: LZCEN Mask              */
N
N#define SPI_I2SCTL_RXLCH_Pos             (23)                                              /*!< SPI_T::I2SCTL: RXLCH Position          */
N#define SPI_I2SCTL_RXLCH_Msk             (0x1ul << SPI_I2SCTL_RXLCH_Pos)                   /*!< SPI_T::I2SCTL: RXLCH Mask              */
N
N#define SPI_I2SCTL_RZCIEN_Pos            (24)                                              /*!< SPI_T::I2SCTL: RZCIEN Position         */
N#define SPI_I2SCTL_RZCIEN_Msk            (0x1ul << SPI_I2SCTL_RZCIEN_Pos)                  /*!< SPI_T::I2SCTL: RZCIEN Mask             */
N
N#define SPI_I2SCTL_LZCIEN_Pos            (25)                                              /*!< SPI_T::I2SCTL: LZCIEN Position         */
N#define SPI_I2SCTL_LZCIEN_Msk            (0x1ul << SPI_I2SCTL_LZCIEN_Pos)                  /*!< SPI_T::I2SCTL: LZCIEN Mask             */
N
N#define SPI_I2SCTL_FORMAT_Pos            (28)                                              /*!< SPI_T::I2SCTL: FORMAT Position         */
N#define SPI_I2SCTL_FORMAT_Msk            (0x3ul << SPI_I2SCTL_FORMAT_Pos)                  /*!< SPI_T::I2SCTL: FORMAT Mask             */
N
N#define SPI_I2SCLK_MCLKDIV_Pos           (0)                                               /*!< SPI_T::I2SCLK: MCLKDIV Position        */
N#define SPI_I2SCLK_MCLKDIV_Msk           (0x3ful << SPI_I2SCLK_MCLKDIV_Pos)                /*!< SPI_T::I2SCLK: MCLKDIV Mask            */
N
N#define SPI_I2SCLK_BCLKDIV_Pos           (8)                                               /*!< SPI_T::I2SCLK: BCLKDIV Position        */
N#define SPI_I2SCLK_BCLKDIV_Msk           (0x1fful << SPI_I2SCLK_BCLKDIV_Pos)               /*!< SPI_T::I2SCLK: BCLKDIV Mask            */
N
N#define SPI_I2SSTS_RIGHT_Pos             (4)                                               /*!< SPI_T::I2SSTS: RIGHT Position          */
N#define SPI_I2SSTS_RIGHT_Msk             (0x1ul << SPI_I2SSTS_RIGHT_Pos)                   /*!< SPI_T::I2SSTS: RIGHT Mask              */
N
N#define SPI_I2SSTS_RXEMPTY_Pos           (8)                                               /*!< SPI_T::I2SSTS: RXEMPTY Position        */
N#define SPI_I2SSTS_RXEMPTY_Msk           (0x1ul << SPI_I2SSTS_RXEMPTY_Pos)                 /*!< SPI_T::I2SSTS: RXEMPTY Mask            */
N
N#define SPI_I2SSTS_RXFULL_Pos            (9)                                               /*!< SPI_T::I2SSTS: RXFULL Position         */
N#define SPI_I2SSTS_RXFULL_Msk            (0x1ul << SPI_I2SSTS_RXFULL_Pos)                  /*!< SPI_T::I2SSTS: RXFULL Mask             */
N
N#define SPI_I2SSTS_RXTHIF_Pos            (10)                                              /*!< SPI_T::I2SSTS: RXTHIF Position         */
N#define SPI_I2SSTS_RXTHIF_Msk            (0x1ul << SPI_I2SSTS_RXTHIF_Pos)                  /*!< SPI_T::I2SSTS: RXTHIF Mask             */
N
N#define SPI_I2SSTS_RXOVIF_Pos            (11)                                              /*!< SPI_T::I2SSTS: RXOVIF Position         */
N#define SPI_I2SSTS_RXOVIF_Msk            (0x1ul << SPI_I2SSTS_RXOVIF_Pos)                  /*!< SPI_T::I2SSTS: RXOVIF Mask             */
N
N#define SPI_I2SSTS_RXTOIF_Pos            (12)                                              /*!< SPI_T::I2SSTS: RXTOIF Position         */
N#define SPI_I2SSTS_RXTOIF_Msk            (0x1ul << SPI_I2SSTS_RXTOIF_Pos)                  /*!< SPI_T::I2SSTS: RXTOIF Mask             */
N
N#define SPI_I2SSTS_I2SENSTS_Pos          (15)                                              /*!< SPI_T::I2SSTS: I2SENSTS Position       */
N#define SPI_I2SSTS_I2SENSTS_Msk          (0x1ul << SPI_I2SSTS_I2SENSTS_Pos)                /*!< SPI_T::I2SSTS: I2SENSTS Mask           */
N
N#define SPI_I2SSTS_TXEMPTY_Pos           (16)                                              /*!< SPI_T::I2SSTS: TXEMPTY Position        */
N#define SPI_I2SSTS_TXEMPTY_Msk           (0x1ul << SPI_I2SSTS_TXEMPTY_Pos)                 /*!< SPI_T::I2SSTS: TXEMPTY Mask            */
N
N#define SPI_I2SSTS_TXFULL_Pos            (17)                                              /*!< SPI_T::I2SSTS: TXFULL Position         */
N#define SPI_I2SSTS_TXFULL_Msk            (0x1ul << SPI_I2SSTS_TXFULL_Pos)                  /*!< SPI_T::I2SSTS: TXFULL Mask             */
N
N#define SPI_I2SSTS_TXTHIF_Pos            (18)                                              /*!< SPI_T::I2SSTS: TXTHIF Position         */
N#define SPI_I2SSTS_TXTHIF_Msk            (0x1ul << SPI_I2SSTS_TXTHIF_Pos)                  /*!< SPI_T::I2SSTS: TXTHIF Mask             */
N
N#define SPI_I2SSTS_TXUFIF_Pos            (19)                                              /*!< SPI_T::I2SSTS: TXUFIF Position         */
N#define SPI_I2SSTS_TXUFIF_Msk            (0x1ul << SPI_I2SSTS_TXUFIF_Pos)                  /*!< SPI_T::I2SSTS: TXUFIF Mask             */
N
N#define SPI_I2SSTS_RZCIF_Pos             (20)                                              /*!< SPI_T::I2SSTS: RZCIF Position          */
N#define SPI_I2SSTS_RZCIF_Msk             (0x1ul << SPI_I2SSTS_RZCIF_Pos)                   /*!< SPI_T::I2SSTS: RZCIF Mask              */
N
N#define SPI_I2SSTS_LZCIF_Pos             (21)                                              /*!< SPI_T::I2SSTS: LZCIF Position          */
N#define SPI_I2SSTS_LZCIF_Msk             (0x1ul << SPI_I2SSTS_LZCIF_Pos)                   /*!< SPI_T::I2SSTS: LZCIF Mask              */
N
N#define SPI_I2SSTS_TXRXRST_Pos           (23)                                              /*!< SPI_T::I2SSTS: TXRXRST Position        */
N#define SPI_I2SSTS_TXRXRST_Msk           (0x1ul << SPI_I2SSTS_TXRXRST_Pos)                 /*!< SPI_T::I2SSTS: TXRXRST Mask            */
N
N#define SPI_I2SSTS_RXCNT_Pos             (24)                                              /*!< SPI_T::I2SSTS: RXCNT Position          */
N#define SPI_I2SSTS_RXCNT_Msk             (0x7ul << SPI_I2SSTS_RXCNT_Pos)                   /*!< SPI_T::I2SSTS: RXCNT Mask              */
N
N#define SPI_I2SSTS_TXCNT_Pos             (28)                                              /*!< SPI_T::I2SSTS: TXCNT Position          */
N#define SPI_I2SSTS_TXCNT_Msk             (0x7ul << SPI_I2SSTS_TXCNT_Pos)                   /*!< SPI_T::I2SSTS: TXCNT Mask              */
N
N/**@}*/ /* SPI_CONST */
N/**@}*/ /* end of SPI register group */
N
N
N/*---------------------- System Manger Controller -------------------------*/
N/**
N    @addtogroup SYS System Manger Controller(SYS)
N    Memory Mapped Structure for SYS Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var SYS_T::PDID
N     * Offset: 0x00  Part Device Identification Number Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |PDID      |Part Device Identification Number (Read Only)
N     * |        |          |This register reflects device part number code.
N     * |        |          |Software can read this register to identify which device is used.
N     * @var SYS_T::RSTSTS
N     * Offset: 0x04  System Reset Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PORF      |POR Reset Flag
N     * |        |          |The POR reset flag is set by the Reset Signal from the Power-on Reset (POR) Controller or bit CHIPRST (SYS_IPRST0[0]) to indicate the previous reset source.
N     * |        |          |0 = No reset from POR or CHIPRST.
N     * |        |          |1 = Power-on Reset (POR) or CHIPRST had issued the reset signal to reset the system.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[1]     |PINRF     |nRESET Pin Reset Flag
N     * |        |          |The nRESET pin reset flag is set by the Reset Signal from the nRESET Pin to indicate the previous reset source.
N     * |        |          |0 = No reset from nRESET pin.
N     * |        |          |1 = Pin nRESET had issued the reset signal to reset the system.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[2]     |WDTRF     |WDT Reset Flag
N     * |        |          |The WDT reset flag is set by the Reset Signal from the Watchdog Timer or Window Watchdog Timer to indicate the previous reset source.
N     * |        |          |0 = No reset from watchdog timer or window watchdog timer.
N     * |        |          |1 = The watchdog timer or window watchdog timer had issued the reset signal to reset the system.
N     * |        |          |Note1: This bit can be cleared by software writing 1.
N     * |        |          |Note2: Watchdog Timer register RSTF(WDT_CTL[2]) bit is set if the system has been reset by WDT time-out reset.
N     * |        |          |Window Watchdog Timer register WWDTRF(WWDT_STATUS[1]) bit is set if the system has been reset by WWDT time-out reset.
N     * |[3]     |LVRF      |LVR Reset Flag
N     * |        |          |The LVR reset flag is set by the Reset Signal from the Low Voltage Reset Controller to indicate the previous reset source.
N     * |        |          |0 = No reset from LVR.
N     * |        |          |1 = LVR controller had issued the reset signal to reset the system.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[4]     |BODRF     |BOD Reset Flag
N     * |        |          |The BOD reset flag is set by the Reset Signal from the Brown-out Detector to indicate the previous reset source.
N     * |        |          |0 = No reset from BOD.
N     * |        |          |1 = The BOD had issued the reset signal to reset the system.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[5]     |MCURF     |MCU Reset Flag
N     * |        |          |The MCU reset flag is set by the Reset Signal from the Cortex-M0 Core to indicate the previous reset source.
N     * |        |          |0 = No reset from Cortex-M0.
N     * |        |          |1 = The Cortex-M0 had issued the reset signal to reset the system by writing 1 to the bit SYSRESETREQ(AIRCR[2], Application Interrupt and Reset Control Register, address = 0xE000ED0C) in system control registers of Cortex-M0 core.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[7]     |CPURF     |CPU Reset Flag
N     * |        |          |The CPU reset flag is set by hardware if software writes CPURST (SYS_IPRST0[1]) 1 to reset Cortex-M0 Core and Flash Memory Controller (FMC).
N     * |        |          |0 = No reset from CPU.
N     * |        |          |1 = The Cortex-M0 Core and FMC are reset by software setting CPURST to 1.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[8]     |CPULKRF   |CPU Lockup Reset Flag
N     * |        |          |The CPU lockup reset flag is set by hardware if Cortex-M0 lockup happened.
N     * |        |          |0 = No reset from CPU lockup happened.
N     * |        |          |1 = The Cortex-M0 lockup happened and chip is reset.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * @var SYS_T::IPRST0
N     * Offset: 0x08  Peripheral  Reset Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CHIPRST   |Chip One-shot Reset (Write Protect)
N     * |        |          |Setting this bit will reset the whole chip, including Processor core and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.
N     * |        |          |The CHIPRST is same as the POR reset, all the chip controllers is reset and the chip setting from flash are also reload.
N     * |        |          |0 = Chip normal operation.
N     * |        |          |1 = Chip one-shot reset.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[1]     |CPURST    |Processor Core One-shot Reset (Write Protect)
N     * |        |          |Setting this bit will only reset the processor core and Flash Memory Controller(FMC), and this bit will automatically return to 0 after the 2 clock cycles.
N     * |        |          |0 = Processor core normal operation.
N     * |        |          |1 = Processor core one-shot reset.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[2]     |PDMARST   |PDMA Controller Reset (Write Protect)
N     * |        |          |Setting this bit to 1 will generate a reset signal to the PDMA.
N     * |        |          |User needs to set this bit to 0 to release from reset state.
N     * |        |          |0 = PDMA controller normal operation.
N     * |        |          |1 = PDMA controller reset.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[3]     |EBIRST    |EBI Controller Reset (Write Protect)
N     * |        |          |Set this bit to 1 will generate a reset signal to the EBI.
N     * |        |          |User needs to set this bit to 0 to release from the reset state.
N     * |        |          |0 = EBI controller normal operation.
N     * |        |          |1 = EBI controller reset.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[4]     |HDIVRST   |HDIV Controller Reset (Write Protect)
N     * |        |          |Set this bit to 1 will generate a reset signal to the HDIV controller.
N     * |        |          |User needs to set this bit to 0 to release from the reset state.
N     * |        |          |0 = HDIV controller normal operation.
N     * |        |          |1 = HDIV controller reset.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[7]     |CRCRST    |CRC Calculation Controller Reset (Write Protect)
N     * |        |          |Set this bit to 1 will generate a reset signal to the CRC calculation controller.
N     * |        |          |User needs to set this bit to 0 to release from the reset state.
N     * |        |          |0 = CRC calculation controller normal operation.
N     * |        |          |1 = CRC calculation controller reset.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * @var SYS_T::IPRST1
N     * Offset: 0x0C  Peripheral Reset Control Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |GPIORST   |GPIO Controller Reset
N     * |        |          |0 = GPIO controller normal operation.
N     * |        |          |1 = GPIO controller reset.
N     * |[2]     |TMR0RST   |Timer0 Controller Reset
N     * |        |          |0 = Timer0 controller normal operation.
N     * |        |          |1 = Timer0 controller reset.
N     * |[3]     |TMR1RST   |Timer1 Controller Reset
N     * |        |          |0 = Timer1 controller normal operation.
N     * |        |          |1 = Timer1 controller reset.
N     * |[4]     |TMR2RST   |Timer2 Controller Reset
N     * |        |          |0 = Timer2 controller normal operation.
N     * |        |          |1 = Timer2 controller reset.
N     * |[5]     |TMR3RST   |Timer3 Controller Reset
N     * |        |          |0 = Timer3 controller normal operation.
N     * |        |          |1 = Timer3 controller reset.
N     * |[8]     |I2C0RST   |I2C0 Controller Reset
N     * |        |          |0 = I2C0 controller normal operation.
N     * |        |          |1 = I2C0 controller reset.
N     * |[9]     |I2C1RST   |I2C1 Controller Reset
N     * |        |          |0 = I2C1 controller normal operation.
N     * |        |          |1 = I2C1 controller reset.
N     * |[12]    |SPI0RST   |SPI0 Controller Reset
N     * |        |          |0 = SPI0 controller normal operation.
N     * |        |          |1 = SPI0 controller reset.
N     * |[13]    |SPI1RST   |SPI1 Controller Reset
N     * |        |          |0 = SPI1 controller normal operation.
N     * |        |          |1 = SPI1 controller reset.
N     * |[16]    |UART0RST  |UART0 Controller Reset
N     * |        |          |0 = UART0 controller normal operation.
N     * |        |          |1 = UART0 controller reset.
N     * |[17]    |UART1RST  |UART1 Controller Reset
N     * |        |          |0 = UART1 controller normal operation.
N     * |        |          |1 = UART1 controller reset.
N     * |[18]    |UART2RST  |UART2 Controller Reset
N     * |        |          |0 = UART2 controller normal operation.
N     * |        |          |1 = UART2 controller reset.
N     * |[20]    |PWM0RST   |PWM0 Controller Reset
N     * |        |          |0 = PWM0 controller normal operation.
N     * |        |          |1 = PWM0 controller reset.
N     * |[21]    |PWM1RST   |PWM1 Controller Reset
N     * |        |          |0 = PWM1 controller normal operation.
N     * |        |          |1 = PWM1 controller reset.
N     * |[22]    |ACMP01RST |ACMP01 Controller Reset
N     * |        |          |0 = ACMP01 controller normal operation.
N     * |        |          |1 = ACMP01 controller reset.
N     * |[27]    |USBDRST   |USB Device Controller Reset
N     * |        |          |0 = USB device controller normal operation.
N     * |        |          |1 = USB device controller reset.
N     * |[28]    |ADCRST    |ADC Controller Reset
N     * |        |          |0 = ADC controller normal operation.
N     * |        |          |1 = ADC controller reset.
N     * @var SYS_T::IPRST2
N     * Offset: 0x10  Peripheral Reset Control Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SC0RST    |SC0 Controller Reset
N     * |        |          |0 = SC0 controller normal operation.
N     * |        |          |1 = SC0 controller reset.
N     * |[1]     |SC1RST    |SC1 Controller Reset
N     * |        |          |0 = SC1 controller normal operation.
N     * |        |          |1 = SC1 controller reset.
N     * |[8]     |USCI0RST  |USCI0 Controller Reset
N     * |        |          |0 = USCI0 controller normal operation.
N     * |        |          |1 = USCI0 controller reset.
N     * |[9]     |USCI1RST  |USCI1 Controller Reset
N     * |        |          |0 = USCI1 controller normal operation.
N     * |        |          |1 = USCI1 controller reset.
N     * |[10]    |USCI2RST  |USCI2 Controller Reset
N     * |        |          |0 = USCI2 controller normal operation.
N     * |        |          |1 = USCI2 controller reset.
N     * @var SYS_T::BODCTL
N     * Offset: 0x18  Brown-out Detector Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BODEN     |Brown-out Detector Enable Bit (Write Protect)
N     * |        |          |The default value is set by flash controller user configuration register CBODEN (CONFIG0 [23]).
N     * |        |          |0 = Brown-out Detector function Disabled.
N     * |        |          |1 = Brown-out Detector function Enabled.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[2:1]   |BODVL     |Brown-out Detector Threshold Voltage Selection (Write Protect)
N     * |        |          |The default value is set by flash controller user configuration register CBOV (CONFIG0 [22:21]).
N     * |        |          |00 = Brown-Out Detector threshold voltage is 2.2V.
N     * |        |          |01 = Brown-Out Detector threshold voltage is 2.7V.
N     * |        |          |10 = Brown-Out Detector threshold voltage is 3.7V.
N     * |        |          |11 = Brown-Out Detector threshold voltage is 4.5V.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[3]     |BODRSTEN  |Brown-out Reset Enable Bit (Write Protect)
N     * |        |          |The default value is set by flash controller user configuration register CBORST(CONFIG0[20]) bit.
N     * |        |          |0 = Brown-out interrupt function Enabled.
N     * |        |          |1 = Brown-out reset function Enabled.
N     * |        |          |Note1:
N     * |        |          |While the Brown-out Detector function is enabled (BODEN high) and BOD reset function is enabled (BODRSTEN high), BOD will assert a signal to reset chip when the detected voltage is lower than the threshold (BODOUT high).
N     * |        |          |While the BOD function is enabled (BODEN high) and BOD interrupt function is enabled (BODRSTEN low), BOD will assert an interrupt if BODOUT is high
N     * |        |          |BOD interrupt will keep till to the BODEN set to 0.
N     * |        |          |BOD interrupt can be blocked by disabling the NVIC BOD interrupt or disabling BOD function (set BODEN low).
N     * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[4]     |BODIF     |Brown-out Detector Interrupt Flag
N     * |        |          |0 = Brown-out Detector does not detect any voltage draft at VDD down through or up through the voltage of BODVL setting.
N     * |        |          |1 = When Brown-out Detector detects the VDD is dropped down through the voltage of BODVL setting or the VDD is raised up through the voltage of BODVL setting, this bit is set to 1 and the brown-out interrupt is requested if brown-out interrupt is enabled.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[5]     |BODLPM    |Brown-out Detector Low Power Mode (Write Protect)
N     * |        |          |0 = BOD operate in normal mode (default).
N     * |        |          |1 = BOD Low Power mode Enabled.
N     * |        |          |Note1: The BOD consumes about 100uA in normal mode, the low power mode can reduce the current to about 1/10 but slow the BOD response.
N     * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[6]     |BODOUT    |Brown-out Detector Output Status
N     * |        |          |0 = Brown-out Detector output status is 0.
N     * |        |          |It means the detected voltage is higher than BODVL setting or BODEN is 0.
N     * |        |          |1 = Brown-out Detector output status is 1.
N     * |        |          |It means the detected voltage is lower than BODVL setting.
N     * |        |          |If the BODEN is 0, BOD function disabled, this bit always responds 0.
N     * |[7]     |LVREN     |Low Voltage Reset Enable Bit (Write Protect)
N     * |        |          |The LVR function resets the chip when the input power voltage is lower than LVR circuit setting.
N     * |        |          |LVR function is enabled by default.
N     * |        |          |0 = Low Voltage Reset function Disabled.
N     * |        |          |1 = Low Voltage Reset function Enabled.
N     * |        |          |Note1: After enabling the bit, the LVR function will be active with 200us delay for LVR output stable (default).
N     * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[10:8]  |BODDGSEL  |Brown-out Detector Output De-glitch Time Select (Write Protect)
N     * |        |          |000 = BOD output is sampled by RC10K clock.
N     * |        |          |001 = 4 system clock (HCLK).
N     * |        |          |010 = 8 system clock (HCLK).
N     * |        |          |011 = 16 system clock (HCLK).
N     * |        |          |100 = 32 system clock (HCLK).
N     * |        |          |101 = 64 system clock (HCLK).
N     * |        |          |110 = 128 system clock (HCLK).
N     * |        |          |111 = 256 system clock (HCLK).
N     * |        |          |Note: These bits are write protected. Refer to the SYS_REGLCTL register.
N     * |[14:12] |LVRDGSEL  |LVR Output De-glitch Time Select (Write Protect)
N     * |        |          |000 = Without de-glitch function.
N     * |        |          |001 = 4 system clock (HCLK).
N     * |        |          |010 = 8 system clock (HCLK).
N     * |        |          |011 = 16 system clock (HCLK).
N     * |        |          |100 = 32 system clock (HCLK).
N     * |        |          |101 = 64 system clock (HCLK).
N     * |        |          |110 = 128 system clock (HCLK).
N     * |        |          |111 = 256 system clock (HCLK).
N     * |        |          |Note: These bits are write protected. Refer to the SYS_REGLCTL register.
N     * |[16]    |EBODEN    |External BOD External Input Voltage Enable Bit
N     * |        |          |0 = EBOD detect external input voltage function Disabled.
N     * |        |          |1 = EBOD detect external input voltage function Enabled.
N     * |        |          |Note1: This function is still active in whole chip power-down mode.
N     * |        |          |Note2: This function need use LIRC or LXT as EBOD clock source, which is selected in EBODCKSEL (CLK_BODCLK[0]).
N     * |        |          |Note3: The input pin for EBOD detect voltage is selectabe by EBODPINSEL (SYS_BODCTL[17]).
N     * |[17]    |EBODPINSEL|External BOD External Input Voltage Pin Selection
N     * |        |          |0 = The input voltage is from P1.0.
N     * |        |          |1 = The input voltage is from P1.1.
N     * |        |          |Note1: If P1.0 is selected, multi-function pin must be selected correctly in P10MFP (SYS_GP1_MFPL[3:0]).
N     * |        |          |Note2: If P1.1 is selected, multi-function pin must be selected correctly in P11MFP (SYS_GP1_MFPL[7:4]).
N     * |[18]    |EBODIEN   |External BOD Interrupt Enable Bit
N     * |        |          |0 = EBOD interrupt Disabled.
N     * |        |          |1 = EBOD interrupt Enabled.
N     * |[19]    |EBODIF    |External BOD Interrupt Flag
N     * |        |          |0 = EBOD does not detect any voltage draft at external pin down through or up through the voltage of Bandgap.
N     * |        |          |1 = When EBOD detects the external pin is dropped down through the voltage of Bandgap or the external pin is raised up through the voltage of Bandgap, this bit is set to 1 and the brown-out interrupt is requested if brown-out interrupt is enabled.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[21:20] |EBODDTSEL |External BOD Frequency Select for External Input Voltage
N     * |        |          |EBOD detect external voltage function can be enabled per serveral EBOD clocks for saving power.
N     * |        |          |00 = EBOD detect external voltage function is always enabled.
N     * |        |          |01 = EBOD detect external voltage function is enabled once per 64 EBOD clocks.
N     * |        |          |10 = EBOD detect external voltage function is enabled once per 128 EBOD clocks.
N     * |        |          |11 = EBOD detect external voltage function is enabled once per 256 EBOD clocks.
N     * |        |          |Note: The EBOD clock must be enabled. The EBOD clock is selected in EBODCKSEL (CLK_BODCLK[0]).
N     * |[23:22] |EBODBGSEL |External BOD Bandgap Enable Frequency Select for External Input Voltage
N     * |        |          |If EBODDTSEL (SYS_BODCTL[21:20]) is selected to 00, the EBOD bandgap can be enabled per serveral EBOD clocks for saving power.
N     * |        |          |00 = EBOD bandgap is always enabled.
N     * |        |          |01 = EBOD bandgap is enabled once per 64 EBOD clocks.
N     * |        |          |10 = EBOD bandgap is enabled once per 128 EBOD clocks.
N     * |        |          |11 = EBOD bandgap is enabled once per 256 EBOD clocks.
N     * |        |          |Note: The EBOD clock must be enabled. The EBOD clock is selected in EBODCKSEL (CLK_BODCLK[0]).
N     * |[24]    |EBODOUT   |External BOD Output Status
N     * |        |          |0 = EBOD output status is 0.
N     * |        |          |It means the detected voltage is higher than Bandgap or EBODEN is 0.
N     * |        |          |1 = EBOD output status is 1.
N     * |        |          |It means the detected voltage is lower than Bandgap.
N     * |        |          |If the EBODEN is 0, EBOD function disabled, this bit always responds 0.
N     * |[27:25] |EBODDGSEL |External BOD Output De-glitch Time Select (Write Protect)
N     * |        |          |000 = EBOD output is sampled by EBOD clock.
N     * |        |          |001 = 16 system clock (HCLK).
N     * |        |          |010 = 32 system clock (HCLK).
N     * |        |          |011 = 64 system clock (HCLK).
N     * |        |          |100 = 128 system clock (HCLK).
N     * |        |          |101 = 256 system clock (HCLK).
N     * |        |          |110 = 512 system clock (HCLK).
N     * |        |          |111 = 1024 system clock (HCLK).
N     * |        |          |Note: These bits are write protected. Refer to the SYS_REGLCTL register.
N     * @var SYS_T::IVSCTL
N     * Offset: 0x1C  Internal Voltage Source Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |VTEMPEN   |Temperature Sensor Enable Bit
N     * |        |          |This bit is used to enable/disable temperature sensor function.
N     * |        |          |0 = Temperature sensor function Disabled (default).
N     * |        |          |1 = Temperature sensor function Enabled.
N     * |        |          |Note: After this bit is set to 1, the value of temperature sensor output can be obtained from ADC conversion result.
N     * |[1]     |VBATUGEN  |VBAT Unity Gain Buffer Enable Bit
N     * |        |          |This bit is used to enable/disable VBAT unity gain buffer function.
N     * |        |          |0 = VBAT unity gain buffer function Disabled (default).
N     * |        |          |1 = VBAT unity gain buffer function Enabled.
N     * |        |          |Note: After this bit is set to 1, the value of VBAT unity gain buffer output voltage can be obtained from ADC conversion result.
N     * @var SYS_T::PORCTL
N     * Offset: 0x24  Power-on Reset Controller Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |POROFF    |Power-on Reset Enable Bit (Write Protect)
N     * |        |          |When powered on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again.
N     * |        |          |User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by writing 0x5AA5 to this field.
N     * |        |          |The POR function will be active again when this field is set to another value or chip is reset by other reset source, including:
N     * |        |          |nRESET, Watchdog, LVR reset, BOD reset, ICE reset command and the software-chip reset function.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * @var SYS_T::VREFCTL
N     * Offset: 0x28  VREF Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4:0]   |VREFCTL   |VREF Control Bits (Write Protect)
N     * |        |          |00000 = From VREF pin.
N     * |        |          |00011 = VREF is internal 2.56V.
N     * |        |          |00111 = VREF is internal 2.048V.
N     * |        |          |01011 = VREF is internal 3.072V.
N     * |        |          |01111 = VREF is internal 4.096V.
N     * |        |          |10000 = VREF is from AVDD.
N     * |        |          |Others = Reserved.
N     * |        |          |Note: These bit are write protected. Refer to the SYS_REGLCTL register.
N     * @var SYS_T::GPA_MFPL
N     * Offset: 0x30  GPIOA Low Byte Multiple Function Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |PA0MFP    |PA.0 Multi-function Pin Selection
N     * |[7:4]   |PA1MFP    |PA.1 Multi-function Pin Selection
N     * |[11:8]  |PA2MFP    |PA.2 Multi-function Pin Selection
N     * |[15:12] |PA3MFP    |PA.3 Multi-function Pin Selection
N     * |[19:16] |PA4MFP    |PA.4 Multi-function Pin Selection
N     * |[23:20] |PA5MFP    |PA.5 Multi-function Pin Selection
N     * |[27:24] |PA6MFP    |PA.6 Multi-function Pin Selection
N     * |[31:28] |PA7MFP    |PA.7 Multi-function Pin Selection
N     * @var SYS_T::GPA_MFPH
N     * Offset: 0x34  GPIOA High Byte Multiple Function Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |PA8MFP    |PA.8 Multi-function Pin Selection
N     * |[7:4]   |PA9MFP    |PA.9 Multi-function Pin Selection
N     * |[11:8]  |PA10MFP   |PA.10 Multi-function Pin Selection
N     * |[15:12] |PA11MFP   |PA.11 Multi-function Pin Selection
N     * |[19:16] |PA12MFP   |PA.12 Multi-function Pin Selection
N     * |[23:20] |PA13MFP   |PA.13 Multi-function Pin Selection
N     * |[27:24] |PA14MFP   |PA.14 Multi-function Pin Selection
N     * |[31:28] |PA15MFP   |PA.15 Multi-function Pin Selection
N     * @var SYS_T::GPB_MFPL
N     * Offset: 0x38  GPIOB Low Byte Multiple Function Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |PB0MFP    |PB.0 Multi-function Pin Selection
N     * |[7:4]   |PB1MFP    |PB.1 Multi-function Pin Selection
N     * |[11:8]  |PB2MFP    |PB.2 Multi-function Pin Selection
N     * |[15:12] |PB3MFP    |PB.3 Multi-function Pin Selection
N     * |[19:16] |PB4MFP    |PB.4 Multi-function Pin Selection
N     * |[23:20] |PB5MFP    |PB.5 Multi-function Pin Selection
N     * |[27:24] |PB6MFP    |PB.6 Multi-function Pin Selection
N     * |[31:28] |PB7MFP    |PB.7 Multi-function Pin Selection
N     * @var SYS_T::GPB_MFPH
N     * Offset: 0x3C  GPIOB High Byte Multiple Function Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |PB8MFP    |PB.8 Multi-function Pin Selection
N     * |[7:4]   |PB9MFP    |PB.9 Multi-function Pin Selection
N     * |[11:8]  |PB10MFP   |PB.10 Multi-function Pin Selection
N     * |[15:12] |PB11MFP   |PB.11 Multi-function Pin Selection
N     * |[19:16] |PB12MFP   |PB.12 Multi-function Pin Selection
N     * |[23:20] |PB13MFP   |PB.13 Multi-function Pin Selection
N     * |[27:24] |PB14MFP   |PB.14 Multi-function Pin Selection
N     * |[31:28] |PB15MFP   |PB.15 Multi-function Pin Selection
N     * @var SYS_T::GPC_MFPL
N     * Offset: 0x40  GPIOC Low Byte Multiple Function Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |PC0MFP    |PC.0 Multi-function Pin Selection
N     * |[7:4]   |PC1MFP    |PC.1 Multi-function Pin Selection
N     * |[11:8]  |PC2MFP    |PC.2 Multi-function Pin Selection
N     * |[15:12] |PC3MFP    |PC.3 Multi-function Pin Selection
N     * |[19:16] |PC4MFP    |PC.4 Multi-function Pin Selection
N     * |[23:20] |PC5MFP    |PC.5 Multi-function Pin Selection
N     * |[27:24] |PC6MFP    |PC.6 Multi-function Pin Selection
N     * |[31:28] |PC7MFP    |PC.7 Multi-function Pin Selection
N     * @var SYS_T::GPC_MFPH
N     * Offset: 0x44  GPIOC High Byte Multiple Function Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |PC8MFP    |PC.8 Multi-function Pin Selection
N     * |[7:4]   |PC9MFP    |PC.9 Multi-function Pin Selection
N     * |[11:8]  |PC10MFP   |PC.10 Multi-function Pin Selection
N     * |[15:12] |PC11MFP   |PC.11 Multi-function Pin Selection
N     * |[19:16] |PC12MFP   |PC.12 Multi-function Pin Selection
N     * |[23:20] |PC13MFP   |PC.13 Multi-function Pin Selection
N     * |[27:24] |PC14MFP   |PC.14 Multi-function Pin Selection
N     * |[31:28] |PC15MFP   |PC.15 Multi-function Pin Selection
N     * @var SYS_T::GPD_MFPL
N     * Offset: 0x48  GPIOD Low Byte Multiple Function Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |PD0MFP    |PD.0 Multi-function Pin Selection
N     * |[7:4]   |PD1MFP    |PD.1 Multi-function Pin Selection
N     * |[11:8]  |PD2MFP    |PD.2 Multi-function Pin Selection
N     * |[15:12] |PD3MFP    |PD.3 Multi-function Pin Selection
N     * |[19:16] |PD4MFP    |PD.4 Multi-function Pin Selection
N     * |[23:20] |PD5MFP    |PD.5 Multi-function Pin Selection
N     * |[27:24] |PD6MFP    |PD.6 Multi-function Pin Selection
N     * |[31:28] |PD7MFP    |PD.7 Multi-function Pin Selection
N     * @var SYS_T::GPD_MFPH
N     * Offset: 0x4C  GPIOD High Byte Multiple Function Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |PD8MFP    |PD.8 Multi-function Pin Selection
N     * |[7:4]   |PD9MFP    |PD.9 Multi-function Pin Selection
N     * |[11:8]  |PD10MFP   |PD.10 Multi-function Pin Selection
N     * |[15:12] |PD11MFP   |PD.11 Multi-function Pin Selection
N     * |[19:16] |PD12MFP   |PD.12 Multi-function Pin Selection
N     * |[23:20] |PD13MFP   |PD.13 Multi-function Pin Selection
N     * |[27:24] |PD14MFP   |PD.14 Multi-function Pin Selection
N     * |[31:28] |PD15MFP   |PD.15 Multi-function Pin Selection
N     * @var SYS_T::GPE_MFPL
N     * Offset: 0x50  GPIOE Low Byte Multiple Function Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |PE0MFP    |PE.0 Multi-function Pin Selection
N     * |[7:4]   |PE1MFP    |PE.1 Multi-function Pin Selection
N     * |[11:8]  |PE2MFP    |PE.2 Multi-function Pin Selection
N     * |[15:12] |PE3MFP    |PE.3 Multi-function Pin Selection
N     * |[19:16] |PE4MFP    |PE.4 Multi-function Pin Selection
N     * |[23:20] |PE5MFP    |PE.5 Multi-function Pin Selection
N     * |[27:24] |PE6MFP    |PE.6 Multi-function Pin Selection
N     * |[31:28] |PE7MFP    |PE.7 Multi-function Pin Selection
N     * @var SYS_T::GPE_MFPH
N     * Offset: 0x54  GPIOE High Byte Multiple Function Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |PE8MFP    |PE.8 Multi-function Pin Selection
N     * |[7:4]   |PE9MFP    |PE.9 Multi-function Pin Selection
N     * |[11:8]  |PE10MFP   |PE.10 Multi-function Pin Selection
N     * |[15:12] |PE11MFP   |PE.11 Multi-function Pin Selection
N     * |[19:16] |PE12MFP   |PE.12 Multi-function Pin Selection
N     * |[23:20] |PE13MFP   |PE.13 Multi-function Pin Selection
N     * @var SYS_T::GPF_MFPL
N     * Offset: 0x58  GPIOF Low Byte Multiple Function Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |PF0MFP    |PF.0 Multi-function Pin Selection
N     * |[7:4]   |PF1MFP    |PF.1 Multi-function Pin Selection
N     * |[11:8]  |PF2MFP    |PF.2 Multi-function Pin Selection
N     * |[15:12] |PF3MFP    |PF.3 Multi-function Pin Selection
N     * |        |          |The default value is set by flash controller user configuration register CFGXT1(CONFIG0[27]) bit.
N     * |        |          |0 = PF.3 pin is configured as GPIO pins.
N     * |        |          |1 = PF.3 pin is configured as external 4~24 MHz external high speed crystal oscillator (HXT) pins.
N     * |[19:16] |PF4MFP    |PF.4 Multi-function Pin Selection
N     * |        |          |The default value is set by flash controller user configuration register CFGXT1(CONFIG0[27]) bit.
N     * |        |          |0 = PF.4 pin is configured as GPIO pins.
N     * |        |          |1 = PF.4 pin is configured as external 4~24 MHz external high speed crystal oscillator (HXT) pins.
N     * |[23:20] |PF5MFP    |PF.5 Multi-function Pin Selection
N     * |[27:24] |PF6MFP    |PF.6 Multi-function Pin Selection
N     * |[31:28] |PF7MFP    |PF.7 Multi-function Pin Selection
N     * @var SYS_T::IRCTCTL0
N     * Offset: 0x80  HIRC0 Trim Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |FREQSEL   |Trim Frequency Selection
N     * |        |          |This field indicates the target frequency of internal high speed RC oscillator 0 (HIRC0) auto trim.
N     * |        |          |During auto trim operation, if clock error detected with CESTOPEN(SYS_IRCTCTL0[8]) is set to 1 or trim retry limitation count reached, this field will be cleared to 00 automatically.
N     * |        |          |00 = Disable HIRC0 auto trim function.
N     * |        |          |01 = Enable HIRC0 auto trim function and trim HIRC to 22.1184 MHz.
N     * |        |          |10 = Reserved.
N     * |        |          |11 = Reserved.
N     * |[5:4]   |LOOPSEL   |Trim Calculation Loop Selection
N     * |        |          |This field defines that trim value calculation is based on how many clocks of reference clock (32.768 kHz, LXT).
N     * |        |          |00 = Trim value calculation is based on average difference in 4 clocks of reference clock.
N     * |        |          |01 = Trim value calculation is based on average difference in 8 clocks of reference clock.
N     * |        |          |10 = Trim value calculation is based on average difference in 16 clocks of reference clock.
N     * |        |          |11 = Trim value calculation is based on average difference in 32 clocks of reference clock.
N     * |        |          |Note: For example, if LOOPSEL is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 clocks of reference clock.
N     * |[7:6]   |RETRYCNT  |Trim Value Update Limitation Count
N     * |        |          |This field defines that how many times the auto trim circuit will try to update the HIRC0 trim value before the frequency of HIRC0 locked.
N     * |        |          |Once the HIRC0 locked, the internal trim value update counter will be reset.
N     * |        |          |If the trim value update counter reached this limitation value and frequency of HIRC0 still does not lock, the auto trim operation will be disabled and FREQSEL(SYS_IRCTCTL0[1:0]) will be cleared to 00.
N     * |        |          |00 = Trim retry count limitation is 64 loops.
N     * |        |          |01 = Trim retry count limitation is 128 loops.
N     * |        |          |10 = Trim retry count limitation is 256 loops.
N     * |        |          |11 = Trim retry count limitation is 512 loops.
N     * |[8]     |CESTOPEN  |Clock Error Stop Enable Bit
N     * |        |          |0 = The trim operation is keep going if clock is inaccuracy.
N     * |        |          |1 = The trim operation is stopped if clock is inaccuracy.
N     * |[10]    |REFCKSEL  |Reference Clock Selection
N     * |        |          |0 = HIRC trim reference clock is from LXT (32.768 kHz).
N     * |        |          |1 = HIRC trim reference clock is from internal USB synchronous mode.
N     * @var SYS_T::IRCTIEN
N     * Offset: 0x84  HIRC Trim Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |TFAILIEN  |HIRC0 Trim Failure Interrupt Enable Bit
N     * |        |          |This bit controls if an interrupt will be triggered while HIRC0 trim value update limitation count reached and HIRC frequency still not locked on target frequency set by FREQSEL(SYS_IRCTCTL0[1:0]).
N     * |        |          |If this bit is high and TFAILIF(SYS_IRCTSTS0[1]) is set during auto trim operation, an interrupt will be triggered to notify that HIRC0 trim value update limitation count was reached.
N     * |        |          |0 = Disable TFAILIF(SYS_IRCTSTS0[1]) status to trigger an interrupt to CPU.
N     * |        |          |1 = Enable TFAILIF(SYS_IRCTSTS0[1]) status to trigger an interrupt to CPU.
N     * |[2]     |CLKEIEN   |HIRC0 Clock Error Interrupt Enable Bit
N     * |        |          |This bit controls if CPU would get an interrupt while HIRC0 clock is inaccuracy during auto trim operation.
N     * |        |          |If this bit is set to1, and CLKERRIF(SYS_IRCTSTS0[2]) is set during auto trim operation, an interrupt will be triggered to notify the clock frequency is inaccuracy.
N     * |        |          |0 = Disable CLKERRIF(SYS_IRCTSTS0[2]) status to trigger an interrupt to CPU.
N     * |        |          |1 = Enable CLKERRIF(SYS_IRCTSTS0[2]) status to trigger an interrupt to CPU.
N     * |[9]     |TFAILIEN1 |HIRC1 Trim Failure Interrupt Enable Bit
N     * |        |          |This bit controls if an interrupt will be triggered while HIRC1 trim value update limitation count reached and HIRC1 frequency still not locked on target frequency set by FREQSEL(SYS_IRCTCTL1[1:0]).
N     * |        |          |If this bit is high and TFAILIF(SYS_IRCTSTS[1]) is set during auto trim operation, an interrupt will be triggered to notify that HIRC1 trim value update limitation count was reached.
N     * |        |          |0 = Disable TFAILIF(SYS_IRCTSTS[1]) status to trigger an interrupt to CPU.
N     * |        |          |1 = Enable TFAILIF(SYS_IRCTSTS[1]) status to trigger an interrupt to CPU.
N     * |[10]    |CLKEIEN1  |HIRC1 Clock Error Interrupt Enable Bit
N     * |        |          |This bit controls if CPU would get an interrupt while HIRC1 clock is inaccuracy during auto trim operation.
N     * |        |          |If this bit is set to1, and CLKERRIF(SYS_IRCTSTS[2]) is set during auto trim operation, an interrupt will be triggered to notify the clock frequency is inaccuracy.
N     * |        |          |0 = Disable CLKERRIF(SYS_IRCTSTS[2]) status to trigger an interrupt to CPU.
N     * |        |          |1 = Enable CLKERRIF(SYS_IRCTSTS[2]) status to trigger an interrupt to CPU.
N     * @var SYS_T::IRCTISTS
N     * Offset: 0x88  HIRC Trim Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |FREQLOCK  |HIRC Frequency Lock Status
N     * |        |          |This bit indicates the HIRC0 frequency is locked.
N     * |        |          |This is a status bit and doesnu2019t trigger any interrupt.
N     * |        |          |0 = The internal high-speed RC oscillator 0 frequency does not lock at 22.1184 MHz yet.
N     * |        |          |1 = The internal high-speed RC oscillator 0 frequency locked at 22.1184 MHz.
N     * |[1]     |TFAILIF   |Trim Failure Interrupt Status
N     * |        |          |This bit indicates that HIRC0 trim value update limitation count reached and the HIRC0 clock frequency still does not be locked.
N     * |        |          |Once this bit is set, the auto trim operation stopped and FREQSEL(SYS_iRCTCTL0[1:0]) will be cleared to 00 by hardware automatically.
N     * |        |          |If this bit is set and TFAILIEN(SYS_IRCTIEN0[1]) is high, an interrupt will be triggered to notify that HIRC0 trim value update limitation count was reached.
N     * |        |          |Write 1 to clear this to 0.
N     * |        |          |0 = Trim value update limitation count does not reach.
N     * |        |          |1 = Trim value update limitation count reached and HIRC frequency still not locked.
N     * |[2]     |CLKERRIF  |Clock Error Interrupt Status
N     * |        |          |When the frequency of 32.768 kHz external low speed crystal oscillator (LXT) or 22.1184 MHz internal high speed RC oscillator 0 (HIRC0) is shift larger to unreasonable value, this bit will be set and to be an indicate that clock frequency is inaccuracy.
N     * |        |          |Once this bit is set to 1, the auto trim operation stopped and FREQSEL(SYS_IRCTCL0[1:0]) will be cleared to 00 by hardware automatically if CESTOPEN(SYS_IRCTCTL0[8]) is set to 1.
N     * |        |          |If this bit is set and CLKEIEN(SYS_IRCTIEN0[2]) is high, an interrupt will be triggered to notify the clock frequency is inaccuracy.
N     * |        |          |Write 1 to clear this to 0.
N     * |        |          |0 = Clock frequency is accuracy.
N     * |        |          |1 = Clock frequency is inaccuracy.
N     * |[8]     |FREQLOCK1 |HIRC1 Frequency Lock Status
N     * |        |          |This bit indicates the HIRC1 frequency is locked.
N     * |        |          |This is a status bit and doesn not trigger any interrupt.
N     * |        |          |0 = The internal high-speed RC oscillator 1 frequency does not lock at 48 MHz yet.
N     * |        |          |1 = The internal high-speed RC oscillator 1 frequency locked at 48 MHz.
N     * |[9]     |TFAILIF1  |HIRC1 Trim Failure Interrupt Status
N     * |        |          |This bit indicates that HIRC1 trim value update limitation count reached and the HIRC1 clock frequency still doesn not be locked
N     * |        |          |Once this bit is set, the auto trim operation stopped and FREQSEL(SYS_iRCTCTL1[1:0]) will be cleared to 00 by hardware automatically.
N     * |        |          |If this bit is set and TFAILIEN(SYS_IRCTIEN1[1]) is high, an interrupt will be triggered to notify that HIRC1 trim value update limitation count was reached.
N     * |        |          |Write 1 to clear this to 0.
N     * |        |          |0 = HIRC1 trim value update limitation count does not reach.
N     * |        |          |1 = HIRC1 trim value update limitation count reached and frequency still not locked.
N     * |[10]    |CLKERRIF1 |HIRC1 Clock Error Interrupt Status
N     * |        |          |When the frequency of 48 MHz internal high speed RC oscillator 1 (HIRC1) is shift larger to unreasonable value, this bit will be set and to be an indicate that clock frequency is inaccuracy.
N     * |        |          |Once this bit is set to 1, the auto trim operation stopped and FREQSEL(SYS_IRCTCL1[1:0]) will be cleared to 00 by hardware automatically if CESTOPEN(SYS_IRCTCTL1[8]) is set to 1.
N     * |        |          |If this bit is set and CLKEIEN(SYS_IRCTIEN1[2]) is high, an interrupt will be triggered to notify the clock frequency is inaccuracy.
N     * |        |          |Write 1 to clear this to 0.
N     * |        |          |0 = HIRC1 Clock frequency is accuracy.
N     * |        |          |1 = HIRC1 Clock frequency is inaccuracy.
N     * @var SYS_T::IRCTCTL1
N     * Offset: 0x90  HIRC1 Trim Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |FREQSEL   |Trim Frequency Selection
N     * |        |          |This field indicates the target frequency of internal high speed RC oscillator 1 (HIRC 1) auto trim.
N     * |        |          |During auto trim operation, if clock error detected with CESTOPEN(SYS_IRCTCTL1[8]) is set to 1 or trim retry limitation count reached, this field will be cleared to 00 automatically.
N     * |        |          |00 = Disable HIRC1 auto trim function.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = Enable HIRC1 auto trim function and trim HIRC to 48 MHz.
N     * |        |          |11 = Reserved.
N     * |[5:4]   |LOOPSEL   |Trim Calculation Loop Selection
N     * |        |          |This field defines that trim value calculation is based on how many clocks of reference clock.
N     * |        |          |00 = Trim value calculation is based on average difference in 4 clocks of reference clock.
N     * |        |          |01 = Trim value calculation is based on average difference in 8 clocks of reference clock.
N     * |        |          |10 = Trim value calculation is based on average difference in 16 clocks of reference clock.
N     * |        |          |11 = Trim value calculation is based on average difference in 32 clocks of reference clock.
N     * |        |          |Note: For example, if LOOPSEL is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 clocks of reference clock.
N     * |[7:6]   |RETRYCNT  |Trim Value Update Limitation Count
N     * |        |          |This field defines that how many times the auto trim circuit will try to update the HIRC1 trim value before the frequency of HIRC1 locked.
N     * |        |          |Once the HIRC1 locked, the internal trim value update counter will be reset.
N     * |        |          |If the trim value update counter reached this limitation value and frequency of HIRC1 still doesnu2019t lock, the auto trim operation will be disabled and FREQSEL(SYS_IRCTCTL1[1:0]) will be cleared to 00.
N     * |        |          |00 = Trim retry count limitation is 64 loops.
N     * |        |          |01 = Trim retry count limitation is 128 loops.
N     * |        |          |10 = Trim retry count limitation is 256 loops.
N     * |        |          |11 = Trim retry count limitation is 512 loops.
N     * |[8]     |CESTOPEN  |Clock Error Stop Enable Bit
N     * |        |          |0 = The trim operation is keep going if clock is inaccuracy.
N     * |        |          |1 = The trim operation is stopped if clock is inaccuracy.
N     * |[10]    |REFCKSEL  |Reference Clock Selection
N     * |        |          |0 = HIRC trim reference clock is from LXT (32.768 kHz).
N     * |        |          |1 = HIRC trim reference clock is from internal USB synchronous mode.
N     * @var SYS_T::MODCTL
N     * Offset: 0xC0  Modulation Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |MODEN     |Modulation Function Enable Bit
N     * |        |          |This bit enables modulation funcion by modulating with PWM channel output and UART1_TXD.
N     * |        |          |0 = Modulation Function Disabled.
N     * |        |          |1 = Modulation Function Enabled.
N     * |[1]     |MODH      |Modulation at Data High
N     * |        |          |Select modulation pulse(PWM) at UART1_TXD high or low.
N     * |        |          |0 = Modulation pulse at UART1_TXD low.
N     * |        |          |1 = Modulation pulse at UART1_TXD high.
N     * |[6:4]   |MODPWMSEL |PWM0 Channel Select for Modulation
N     * |        |          |Select the PWM0 channel to modulate with the UART1_TXD.
N     * |        |          |000 = PWM0 channel 0 modulate with UART1_TXD.
N     * |        |          |001 = PWM0 channel 1 modulate with UART1_TXD.
N     * |        |          |010 = PWM0 channel 2 modulate with UART1_TXD.
N     * |        |          |011 = PWM0 channel 3 modulete with UART1_TXD.
N     * |        |          |Others = Reserved.
N     * |        |          |Note: This bis is valid while MODEN (SYS_MODCTL[0]) is set to 1.
N     * @var SYS_T::SRAM_BISTCTL
N     * Offset: 0xD0  System SRAM BIST Test Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SRBIST    |SRAM BIST Enable Bit (Write Protect)
N     * |        |          |This bit enables BIST test for SRAM located in address 0x2000_0000~0x2000_4FFF
N     * |        |          |0 = System SRAM BIST Disabled.
N     * |        |          |1 = System SRAM BIST Enabled.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[2]     |CRBIST    |CACHE BIST Enable Bit (Write Protect)
N     * |        |          |This bit enables BIST test for CACHE RAM.
N     * |        |          |0 = System CACHE BIST Disabled.
N     * |        |          |1 = System CACHE BIST Enabled.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[4]     |USBBIST   |USB BIST Enable Bit (Write Protect)
N     * |        |          |This bit enables BIST test for USB RAM.
N     * |        |          |0 = System USB BIST Disabled.
N     * |        |          |1 = System USB BIST Enabled.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * @var SYS_T::SRAM_BISTSTS
N     * Offset: 0xD4  System SRAM BIST Test Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SRBISTEF  |System SRAM BIST Fail Flag
N     * |        |          |0 = System SRAM BIST test pass.
N     * |        |          |1 = System SRAM BIST test fail.
N     * |[2]     |CRBISTEF  |CACHE SRAM BIST Fail Flag
N     * |        |          |0 = System CACHE RAM BIST test pass.
N     * |        |          |1 = System CACHE RAM BIST test fail.
N     * |[4]     |USBBEF    |USB SRAM BIST Fail Flag
N     * |        |          |0 = USB SRAM BIST test pass.
N     * |        |          |1 = USB SRAM BIST test fail.
N     * |[16]    |SRBEND    |SRAM BIST Test Finish
N     * |        |          |0 = System SRAM BIST active.
N     * |        |          |1 = System SRAM BIST finish.
N     * |[18]    |CRBEND    |CACHE SRAM BIST Test Finish
N     * |        |          |0 = System CACHE RAM BIST is active.
N     * |        |          |1 = System CACHE RAM BIST test finish.
N     * |[20]    |USBBEND   |USB SRAM BIST Test Finish
N     * |        |          |0 = USB SRAM BIST is active.
N     * |        |          |1 = USB SRAM BIST test finish.
N     * @var SYS_T::REGLCTL
N     * Offset: 0x100  Register Lock Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |REGLCTL   |Register Lock Control Code
N     * |        |          |Write operation:
N     * |        |          |Some registers have write-protection function.
N     * |        |          |Writing these registers have to disable the protected function by writing the sequence value "59h", "16h", "88h" to this field.
N     * |        |          |After this sequence is completed, the REGLCTL bit will be set to 1 and write-protection registers can be normal write.
N     * |        |          |Read operation:
N     * |        |          |0 = Write-protection Enabled for writing protected registers. Any write to the protected register is ignored.
N     * |        |          |1 = Write-protection Disabled for writing protected registers.
N     * @var SYS_T::TSOFFSET
N     * Offset: 0x114  Temperature Sensor Offset Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |VTEMP     |Temperature Sensor Offset Value
N     * |        |          |This field reflects temperature sensor output voltage offset at 25 Celsius degree from flash.
N     */
N
N    __I  uint32_t PDID;                  /*!< [0x0000] Part Device Identification Number Register                       */
X    volatile const  uint32_t PDID;                   
N    __IO uint32_t RSTSTS;                /*!< [0x0004] System Reset Status Register                                     */
X    volatile uint32_t RSTSTS;                 
N    __IO uint32_t IPRST0;                /*!< [0x0008] Peripheral  Reset Control Register 0                             */
X    volatile uint32_t IPRST0;                 
N    __IO uint32_t IPRST1;                /*!< [0x000c] Peripheral Reset Control Register 1                              */
X    volatile uint32_t IPRST1;                 
N    __IO uint32_t IPRST2;                /*!< [0x0010] Peripheral Reset Control Register 2                              */
X    volatile uint32_t IPRST2;                 
N    __I  uint32_t RESERVE0[1];
X    volatile const  uint32_t RESERVE0[1];
N    __IO uint32_t BODCTL;                /*!< [0x0018] Brown-out Detector Control Register                              */
X    volatile uint32_t BODCTL;                 
N    __IO uint32_t IVSCTL;                /*!< [0x001c] Internal Voltage Source Control Register                         */
X    volatile uint32_t IVSCTL;                 
N    __I  uint32_t RESERVE1[1];
X    volatile const  uint32_t RESERVE1[1];
N    __IO uint32_t PORCTL;                /*!< [0x0024] Power-on Reset Controller Register                               */
X    volatile uint32_t PORCTL;                 
N    __IO uint32_t VREFCTL;               /*!< [0x0028] VREF Control Register                                            */
X    volatile uint32_t VREFCTL;                
N    __I  uint32_t RESERVE2[1];
X    volatile const  uint32_t RESERVE2[1];
N    __IO uint32_t GPA_MFPL;              /*!< [0x0030] GPIOA Low Byte Multiple Function Control Register                */
X    volatile uint32_t GPA_MFPL;               
N    __IO uint32_t GPA_MFPH;              /*!< [0x0034] GPIOA High Byte Multiple Function Control Register               */
X    volatile uint32_t GPA_MFPH;               
N    __IO uint32_t GPB_MFPL;              /*!< [0x0038] GPIOB Low Byte Multiple Function Control Register                */
X    volatile uint32_t GPB_MFPL;               
N    __IO uint32_t GPB_MFPH;              /*!< [0x003c] GPIOB High Byte Multiple Function Control Register               */
X    volatile uint32_t GPB_MFPH;               
N    __IO uint32_t GPC_MFPL;              /*!< [0x0040] GPIOC Low Byte Multiple Function Control Register                */
X    volatile uint32_t GPC_MFPL;               
N    __IO uint32_t GPC_MFPH;              /*!< [0x0044] GPIOC High Byte Multiple Function Control Register               */
X    volatile uint32_t GPC_MFPH;               
N    __IO uint32_t GPD_MFPL;              /*!< [0x0048] GPIOD Low Byte Multiple Function Control Register                */
X    volatile uint32_t GPD_MFPL;               
N    __IO uint32_t GPD_MFPH;              /*!< [0x004c] GPIOD High Byte Multiple Function Control Register               */
X    volatile uint32_t GPD_MFPH;               
N    __IO uint32_t GPE_MFPL;              /*!< [0x0050] GPIOE Low Byte Multiple Function Control Register                */
X    volatile uint32_t GPE_MFPL;               
N    __IO uint32_t GPE_MFPH;              /*!< [0x0054] GPIOE High Byte Multiple Function Control Register               */
X    volatile uint32_t GPE_MFPH;               
N    __IO uint32_t GPF_MFPL;              /*!< [0x0058] GPIOF Low Byte Multiple Function Control Register                */
X    volatile uint32_t GPF_MFPL;               
N    __I  uint32_t RESERVE3[9];
X    volatile const  uint32_t RESERVE3[9];
N    __IO uint32_t IRCTCTL0;              /*!< [0x0080] HIRC0 Trim Control Register                                      */
X    volatile uint32_t IRCTCTL0;               
N    __IO uint32_t IRCTIEN;               /*!< [0x0084] HIRC Trim Interrupt Enable Register                              */
X    volatile uint32_t IRCTIEN;                
N    __IO uint32_t IRCTISTS;              /*!< [0x0088] HIRC Trim Interrupt Status Register                              */
X    volatile uint32_t IRCTISTS;               
N    __I  uint32_t RESERVE4[1];
X    volatile const  uint32_t RESERVE4[1];
N    __IO uint32_t IRCTCTL1;              /*!< [0x0090] HIRC1 Trim Control Register                                      */
X    volatile uint32_t IRCTCTL1;               
N    __I  uint32_t RESERVE5[11];
X    volatile const  uint32_t RESERVE5[11];
N    __IO uint32_t MODCTL;                /*!< [0x00c0] Modulation Control Register                                      */
X    volatile uint32_t MODCTL;                 
N    __I  uint32_t RESERVE6[3];
X    volatile const  uint32_t RESERVE6[3];
N    __IO uint32_t SRAM_BISTCTL;          /*!< [0x00d0] System SRAM BIST Test Control Register                           */
X    volatile uint32_t SRAM_BISTCTL;           
N    __I  uint32_t SRAM_BISTSTS;          /*!< [0x00d4] System SRAM BIST Test Status Register                            */
X    volatile const  uint32_t SRAM_BISTSTS;           
N    __I  uint32_t RESERVE7[10];
X    volatile const  uint32_t RESERVE7[10];
N    __IO uint32_t REGLCTL;               /*!< [0x0100] Register Lock Control Register                                   */
X    volatile uint32_t REGLCTL;                
N    __I  uint32_t RESERVE8[4];
X    volatile const  uint32_t RESERVE8[4];
N    __I  uint32_t TSOFFSET;              /*!< [0x0114] Temperature Sensor Offset Register                               */
X    volatile const  uint32_t TSOFFSET;               
N
N
N} SYS_T;
N
N/**
N    @addtogroup SYS_CONST SYS Bit Field Definition
N    Constant Definitions for SYS Controller
N@{ */
N
N#define SYS_PDID_PDID_Pos                (0)                                               /*!< SYS_T::PDID: PDID Position             */
N#define SYS_PDID_PDID_Msk                (0xfffffffful << SYS_PDID_PDID_Pos)               /*!< SYS_T::PDID: PDID Mask                 */
N
N#define SYS_RSTSTS_PORF_Pos              (0)                                               /*!< SYS_T::RSTSTS: PORF Position           */
N#define SYS_RSTSTS_PORF_Msk              (0x1ul << SYS_RSTSTS_PORF_Pos)                    /*!< SYS_T::RSTSTS: PORF Mask               */
N
N#define SYS_RSTSTS_PINRF_Pos             (1)                                               /*!< SYS_T::RSTSTS: PINRF Position          */
N#define SYS_RSTSTS_PINRF_Msk             (0x1ul << SYS_RSTSTS_PINRF_Pos)                   /*!< SYS_T::RSTSTS: PINRF Mask              */
N
N#define SYS_RSTSTS_WDTRF_Pos             (2)                                               /*!< SYS_T::RSTSTS: WDTRF Position          */
N#define SYS_RSTSTS_WDTRF_Msk             (0x1ul << SYS_RSTSTS_WDTRF_Pos)                   /*!< SYS_T::RSTSTS: WDTRF Mask              */
N
N#define SYS_RSTSTS_LVRF_Pos              (3)                                               /*!< SYS_T::RSTSTS: LVRF Position           */
N#define SYS_RSTSTS_LVRF_Msk              (0x1ul << SYS_RSTSTS_LVRF_Pos)                    /*!< SYS_T::RSTSTS: LVRF Mask               */
N
N#define SYS_RSTSTS_BODRF_Pos             (4)                                               /*!< SYS_T::RSTSTS: BODRF Position          */
N#define SYS_RSTSTS_BODRF_Msk             (0x1ul << SYS_RSTSTS_BODRF_Pos)                   /*!< SYS_T::RSTSTS: BODRF Mask              */
N
N#define SYS_RSTSTS_MCURF_Pos             (5)                                               /*!< SYS_T::RSTSTS: MCURF Position          */
N#define SYS_RSTSTS_MCURF_Msk             (0x1ul << SYS_RSTSTS_MCURF_Pos)                   /*!< SYS_T::RSTSTS: MCURF Mask              */
N
N#define SYS_RSTSTS_CPURF_Pos             (7)                                               /*!< SYS_T::RSTSTS: CPURF Position          */
N#define SYS_RSTSTS_CPURF_Msk             (0x1ul << SYS_RSTSTS_CPURF_Pos)                   /*!< SYS_T::RSTSTS: CPURF Mask              */
N
N#define SYS_RSTSTS_CPULKRF_Pos           (8)                                               /*!< SYS_T::RSTSTS: CPULKRF Position        */
N#define SYS_RSTSTS_CPULKRF_Msk           (0x1ul << SYS_RSTSTS_CPULKRF_Pos)                 /*!< SYS_T::RSTSTS: CPULKRF Mask            */
N
N#define SYS_IPRST0_CHIPRST_Pos           (0)                                               /*!< SYS_T::IPRST0: CHIPRST Position        */
N#define SYS_IPRST0_CHIPRST_Msk           (0x1ul << SYS_IPRST0_CHIPRST_Pos)                 /*!< SYS_T::IPRST0: CHIPRST Mask            */
N
N#define SYS_IPRST0_CPURST_Pos            (1)                                               /*!< SYS_T::IPRST0: CPURST Position         */
N#define SYS_IPRST0_CPURST_Msk            (0x1ul << SYS_IPRST0_CPURST_Pos)                  /*!< SYS_T::IPRST0: CPURST Mask             */
N
N#define SYS_IPRST0_PDMARST_Pos           (2)                                               /*!< SYS_T::IPRST0: PDMARST Position        */
N#define SYS_IPRST0_PDMARST_Msk           (0x1ul << SYS_IPRST0_PDMARST_Pos)                 /*!< SYS_T::IPRST0: PDMARST Mask            */
N
N#define SYS_IPRST0_EBIRST_Pos            (3)                                               /*!< SYS_T::IPRST0: EBIRST Position         */
N#define SYS_IPRST0_EBIRST_Msk            (0x1ul << SYS_IPRST0_EBIRST_Pos)                  /*!< SYS_T::IPRST0: EBIRST Mask             */
N
N#define SYS_IPRST0_HDIVRST_Pos           (4)                                               /*!< SYS_T::IPRST0: HDIVRST Position        */
N#define SYS_IPRST0_HDIVRST_Msk           (0x1ul << SYS_IPRST0_HDIVRST_Pos)                 /*!< SYS_T::IPRST0: HDIVRST Mask            */
N
N#define SYS_IPRST0_CRCRST_Pos            (7)                                               /*!< SYS_T::IPRST0: CRCRST Position         */
N#define SYS_IPRST0_CRCRST_Msk            (0x1ul << SYS_IPRST0_CRCRST_Pos)                  /*!< SYS_T::IPRST0: CRCRST Mask             */
N
N#define SYS_IPRST1_GPIORST_Pos           (1)                                               /*!< SYS_T::IPRST1: GPIORST Position        */
N#define SYS_IPRST1_GPIORST_Msk           (0x1ul << SYS_IPRST1_GPIORST_Pos)                 /*!< SYS_T::IPRST1: GPIORST Mask            */
N
N#define SYS_IPRST1_TMR0RST_Pos           (2)                                               /*!< SYS_T::IPRST1: TMR0RST Position        */
N#define SYS_IPRST1_TMR0RST_Msk           (0x1ul << SYS_IPRST1_TMR0RST_Pos)                 /*!< SYS_T::IPRST1: TMR0RST Mask            */
N
N#define SYS_IPRST1_TMR1RST_Pos           (3)                                               /*!< SYS_T::IPRST1: TMR1RST Position        */
N#define SYS_IPRST1_TMR1RST_Msk           (0x1ul << SYS_IPRST1_TMR1RST_Pos)                 /*!< SYS_T::IPRST1: TMR1RST Mask            */
N
N#define SYS_IPRST1_TMR2RST_Pos           (4)                                               /*!< SYS_T::IPRST1: TMR2RST Position        */
N#define SYS_IPRST1_TMR2RST_Msk           (0x1ul << SYS_IPRST1_TMR2RST_Pos)                 /*!< SYS_T::IPRST1: TMR2RST Mask            */
N
N#define SYS_IPRST1_TMR3RST_Pos           (5)                                               /*!< SYS_T::IPRST1: TMR3RST Position        */
N#define SYS_IPRST1_TMR3RST_Msk           (0x1ul << SYS_IPRST1_TMR3RST_Pos)                 /*!< SYS_T::IPRST1: TMR3RST Mask            */
N
N#define SYS_IPRST1_I2C0RST_Pos           (8)                                               /*!< SYS_T::IPRST1: I2C0RST Position        */
N#define SYS_IPRST1_I2C0RST_Msk           (0x1ul << SYS_IPRST1_I2C0RST_Pos)                 /*!< SYS_T::IPRST1: I2C0RST Mask            */
N
N#define SYS_IPRST1_I2C1RST_Pos           (9)                                               /*!< SYS_T::IPRST1: I2C1RST Position        */
N#define SYS_IPRST1_I2C1RST_Msk           (0x1ul << SYS_IPRST1_I2C1RST_Pos)                 /*!< SYS_T::IPRST1: I2C1RST Mask            */
N
N#define SYS_IPRST1_SPI0RST_Pos           (12)                                              /*!< SYS_T::IPRST1: SPI0RST Position        */
N#define SYS_IPRST1_SPI0RST_Msk           (0x1ul << SYS_IPRST1_SPI0RST_Pos)                 /*!< SYS_T::IPRST1: SPI0RST Mask            */
N
N#define SYS_IPRST1_SPI1RST_Pos           (13)                                              /*!< SYS_T::IPRST1: SPI1RST Position        */
N#define SYS_IPRST1_SPI1RST_Msk           (0x1ul << SYS_IPRST1_SPI1RST_Pos)                 /*!< SYS_T::IPRST1: SPI1RST Mask            */
N
N#define SYS_IPRST1_UART0RST_Pos          (16)                                              /*!< SYS_T::IPRST1: UART0RST Position       */
N#define SYS_IPRST1_UART0RST_Msk          (0x1ul << SYS_IPRST1_UART0RST_Pos)                /*!< SYS_T::IPRST1: UART0RST Mask           */
N
N#define SYS_IPRST1_UART1RST_Pos          (17)                                              /*!< SYS_T::IPRST1: UART1RST Position       */
N#define SYS_IPRST1_UART1RST_Msk          (0x1ul << SYS_IPRST1_UART1RST_Pos)                /*!< SYS_T::IPRST1: UART1RST Mask           */
N
N#define SYS_IPRST1_UART2RST_Pos          (18)                                              /*!< SYS_T::IPRST1: UART2RST Position       */
N#define SYS_IPRST1_UART2RST_Msk          (0x1ul << SYS_IPRST1_UART2RST_Pos)                /*!< SYS_T::IPRST1: UART2RST Mask           */
N
N#define SYS_IPRST1_PWM0RST_Pos           (20)                                              /*!< SYS_T::IPRST1: PWM0RST Position        */
N#define SYS_IPRST1_PWM0RST_Msk           (0x1ul << SYS_IPRST1_PWM0RST_Pos)                 /*!< SYS_T::IPRST1: PWM0RST Mask            */
N
N#define SYS_IPRST1_PWM1RST_Pos           (21)                                              /*!< SYS_T::IPRST1: PWM1RST Position        */
N#define SYS_IPRST1_PWM1RST_Msk           (0x1ul << SYS_IPRST1_PWM1RST_Pos)                 /*!< SYS_T::IPRST1: PWM1RST Mask            */
N
N#define SYS_IPRST1_ACMP01RST_Pos         (22)                                              /*!< SYS_T::IPRST1: ACMP01RST Position      */
N#define SYS_IPRST1_ACMP01RST_Msk         (0x1ul << SYS_IPRST1_ACMP01RST_Pos)               /*!< SYS_T::IPRST1: ACMP01RST Mask          */
N
N#define SYS_IPRST1_USBDRST_Pos           (27)                                              /*!< SYS_T::IPRST1: USBDRST Position        */
N#define SYS_IPRST1_USBDRST_Msk           (0x1ul << SYS_IPRST1_USBDRST_Pos)                 /*!< SYS_T::IPRST1: USBDRST Mask            */
N
N#define SYS_IPRST1_ADCRST_Pos            (28)                                              /*!< SYS_T::IPRST1: ADCRST Position         */
N#define SYS_IPRST1_ADCRST_Msk            (0x1ul << SYS_IPRST1_ADCRST_Pos)                  /*!< SYS_T::IPRST1: ADCRST Mask             */
N
N#define SYS_IPRST2_SC0RST_Pos            (0)                                               /*!< SYS_T::IPRST2: SC0RST Position         */
N#define SYS_IPRST2_SC0RST_Msk            (0x1ul << SYS_IPRST2_SC0RST_Pos)                  /*!< SYS_T::IPRST2: SC0RST Mask             */
N
N#define SYS_IPRST2_SC1RST_Pos            (1)                                               /*!< SYS_T::IPRST2: SC1RST Position         */
N#define SYS_IPRST2_SC1RST_Msk            (0x1ul << SYS_IPRST2_SC1RST_Pos)                  /*!< SYS_T::IPRST2: SC1RST Mask             */
N
N#define SYS_IPRST2_USCI0RST_Pos          (8)                                               /*!< SYS_T::IPRST2: USCI0RST Position       */
N#define SYS_IPRST2_USCI0RST_Msk          (0x1ul << SYS_IPRST2_USCI0RST_Pos)                /*!< SYS_T::IPRST2: USCI0RST Mask           */
N
N#define SYS_IPRST2_USCI1RST_Pos          (9)                                               /*!< SYS_T::IPRST2: USCI1RST Position       */
N#define SYS_IPRST2_USCI1RST_Msk          (0x1ul << SYS_IPRST2_USCI1RST_Pos)                /*!< SYS_T::IPRST2: USCI1RST Mask           */
N
N#define SYS_IPRST2_USCI2RST_Pos          (10)                                              /*!< SYS_T::IPRST2: USCI2RST Position       */
N#define SYS_IPRST2_USCI2RST_Msk          (0x1ul << SYS_IPRST2_USCI2RST_Pos)                /*!< SYS_T::IPRST2: USCI2RST Mask           */
N
N#define SYS_BODCTL_BODEN_Pos             (0)                                               /*!< SYS_T::BODCTL: BODEN Position          */
N#define SYS_BODCTL_BODEN_Msk             (0x1ul << SYS_BODCTL_BODEN_Pos)                   /*!< SYS_T::BODCTL: BODEN Mask              */
N
N#define SYS_BODCTL_BODVL_Pos             (1)                                               /*!< SYS_T::BODCTL: BODVL Position          */
N#define SYS_BODCTL_BODVL_Msk             (0x3ul << SYS_BODCTL_BODVL_Pos)                   /*!< SYS_T::BODCTL: BODVL Mask              */
N
N#define SYS_BODCTL_BODRSTEN_Pos          (3)                                               /*!< SYS_T::BODCTL: BODRSTEN Position       */
N#define SYS_BODCTL_BODRSTEN_Msk          (0x1ul << SYS_BODCTL_BODRSTEN_Pos)                /*!< SYS_T::BODCTL: BODRSTEN Mask           */
N
N#define SYS_BODCTL_BODIF_Pos             (4)                                               /*!< SYS_T::BODCTL: BODIF Position          */
N#define SYS_BODCTL_BODIF_Msk             (0x1ul << SYS_BODCTL_BODIF_Pos)                   /*!< SYS_T::BODCTL: BODIF Mask              */
N
N#define SYS_BODCTL_BODLPM_Pos            (5)                                               /*!< SYS_T::BODCTL: BODLPM Position         */
N#define SYS_BODCTL_BODLPM_Msk            (0x1ul << SYS_BODCTL_BODLPM_Pos)                  /*!< SYS_T::BODCTL: BODLPM Mask             */
N
N#define SYS_BODCTL_BODOUT_Pos            (6)                                               /*!< SYS_T::BODCTL: BODOUT Position         */
N#define SYS_BODCTL_BODOUT_Msk            (0x1ul << SYS_BODCTL_BODOUT_Pos)                  /*!< SYS_T::BODCTL: BODOUT Mask             */
N
N#define SYS_BODCTL_LVREN_Pos             (7)                                               /*!< SYS_T::BODCTL: LVREN Position          */
N#define SYS_BODCTL_LVREN_Msk             (0x1ul << SYS_BODCTL_LVREN_Pos)                   /*!< SYS_T::BODCTL: LVREN Mask              */
N
N#define SYS_BODCTL_BODDGSEL_Pos          (8)                                               /*!< SYS_T::BODCTL: BODDGSEL Position       */
N#define SYS_BODCTL_BODDGSEL_Msk          (0x7ul << SYS_BODCTL_BODDGSEL_Pos)                /*!< SYS_T::BODCTL: BODDGSEL Mask           */
N
N#define SYS_BODCTL_LVRDGSEL_Pos          (12)                                              /*!< SYS_T::BODCTL: LVRDGSEL Position       */
N#define SYS_BODCTL_LVRDGSEL_Msk          (0x7ul << SYS_BODCTL_LVRDGSEL_Pos)                /*!< SYS_T::BODCTL: LVRDGSEL Mask           */
N
N#define SYS_BODCTL_EBODEN_Pos            (16)                                              /*!< SYS_T::BODCTL: EBODEN Position         */
N#define SYS_BODCTL_EBODEN_Msk            (0x1ul << SYS_BODCTL_EBODEN_Pos)                  /*!< SYS_T::BODCTL: EBODEN Mask             */
N
N#define SYS_BODCTL_EBODPINSEL_Pos        (17)                                              /*!< SYS_T::BODCTL: EBODPINSEL Position     */
N#define SYS_BODCTL_EBODPINSEL_Msk        (0x1ul << SYS_BODCTL_EBODPINSEL_Pos)              /*!< SYS_T::BODCTL: EBODPINSEL Mask         */
N
N#define SYS_BODCTL_EBODIEN_Pos           (18)                                              /*!< SYS_T::BODCTL: EBODIEN Position        */
N#define SYS_BODCTL_EBODIEN_Msk           (0x1ul << SYS_BODCTL_EBODIEN_Pos)                 /*!< SYS_T::BODCTL: EBODIEN Mask            */
N
N#define SYS_BODCTL_EBODIF_Pos            (19)                                              /*!< SYS_T::BODCTL: EBODIF Position         */
N#define SYS_BODCTL_EBODIF_Msk            (0x1ul << SYS_BODCTL_EBODIF_Pos)                  /*!< SYS_T::BODCTL: EBODIF Mask             */
N
N#define SYS_BODCTL_EBODDTSEL_Pos         (20)                                              /*!< SYS_T::BODCTL: EBODDTSEL Position      */
N#define SYS_BODCTL_EBODDTSEL_Msk         (0x3ul << SYS_BODCTL_EBODDTSEL_Pos)               /*!< SYS_T::BODCTL: EBODDTSEL Mask          */
N
N#define SYS_BODCTL_EBODBGSEL_Pos         (22)                                              /*!< SYS_T::BODCTL: EBODBGSEL Position      */
N#define SYS_BODCTL_EBODBGSEL_Msk         (0x3ul << SYS_BODCTL_EBODBGSEL_Pos)               /*!< SYS_T::BODCTL: EBODBGSEL Mask          */
N
N#define SYS_BODCTL_EBODOUT_Pos           (24)                                              /*!< SYS_T::BODCTL: EBODOUT Position        */
N#define SYS_BODCTL_EBODOUT_Msk           (0x1ul << SYS_BODCTL_EBODOUT_Pos)                 /*!< SYS_T::BODCTL: EBODOUT Mask            */
N
N#define SYS_BODCTL_EBODDGSEL_Pos         (25)                                              /*!< SYS_T::BODCTL: EBODDGSEL Position      */
N#define SYS_BODCTL_EBODDGSEL_Msk         (0x7ul << SYS_BODCTL_EBODDGSEL_Pos)               /*!< SYS_T::BODCTL: EBODDGSEL Mask          */
N
N#define SYS_IVSCTL_VTEMPEN_Pos           (0)                                               /*!< SYS_T::IVSCTL: VTEMPEN Position        */
N#define SYS_IVSCTL_VTEMPEN_Msk           (0x1ul << SYS_IVSCTL_VTEMPEN_Pos)                 /*!< SYS_T::IVSCTL: VTEMPEN Mask            */
N
N#define SYS_IVSCTL_VBATUGEN_Pos          (1)                                               /*!< SYS_T::IVSCTL: VBATUGEN Position       */
N#define SYS_IVSCTL_VBATUGEN_Msk          (0x1ul << SYS_IVSCTL_VBATUGEN_Pos)                /*!< SYS_T::IVSCTL: VBATUGEN Mask           */
N
N#define SYS_PORCTL_POROFF_Pos            (0)                                               /*!< SYS_T::PORCTL: POROFF Position         */
N#define SYS_PORCTL_POROFF_Msk            (0xfffful << SYS_PORCTL_POROFF_Pos)               /*!< SYS_T::PORCTL: POROFF Mask             */
N
N#define SYS_VREFCTL_VREFCTL_Pos          (0)                                               /*!< SYS_T::VREFCTL: VREFCTL Position       */
N#define SYS_VREFCTL_VREFCTL_Msk          (0x1ful << SYS_VREFCTL_VREFCTL_Pos)               /*!< SYS_T::VREFCTL: VREFCTL Mask           */
N
N#define SYS_GPA_MFPL_PA0MFP_Pos          (0)                                               /*!< SYS_T::GPA_MFPL: PA0MFP Position       */
N#define SYS_GPA_MFPL_PA0MFP_Msk          (0xful << SYS_GPA_MFPL_PA0MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA0MFP Mask           */
N
N#define SYS_GPA_MFPL_PA1MFP_Pos          (4)                                               /*!< SYS_T::GPA_MFPL: PA1MFP Position       */
N#define SYS_GPA_MFPL_PA1MFP_Msk          (0xful << SYS_GPA_MFPL_PA1MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA1MFP Mask           */
N
N#define SYS_GPA_MFPL_PA2MFP_Pos          (8)                                               /*!< SYS_T::GPA_MFPL: PA2MFP Position       */
N#define SYS_GPA_MFPL_PA2MFP_Msk          (0xful << SYS_GPA_MFPL_PA2MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA2MFP Mask           */
N
N#define SYS_GPA_MFPL_PA3MFP_Pos          (12)                                              /*!< SYS_T::GPA_MFPL: PA3MFP Position       */
N#define SYS_GPA_MFPL_PA3MFP_Msk          (0xful << SYS_GPA_MFPL_PA3MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA3MFP Mask           */
N
N#define SYS_GPA_MFPL_PA4MFP_Pos          (16)                                              /*!< SYS_T::GPA_MFPL: PA4MFP Position       */
N#define SYS_GPA_MFPL_PA4MFP_Msk          (0xful << SYS_GPA_MFPL_PA4MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA4MFP Mask           */
N
N#define SYS_GPA_MFPL_PA5MFP_Pos          (20)                                              /*!< SYS_T::GPA_MFPL: PA5MFP Position       */
N#define SYS_GPA_MFPL_PA5MFP_Msk          (0xful << SYS_GPA_MFPL_PA5MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA5MFP Mask           */
N
N#define SYS_GPA_MFPL_PA6MFP_Pos          (24)                                              /*!< SYS_T::GPA_MFPL: PA6MFP Position       */
N#define SYS_GPA_MFPL_PA6MFP_Msk          (0xful << SYS_GPA_MFPL_PA6MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA6MFP Mask           */
N
N#define SYS_GPA_MFPL_PA7MFP_Pos          (28)                                              /*!< SYS_T::GPA_MFPL: PA7MFP Position       */
N#define SYS_GPA_MFPL_PA7MFP_Msk          (0xful << SYS_GPA_MFPL_PA7MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA7MFP Mask           */
N
N#define SYS_GPA_MFPH_PA8MFP_Pos          (0)                                               /*!< SYS_T::GPA_MFPH: PA8MFP Position       */
N#define SYS_GPA_MFPH_PA8MFP_Msk          (0xful << SYS_GPA_MFPH_PA8MFP_Pos)                /*!< SYS_T::GPA_MFPH: PA8MFP Mask           */
N
N#define SYS_GPA_MFPH_PA9MFP_Pos          (4)                                               /*!< SYS_T::GPA_MFPH: PA9MFP Position       */
N#define SYS_GPA_MFPH_PA9MFP_Msk          (0xful << SYS_GPA_MFPH_PA9MFP_Pos)                /*!< SYS_T::GPA_MFPH: PA9MFP Mask           */
N
N#define SYS_GPA_MFPH_PA10MFP_Pos         (8)                                               /*!< SYS_T::GPA_MFPH: PA10MFP Position      */
N#define SYS_GPA_MFPH_PA10MFP_Msk         (0xful << SYS_GPA_MFPH_PA10MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA10MFP Mask          */
N
N#define SYS_GPA_MFPH_PA11MFP_Pos         (12)                                              /*!< SYS_T::GPA_MFPH: PA11MFP Position      */
N#define SYS_GPA_MFPH_PA11MFP_Msk         (0xful << SYS_GPA_MFPH_PA11MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA11MFP Mask          */
N
N#define SYS_GPA_MFPH_PA12MFP_Pos         (16)                                              /*!< SYS_T::GPA_MFPH: PA12MFP Position      */
N#define SYS_GPA_MFPH_PA12MFP_Msk         (0xful << SYS_GPA_MFPH_PA12MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA12MFP Mask          */
N
N#define SYS_GPA_MFPH_PA13MFP_Pos         (20)                                              /*!< SYS_T::GPA_MFPH: PA13MFP Position      */
N#define SYS_GPA_MFPH_PA13MFP_Msk         (0xful << SYS_GPA_MFPH_PA13MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA13MFP Mask          */
N
N#define SYS_GPA_MFPH_PA14MFP_Pos         (24)                                              /*!< SYS_T::GPA_MFPH: PA14MFP Position      */
N#define SYS_GPA_MFPH_PA14MFP_Msk         (0xful << SYS_GPA_MFPH_PA14MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA14MFP Mask          */
N
N#define SYS_GPA_MFPH_PA15MFP_Pos         (28)                                              /*!< SYS_T::GPA_MFPH: PA15MFP Position      */
N#define SYS_GPA_MFPH_PA15MFP_Msk         (0xful << SYS_GPA_MFPH_PA15MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA15MFP Mask          */
N
N#define SYS_GPB_MFPL_PB0MFP_Pos          (0)                                               /*!< SYS_T::GPB_MFPL: PB0MFP Position       */
N#define SYS_GPB_MFPL_PB0MFP_Msk          (0xful << SYS_GPB_MFPL_PB0MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB0MFP Mask           */
N
N#define SYS_GPB_MFPL_PB1MFP_Pos          (4)                                               /*!< SYS_T::GPB_MFPL: PB1MFP Position       */
N#define SYS_GPB_MFPL_PB1MFP_Msk          (0xful << SYS_GPB_MFPL_PB1MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB1MFP Mask           */
N
N#define SYS_GPB_MFPL_PB2MFP_Pos          (8)                                               /*!< SYS_T::GPB_MFPL: PB2MFP Position       */
N#define SYS_GPB_MFPL_PB2MFP_Msk          (0xful << SYS_GPB_MFPL_PB2MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB2MFP Mask           */
N
N#define SYS_GPB_MFPL_PB3MFP_Pos          (12)                                              /*!< SYS_T::GPB_MFPL: PB3MFP Position       */
N#define SYS_GPB_MFPL_PB3MFP_Msk          (0xful << SYS_GPB_MFPL_PB3MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB3MFP Mask           */
N
N#define SYS_GPB_MFPL_PB4MFP_Pos          (16)                                              /*!< SYS_T::GPB_MFPL: PB4MFP Position       */
N#define SYS_GPB_MFPL_PB4MFP_Msk          (0xful << SYS_GPB_MFPL_PB4MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB4MFP Mask           */
N
N#define SYS_GPB_MFPL_PB5MFP_Pos          (20)                                              /*!< SYS_T::GPB_MFPL: PB5MFP Position       */
N#define SYS_GPB_MFPL_PB5MFP_Msk          (0xful << SYS_GPB_MFPL_PB5MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB5MFP Mask           */
N
N#define SYS_GPB_MFPL_PB6MFP_Pos          (24)                                              /*!< SYS_T::GPB_MFPL: PB6MFP Position       */
N#define SYS_GPB_MFPL_PB6MFP_Msk          (0xful << SYS_GPB_MFPL_PB6MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB6MFP Mask           */
N
N#define SYS_GPB_MFPL_PB7MFP_Pos          (28)                                              /*!< SYS_T::GPB_MFPL: PB7MFP Position       */
N#define SYS_GPB_MFPL_PB7MFP_Msk          (0xful << SYS_GPB_MFPL_PB7MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB7MFP Mask           */
N
N#define SYS_GPB_MFPH_PB8MFP_Pos          (0)                                               /*!< SYS_T::GPB_MFPH: PB8MFP Position       */
N#define SYS_GPB_MFPH_PB8MFP_Msk          (0xful << SYS_GPB_MFPH_PB8MFP_Pos)                /*!< SYS_T::GPB_MFPH: PB8MFP Mask           */
N
N#define SYS_GPB_MFPH_PB9MFP_Pos          (4)                                               /*!< SYS_T::GPB_MFPH: PB9MFP Position       */
N#define SYS_GPB_MFPH_PB9MFP_Msk          (0xful << SYS_GPB_MFPH_PB9MFP_Pos)                /*!< SYS_T::GPB_MFPH: PB9MFP Mask           */
N
N#define SYS_GPB_MFPH_PB10MFP_Pos         (8)                                               /*!< SYS_T::GPB_MFPH: PB10MFP Position      */
N#define SYS_GPB_MFPH_PB10MFP_Msk         (0xful << SYS_GPB_MFPH_PB10MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB10MFP Mask          */
N
N#define SYS_GPB_MFPH_PB11MFP_Pos         (12)                                              /*!< SYS_T::GPB_MFPH: PB11MFP Position      */
N#define SYS_GPB_MFPH_PB11MFP_Msk         (0xful << SYS_GPB_MFPH_PB11MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB11MFP Mask          */
N
N#define SYS_GPB_MFPH_PB12MFP_Pos         (16)                                              /*!< SYS_T::GPB_MFPH: PB12MFP Position      */
N#define SYS_GPB_MFPH_PB12MFP_Msk         (0xful << SYS_GPB_MFPH_PB12MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB12MFP Mask          */
N
N#define SYS_GPB_MFPH_PB13MFP_Pos         (20)                                              /*!< SYS_T::GPB_MFPH: PB13MFP Position      */
N#define SYS_GPB_MFPH_PB13MFP_Msk         (0xful << SYS_GPB_MFPH_PB13MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB13MFP Mask          */
N
N#define SYS_GPB_MFPH_PB14MFP_Pos         (24)                                              /*!< SYS_T::GPB_MFPH: PB14MFP Position      */
N#define SYS_GPB_MFPH_PB14MFP_Msk         (0xful << SYS_GPB_MFPH_PB14MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB14MFP Mask          */
N
N#define SYS_GPB_MFPH_PB15MFP_Pos         (28)                                              /*!< SYS_T::GPB_MFPH: PB15MFP Position      */
N#define SYS_GPB_MFPH_PB15MFP_Msk         (0xful << SYS_GPB_MFPH_PB15MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB15MFP Mask          */
N
N#define SYS_GPC_MFPL_PC0MFP_Pos          (0)                                               /*!< SYS_T::GPC_MFPL: PC0MFP Position       */
N#define SYS_GPC_MFPL_PC0MFP_Msk          (0xful << SYS_GPC_MFPL_PC0MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC0MFP Mask           */
N
N#define SYS_GPC_MFPL_PC1MFP_Pos          (4)                                               /*!< SYS_T::GPC_MFPL: PC1MFP Position       */
N#define SYS_GPC_MFPL_PC1MFP_Msk          (0xful << SYS_GPC_MFPL_PC1MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC1MFP Mask           */
N
N#define SYS_GPC_MFPL_PC2MFP_Pos          (8)                                               /*!< SYS_T::GPC_MFPL: PC2MFP Position       */
N#define SYS_GPC_MFPL_PC2MFP_Msk          (0xful << SYS_GPC_MFPL_PC2MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC2MFP Mask           */
N
N#define SYS_GPC_MFPL_PC3MFP_Pos          (12)                                              /*!< SYS_T::GPC_MFPL: PC3MFP Position       */
N#define SYS_GPC_MFPL_PC3MFP_Msk          (0xful << SYS_GPC_MFPL_PC3MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC3MFP Mask           */
N
N#define SYS_GPC_MFPL_PC4MFP_Pos          (16)                                              /*!< SYS_T::GPC_MFPL: PC4MFP Position       */
N#define SYS_GPC_MFPL_PC4MFP_Msk          (0xful << SYS_GPC_MFPL_PC4MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC4MFP Mask           */
N
N#define SYS_GPC_MFPL_PC5MFP_Pos          (20)                                              /*!< SYS_T::GPC_MFPL: PC5MFP Position       */
N#define SYS_GPC_MFPL_PC5MFP_Msk          (0xful << SYS_GPC_MFPL_PC5MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC5MFP Mask           */
N
N#define SYS_GPC_MFPL_PC6MFP_Pos          (24)                                              /*!< SYS_T::GPC_MFPL: PC6MFP Position       */
N#define SYS_GPC_MFPL_PC6MFP_Msk          (0xful << SYS_GPC_MFPL_PC6MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC6MFP Mask           */
N
N#define SYS_GPC_MFPL_PC7MFP_Pos          (28)                                              /*!< SYS_T::GPC_MFPL: PC7MFP Position       */
N#define SYS_GPC_MFPL_PC7MFP_Msk          (0xful << SYS_GPC_MFPL_PC7MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC7MFP Mask           */
N
N#define SYS_GPC_MFPH_PC8MFP_Pos          (0)                                               /*!< SYS_T::GPC_MFPH: PC8MFP Position       */
N#define SYS_GPC_MFPH_PC8MFP_Msk          (0xful << SYS_GPC_MFPH_PC8MFP_Pos)                /*!< SYS_T::GPC_MFPH: PC8MFP Mask           */
N
N#define SYS_GPC_MFPH_PC9MFP_Pos          (4)                                               /*!< SYS_T::GPC_MFPH: PC9MFP Position       */
N#define SYS_GPC_MFPH_PC9MFP_Msk          (0xful << SYS_GPC_MFPH_PC9MFP_Pos)                /*!< SYS_T::GPC_MFPH: PC9MFP Mask           */
N
N#define SYS_GPC_MFPH_PC10MFP_Pos         (8)                                               /*!< SYS_T::GPC_MFPH: PC10MFP Position      */
N#define SYS_GPC_MFPH_PC10MFP_Msk         (0xful << SYS_GPC_MFPH_PC10MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC10MFP Mask          */
N
N#define SYS_GPC_MFPH_PC11MFP_Pos         (12)                                              /*!< SYS_T::GPC_MFPH: PC11MFP Position      */
N#define SYS_GPC_MFPH_PC11MFP_Msk         (0xful << SYS_GPC_MFPH_PC11MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC11MFP Mask          */
N
N#define SYS_GPC_MFPH_PC12MFP_Pos         (16)                                              /*!< SYS_T::GPC_MFPH: PC12MFP Position      */
N#define SYS_GPC_MFPH_PC12MFP_Msk         (0xful << SYS_GPC_MFPH_PC12MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC12MFP Mask          */
N
N#define SYS_GPC_MFPH_PC13MFP_Pos         (20)                                              /*!< SYS_T::GPC_MFPH: PC13MFP Position      */
N#define SYS_GPC_MFPH_PC13MFP_Msk         (0xful << SYS_GPC_MFPH_PC13MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC13MFP Mask          */
N
N#define SYS_GPC_MFPH_PC14MFP_Pos         (24)                                              /*!< SYS_T::GPC_MFPH: PC14MFP Position      */
N#define SYS_GPC_MFPH_PC14MFP_Msk         (0xful << SYS_GPC_MFPH_PC14MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC14MFP Mask          */
N
N#define SYS_GPC_MFPH_PC15MFP_Pos         (28)                                              /*!< SYS_T::GPC_MFPH: PC15MFP Position      */
N#define SYS_GPC_MFPH_PC15MFP_Msk         (0xful << SYS_GPC_MFPH_PC15MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC15MFP Mask          */
N
N#define SYS_GPD_MFPL_PD0MFP_Pos          (0)                                               /*!< SYS_T::GPD_MFPL: PD0MFP Position       */
N#define SYS_GPD_MFPL_PD0MFP_Msk          (0xful << SYS_GPD_MFPL_PD0MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD0MFP Mask           */
N
N#define SYS_GPD_MFPL_PD1MFP_Pos          (4)                                               /*!< SYS_T::GPD_MFPL: PD1MFP Position       */
N#define SYS_GPD_MFPL_PD1MFP_Msk          (0xful << SYS_GPD_MFPL_PD1MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD1MFP Mask           */
N
N#define SYS_GPD_MFPL_PD2MFP_Pos          (8)                                               /*!< SYS_T::GPD_MFPL: PD2MFP Position       */
N#define SYS_GPD_MFPL_PD2MFP_Msk          (0xful << SYS_GPD_MFPL_PD2MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD2MFP Mask           */
N
N#define SYS_GPD_MFPL_PD3MFP_Pos          (12)                                              /*!< SYS_T::GPD_MFPL: PD3MFP Position       */
N#define SYS_GPD_MFPL_PD3MFP_Msk          (0xful << SYS_GPD_MFPL_PD3MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD3MFP Mask           */
N
N#define SYS_GPD_MFPL_PD4MFP_Pos          (16)                                              /*!< SYS_T::GPD_MFPL: PD4MFP Position       */
N#define SYS_GPD_MFPL_PD4MFP_Msk          (0xful << SYS_GPD_MFPL_PD4MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD4MFP Mask           */
N
N#define SYS_GPD_MFPL_PD5MFP_Pos          (20)                                              /*!< SYS_T::GPD_MFPL: PD5MFP Position       */
N#define SYS_GPD_MFPL_PD5MFP_Msk          (0xful << SYS_GPD_MFPL_PD5MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD5MFP Mask           */
N
N#define SYS_GPD_MFPL_PD6MFP_Pos          (24)                                              /*!< SYS_T::GPD_MFPL: PD6MFP Position       */
N#define SYS_GPD_MFPL_PD6MFP_Msk          (0xful << SYS_GPD_MFPL_PD6MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD6MFP Mask           */
N
N#define SYS_GPD_MFPL_PD7MFP_Pos          (28)                                              /*!< SYS_T::GPD_MFPL: PD7MFP Position       */
N#define SYS_GPD_MFPL_PD7MFP_Msk          (0xful << SYS_GPD_MFPL_PD7MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD7MFP Mask           */
N
N#define SYS_GPD_MFPH_PD8MFP_Pos          (0)                                               /*!< SYS_T::GPD_MFPH: PD8MFP Position       */
N#define SYS_GPD_MFPH_PD8MFP_Msk          (0xful << SYS_GPD_MFPH_PD8MFP_Pos)                /*!< SYS_T::GPD_MFPH: PD8MFP Mask           */
N
N#define SYS_GPD_MFPH_PD9MFP_Pos          (4)                                               /*!< SYS_T::GPD_MFPH: PD9MFP Position       */
N#define SYS_GPD_MFPH_PD9MFP_Msk          (0xful << SYS_GPD_MFPH_PD9MFP_Pos)                /*!< SYS_T::GPD_MFPH: PD9MFP Mask           */
N
N#define SYS_GPD_MFPH_PD10MFP_Pos         (8)                                               /*!< SYS_T::GPD_MFPH: PD10MFP Position      */
N#define SYS_GPD_MFPH_PD10MFP_Msk         (0xful << SYS_GPD_MFPH_PD10MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD10MFP Mask          */
N
N#define SYS_GPD_MFPH_PD11MFP_Pos         (12)                                              /*!< SYS_T::GPD_MFPH: PD11MFP Position      */
N#define SYS_GPD_MFPH_PD11MFP_Msk         (0xful << SYS_GPD_MFPH_PD11MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD11MFP Mask          */
N
N#define SYS_GPD_MFPH_PD12MFP_Pos         (16)                                              /*!< SYS_T::GPD_MFPH: PD12MFP Position      */
N#define SYS_GPD_MFPH_PD12MFP_Msk         (0xful << SYS_GPD_MFPH_PD12MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD12MFP Mask          */
N
N#define SYS_GPD_MFPH_PD13MFP_Pos         (20)                                              /*!< SYS_T::GPD_MFPH: PD13MFP Position      */
N#define SYS_GPD_MFPH_PD13MFP_Msk         (0xful << SYS_GPD_MFPH_PD13MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD13MFP Mask          */
N
N#define SYS_GPD_MFPH_PD14MFP_Pos         (24)                                              /*!< SYS_T::GPD_MFPH: PD14MFP Position      */
N#define SYS_GPD_MFPH_PD14MFP_Msk         (0xful << SYS_GPD_MFPH_PD14MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD14MFP Mask          */
N
N#define SYS_GPD_MFPH_PD15MFP_Pos         (28)                                              /*!< SYS_T::GPD_MFPH: PD15MFP Position      */
N#define SYS_GPD_MFPH_PD15MFP_Msk         (0xful << SYS_GPD_MFPH_PD15MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD15MFP Mask          */
N
N#define SYS_GPE_MFPL_PE0MFP_Pos          (0)                                               /*!< SYS_T::GPE_MFPL: PE0MFP Position       */
N#define SYS_GPE_MFPL_PE0MFP_Msk          (0xful << SYS_GPE_MFPL_PE0MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE0MFP Mask           */
N
N#define SYS_GPE_MFPL_PE1MFP_Pos          (4)                                               /*!< SYS_T::GPE_MFPL: PE1MFP Position       */
N#define SYS_GPE_MFPL_PE1MFP_Msk          (0xful << SYS_GPE_MFPL_PE1MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE1MFP Mask           */
N
N#define SYS_GPE_MFPL_PE2MFP_Pos          (8)                                               /*!< SYS_T::GPE_MFPL: PE2MFP Position       */
N#define SYS_GPE_MFPL_PE2MFP_Msk          (0xful << SYS_GPE_MFPL_PE2MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE2MFP Mask           */
N
N#define SYS_GPE_MFPL_PE3MFP_Pos          (12)                                              /*!< SYS_T::GPE_MFPL: PE3MFP Position       */
N#define SYS_GPE_MFPL_PE3MFP_Msk          (0xful << SYS_GPE_MFPL_PE3MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE3MFP Mask           */
N
N#define SYS_GPE_MFPL_PE4MFP_Pos          (16)                                              /*!< SYS_T::GPE_MFPL: PE4MFP Position       */
N#define SYS_GPE_MFPL_PE4MFP_Msk          (0xful << SYS_GPE_MFPL_PE4MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE4MFP Mask           */
N
N#define SYS_GPE_MFPL_PE5MFP_Pos          (20)                                              /*!< SYS_T::GPE_MFPL: PE5MFP Position       */
N#define SYS_GPE_MFPL_PE5MFP_Msk          (0xful << SYS_GPE_MFPL_PE5MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE5MFP Mask           */
N
N#define SYS_GPE_MFPL_PE6MFP_Pos          (24)                                              /*!< SYS_T::GPE_MFPL: PE6MFP Position       */
N#define SYS_GPE_MFPL_PE6MFP_Msk          (0xful << SYS_GPE_MFPL_PE6MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE6MFP Mask           */
N
N#define SYS_GPE_MFPL_PE7MFP_Pos          (28)                                              /*!< SYS_T::GPE_MFPL: PE7MFP Position       */
N#define SYS_GPE_MFPL_PE7MFP_Msk          (0xful << SYS_GPE_MFPL_PE7MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE7MFP Mask           */
N
N#define SYS_GPE_MFPH_PE8MFP_Pos          (0)                                               /*!< SYS_T::GPE_MFPH: PE8MFP Position       */
N#define SYS_GPE_MFPH_PE8MFP_Msk          (0xful << SYS_GPE_MFPH_PE8MFP_Pos)                /*!< SYS_T::GPE_MFPH: PE8MFP Mask           */
N
N#define SYS_GPE_MFPH_PE9MFP_Pos          (4)                                               /*!< SYS_T::GPE_MFPH: PE9MFP Position       */
N#define SYS_GPE_MFPH_PE9MFP_Msk          (0xful << SYS_GPE_MFPH_PE9MFP_Pos)                /*!< SYS_T::GPE_MFPH: PE9MFP Mask           */
N
N#define SYS_GPE_MFPH_PE10MFP_Pos         (8)                                               /*!< SYS_T::GPE_MFPH: PE10MFP Position      */
N#define SYS_GPE_MFPH_PE10MFP_Msk         (0xful << SYS_GPE_MFPH_PE10MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE10MFP Mask          */
N
N#define SYS_GPE_MFPH_PE11MFP_Pos         (12)                                              /*!< SYS_T::GPE_MFPH: PE11MFP Position      */
N#define SYS_GPE_MFPH_PE11MFP_Msk         (0xful << SYS_GPE_MFPH_PE11MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE11MFP Mask          */
N
N#define SYS_GPE_MFPH_PE12MFP_Pos         (16)                                              /*!< SYS_T::GPE_MFPH: PE12MFP Position      */
N#define SYS_GPE_MFPH_PE12MFP_Msk         (0xful << SYS_GPE_MFPH_PE12MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE12MFP Mask          */
N
N#define SYS_GPE_MFPH_PE13MFP_Pos         (20)                                              /*!< SYS_T::GPE_MFPH: PE13MFP Position      */
N#define SYS_GPE_MFPH_PE13MFP_Msk         (0xful << SYS_GPE_MFPH_PE13MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE13MFP Mask          */
N
N#define SYS_GPF_MFPL_PF0MFP_Pos          (0)                                               /*!< SYS_T::GPF_MFPL: PF0MFP Position       */
N#define SYS_GPF_MFPL_PF0MFP_Msk          (0xful << SYS_GPF_MFPL_PF0MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF0MFP Mask           */
N
N#define SYS_GPF_MFPL_PF1MFP_Pos          (4)                                               /*!< SYS_T::GPF_MFPL: PF1MFP Position       */
N#define SYS_GPF_MFPL_PF1MFP_Msk          (0xful << SYS_GPF_MFPL_PF1MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF1MFP Mask           */
N
N#define SYS_GPF_MFPL_PF2MFP_Pos          (8)                                               /*!< SYS_T::GPF_MFPL: PF2MFP Position       */
N#define SYS_GPF_MFPL_PF2MFP_Msk          (0xful << SYS_GPF_MFPL_PF2MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF2MFP Mask           */
N
N#define SYS_GPF_MFPL_PF3MFP_Pos          (12)                                              /*!< SYS_T::GPF_MFPL: PF3MFP Position       */
N#define SYS_GPF_MFPL_PF3MFP_Msk          (0xful << SYS_GPF_MFPL_PF3MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF3MFP Mask           */
N
N#define SYS_GPF_MFPL_PF4MFP_Pos          (16)                                              /*!< SYS_T::GPF_MFPL: PF4MFP Position       */
N#define SYS_GPF_MFPL_PF4MFP_Msk          (0xful << SYS_GPF_MFPL_PF4MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF4MFP Mask           */
N
N#define SYS_GPF_MFPL_PF5MFP_Pos          (20)                                              /*!< SYS_T::GPF_MFPL: PF5MFP Position       */
N#define SYS_GPF_MFPL_PF5MFP_Msk          (0xful << SYS_GPF_MFPL_PF5MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF5MFP Mask           */
N
N#define SYS_GPF_MFPL_PF6MFP_Pos          (24)                                              /*!< SYS_T::GPF_MFPL: PF6MFP Position       */
N#define SYS_GPF_MFPL_PF6MFP_Msk          (0xful << SYS_GPF_MFPL_PF6MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF6MFP Mask           */
N
N#define SYS_GPF_MFPL_PF7MFP_Pos          (28)                                              /*!< SYS_T::GPF_MFPL: PF7MFP Position       */
N#define SYS_GPF_MFPL_PF7MFP_Msk          (0xful << SYS_GPF_MFPL_PF7MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF7MFP Mask           */
N
N#define SYS_IRCTCTL0_FREQSEL_Pos         (0)                                               /*!< SYS_T::IRCTCTL0: FREQSEL Position      */
N#define SYS_IRCTCTL0_FREQSEL_Msk         (0x3ul << SYS_IRCTCTL0_FREQSEL_Pos)               /*!< SYS_T::IRCTCTL0: FREQSEL Mask          */
N
N#define SYS_IRCTCTL0_LOOPSEL_Pos         (4)                                               /*!< SYS_T::IRCTCTL0: LOOPSEL Position      */
N#define SYS_IRCTCTL0_LOOPSEL_Msk         (0x3ul << SYS_IRCTCTL0_LOOPSEL_Pos)               /*!< SYS_T::IRCTCTL0: LOOPSEL Mask          */
N
N#define SYS_IRCTCTL0_RETRYCNT_Pos        (6)                                               /*!< SYS_T::IRCTCTL0: RETRYCNT Position     */
N#define SYS_IRCTCTL0_RETRYCNT_Msk        (0x3ul << SYS_IRCTCTL0_RETRYCNT_Pos)              /*!< SYS_T::IRCTCTL0: RETRYCNT Mask         */
N
N#define SYS_IRCTCTL0_CESTOPEN_Pos        (8)                                               /*!< SYS_T::IRCTCTL0: CESTOPEN Position     */
N#define SYS_IRCTCTL0_CESTOPEN_Msk        (0x1ul << SYS_IRCTCTL0_CESTOPEN_Pos)              /*!< SYS_T::IRCTCTL0: CESTOPEN Mask         */
N
N#define SYS_IRCTCTL0_REFCKSEL_Pos        (10)                                              /*!< SYS_T::IRCTCTL0: REFCKSEL Position     */
N#define SYS_IRCTCTL0_REFCKSEL_Msk        (0x1ul << SYS_IRCTCTL0_REFCKSEL_Pos)              /*!< SYS_T::IRCTCTL0: REFCKSEL Mask         */
N
N#define SYS_IRCTIEN_TFAILIEN_Pos         (1)                                               /*!< SYS_T::IRCTIEN: TFAILIEN Position      */
N#define SYS_IRCTIEN_TFAILIEN_Msk         (0x1ul << SYS_IRCTIEN_TFAILIEN_Pos)               /*!< SYS_T::IRCTIEN: TFAILIEN Mask          */
N
N#define SYS_IRCTIEN_CLKEIEN_Pos          (2)                                               /*!< SYS_T::IRCTIEN: CLKEIEN Position       */
N#define SYS_IRCTIEN_CLKEIEN_Msk          (0x1ul << SYS_IRCTIEN_CLKEIEN_Pos)                /*!< SYS_T::IRCTIEN: CLKEIEN Mask           */
N
N#define SYS_IRCTIEN_TFAILIEN1_Pos        (9)                                               /*!< SYS_T::IRCTIEN: TFAILIEN1 Position     */
N#define SYS_IRCTIEN_TFAILIEN1_Msk        (0x1ul << SYS_IRCTIEN_TFAILIEN1_Pos)              /*!< SYS_T::IRCTIEN: TFAILIEN1 Mask         */
N
N#define SYS_IRCTIEN_CLKEIEN1_Pos         (10)                                              /*!< SYS_T::IRCTIEN: CLKEIEN1 Position      */
N#define SYS_IRCTIEN_CLKEIEN1_Msk         (0x1ul << SYS_IRCTIEN_CLKEIEN1_Pos)               /*!< SYS_T::IRCTIEN: CLKEIEN1 Mask          */
N
N#define SYS_IRCTISTS_FREQLOCK_Pos        (0)                                               /*!< SYS_T::IRCTISTS: FREQLOCK Position     */
N#define SYS_IRCTISTS_FREQLOCK_Msk        (0x1ul << SYS_IRCTISTS_FREQLOCK_Pos)              /*!< SYS_T::IRCTISTS: FREQLOCK Mask         */
N
N#define SYS_IRCTISTS_TFAILIF_Pos         (1)                                               /*!< SYS_T::IRCTISTS: TFAILIF Position      */
N#define SYS_IRCTISTS_TFAILIF_Msk         (0x1ul << SYS_IRCTISTS_TFAILIF_Pos)               /*!< SYS_T::IRCTISTS: TFAILIF Mask          */
N
N#define SYS_IRCTISTS_CLKERRIF_Pos        (2)                                               /*!< SYS_T::IRCTISTS: CLKERRIF Position     */
N#define SYS_IRCTISTS_CLKERRIF_Msk        (0x1ul << SYS_IRCTISTS_CLKERRIF_Pos)              /*!< SYS_T::IRCTISTS: CLKERRIF Mask         */
N
N#define SYS_IRCTISTS_FREQLOCK1_Pos       (8)                                               /*!< SYS_T::IRCTISTS: FREQLOCK1 Position    */
N#define SYS_IRCTISTS_FREQLOCK1_Msk       (0x1ul << SYS_IRCTISTS_FREQLOCK1_Pos)             /*!< SYS_T::IRCTISTS: FREQLOCK1 Mask        */
N
N#define SYS_IRCTISTS_TFAILIF1_Pos        (9)                                               /*!< SYS_T::IRCTISTS: TFAILIF1 Position     */
N#define SYS_IRCTISTS_TFAILIF1_Msk        (0x1ul << SYS_IRCTISTS_TFAILIF1_Pos)              /*!< SYS_T::IRCTISTS: TFAILIF1 Mask         */
N
N#define SYS_IRCTISTS_CLKERRIF1_Pos       (10)                                              /*!< SYS_T::IRCTISTS: CLKERRIF1 Position    */
N#define SYS_IRCTISTS_CLKERRIF1_Msk       (0x1ul << SYS_IRCTISTS_CLKERRIF1_Pos)             /*!< SYS_T::IRCTISTS: CLKERRIF1 Mask        */
N
N#define SYS_IRCTCTL1_FREQSEL_Pos         (0)                                               /*!< SYS_T::IRCTCTL1: FREQSEL Position      */
N#define SYS_IRCTCTL1_FREQSEL_Msk         (0x3ul << SYS_IRCTCTL1_FREQSEL_Pos)               /*!< SYS_T::IRCTCTL1: FREQSEL Mask          */
N
N#define SYS_IRCTCTL1_LOOPSEL_Pos         (4)                                               /*!< SYS_T::IRCTCTL1: LOOPSEL Position      */
N#define SYS_IRCTCTL1_LOOPSEL_Msk         (0x3ul << SYS_IRCTCTL1_LOOPSEL_Pos)               /*!< SYS_T::IRCTCTL1: LOOPSEL Mask          */
N
N#define SYS_IRCTCTL1_RETRYCNT_Pos        (6)                                               /*!< SYS_T::IRCTCTL1: RETRYCNT Position     */
N#define SYS_IRCTCTL1_RETRYCNT_Msk        (0x3ul << SYS_IRCTCTL1_RETRYCNT_Pos)              /*!< SYS_T::IRCTCTL1: RETRYCNT Mask         */
N
N#define SYS_IRCTCTL1_CESTOPEN_Pos        (8)                                               /*!< SYS_T::IRCTCTL1: CESTOPEN Position     */
N#define SYS_IRCTCTL1_CESTOPEN_Msk        (0x1ul << SYS_IRCTCTL1_CESTOPEN_Pos)              /*!< SYS_T::IRCTCTL1: CESTOPEN Mask         */
N
N#define SYS_IRCTCTL1_REFCKSEL_Pos        (10)                                              /*!< SYS_T::IRCTCTL1: REFCKSEL Position     */
N#define SYS_IRCTCTL1_REFCKSEL_Msk        (0x1ul << SYS_IRCTCTL1_REFCKSEL_Pos)              /*!< SYS_T::IRCTCTL1: REFCKSEL Mask         */
N
N#define SYS_MODCTL_MODEN_Pos             (0)                                               /*!< SYS_T::MODCTL: MODEN Position          */
N#define SYS_MODCTL_MODEN_Msk             (0x1ul << SYS_MODCTL_MODEN_Pos)                   /*!< SYS_T::MODCTL: MODEN Mask              */
N
N#define SYS_MODCTL_MODH_Pos              (1)                                               /*!< SYS_T::MODCTL: MODH Position           */
N#define SYS_MODCTL_MODH_Msk              (0x1ul << SYS_MODCTL_MODH_Pos)                    /*!< SYS_T::MODCTL: MODH Mask               */
N
N#define SYS_MODCTL_MODPWMSEL_Pos         (4)                                               /*!< SYS_T::MODCTL: MODPWMSEL Position      */
N#define SYS_MODCTL_MODPWMSEL_Msk         (0x7ul << SYS_MODCTL_MODPWMSEL_Pos)               /*!< SYS_T::MODCTL: MODPWMSEL Mask          */
N
N#define SYS_SRAM_BISTCTL_SRBIST_Pos      (0)                                               /*!< SYS_T::SRAM_BISTCTL: SRBIST Position   */
N#define SYS_SRAM_BISTCTL_SRBIST_Msk      (0x1ul << SYS_SRAM_BISTCTL_SRBIST_Pos)            /*!< SYS_T::SRAM_BISTCTL: SRBIST Mask       */
N
N#define SYS_SRAM_BISTCTL_CRBIST_Pos      (2)                                               /*!< SYS_T::SRAM_BISTCTL: CRBIST Position   */
N#define SYS_SRAM_BISTCTL_CRBIST_Msk      (0x1ul << SYS_SRAM_BISTCTL_CRBIST_Pos)            /*!< SYS_T::SRAM_BISTCTL: CRBIST Mask       */
N
N#define SYS_SRAM_BISTCTL_USBBIST_Pos     (4)                                               /*!< SYS_T::SRAM_BISTCTL: USBBIST Position  */
N#define SYS_SRAM_BISTCTL_USBBIST_Msk     (0x1ul << SYS_SRAM_BISTCTL_USBBIST_Pos)           /*!< SYS_T::SRAM_BISTCTL: USBBIST Mask      */
N
N#define SYS_SRAM_BISTSTS_SRBISTEF_Pos    (0)                                               /*!< SYS_T::SRAM_BISTSTS: SRBISTEF Position */
N#define SYS_SRAM_BISTSTS_SRBISTEF_Msk    (0x1ul << SYS_SRAM_BISTSTS_SRBISTEF_Pos)          /*!< SYS_T::SRAM_BISTSTS: SRBISTEF Mask     */
N
N#define SYS_SRAM_BISTSTS_CRBISTEF_Pos    (2)                                               /*!< SYS_T::SRAM_BISTSTS: CRBISTEF Position */
N#define SYS_SRAM_BISTSTS_CRBISTEF_Msk    (0x1ul << SYS_SRAM_BISTSTS_CRBISTEF_Pos)          /*!< SYS_T::SRAM_BISTSTS: CRBISTEF Mask     */
N
N#define SYS_SRAM_BISTSTS_USBBEF_Pos      (4)                                               /*!< SYS_T::SRAM_BISTSTS: USBBEF Position   */
N#define SYS_SRAM_BISTSTS_USBBEF_Msk      (0x1ul << SYS_SRAM_BISTSTS_USBBEF_Pos)            /*!< SYS_T::SRAM_BISTSTS: USBBEF Mask       */
N
N#define SYS_SRAM_BISTSTS_SRBEND_Pos      (16)                                              /*!< SYS_T::SRAM_BISTSTS: SRBEND Position   */
N#define SYS_SRAM_BISTSTS_SRBEND_Msk      (0x1ul << SYS_SRAM_BISTSTS_SRBEND_Pos)            /*!< SYS_T::SRAM_BISTSTS: SRBEND Mask       */
N
N#define SYS_SRAM_BISTSTS_CRBEND_Pos      (18)                                              /*!< SYS_T::SRAM_BISTSTS: CRBEND Position   */
N#define SYS_SRAM_BISTSTS_CRBEND_Msk      (0x1ul << SYS_SRAM_BISTSTS_CRBEND_Pos)            /*!< SYS_T::SRAM_BISTSTS: CRBEND Mask       */
N
N#define SYS_SRAM_BISTSTS_USBBEND_Pos     (20)                                              /*!< SYS_T::SRAM_BISTSTS: USBBEND Position  */
N#define SYS_SRAM_BISTSTS_USBBEND_Msk     (0x1ul << SYS_SRAM_BISTSTS_USBBEND_Pos)           /*!< SYS_T::SRAM_BISTSTS: USBBEND Mask      */
N
N#define SYS_TSOFFSET_VTEMP_Pos           (0)                                               /*!< SYS_T::TSOFFSET: VTEMP Position        */
N#define SYS_TSOFFSET_VTEMP_Msk           (0xffful << SYS_TSOFFSET_VTEMP_Pos)               /*!< SYS_T::TSOFFSET: VTEMP Mask            */
N
N/**@}*/ /* SYS_CONST */
N
N
N
Ntypedef struct
N{
N
N
N    /**
N     * @var SYS_INT_T::IRQSRC
N     * Offset: 0x00  Interrupt Source Identity Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |INTSRC    |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     * |        |          |IRQSRC[0].0 - BOD INT
N     * |        |          |IRQSRC[0].1 - 0
N     * |        |          |IRQSRC[0].2 - 0
N     * |        |          |IRQSRC[1].0 - WDT INT
N     * |        |          |IRQSRC[1].1 - WWDT_INT
N     * |        |          |IRQSRC[1].2 - 0
N     * |        |          |IRQSRC[2].0 - EINT0, external interrupt 0 from PA.0/PD.2/PE.4
N     * |        |          |IRQSRC[2].1 - EINT2, external interrupt 2 from PC.0
N     * |        |          |IRQSRC[2].2 - EINT4, external interrupt 4 from PE.0
N     * |        |          |IRQSRC[3].0 - EINT1, external interrupt 1 from PB.0/PD.3/PE.5
N     * |        |          |IRQSRC[3].1 - EINT3, external interrupt 3 from PD.0
N     * |        |          |IRQSRC[3].2 - EINT5, external interrupt 5 from PF.0
N     * |        |          |IRQSRC[4].0 - GPA_INT
N     * |        |          |IRQSRC[4].1 - GPB_INT
N     * |        |          |IRQSRC[4].2 - 0
N     * |        |          |IRQSRC[5].0 - GPC_INT
N     * |        |          |IRQSRC[5].1 - GPD_INT
N     * |        |          |IRQSRC[5].2 - GPE_INT
N     * |        |          |IRQSRC[5].3 - GPF_INT
N     * |        |          |IRQSRC[6].0 - PWM1 INT
N     * |        |          |IRQSRC[6].1 - BRAKE0_INT
N     * |        |          |IRQSRC[6].2 - 0
N     * |        |          |IRQSRC[6].3 - 0
N     * |        |          |IRQSRC[7].0 - PWM1_INT
N     * |        |          |IRQSRC[7].1 - BRAKE1_INT
N     * |        |          |IRQSRC[7].2 - 0
N     * |        |          |IRQSRC[7].3 - 0
N     * |        |          |IRQSRC[8].0 - TMR0_INT
N     * |        |          |IRQSRC[8].1 - 0
N     * |        |          |IRQSRC[8].2 - 0
N     * |        |          |IRQSRC[9].0 - TMR1_INT
N     * |        |          |IRQSRC[9].1 - 0
N     * |        |          |IRQSRC[9].2 - 0
N     * |        |          |IRQSRC[10].0 - TMR2_INT
N     * |        |          |IRQSRC[10].1 - 0
N     * |        |          |IRQSRC[10].2 - 0
N     * |        |          |IRQSRC[11].0 - TMR3_INT
N     * |        |          |IRQSRC[11].1 - 0
N     * |        |          |IRQSRC[11].2 - 0
N     * |        |          |IRQSRC[12].0 - UART0_INT
N     * |        |          |IRQSRC[12].1 - UART2_INT
N     * |        |          |IRQSRC[12].2 - 0
N     * |        |          |IRQSRC[13].0 - UART1_INT
N     * |        |          |IRQSRC[13].1 - 0
N     * |        |          |IRQSRC[13].2 - 0
N     * |        |          |IRQSRC[14].0 - SPI0_INT
N     * |        |          |IRQSRC[14].1 - 0
N     * |        |          |IRQSRC[14].2 - 0
N     * |        |          |IRQSRC[15].0 - SPI1_INT
N     * |        |          |IRQSRC[15].1 - 0
N     * |        |          |IRQSRC[15].2 - 0
N     * |        |          |IRQSRC[16].0 - 0
N     * |        |          |IRQSRC[16].1 - 0
N     * |        |          |IRQSRC[16].2 - 0
N     * |        |          |IRQSRC[17].0 - 0
N     * |        |          |IRQSRC[17].1 - 0
N     * |        |          |IRQSRC[17].2 - 0
N     * |        |          |IRQSRC[18].0 - I2C0_INT
N     * |        |          |IRQSRC[18].1 - 0
N     * |        |          |IRQSRC[18].2 - 0
N     * |        |          |IRQSRC[19].0 - I2C1_INT
N     * |        |          |IRQSRC[19].1 - 0
N     * |        |          |IRQSRC[19].2 - 0
N     * |        |          |IRQSRC[20].0 - 0
N     * |        |          |IRQSRC[20].1 - 0
N     * |        |          |IRQSRC[20].2 - 0
N     * |        |          |IRQSRC[21].0 - 0
N     * |        |          |IRQSRC[21].1 - 0
N     * |        |          |IRQSRC[21].2 - 0
N     * |        |          |IRQSRC[22].0 - USCI0_INT
N     * |        |          |IRQSRC[22].1 - USCI1_INT
N     * |        |          |IRQSRC[22].2 - USCI2_INT
N     * |        |          |IRQSRC[23].0 - USBD_INT
N     * |        |          |IRQSRC[23].1 - 0
N     * |        |          |IRQSRC[23].2 - 0
N     * |        |          |IRQSRC[24].0 - SMC0_INT
N     * |        |          |IRQSRC[24].1 - SMC1_INT
N     * |        |          |IRQSRC[24].2 - 0
N     * |        |          |IRQSRC[25].0 - ACMP_INT
N     * |        |          |IRQSRC[25].1 - 0
N     * |        |          |IRQSRC[25].2 - 0
N     * |        |          |IRQSRC[26].0 - PDMA_INT
N     * |        |          |IRQSRC[26].1 - 0
N     * |        |          |IRQSRC[26].2 - 0
N     * |        |          |IRQSRC[27].0 - 0
N     * |        |          |IRQSRC[27].1 - 0
N     * |        |          |IRQSRC[27].2 - 0
N     * |        |          |IRQSRC[28].0 - PWRWU_INT
N     * |        |          |IRQSRC[28].1 - 0
N     * |        |          |IRQSRC[28].2 - 0
N     * |        |          |IRQSRC[29].0 - ADC_INT
N     * |        |          |IRQSRC[29].1 - 0
N     * |        |          |IRQSRC[29].2 - 0
N     * |        |          |IRQSRC[30].0 - IRC_INT
N     * |        |          |IRQSRC[30].1 - CLKD_INT
N     * |        |          |IRQSRC[30].2 - SRAMF_INT
N     * |        |          |IRQSRC[31].0 - RTC_INT
N     * |        |          |IRQSRC[31].1 - 0
N     * |        |          |IRQSRC[31].2 - 0
N     * @var SYS_INT_T::NMISEL
N     * Offset: 0x80  NMI Source Interrupt Select Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4:0]   |NMISEL    |NMI Interrupt Source Selection
N     * |        |          |The NMI interrupt to Cortex-M0 can be selected from one of the peripheral interrupt by setting NMISEL.
N     * |[8]     |NMIEN     |NMI Interrupt Enable Bit (Write Protect)
N     * |        |          |0 = NMI interrupt Disabled.
N     * |        |          |1 = NMI interrupt Enabled.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     */
N
N
N    __I  uint32_t IRQSRC[32];            /*!< [0x0000-0x007C] MCU IRQn(n=0~31) Interrupt Source Identity Register       */
X    volatile const  uint32_t IRQSRC[32];             
N    __IO uint32_t NMISEL;                /*!< [0x0080] NMI Source Interrupt Select Control Register                     */
X    volatile uint32_t NMISEL;                 
N
N
N} SYS_INT_T;
N
N/**
N    @addtogroup INT_CONST INT Bit Field Definition
N    Constant Definitions for INT Controller
N@{ */
N
N#define INT_INTSRC_INTSRC_Pos             (0)                                               /*!< SYS_INT_T::INTSRC: INTSRC Position           */
N#define INT_INTSRC_INTSRC_Msk             (0xful << INT_INTSRC_INTSRC_Pos)                  /*!< SYS_INT_T::INTSRC: INTSRC Mask               */
N
N#define INT_NMISEL_NMISEL_Pos             (0)                                               /*!< SYS_INT_T::NMISEL: NMISEL Position           */
N#define INT_NMISEL_NMISEL_Msk             (0x1ful << INT_NMISEL_NMISEL_Msk)                 /*!< SYS_INT_T::NMISEL: NMISEL Mask               */
N
N#define INT_NMISEL_NMIEN_Pos              (8)                                               /*!< SYS_INT_T::NMISEL: NMIEN Position            */
N#define INT_NMISEL_NMIEN_Msk              (0x1ul << INT_NMISEL_NMIEN_Pos)                   /*!< SYS_INT_T::NMISEL: NMIEN Mask                */
N
N/**@}*/ /* INT_CONST */
N/**@}*/ /* end of SYS register group */
N
N
N
N
N/*---------------------- Timer Controller -------------------------*/
N/**
N    @addtogroup TIMER Timer Controller(TIMER)
N    Memory Mapped Structure for TIMER Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var TIMER_T::CTL
N     * Offset: 0x00  Timer Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |PSC       |Prescale Counter
N     * |        |          |Timer input clock or event source is divided by (PSC+1) before it is fed to the timer up counter
N     * |        |          |If this field is 0 (PSC = 0), then there is no scaling.
N     * |        |          |Note: Update prescale counter value will reset internal 8-bit prescale counter and 24-bit up counter value.
N     * |[19]    |INTRGEN   |Inter-Timer Trigger Mode Enable Control
N     * |        |          |Setting this bit will enable the inter-timer trigger capture function.
N     * |        |          |The Timer0/2 will be in event counter mode and counting with external clock source or event
N     * |        |          |Also, Timer1/3 will be in trigger-counting mode of capture function.
N     * |        |          |0 = Inter-Timer Trigger Capture mode Disabled.
N     * |        |          |1 = Inter-Timer Trigger Capture mode Enabled.
N     * |        |          |Note: For Timer1/3, this bit is ignored and the read back value is always 0.
N     * |[20]    |PERIOSEL  |Periodic Mode Behavior Selection Enable Bit
N     * |        |          |0 = The behavior selection in periodic mode is Disabled.
N     * |        |          |When user updates CMPDAT while timer is running in periodic mode,
N     * |        |          |CNT will be reset to default value.
N     * |        |          |1 = The behavior selection in periodic mode is Enabled.
N     * |        |          |When user update CMPDAT while timer is running in periodic mode, the limitations as bellows list,
N     * |        |          |If updated CMPDAT value > CNT, CMPDAT will be updated and CNT keep running continually.
N     * |        |          |If updated CMPDAT value = CNT, timer time-out interrupt will be asserted immediately.
N     * |        |          |If updated CMPDAT value < CNT, CNT will be reset to default value.
N     * |[21]    |TGLPINSEL |Toggle-Output Pin Select
N     * |        |          |0 = Toggle mode output to Tx (Timer Event Counter Pin).
N     * |        |          |1 = Toggle mode output to Tx_EXT (Timer External Capture Pin).
N     * |[22]    |CAPSRC    |Capture Pin Source Selection
N     * |        |          |0 = Capture Function source is from Tx_EXT (x= 0~3) pin.
N     * |        |          |1 = Capture Function source is from internal ACMP output signal
N     * |        |          |User can set ACMPSSEL (TIMERx_EXTCTL[8]) to decide which internal ACMP output signal as timer capture source.
N     * |[23]    |WKEN      |Wake-Up Function Enable Bit
N     * |        |          |If this bit is set to 1, while timer interrupt flag TIF (TIMERx_INTSTS[0]) is 1 and INTEN (TIMERx_CTL[29]) is enabled, the timer interrupt signal will generate a wake-up trigger event to CPU.
N     * |        |          |0 = Wake-up function Disabled if timer interrupt signal generated.
N     * |        |          |1 = Wake-up function Enabled if timer interrupt signal generated.
N     * |[24]    |EXTCNTEN  |Event Counter Mode Enable Bit
N     * |        |          |This bit is for external counting pin function enabled.
N     * |        |          |0 = Event counter mode Disabled.
N     * |        |          |1 = Event counter mode Enabled.
N     * |        |          |Note: When timer is used as an event counter, this bit should be set to 1 and select PCLK as timer clock source.
N     * |[25]    |ACTSTS    |Timer Active Status Bit (Read Only)
N     * |        |          |This bit indicates the 24-bit up counter status.
N     * |        |          |0 = 24-bit up counter is not active.
N     * |        |          |1 = 24-bit up counter is active.
N     * |[28:27] |OPMODE    |Timer Counting Mode Select
N     * |        |          |00 = The Timer controller is operated in One-shot mode.
N     * |        |          |01 = The Timer controller is operated in Periodic mode.
N     * |        |          |10 = The Timer controller is operated in Toggle-output mode.
N     * |        |          |11 = The Timer controller is operated in Continuous Counting mode.
N     * |[29]    |INTEN     |Timer Interrupt Enable Bit
N     * |        |          |0 = Timer time-out iInterrupt Disabled.
N     * |        |          |1 = Timer time-out iInterrupt Enabled.
N     * |        |          |Note: If this bit is enabled, when the timer time-out interrupt flag TIF is set to 1, the timer interrupt signal is generated and inform to CPU.
N     * |[30]    |CNTEN     |Timer Counting Enable Bit
N     * |        |          |0 = Stops/Suspends counting.
N     * |        |          |1 = Starts counting.
N     * |        |          |Note1: In stop status, and then set CNTEN to 1 will enable the 24-bit up counter to keep counting from the last stop counting value.
N     * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode (TIMER_CTL[28:27] = 00) when the timer time-out interrupt flag TIF (TIMERx_INTSTS[0]) is generated.
N     * |        |          |Note3: Set enable/disable this bit needs 2 * TMR_CLK period to become active, user can read ACTSTS (TIMERx_CTL[25]) to check enabe/disable command is completed or not.
N     * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control (Write Protect)
N     * |        |          |0 = ICE debug mode acknowledgement effects TIMER counting.
N     * |        |          |TIMER counter will be held while CPU is held by ICE.
N     * |        |          |1 = ICE debug mode acknowledgement Disabled.
N     * |        |          |TIMER counter will keep going no matter CPU is held by ICE or not.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * @var TIMER_T::CMP
N     * Offset: 0x04  Timer Comparator Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |CMPDAT    |Timer Comparedator Value
N     * |        |          |CMPDAT is a 24-bit compared value register
N     * |        |          |When the internal 24-bit up counter value is equal to CMPDAT value, the TIF (TIMERx_INTSTS[0] Timer Interrupt Flag) will set to 1.
N     * |        |          |Time-out period = (Period of timer clock input) * (8-bit PSC + 1) * (24-bit CMPDAT).
N     * |        |          |Note1: Never write 0x0 or 0x1 in CMPDAT field, or the core will run into unknown state.
N     * |        |          |Note2: When timer is operating at continuous counting mode, the 24-bit up counter will keep counting continuously even if user writes a new value into CMPDAT field
N     * |        |          |But if timer is operating at other modes, the 24-bit up counter will restart counting from 0 and using newest CMPDAT value to be the timer compared value while user writes a new value into CMPDAT field.
N     * @var TIMER_T::INTSTS
N     * Offset: 0x08  Timer Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TIF       |Timer Interrupt Flag
N     * |        |          |This bit indicates the interrupt flag status of Timer while 24-bit timer up counter CNT (TIMERx_CNT[23:0]) value reaches to CMPDAT (TIMERx_CMP[23:0]) value.
N     * |        |          |0 = No effect.
N     * |        |          |1 = CNT value matches the CMPDAT value.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[1]     |TWKF      |Timer Wake-Up Flag
N     * |        |          |This bit indicates the interrupt wake-up flag status of timer.
N     * |        |          |0 = Timer does not cause CPU wake-up.
N     * |        |          |1 = CPU wake-up from Idle or Power-down mode if timer time-out interrupt signal generated.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * @var TIMER_T::CNT
N     * Offset: 0x0C  Timer Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |CNT       |Timer Data Register
N     * |        |          |Read operation.
N     * |        |          |Read this register to get CNT value. For example:
N     * |        |          |If EXTCNTEN (TIMERx_CTL[24] ) is 0, user can read CNT value for getting current 24-bit counter value.
N     * |        |          |If EXTCNTEN (TIMERx_CTL[24] ) is 1, user can read CNT value for getting current 24-bit event input counter value.
N     * |        |          |Write operation.
N     * |        |          |Writing any value to this register will reset current CNT value to 0 and reload internal 8-bit prescale counter.
N     * |[31]    |RSTACT    |Timer Data Register Reset Active (Read Only)
N     * |        |          |This bit indicates if the counter reset operation active.
N     * |        |          |When user writes this CNT register, timer starts to reset its internal 24-bit timer up-counter to 0 and reload 8-bit pre-scale counter
N     * |        |          |At the same time, timer set this flag to 1 to indicate the counter reset operation is in progress
N     * |        |          |Once the counter reset operation done, timer clear this bit to 0 automatically.
N     * |        |          |0 = Reset operation is done.
N     * |        |          |1 = Reset operation triggered by writing TIMERx_CNT is in progress.
N     * |        |          |Note: This bit is read only.
N     * @var TIMER_T::CAP
N     * Offset: 0x10  Timer Capture Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |CAPDAT    |Timer Capture Data Register
N     * |        |          |When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on Tx_EXT pin matched the CAPEDGE (TIMERx_EXTCTL[14:12]) setting, CAPIF (TIMERx_EINTSTS[0]) will set to 1 and the current timer counter value CNT (TIMERx_CNT[23:0]) will be auto-loaded into this CAPDAT field.
N     * @var TIMER_T::EXTCTL
N     * Offset: 0x14  Timer External Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CNTPHASE  |Timer External Count Phase
N     * |        |          |This bit indicates the detection phase of external counting pin Tx (x= 0~3).
N     * |        |          |0 = A falling edge of external counting pin will be counted.
N     * |        |          |1 = A rising edge of external counting pin will be counted.
N     * |[3]     |CAPEN     |Timer External Capture Pin Enable Bit
N     * |        |          |This bit enables the Tx_EXT capture pin input function.
N     * |        |          |0 =Tx_EXT (x= 0~3) pin Disabled.
N     * |        |          |1 =Tx_EXT (x= 0~3) pin Enabled.
N     * |[4]     |CAPFUNCS  |Capture Function Selection
N     * |        |          |0 = External Capture Mode Enabled.
N     * |        |          |1 = External Reset Mode Enabled.
N     * |        |          |Note1: When CAPFUNCS is 0, transition on Tx_EXT (x= 0~3) pin is using to save current 24-bit timer counter value (CNT value) to CAPDAT field.
N     * |        |          |Note2: When CAPFUNCS is 1, transition on Tx_EXT (x= 0~3) pin is using to save current 24-bit timer counter value (CNT value) to CAPDAT field and then CNT value will be reset immediately.
N     * |[5]     |CAPIEN    |Timer External Capture Interrupt Enable Bit
N     * |        |          |0 = Tx_EXT (x= 0~3) pin detection Interrupt Disabled.
N     * |        |          |1 = Tx_EXT (x= 0~3) pin detection Interrupt Enabled.
N     * |        |          |Note: CAPIEN is used to enable timer external interrupt
N     * |        |          |If CAPIEN enabled, timer will rise an interrupt when CAPIF (TIMERx_EINTSTS[0]) is 1.
N     * |        |          |For example, while CAPIEN = 1, CAPEN = 1, and CAPEDGE = 00, a 1 to 0 transition on the Tx_EXT pin will cause the CAPIF to be set then the interrupt signal is generated and sent to NVIC to inform CPU.
N     * |[6]     |CAPDBEN   |Timer External Capture Pin De-Bounce Enable Bit
N     * |        |          |0 = Tx_EXT (x= 0~3) pin de-bounce or ACMP output de-bounce Disabled.
N     * |        |          |1 = Tx_EXT (x= 0~3) pin de-bounce or ACMP output de-bounce Enabled.
N     * |        |          |Note: If this bit is enabled, the edge detection of Tx_EXT pin or ACMP output is detected with de-bounce circuit.
N     * |[7]     |CNTDBEN   |Timer Counter Pin De-Bounce Enable Bit
N     * |        |          |0 = Tx (x= 0~3) pin de-bounce Disabled.
N     * |        |          |1 = Tx (x= 0~3) pin de-bounce Enabled.
N     * |        |          |Note: If this bit is enabled, the edge detection of Tx pin is detected with de-bounce circuit.
N     * |[8]     |ACMPSSEL  |ACMP Source Selection to Trigger Capture Function
N     * |        |          |0 = Capture Function source is from internal ACMP0 output signal.
N     * |        |          |1 = Capture Function source is from internal ACMP1 output signal.
N     * |        |          |Note: these bits only available when CAPSRC (TIMERx_CTL[22]) is 1.
N     * |[14:12] |CAPEDGE   |Timer External Capture Pin Edge Detect
N     * |        |          |When first capture event is generated, the CNT (TIMERx_CNT[23:0]) will be reset to 0 and first CAPDAT (TIMERx_CAP[23:0]) should be to 0.
N     * |        |          |000 = Capture event occurred when detect falling edge transfer on Tx_EXT (x= 0~3) pin.
N     * |        |          |001 = Capture event occurred when detect rising edge transfer on Tx_EXT (x= 0~3) pin.
N     * |        |          |010 = Capture event occurred when detect both falling and rising edge transfer on Tx_EXT (x= 0~3) pin, and first capture event occurred at falling edge transfer.
N     * |        |          |011 = Capture event occurred when detect both rising and falling edge transfer on Tx_EXT (x= 0~3) pin, and first capture event occurred at rising edge transfer.
N     * |        |          |110 = First capture event occurred at falling edge, follows capture events are at rising edge transfer on Tx_EXT (x= 0~3) pin.
N     * |        |          |111 = First capture event occurred at rising edge, follows capture events are at falling edge transfer on Tx_EXT (x= 0~3) pin.
N     * |        |          |100, 101 = Reserved.
N     * |[16]    |ECNTSSEL  |Event Counter Source Selection to Trigger Event Counter Function
N     * |        |          |0 = Event Counter input source is from Tx (x= 0~3) pin.
N     * |        |          |1 = Event Counter input source is from USB internal SOF output signal.
N     * @var TIMER_T::EINTSTS
N     * Offset: 0x18  Timer0 External Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CAPIF     |Timer External Capture Interrupt Flag
N     * |        |          |This bit indicates the timer external capture interrupt flag status.
N     * |        |          |0 = Tx_EXT (x= 0~3) pin interrupt did not occur.
N     * |        |          |1 = Tx_EXT (x= 0~3) pin interrupt occurred.
N     * |        |          |Note1: This bit is cleared by writing 1 to it.
N     * |        |          |Note2: When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on Tx_EXT (x= 0~3) pin matched the CAPEDGE (TIMERx_EXTCTL[2:1]) setting, this bit will set to 1 by hardware.
N     * |        |          |Note3: There is a new incoming capture event detected before CPU clearing the CAPIF status
N     * |        |          |If the above condition occurred, the Timer will keep register TIMERx_CAP unchanged and drop the new capture value.
N     * @var TIMER_T::TRGCTL
N     * Offset: 0x1C  Timer Trigger Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TRGSSEL   |Trigger Source Select Bit
N     * |        |          |This bit is used to select internal trigger source is form Timer timer time-out interrupt signal or capture interrupt signal.
N     * |        |          |0 = Timer tTime-out interrupt signal is used to internal trigger PWM, PDMA, and ADC.
N     * |        |          |1 = Capture interrupt signal is used to internal trigger PWM, PDMA, and ADC.
N     * |[1]     |TRGPWM    |Trigger PWM Enable Bit
N     * |        |          |If this bit is set to 1, each timer time-out event interrupt or capture interrupt event can be as PWM counter clock source.triggered PWM.
N     * |        |          |0 = Timer interrupt trigger PWM Disabled.
N     * |        |          |1 = Timer interrupt trigger PWM Enabled.
N     * |        |          |Note: If TRGSSEL (TIMERx_TRGCTL[0]) = 0, time-out interrupt signal will as trigger PWM counter clock source.
N     * |        |          |If TRGSSEL (TIMERx_TRGCTL[0]) = 1, capture interrupt signal as PWM counter clock source will trigger PWM.
N     * |[2]     |TRGADC    |Trigger ADC Enable Bit
N     * |        |          |If this bit is set to 1, each timer time-out event interrupt or capture interrupt event can be triggered ADC conversion.
N     * |        |          |0 = Timer interrupt trigger ADC Disabled.
N     * |        |          |1 = Timer interrupt trigger ADC Enabled.
N     * |        |          |Note: If TRGSSEL (TIMERx_TRGCTL[0]) = 0, time-out interrupt signal will trigger EADC conversion.
N     * |        |          |If TRGSSEL (TIMERx_TRGCTL[0]) = 1, capture interrupt signal will trigger EADC conversion.
N     * |[4]     |TRGPDMA   |Trigger PDMA Enable Bit
N     * |        |          |If this bit is set to 1, each timer time-out interrupt event or capture interrupt event can be triggered PDMA transfer.
N     * |        |          |0 = Timer interrupt trigger PDMA Disabled.
N     * |        |          |1 = Timer interrupt trigger PDMA Enabled.
N     * |        |          |Note: If TRGSSEL (TIMERx_TRGCTL[0]) = 0, time-out interrupt signal will trigger PDMA transfer.
N     * |        |          |If TRGSSEL (TIMERx_TRGCTL[0]) = 1, capture interrupt signal will trigger PDMA transfer.
N     * @var TIMER_T::ALTCTL
N     * Offset: 0x20  Timer Alternative Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |FUNCSEL   |Function Selection
N     * |        |          |0 = Timer controller is used as timer function.
N     * |        |          |1 = Timer controller is used as PWM function.
N     * |        |          |Note: When timer is used as PWM, the clock source of time controller will be forced to PCLKx automatically.
N     * @var TIMER_T::PWMCTL
N     * Offset: 0x40  Timer PWM Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CNTEN     |PWM Counter Enable Bit
N     * |        |          |0 = PWM counter and clock prescale Stop Running.
N     * |        |          |1 = PWM counter and clock prescale Start Running.
N     * |[2:1]   |CNTTYPE   |PWM Counter Behavior Type
N     * |        |          |00 = Up count type.
N     * |        |          |01 = Down count type.
N     * |        |          |10 = Up-down count type.
N     * |        |          |11 = Reserved.
N     * |[3]     |CNTMODE   |PWM Counter Mode
N     * |        |          |0 = Auto-reload mode.
N     * |        |          |1 = One-shot mode.
N     * |[8]     |CTRLD     |Center Re-Load
N     * |        |          |In up-down count type, PERIOD will load to PBUF when current PWM period is completedat the end point of each period
N     * |        |          |always and CMPDAT will load to CMPBUF at the center point of current period at the center point of a period.
N     * |[9]     |IMMLDEN   |Immediately Load Enable Bit
N     * |        |          |0 = PERIOD will load to PBUF when current PWM period is completed no matter CTRLD is enabled/disabled.at the end point of each period
N     * |        |          |If CTRLD is disabled, CMPDAT will load to CMPBUF when current PWM period is completed; if CTRLD is enabled in up-down count type, CMPDAT will load to CMPBUF at the center point of current period at the end point of each period by setting CTRLD bit.
N     * |        |          |1 = PERIOD//CMPDAT will load to PBUF and /CMPBUF immediately when usersoftware update PPERIOD//CMPDAT.
N     * |        |          |Note: If IMMLDEN is enabled, CTRLD will be invalid.
N     * |[16]    |OUTMODE   |PWM Output Mode
N     * |        |          |0 = PWM independent mode.
N     * |        |          |1 = PWM complementary mode.
N     * |[30]    |DBGHALT   |ICE Debug Mode Counter Halt (Write Protect)
N     * |        |          |If debug mode counter halt is enabled, PWM all counters will keep current value until exit ICE debug mode.
N     * |        |          |0 = ICE debug mode counter halt disable.
N     * |        |          |1 = ICE debug mode counter halt enable.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[31]    |DBGTRIOFF |ICE Debug Mode Acknowledge Disable Bit (Write Protect)
N     * |        |          |0 = ICE debug mode acknowledgement effects PWM output.
N     * |        |          |PWM output pin will be forced as tri-state while ICE debug mode acknowledged.
N     * |        |          |1 = ICE debug mode acknowledgement disabled.
N     * |        |          |PWM output pin will keep output no matter ICE debug mode acknowledged or not.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * @var TIMER_T::PWMCLKSRC
N     * Offset: 0x44  Timer PWM Counter Clock Source Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |CLKSRC    |PWM Counter External Clock Source Select
N     * |        |          |The PWM counter clock source can be selected from TMRx_CLK or internal timer time-out or capture event.
N     * |        |          |000 = TMRx_CLK.
N     * |        |          |001 = Internal TIMER0 time-out or capture event overflow.
N     * |        |          |010 = Internal TIMER1 time-out or capture event TIMER1 overflow.
N     * |        |          |011 = Internal TIMER2 time-out or capture event TIMER2 overflow.
N     * |        |          |100 = Internal TIMER3 time-out or capture event TIMER3 overflow.
N     * |        |          |Others = Reserved.
N     * |        |          |Note: If TIMER0 PWM function is enabled, trigger sourcthe PWM counter clock source can be selected from TMR0_CLK, TIMER1 interrupt events, TIMER2 interrupt events, or TIMER3 interrupt eventse from different TIMER1, TIMER2, and TIMER3u2019s overflow.
N     * @var TIMER_T::PWMCLKPSC
N     * Offset: 0x48  Timer PWM Counter Clock Pre-scale Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-Scale
N     * |        |          |The active clock of PWM counter is decided by counter clock prescale and
N     * |        |          |Each PWM channel pair share one PWM counter clock prescale
N     * |        |          |The clock of PWM counter is divided by (CLKPSC + 1)
N     * |        |          |If CLKPSC is 0, then there is no scaling in PWM counter clock source.
N     * @var TIMER_T::PWMCNTCLR
N     * Offset: 0x4C  Timer PWM Clear Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CNTCLR    |Clear PWM Counter Control Bit
N     * |        |          |It is automatically cleared by hardware.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear 16-bit PWM counter to 0000 0x10000 in up and up-down count type and reset counter value to PERIOD in down count type.H.
N     * @var TIMER_T::PWMPERIOD
N     * Offset: 0x50  Timer PWM Period Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PERIOD    |PWM Period Register
N     * |        |          |In uUp cCount typemode: In this mode, PWM counter counts from 00 to PERIOD, and restarts from 00.
N     * |        |          |In dDown cCount typemode: In this mode, PWM counter counts from PERIOD to 0, and restarts from PERIOD.
N     * |        |          |In up-down count type: PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
N     * |        |          |In up and down count type:
N     * |        |          |PWM period time = (PERIOD + 1) ** (CLKPSC + 1) x * TMRx_PWMCLK.
N     * |        |          |In up-down count type:
N     * |        |          |Up-Down Count mode: In this mode, PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
N     * |        |          |PWM period time = 2 * * PERIOD * * (CLKPSC+ 1) x * TMRx_PWMCLK
N     * |        |          |Note: User should take care DIRF (TIMERx_PWMCNT[16]) bit in up/down/up-down count type to monitor current counter direction in each count type..
N     * @var TIMER_T::PWMCMPDAT
N     * Offset: 0x54  Timer PWM Comparator Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMPDAT    |PWM Comparator
N     * |        |          |PWM CMPDAT is used to compare with PWM CNT to generate PWM output waveform, interrupt events and trigger ADC to start convert.
N     * @var TIMER_T::PWMDTCTL
N     * Offset: 0x58  Timer PWM Dead-Time Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |DTCNT     |Dead-Time Counter (Write Protect)
N     * |        |          |The dead-time can be calculated from the following two formulas:
N     * |        |          |Dead-time = (DTCNT[11:0] + 1) * * TMRx_PWMCLK, if DTCKSEL is 0.
N     * |        |          |Dead-time = (DTCNT[11:0] + 1) * TMRx_PWMCLK * (CLKPSC + 1), if DTCKSEL is 1.
N     * |        |          |period.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[16]    |DTEN      |Enable Dead-Time Insertion For PWM Pair (PWMx_CH0 and, PWMx_CH1) (PWM_CH2, PWM_CH3) (Write Protect)
N     * |        |          |Dead-time insertion function is only active when this pair of complementary PWM complementary mode is enabled
N     * |        |          |If dead- time insertion is inactive, the outputs of pin PWMx_CH0 and PWMx_CH1pair are complementary without any delay.
N     * |        |          |0 = Dead-time insertion Disabled on the pin pair.
N     * |        |          |1 = Dead-time insertion Enabled on the pin pair.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[24]    |DTCKSEL   |Dead-Ttime Cclock Sselect (Write Protect)
N     * |        |          |0 = Dead-time clock source from TMRx_PWMCLK without counter clock prescale.
N     * |        |          |1 = Dead-time clock source from TMRx_PWMCLK with counter clock prescale prescale output.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL REGWRPROT register.
N     * @var TIMER_T::PWMCNT
N     * Offset: 0x5C  Timer PWM Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CNT       |PWM Counter ValueData Register (Read Only)
N     * |        |          |User can monitor CNTR to know the current counter value in 16-bit period counter.
N     * |[16]    |DIRF      |PWM Counter Direction Indicator Flag (Read Only)
N     * |        |          |0 = Counter is active in dDown count.
N     * |        |          |1 = Counter is active upUP count.
N     * @var TIMER_T::PWMMSKEN
N     * Offset: 0x60  Timer PWM Output Mask Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |MSKEN0    |PWMx_CH0 Output Mask Enable Bit
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |The PWMx_CH0 output signal will be masked when this bit is enabled
N     * |        |          |The corresponding PWMx_CH0 channel n will output MSKDAT0n (TIMER_PWM_MSK[1:0]) data.
N     * |        |          |0 = PWMx_CH0 output signal is non-masked.
N     * |        |          |1 = PWMx_CH0M output signal is masked and output MSKDAT0n data.
N     * |        |          |Note: n=0, 1.
N     * |[1]     |MSKEN1    |PWMx_CH1 Output Mask Enable Bit
N     * |        |          |The PWMx_CH1 output signal will be masked when this bit is enabled
N     * |        |          |The PWMx_CH1 will output MSKDAT1 (TIMER_PWMMSK[1]) data.
N     * |        |          |0 = PWMx_CH1 output signal is non-masked.
N     * |        |          |1 = PWMx_CH1 output signal is masked and output MSKDAT1 data.
N     * @var TIMER_T::PWMMSK
N     * Offset: 0x64  Timer PWM Output Mask Data Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |MSKDAT0   |PWMx_CH0 Output Mask Data Control Bit Bit
N     * |        |          |This bit is used to control the output state of PWMx_CH0 pin whenThis data bit control the state of PWMn output pin, if PWMx_CH0 correspooutput nding mask mask function is enabled (MSKEN0 = 1)
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Output logic Llow to PWMnPWMx_CH0.
N     * |        |          |1 = Output logic Hhigh to PWMx_CH0PWMn.
N     * |        |          |Note: n=0, 1.
N     * |[1]     |MSKDAT1   |PWMx_CH1 Output Mask Data Control Bit
N     * |        |          |This bit is used to control the output state of PWMx_CH1 pin when PWMx_CH1 output mask function is enabled (MSKEN1 = 1).
N     * |        |          |0 = Output logic Low to PWMx_CH1.
N     * |        |          |1 = Output logic High to PWMx_CH1.
N     * @var TIMER_T::PWMBNF
N     * Offset: 0x68  Timer PWM Brake Pin Noise Filter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BRKNFEN   |Brake Pin Noise Filter Enable Bit
N     * |        |          |0 = Pin dDe-bBounce detect of TMR_BRAKEx Disabled.
N     * |        |          |1 = Pin dDe-bBounce detect of TMR_BRAKEx Enabled.
N     * |[3:1]   |BRKNFSEL  |Brake Edge Pin Detector De-Bounce Clock Selection
N     * |        |          |000 = De-Bounce clock = is PCLKx.
N     * |        |          |001 = De-Bounce clock = is PCLKx/2.
N     * |        |          |010 = De-Bounce clock = is PCLKx/4.
N     * |        |          |011 = De-Bounce clock = is PCLKx/8.
N     * |        |          |100 = De-Bounce clock = is PCLKx/16.
N     * |        |          |101 = De-Bounce clock = is PCLKx/32.
N     * |        |          |110 = De-Bounce clock = is PCLKx/64.
N     * |        |          |111 = De-Bounce clock = is PCLKx/128.
N     * |[6:4]   |BRKFCNT   |Brake Pin Edge Detector De-Bounce Count
N     * |        |          |The register fields is used to bits control the active de-bounce sample time.
N     * |        |          |Once de-bounce sample time = (Period time of BRKDBCS)Brake0 filter counter to count from 0 to BRK0FCNT
N     * |        |          |* BRKDBCNT.
N     * |[7]     |BRKPINV   |Brake Pin InverseDetection Control Bit
N     * |        |          |0 = The state of pin TM_BRAKEx is passed to the negative edge detector. x=0~3.
N     * |        |          |Set BRKPINV 0 will detect TM_BRAKEx Brake pin event will be detected if TM_BRAKEx pin status transfer from from low lowto to high in edge-detect, or pin status is high in level-detect.high
N     * |        |          |1 = Brake pin event will be detected if TM_BRAKEx pin status transfer from high to low in edge-detect, or pin status is low in level-detect The inversed state of pin TM_BRAKEx is passed to the negative edge detector
N     * |        |          |x=0~3.
N     * |        |          |Set BRKPINV 1 will detect TM_BRAKEx pin status from high to low.
N     * |[17:16] |BKPINSRC  |Brake Pin Source Select
N     * |        |          |00 = Brake pin source comes from TMR_BRAKE0.
N     * |        |          |01 = Brake pin source comes from TMR_BRAKE1.
N     * |        |          |10 = Brake pin source comes from TMR_BRAKE2.
N     * |        |          |11 = Brake pin source comes from TMR_BRAKE3.
N     * @var TIMER_T::PWMFAILBRK
N     * Offset: 0x6C  Timer PWM System Fail Brake Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CSSBRKEN  |Clock Security System Detection Trigger PWM Brake Function Enable Bit
N     * |        |          |0 = Brake Function triggered by CSS clock fail detection Disabled.
N     * |        |          |1 = Brake Function triggered by clock fail CSS detection Enabled.
N     * |        |          |Note: This register is only in TIMER0 and TIMER2.
N     * |[1]     |BODBRKEN  |Brown-Out Detection Trigger PWM Brake Function Enable Bit
N     * |        |          |0 = Brake Function triggered by BOD event Disabled.
N     * |        |          |1 = Brake Function triggered by BOD event Enabled.
N     * |        |          |Note: This register is only in TIMER0 and TIMER2.
N     * |[3]     |CORBRKEN  |Core Lockup Detection Trigger PWM Brake Function Enable Bit
N     * |        |          |0 = Brake Function triggered by cCore lockup detection event Disabled.
N     * |        |          |1 = Brake Function triggered by cCore lockup detection event Enabled.
N     * |        |          |Note: This register is only in TIMER0 and TIMER2.
N     * @var TIMER_T::PWMBRKCTL
N     * Offset: 0x70  Timer PWM Brake Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CPO0EBEN  |Enable Internal ACMP0_O Digital Output As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = Internal ACMP0_O signal as edge-detect brake source Disabled.
N     * |        |          |1 = Internal ACMP0_O signal as edge-detect brake source Enabled.
N     * |        |          |Note1: Only internal ACMP0_O signal from low to high will be detected as brake event.
N     * |        |          |Note2: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[1]     |CPO1EBEN  |Enable Internal ACMP1_O Digital Output As Edge-detect Brake Source (Write Protect)
N     * |        |          |0 = Internal ACMP1_O signal as edge-detect brake source Disabled.
N     * |        |          |1 = Internal ACMP1_O signal as edge-detect brake source Enabled.
N     * |        |          |Note1: Only internal ACMP1_O signal from low to high will be detected as brake event.
N     * |        |          |Note2: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[4]     |BRKPEEN   |Enable TMR_BRAKEx Pin As Edge-Detect Brake Source (Write Protect)
N     * |        |          |0 = TMR_BRAKEx pin event as edge-detect brake source Disabled.
N     * |        |          |1 = TMR_BRAKEx pin event as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[7]     |SYSEBEN   |Enable System Fail As Edge-Detect Brake Source (Write Protect)
N     * |        |          |0 = System fFail condition as edge-detect brake source Disabled.
N     * |        |          |1 = System fFail condition as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[8]     |CPO0LBEN  |Enable Internal ACMP0_O Digital Output As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = Internal ACMP0_O signal as level-detect brake source Disabled.
N     * |        |          |1 = Internal ACMP0_O signal as level-detect brake source Enabled.
N     * |        |          |Note1: Only internal ACMP0_O signal from low to high will be detected as brake event.
N     * |        |          |Note2: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[9]     |CPO1LBEN  |Enable Internal ACMP1_O Digital Output As Level-detect Brake Source (Write Protect)
N     * |        |          |0 = Internal ACMP1_O signal as level-detect brake source Disabled.
N     * |        |          |1 = Internal ACMP1_O signal as level-detect brake source Enabled.
N     * |        |          |Note1: Only internal ACMP1_O signal from low to high will be detected as brake event.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[12]    |BRKPLEN   |Enable TMR_BRAKEx Pin As Level-Detect Brake Source (Write Protect)
N     * |        |          |0 = TMR_BRAKEx Brake pin event as level-detect brake source Disabled.
N     * |        |          |1 = TMR_BRAKEx Brake pin event as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[15]    |SYSLBEN   |Enable System Fail As Level-Detect Brake Source (Write Protect)
N     * |        |          |0 = System fFail condition as level-detect brake source Disabled.
N     * |        |          |1 = System fFail condition as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[17:16] |BRKAEVEN  |PWM Brake Action Select For Even ChannelPWMx_CH0 (Write Protect)
N     * |        |          |00 = TIMERx_PWM even brake eventchannel level-detect brake functi willon not affect channel PWMx_CH0outpu outputt.
N     * |        |          |01 = PWMx_CH0PWM even channel output tri-state when TIMERx_PWM brake eventlevel-detect brake happened.
N     * |        |          |10 = PWMx_CH0 outputPWM even channel output low level when TIMERx_PWM brake event level-detect brake happened.
N     * |        |          |11 = PWMx_CH0 outputPWM even channel output high level when TIMERx_PWM brake eventlevel-detect brake happened.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[19:18] |BRKAODD   |PWM Brake Action Select For PWMx_CH1Odd Channel (Write Protect)
N     * |        |          |00 = TIMERx_PWM brake event will not affect PWMx_CH1 output.
N     * |        |          |01 = PWMx_CH1 output tri-state when TIMERx_PWM brake event happened.
N     * |        |          |10 = PWMx_CH1 output low level when TIMERx_PWM brake event happened.
N     * |        |          |11 = PWMx_CH1 output high level when TIMERx_PWM brake event happened.
N     * |        |          |00 = TIMER_PWM odd channel level-detect brake function not affect channel output.
N     * |        |          |01 = TIMER_PWM odd channel output tri-state when level-detect brake happened.
N     * |        |          |10 = TIMER_PWM odd channel output low level when level-detect brake happened.
N     * |        |          |11 = TIMER_PWM odd channel output high level when level-detect brake happened.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * @var TIMER_T::PWMPOLCTL
N     * Offset: 0x74  Timer PWM Output Pin Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PINV0     |PWMx_CH0 Output Pin Polar Control Bit
N     * |        |          |The register bit is used to controlcontrols polarity state of PWMx_CH0 output pin
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWMx_CH0 output pin polar inverse Disabled.
N     * |        |          |1 = PWMx_CH0 output pin PWM output polar inverse Enabled.
N     * |        |          |n=0, 1.
N     * |[1]     |PINV1     |PWMx_CH1 Output Pin Polar Control Bit
N     * |        |          |The bit is used to control polarity state of PWMx_CH1 output pin.
N     * |        |          |0 = PWMx_CH1 output pin polar inverse Disabled.
N     * |        |          |1 = PWMx_CH1 output pin polar inverse Enabled.
N     * @var TIMER_T::PWMPOEN
N     * Offset: 0x78  Timer PWM Output Pin Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |POEN0     |PWMx_CH0 Output Pin Output Enable Bit
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWMx_CH0 pin at tri-state mode.
N     * |        |          |1 = PWMx_CH0PWM pin in output mode.
N     * |        |          |n=0, 1.
N     * |[1]     |POEN1     |PWMx_CH1 Output Pin Enable Bit
N     * |        |          |0 = PWMx_CH1 pin at tri-state mode.
N     * |        |          |1 = PWMx_CH1 pin in output mode.
N     * @var TIMER_T::PWMSWBRK
N     * Offset: 0x7C  Timer PWM Software Trigger Brake Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BRKETRG   |PWM Software Trigger Edge-Detect Brake SourceSoftware Trigger (Write Only) (Write Protect)
N     * |        |          |Write 1 to this bit will trigger PWM edge-detect brake source, then BRKEIF0 and BRKEIF1 will set to 1 automatically in TIMERx_PWMINTSTS1, and set BRKEIF to 1 in PWM_INTSTS1 register.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[8]     |BRKLTRG   |Software Trigger Level-Detect Brake Source PWM Level Brake Software Trigger (Write Only) (Write Protect)
N     * |        |          |Write 1 to this bit will trigger PWM level-detect brake source, and then set BRKLIF0 and BRKLIF1 will set to 1 automatically in TIMERx_PWM_INTSTS1 register.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * @var TIMER_T::PWMINTEN0
N     * Offset: 0x80  Timer PWM Interrupt Enable Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ZIEN      |PWM Zero Point Interrupt Enable Bit
N     * |        |          |0 = Zero point interrupt Disabled.
N     * |        |          |1 = Zero point interrupt Enabled.
N     * |        |          |Note: Odd channels will read always 0 at complementary mode.
N     * |[1]     |PIEN      |PWM Period Point Interrupt Enable Bit
N     * |        |          |0 = Period point interrupt Disabled.
N     * |        |          |1 = Period point interrupt Enabled.
N     * |        |          |Note: When When in up-down count type, period point means the center point of current PWM period.
N     * |[2]     |CMPUIEN   |PWM Compare Up Count Interrupt Enable Bit
N     * |        |          |0 = Compare up count interrupt Disabled.
N     * |        |          |1 = Compare up count interrupt Enabled.
N     * |[3]     |CMPDIEN   |PWM Compare Down Count Interrupt Enable Bit
N     * |        |          |0 = Compare down count interrupt Disabled.
N     * |        |          |1 = Compare down count interrupt Enabled.
N     * @var TIMER_T::PWMINTEN1
N     * Offset: 0x84  Timer PWM Interrupt Enable Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BRKEIEN   |PWM Edge-Detect Brake Interrupt Enable For Channel0/1 (Write Protect)
N     * |        |          |0 = PWM eEdge-detect Brake brake interrupt for channel0/1 Disabled.
N     * |        |          |1 = PWM eEdge-detect Brake brake interrupt for channel0/1 Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[8]     |BRKLIEN   |PWM Level-Detect Brake Interrupt Enable For Channel0/1 (Write Protect)
N     * |        |          |0 = PWM lLevel-detect Brake brake interrupt for channel0/1 Disabled.
N     * |        |          |1 = PWM level-detect brake interruptLevel-detect Brake interrupt for channel0/1 Enabled.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * @var TIMER_T::PWMINTSTS0
N     * Offset: 0x88  Timer PWM Interrupt Status Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ZIF       |PWM Zero Point Interrupt Flag
N     * |        |          |This bit is set by hardware when TIMERx_PWM_CHx counter reaches zero, software can write 1 to clear this bit to zero
N     * |        |          |x=0, 1..
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[1]     |PIF       |PWM Period Point Interrupt Flag
N     * |        |          |This bit is set by hardware when TIMERx_PWMPWM_CHx counter reaches PWMPERIOD.
N     * |        |          |Note: This bit is cleared by writing 1 to it.Note1: When in up-down count type, PIF flag means the center point flag of current PWM period.
N     * |        |          |Note2: This bit is cleared by writing 1 to it., software can write 1 to clear this bit to zero. x=0, 1.
N     * |[2]     |CMPUIF    |PWM Compare Up Count Interrupt Flag
N     * |        |          |Flag This bit is set by hardware when TIMERx_PWMPWM counter in up count direction and reaches PWMCMPDAT.,
N     * |        |          |Note1: This bit is cleared by writing 1 to it. software can clear this bit by writing 1 to it.
N     * |        |          |Note12: If CMPDAT equal to PERIOD, there is no CMPUIF flag this flag is not working in up count type and up-down count type
N     * |        |          |selection.
N     * |        |          |Note2: This bit is cleared by writing 1 to it.
N     * |[3]     |CMPDIF    |PWM Compare Down Count Interrupt Flag
N     * |        |          |Flag This bit is set by hardware when TIMERx_PWM PWM counter in down count direction and reaches PWMCMPDAT, software can clear this bit by writing 1 to it.
N     * |        |          |Note1: This bit is cleared by writing 1 to it.
N     * |        |          |Note12: If CMPDAT equal to PERIOD, this there is no CMPDIFflag flag is not working in down count type selection.
N     * |        |          |Note2: This bit is cleared by writing 1 to it.
N     * @var TIMER_T::PWMINTSTS1
N     * Offset: 0x8C  Timer PWM Interrupt Status Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BRKEIF0   |PWM Channel0 Edge-Detect Brake Interrupt Flag on PWMx_CH0 (Write Protect)
N     * |        |          |0 = PWMx_CH0 channel0 edge-detect brake event do not happened.
N     * |        |          |1 = PWMx_CH0When PWM channel0 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
N     * |        |          |Note1: This bit is cleared by writing 1 to it.
N     * |        |          |Note2: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[1]     |BRKEIF1   |PWM Channel1 Edge-Detect Brake Interrupt Flag PWMx_CH1 (Write Protect)
N     * |        |          |0 = PWMx_CH1 edge-detect brake event do not happened.
N     * |        |          |1 = PWMx_CH1 edge-detect brake event happened.
N     * |        |          |0 = PWM channel1 edge-detect brake event do not happened.
N     * |        |          |1 = When PWM channel1 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
N     * |        |          |Note1: This bit is cleared by writing 1 to it.
N     * |        |          |Note2: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[8]     |BRKLIF0   |PWM Channel0 Level-Detect Brake Interrupt Flag on PWMx_CH0 (Write Protect)
N     * |        |          |0 = PWMx_CH0PWM channel0 level-detect brake event do not happened.
N     * |        |          |1 = PWMx_CH0When PWM channel0 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
N     * |        |          |Note1: This bit is cleared by writing 1 to it.
N     * |        |          |Note2: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[9]     |BRKLIF1   |PWM Channel1 Level-Detect Brake Interrupt Flag on PWMx_CH1 (Write Protect)
N     * |        |          |0 = PWMx_CH1 level-detect brake event do not happened.
N     * |        |          |1 = PWMx_CH1 level-detect brake event happened.
N     * |        |          |0 = PWM channel1 level-detect brake event do not happened.
N     * |        |          |1 = When PWM channel1 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
N     * |        |          |Note1: This bit is cleared by writing 1 to it.
N     * |        |          |Note2: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[16]    |BRKESTS0  |Edge -Detect Brake Status of PWMx_CH0 (Read Only)
N     * |        |          |0 = PWMx_CH0 edge-detect brake state is released.
N     * |        |          |1 = PWMx_CH0 at edge-detect brake state.
N     * |        |          |Note: User can set BRKEIF0 1 to clear BRKEIF0 flag and PWMx_CH0 will release brake state when current PWM period finished and resume PWMx_CH0 output waveform start from next full PWM period.PWM Channel0 Edge-Detect Brake Status (Read Only)
N     * |        |          |0 = PWM channel0 edge-detect brake state is released.
N     * |        |          |1 = When PWM channel0 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel0 at brake state.
N     * |[17]    |BRKESTS1  |PWM Channel1 Edge-Detect Brake Status of PWMx_CH1 (Read Only)
N     * |        |          |0 = PWMx_CH1 edge-detect brake state is released.
N     * |        |          |1 = PWMx_CH1 at edge-detect brake state.
N     * |        |          |Note: User can set BRKEIF1 1 to clear BRKEIF1 flag and PWMx_CH1 will release brake state when current PWM period finished and resume PWMx_CH1 output waveform start from next full PWM period.0 = PWM channel1 edge-detect brake state is released.
N     * |        |          |1 = When PWM channel1 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel1 at brake state.
N     * |[24]    |BRKLSTS0  |PWM Channel0 Level-Detect Brake Status of PWMx_CH0 (Read Only)
N     * |        |          |0 = PWMx_CH0PWM channel0 level-detect brake state is released.
N     * |        |          |1 = PWMx_CH0 at level-detect brake stateWhen PWM channel0 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel0 at brake state.
N     * |        |          |Note: This bit is read only and auto cleared by hardware
N     * |        |          |WhenIf TIMERx_PWM enabled level-detect brake source has released, both return to high level, PWMx_CH0 and PWMx_CH1PWM will release brake state until when current PWM period finished and resume
N     * |        |          |The PWMx_CH0 and PWMx_CH1 output waveform will start output from next full PWM period.
N     * |[25]    |BRKLSTS1  |PWM Channel1 Level-Detect Brake Status of PWMx_CH1 (Read Only)
N     * |        |          |0 = PWMx_CH1PWM channel1 level-detect brake state is released.
N     * |        |          |1 = PWMx_CH1 at level-detect brake state.
N     * |        |          |Note: If TIMERx_PWM level-detect brake source has released, both PWMx_CH0 and PWMx_CH1 will release brake state when current PWM period finished and resume PWMx_CH0 and PWMx_CH1 output waveform start from next full PWM period.1 = When PWM channel1 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel1 at brake state.
N     * |        |          |Note: This bit is read only and auto cleared by hardware
N     * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished
N     * |        |          |The PWM waveform will start output from next full PWM period.
N     * @var TIMER_T::PWMADCTS
N     * Offset: 0x90  Timer PWM Trigger ADC Source Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |TRGSEL    |PWM Counter Event Source Select To Trigger ADC ConversionPWM_CH Trigger ADC Source Select
N     * |        |          |000 = Trigger ADC conversion at PWM_CH0 zero point. (ZIF).
N     * |        |          |001 = Trigger ADC conversion atPWM_CH0 period point. (PIF).
N     * |        |          |010 = Trigger ADC conversion atPWM_CH0 zero or period point. (ZIF or PIF).
N     * |        |          |011 = Trigger ADC conversion atPWM_CH0 compare up count CMPDAT point (CMPUIF).
N     * |        |          |100 = Trigger ADC conversion atPWM_CH0 compare down count CMPDAT point (CMPDIF).
N     * |        |          |Others = Rreserved.
N     * |[7]     |TRGEN     |PWM Counter Event Trigger ADC Conversion Enable Bit
N     * |        |          |0 = PWM counter event trigger ADC conversion Disabled.
N     * |        |          |1 = PWM counter event trigger ADC conversion Enabled.PWM_CH0 Trigger ADC enable bit.
N     * @var TIMER_T::PWMSCTL
N     * Offset: 0x94  Timer PWM Synchronous Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |SYNCMODE  |PWM Synchronous Mode Enable Select
N     * |        |          |00 = PWM synchronous function Disabled.
N     * |        |          |01 = PWM synchronous counter start function Enabled.
N     * |        |          |10 = Reserved.
N     * |        |          |11 = PWM synchronous counter clear function Enabled.
N     * |[8]     |SYNCSRC   |PWM Synchronous Counter Start/Clear Start Source Select
N     * |        |          |0 = Counter sSynchronous start/clear source by triggercome from TIMER0_PWMSSTRG STRGENCNTSEN.
N     * |        |          |1 = Counter sSynchronous start/clear source by triggercome from TIMER2_PWMSSTRG STRGENCNTSEN.
N     * |        |          |Note1: If TIMER0/1/2/3 PWM counter synchronous source are from TIMER0, TIME0_PWMSCTL[8], TIME1_PWMSCTL[8], TIME2_PWMSCTL[8] and TIME3_PWMSCTL[8] should be 0.
N     * |        |          |Note2: If TIMER0/1/ PWM counter synchronous source are from TIMER0, TIME0_PWMSCTL[8] and TIME1_PWMSCTL[8] should be set 0, and TIMER2/3/ PWM counter synchronous source are from TIMER2, TIME2_PWMSCTL[8] and TIME3_PWMSCTL[8] should be set 1.Note: This register is only in TIMER0 and TIMER2.
N     * @var TIMER_T::PWMSTRG
N     * Offset: 0x98  Timer PWM Synchronous Trigger Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |STRGEN    |PWM Counter Counter Synchronous Trigger Enable BitStart Enable (Write Only)
N     * |        |          |PMW counter synchronous enable function is used to make selected PWM channels (include TIMER0/1/2/3_ PWM, _CHx and TIMER02/1 PWM and TIMER2/33_ PWM_CHx) start counting or clear counter at the same time according to TIMERx_PWMSCTL setting.
N     * |        |          |Writing this bit to 1 will also set the counter enable bit (CNTEN) if correlated PWM channel counter synchronous start function is enabled.
N     * |        |          |Note: This register bit is only available in TIMER0 and TIMER2.
N     * @var TIMER_T::PWMSTATUS
N     * Offset: 0x9C  Timer PWM Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CNTMAXF   |Time-BasePWM Counter Counter Equal To 0xFFFF Latched SStatus
N     * |        |          |0 = Iindicates the timePWM counter-base coun valueter never reached its maximum value 0xFFFF.
N     * |        |          |1 = Iindicates the PWM counter value has time-base counter reached its maximum value, software can write 1 to clear this bit.e.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[16]    |ADCTRGF   |Trigger ADC Start Of Conversion Status
N     * |        |          |0 = PWM counter event trigger ADC start conversion is not occurred.Indicates no ADC start of conversion trigger event has occurred.
N     * |        |          |1 = PWM counter event trigger ADC start conversion has occurredIndicates an ADC start of conversion trigger event has occurred, software can write 1 to clear this bit..
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * @var TIMER_T::PWMPBUF
N     * Offset: 0xA0  Timer PWM Period Buffer Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PBUF      |PWM Period Buffer Register Buffer (Read Only)
N     * |        |          |Used as PERIOD active register.
N     * @var TIMER_T::PWMCMPBUF
N     * Offset: 0xA4  Timer PWM Comparator Buffer Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMPBUF    |PWM Comparator Buffer Register Buffer (Read Only)
N     * |        |          |Used as CMPDAT active register.
N     */
N
N    __IO uint32_t CTL;                   /*!< [0x0000] Timer Control Register                                           */
X    volatile uint32_t CTL;                    
N    __IO uint32_t CMP;                   /*!< [0x0004] Timer Comparator Register                                        */
X    volatile uint32_t CMP;                    
N    __IO uint32_t INTSTS;                /*!< [0x0008] Timer Interrupt Status Register                                  */
X    volatile uint32_t INTSTS;                 
N    __IO uint32_t CNT;                   /*!< [0x000c] Timer Data Register                                              */
X    volatile uint32_t CNT;                    
N    __I  uint32_t CAP;                   /*!< [0x0010] Timer Capture Data Register                                      */
X    volatile const  uint32_t CAP;                    
N    __IO uint32_t EXTCTL;                /*!< [0x0014] Timer External Control Register                                  */
X    volatile uint32_t EXTCTL;                 
N    __IO uint32_t EINTSTS;               /*!< [0x0018] Timer External Interrupt Status Register                         */
X    volatile uint32_t EINTSTS;                
N    __IO uint32_t TRGCTL;                /*!< [0x001c] Timer Trigger Control Register                                   */
X    volatile uint32_t TRGCTL;                 
N    __IO uint32_t ALTCTL;                /*!< [0x0020] Timer Alternative Control Register                               */
X    volatile uint32_t ALTCTL;                 
N    __I  uint32_t RESERVE0[7];
X    volatile const  uint32_t RESERVE0[7];
N    __IO uint32_t PWMCTL;                /*!< [0x0040] Timer PWM Control Register                                       */
X    volatile uint32_t PWMCTL;                 
N    __IO uint32_t PWMCLKSRC;             /*!< [0x0044] Timer PWM Counter Clock Source Register                          */
X    volatile uint32_t PWMCLKSRC;              
N    __IO uint32_t PWMCLKPSC;             /*!< [0x0048] Timer PWM Counter Clock Pre-scale Register                       */
X    volatile uint32_t PWMCLKPSC;              
N    __IO uint32_t PWMCNTCLR;             /*!< [0x004c] Timer PWM Clear Counter Register                                 */
X    volatile uint32_t PWMCNTCLR;              
N    __IO uint32_t PWMPERIOD;             /*!< [0x0050] Timer PWM Period Register                                        */
X    volatile uint32_t PWMPERIOD;              
N    __IO uint32_t PWMCMPDAT;             /*!< [0x0054] Timer PWM Comparator Register                                    */
X    volatile uint32_t PWMCMPDAT;              
N    __IO uint32_t PWMDTCTL;              /*!< [0x0058] Timer PWM Dead-Time Control Register                             */
X    volatile uint32_t PWMDTCTL;               
N    __I  uint32_t PWMCNT;                /*!< [0x005c] Timer PWM Counter Register                                       */
X    volatile const  uint32_t PWMCNT;                 
N    __IO uint32_t PWMMSKEN;              /*!< [0x0060] Timer PWM Output Mask Enable Register                            */
X    volatile uint32_t PWMMSKEN;               
N    __IO uint32_t PWMMSK;                /*!< [0x0064] Timer PWM Output Mask Data Control Register                      */
X    volatile uint32_t PWMMSK;                 
N    __IO uint32_t PWMBNF;                /*!< [0x0068] Timer PWM Brake Pin Noise Filter Register                          */
X    volatile uint32_t PWMBNF;                 
N    __IO uint32_t PWMFAILBRK;            /*!< [0x006c] Timer PWM System Fail Brake Control Register                     */
X    volatile uint32_t PWMFAILBRK;             
N    __IO uint32_t PWMBRKCTL;             /*!< [0x0070] Timer PWM Brake Control Register                                 */
X    volatile uint32_t PWMBRKCTL;              
N    __IO uint32_t PWMPOLCTL;             /*!< [0x0074] Timer PWM Pin Output Control Register                            */
X    volatile uint32_t PWMPOLCTL;              
N    __IO uint32_t PWMPOEN;               /*!< [0x0078] Timer PWM Pin Output Enable Register                             */
X    volatile uint32_t PWMPOEN;                
N    __O  uint32_t PWMSWBRK;              /*!< [0x007c] Timer PWM Software Trigger Brake Control Register                */
X    volatile  uint32_t PWMSWBRK;               
N    __IO uint32_t PWMINTEN0;             /*!< [0x0080] Timer PWM Interrupt Enable Register 0                            */
X    volatile uint32_t PWMINTEN0;              
N    __IO uint32_t PWMINTEN1;             /*!< [0x0084] Timer PWM Interrupt Enable Register 1                            */
X    volatile uint32_t PWMINTEN1;              
N    __IO uint32_t PWMINTSTS0;            /*!< [0x0088] Timer PWM Interrupt Status Register 0                            */
X    volatile uint32_t PWMINTSTS0;             
N    __IO uint32_t PWMINTSTS1;            /*!< [0x008c] Timer PWM Interrupt Status Register 1                            */
X    volatile uint32_t PWMINTSTS1;             
N    __IO uint32_t PWMADCTS;              /*!< [0x0090] Timer PWM ADC Trigger Source Select Register                     */
X    volatile uint32_t PWMADCTS;               
N    __IO uint32_t PWMSCTL;               /*!< [0x0094] Timer PWM Synchronous Control Register                           */
X    volatile uint32_t PWMSCTL;                
N    __O  uint32_t PWMSTRG;               /*!< [0x0098] Timer PWM Synchronous Trigger Register                           */
X    volatile  uint32_t PWMSTRG;                
N    __IO uint32_t PWMSTATUS;             /*!< [0x009c] Timer PWM Status Register                                        */
X    volatile uint32_t PWMSTATUS;              
N    __I  uint32_t PWMPBUF;               /*!< [0x00a0] Timer PWM Period Buffer Register                                 */
X    volatile const  uint32_t PWMPBUF;                
N    __I  uint32_t PWMCMPBUF;             /*!< [0x00a4] Timer PWM Comparator Buffer Register                             */
X    volatile const  uint32_t PWMCMPBUF;              
N
N} TIMER_T;
N
N/**
N    @addtogroup TIMER_CONST TIMER Bit Field Definition
N    Constant Definitions for TIMER Controller
N@{ */
N
N#define TIMER_CTL_PSC_Pos                (0)                                               /*!< TIMER_T::CTL: PSC Position             */
N#define TIMER_CTL_PSC_Msk                (0xfful << TIMER_CTL_PSC_Pos)                     /*!< TIMER_T::CTL: PSC Mask                 */
N
N#define TIMER_CTL_INTRGEN_Pos            (19)                                              /*!< TIMER_T::CTL: INTRGEN Position         */
N#define TIMER_CTL_INTRGEN_Msk            (0x1ul << TIMER_CTL_INTRGEN_Pos)                  /*!< TIMER_T::CTL: INTRGEN Mask             */
N
N#define TIMER_CTL_PERIOSEL_Pos           (20)                                              /*!< TIMER_T::CTL: PERIOSEL Position        */
N#define TIMER_CTL_PERIOSEL_Msk           (0x1ul << TIMER_CTL_PERIOSEL_Pos)                 /*!< TIMER_T::CTL: PERIOSEL Mask            */
N
N#define TIMER_CTL_TGLPINSEL_Pos          (21)                                              /*!< TIMER_T::CTL: TGLPINSEL Position       */
N#define TIMER_CTL_TGLPINSEL_Msk          (0x1ul << TIMER_CTL_TGLPINSEL_Pos)                /*!< TIMER_T::CTL: TGLPINSEL Mask           */
N
N#define TIMER_CTL_CAPSRC_Pos             (22)                                              /*!< TIMER_T::CTL: CAPSRC Position          */
N#define TIMER_CTL_CAPSRC_Msk             (0x1ul << TIMER_CTL_CAPSRC_Pos)                   /*!< TIMER_T::CTL: CAPSRC Mask              */
N
N#define TIMER_CTL_WKEN_Pos               (23)                                              /*!< TIMER_T::CTL: WKEN Position            */
N#define TIMER_CTL_WKEN_Msk               (0x1ul << TIMER_CTL_WKEN_Pos)                     /*!< TIMER_T::CTL: WKEN Mask                */
N
N#define TIMER_CTL_EXTCNTEN_Pos           (24)                                              /*!< TIMER_T::CTL: EXTCNTEN Position        */
N#define TIMER_CTL_EXTCNTEN_Msk           (0x1ul << TIMER_CTL_EXTCNTEN_Pos)                 /*!< TIMER_T::CTL: EXTCNTEN Mask            */
N
N#define TIMER_CTL_ACTSTS_Pos             (25)                                              /*!< TIMER_T::CTL: ACTSTS Position          */
N#define TIMER_CTL_ACTSTS_Msk             (0x1ul << TIMER_CTL_ACTSTS_Pos)                   /*!< TIMER_T::CTL: ACTSTS Mask              */
N
N#define TIMER_CTL_OPMODE_Pos             (27)                                              /*!< TIMER_T::CTL: OPMODE Position          */
N#define TIMER_CTL_OPMODE_Msk             (0x3ul << TIMER_CTL_OPMODE_Pos)                   /*!< TIMER_T::CTL: OPMODE Mask              */
N
N#define TIMER_CTL_INTEN_Pos              (29)                                              /*!< TIMER_T::CTL: INTEN Position           */
N#define TIMER_CTL_INTEN_Msk              (0x1ul << TIMER_CTL_INTEN_Pos)                    /*!< TIMER_T::CTL: INTEN Mask               */
N
N#define TIMER_CTL_CNTEN_Pos              (30)                                              /*!< TIMER_T::CTL: CNTEN Position           */
N#define TIMER_CTL_CNTEN_Msk              (0x1ul << TIMER_CTL_CNTEN_Pos)                    /*!< TIMER_T::CTL: CNTEN Mask               */
N
N#define TIMER_CTL_ICEDEBUG_Pos           (31)                                              /*!< TIMER_T::CTL: ICEDEBUG Position        */
N#define TIMER_CTL_ICEDEBUG_Msk           (0x1ul << TIMER_CTL_ICEDEBUG_Pos)                 /*!< TIMER_T::CTL: ICEDEBUG Mask            */
N
N#define TIMER_CMP_CMPDAT_Pos             (0)                                               /*!< TIMER_T::CMP: CMPDAT Position          */
N#define TIMER_CMP_CMPDAT_Msk             (0xfffffful << TIMER_CMP_CMPDAT_Pos)              /*!< TIMER_T::CMP: CMPDAT Mask              */
N
N#define TIMER_INTSTS_TIF_Pos             (0)                                               /*!< TIMER_T::INTSTS: TIF Position          */
N#define TIMER_INTSTS_TIF_Msk             (0x1ul << TIMER_INTSTS_TIF_Pos)                   /*!< TIMER_T::INTSTS: TIF Mask              */
N
N#define TIMER_INTSTS_TWKF_Pos            (1)                                               /*!< TIMER_T::INTSTS: TWKF Position         */
N#define TIMER_INTSTS_TWKF_Msk            (0x1ul << TIMER_INTSTS_TWKF_Pos)                  /*!< TIMER_T::INTSTS: TWKF Mask             */
N
N#define TIMER_CNT_CNT_Pos                (0)                                               /*!< TIMER_T::CNT: CNT Position             */
N#define TIMER_CNT_CNT_Msk                (0xfffffful << TIMER_CNT_CNT_Pos)                 /*!< TIMER_T::CNT: CNT Mask                 */
N
N#define TIMER_CNT_RSTACT_Pos             (31)                                              /*!< TIMER_T::CNT: RSTACT Position          */
N#define TIMER_CNT_RSTACT_Msk             (0x1ul << TIMER_CNT_RSTACT_Pos)                   /*!< TIMER_T::CNT: RSTACT Mask              */
N
N#define TIMER_CAP_CAPDAT_Pos             (0)                                               /*!< TIMER_T::CAP: CAPDAT Position          */
N#define TIMER_CAP_CAPDAT_Msk             (0xfffffful << TIMER_CAP_CAPDAT_Pos)              /*!< TIMER_T::CAP: CAPDAT Mask              */
N
N#define TIMER_EXTCTL_CNTPHASE_Pos        (0)                                               /*!< TIMER_T::EXTCTL: CNTPHASE Position     */
N#define TIMER_EXTCTL_CNTPHASE_Msk        (0x1ul << TIMER_EXTCTL_CNTPHASE_Pos)              /*!< TIMER_T::EXTCTL: CNTPHASE Mask         */
N
N#define TIMER_EXTCTL_CAPEN_Pos           (3)                                               /*!< TIMER_T::EXTCTL: CAPEN Position        */
N#define TIMER_EXTCTL_CAPEN_Msk           (0x1ul << TIMER_EXTCTL_CAPEN_Pos)                 /*!< TIMER_T::EXTCTL: CAPEN Mask            */
N
N#define TIMER_EXTCTL_CAPFUNCS_Pos        (4)                                               /*!< TIMER_T::EXTCTL: CAPFUNCS Position     */
N#define TIMER_EXTCTL_CAPFUNCS_Msk        (0x1ul << TIMER_EXTCTL_CAPFUNCS_Pos)              /*!< TIMER_T::EXTCTL: CAPFUNCS Mask         */
N
N#define TIMER_EXTCTL_CAPIEN_Pos          (5)                                               /*!< TIMER_T::EXTCTL: CAPIEN Position       */
N#define TIMER_EXTCTL_CAPIEN_Msk          (0x1ul << TIMER_EXTCTL_CAPIEN_Pos)                /*!< TIMER_T::EXTCTL: CAPIEN Mask           */
N
N#define TIMER_EXTCTL_CAPDBEN_Pos         (6)                                               /*!< TIMER_T::EXTCTL: CAPDBEN Position      */
N#define TIMER_EXTCTL_CAPDBEN_Msk         (0x1ul << TIMER_EXTCTL_CAPDBEN_Pos)               /*!< TIMER_T::EXTCTL: CAPDBEN Mask          */
N
N#define TIMER_EXTCTL_CNTDBEN_Pos         (7)                                               /*!< TIMER_T::EXTCTL: CNTDBEN Position      */
N#define TIMER_EXTCTL_CNTDBEN_Msk         (0x1ul << TIMER_EXTCTL_CNTDBEN_Pos)               /*!< TIMER_T::EXTCTL: CNTDBEN Mask          */
N
N#define TIMER_EXTCTL_ACMPSSEL_Pos        (8)                                               /*!< TIMER_T::EXTCTL: ACMPSSEL Position     */
N#define TIMER_EXTCTL_ACMPSSEL_Msk        (0x1ul << TIMER_EXTCTL_ACMPSSEL_Pos)              /*!< TIMER_T::EXTCTL: ACMPSSEL Mask         */
N
N#define TIMER_EXTCTL_CAPEDGE_Pos         (12)                                              /*!< TIMER_T::EXTCTL: CAPEDGE Position      */
N#define TIMER_EXTCTL_CAPEDGE_Msk         (0x7ul << TIMER_EXTCTL_CAPEDGE_Pos)               /*!< TIMER_T::EXTCTL: CAPEDGE Mask          */
N
N#define TIMER_EXTCTL_ECNTSSEL_Pos        (16)                                              /*!< TIMER_T::EXTCTL: ECNTSSEL Position     */
N#define TIMER_EXTCTL_ECNTSSEL_Msk        (0x1ul << TIMER_EXTCTL_ECNTSSEL_Pos)              /*!< TIMER_T::EXTCTL: ECNTSSEL Mask         */
N
N#define TIMER_EINTSTS_CAPIF_Pos          (0)                                               /*!< TIMER_T::EINTSTS: CAPIF Position       */
N#define TIMER_EINTSTS_CAPIF_Msk          (0x1ul << TIMER_EINTSTS_CAPIF_Pos)                /*!< TIMER_T::EINTSTS: CAPIF Mask           */
N
N#define TIMER_TRGCTL_TRGSSEL_Pos         (0)                                               /*!< TIMER_T::TRGCTL: TRGSSEL Position      */
N#define TIMER_TRGCTL_TRGSSEL_Msk         (0x1ul << TIMER_TRGCTL_TRGSSEL_Pos)               /*!< TIMER_T::TRGCTL: TRGSSEL Mask          */
N
N#define TIMER_TRGCTL_TRGPWM_Pos          (1)                                               /*!< TIMER_T::TRGCTL: TRGPWM Position       */
N#define TIMER_TRGCTL_TRGPWM_Msk          (0x1ul << TIMER_TRGCTL_TRGPWM_Pos)                /*!< TIMER_T::TRGCTL: TRGPWM Mask           */
N
N#define TIMER_TRGCTL_TRGADC_Pos          (2)                                               /*!< TIMER_T::TRGCTL: TRGADC Position       */
N#define TIMER_TRGCTL_TRGADC_Msk          (0x1ul << TIMER_TRGCTL_TRGADC_Pos)                /*!< TIMER_T::TRGCTL: TRGADC Mask           */
N
N#define TIMER_TRGCTL_TRGPDMA_Pos         (4)                                               /*!< TIMER_T::TRGCTL: TRGPDMA Position      */
N#define TIMER_TRGCTL_TRGPDMA_Msk         (0x1ul << TIMER_TRGCTL_TRGPDMA_Pos)               /*!< TIMER_T::TRGCTL: TRGPDMA Mask          */
N
N#define TIMER_ALTCTL_FUNCSEL_Pos         (0)                                               /*!< TIMER_T::ALTCTL: FUNCSEL Position      */
N#define TIMER_ALTCTL_FUNCSEL_Msk         (0x1ul << TIMER_ALTCTL_FUNCSEL_Pos)               /*!< TIMER_T::ALTCTL: FUNCSEL Mask          */
N
N#define TIMER_PWMCTL_CNTEN_Pos           (0)                                               /*!< TIMER_T::PWMCTL: CNTEN Position        */
N#define TIMER_PWMCTL_CNTEN_Msk           (0x1ul << TIMER_PWMCTL_CNTEN_Pos)                 /*!< TIMER_T::PWMCTL: CNTEN Mask            */
N
N#define TIMER_PWMCTL_CNTTYPE_Pos         (1)                                               /*!< TIMER_T::PWMCTL: CNTTYPE Position      */
N#define TIMER_PWMCTL_CNTTYPE_Msk         (0x3ul << TIMER_PWMCTL_CNTTYPE_Pos)               /*!< TIMER_T::PWMCTL: CNTTYPE Mask          */
N
N#define TIMER_PWMCTL_CNTMODE_Pos         (3)                                               /*!< TIMER_T::PWMCTL: CNTMODE Position      */
N#define TIMER_PWMCTL_CNTMODE_Msk         (0x1ul << TIMER_PWMCTL_CNTMODE_Pos)               /*!< TIMER_T::PWMCTL: CNTMODE Mask          */
N
N#define TIMER_PWMCTL_CTRLD_Pos           (8)                                               /*!< TIMER_T::PWMCTL: CTRLD Position        */
N#define TIMER_PWMCTL_CTRLD_Msk           (0x1ul << TIMER_PWMCTL_CTRLD_Pos)                 /*!< TIMER_T::PWMCTL: CTRLD Mask            */
N
N#define TIMER_PWMCTL_IMMLDEN_Pos         (9)                                               /*!< TIMER_T::PWMCTL: IMMLDEN Position      */
N#define TIMER_PWMCTL_IMMLDEN_Msk         (0x1ul << TIMER_PWMCTL_IMMLDEN_Pos)               /*!< TIMER_T::PWMCTL: IMMLDEN Mask          */
N
N#define TIMER_PWMCTL_OUTMODE_Pos         (16)                                              /*!< TIMER_T::PWMCTL: OUTMODE Position      */
N#define TIMER_PWMCTL_OUTMODE_Msk         (0x1ul << TIMER_PWMCTL_OUTMODE_Pos)               /*!< TIMER_T::PWMCTL: OUTMODE Mask          */
N
N#define TIMER_PWMCTL_DBGHALT_Pos         (30)                                              /*!< TIMER_T::PWMCTL: DBGHALT Position      */
N#define TIMER_PWMCTL_DBGHALT_Msk         (0x1ul << TIMER_PWMCTL_DBGHALT_Pos)               /*!< TIMER_T::PWMCTL: DBGHALT Mask          */
N
N#define TIMER_PWMCTL_DBGTRIOFF_Pos       (31)                                              /*!< TIMER_T::PWMCTL: DBGTRIOFF Position    */
N#define TIMER_PWMCTL_DBGTRIOFF_Msk       (0x1ul << TIMER_PWMCTL_DBGTRIOFF_Pos)             /*!< TIMER_T::PWMCTL: DBGTRIOFF Mask        */
N
N#define TIMER_PWMCLKSRC_CLKSRC_Pos       (0)                                               /*!< TIMER_T::PWMCLKSRC: CLKSRC Position    */
N#define TIMER_PWMCLKSRC_CLKSRC_Msk       (0x7ul << TIMER_PWMCLKSRC_CLKSRC_Pos)             /*!< TIMER_T::PWMCLKSRC: CLKSRC Mask        */
N
N#define TIMER_PWMCLKPSC_CLKPSC_Pos       (0)                                               /*!< TIMER_T::PWMCLKPSC: CLKPSC Position    */
N#define TIMER_PWMCLKPSC_CLKPSC_Msk       (0xffful << TIMER_PWMCLKPSC_CLKPSC_Pos)           /*!< TIMER_T::PWMCLKPSC: CLKPSC Mask        */
N
N#define TIMER_PWMCNTCLR_CNTCLR_Pos       (0)                                               /*!< TIMER_T::PWMCNTCLR: CNTCLR Position    */
N#define TIMER_PWMCNTCLR_CNTCLR_Msk       (0x1ul << TIMER_PWMCNTCLR_CNTCLR_Pos)             /*!< TIMER_T::PWMCNTCLR: CNTCLR Mask        */
N
N#define TIMER_PWMPERIOD_PERIOD_Pos       (0)                                               /*!< TIMER_T::PWMPERIOD: PERIOD Position    */
N#define TIMER_PWMPERIOD_PERIOD_Msk       (0xfffful << TIMER_PWMPERIOD_PERIOD_Pos)          /*!< TIMER_T::PWMPERIOD: PERIOD Mask        */
N
N#define TIMER_PWMCMPDAT_CMP_Pos         (0)                                                /*!< TIMER_T::PWMCMPDAT: CMP Position         */
N#define TIMER_PWMCMPDAT_CMP_Msk         (0xfffful << TIMER_PWMCMPDAT_CMP_Pos)              /*!< TIMER_T::PWMCMPDAT: CMP Mask             */
N
N#define TIMER_PWMDTCTL_DTCNT_Pos         (0)                                               /*!< TIMER_T::PWMDTCTL: DTCNT Position      */
N#define TIMER_PWMDTCTL_DTCNT_Msk         (0xffful << TIMER_PWMDTCTL_DTCNT_Pos)             /*!< TIMER_T::PWMDTCTL: DTCNT Mask          */
N
N#define TIMER_PWMDTCTL_DTEN_Pos          (16)                                              /*!< TIMER_T::PWMDTCTL: DTEN Position       */
N#define TIMER_PWMDTCTL_DTEN_Msk          (0x1ul << TIMER_PWMDTCTL_DTEN_Pos)                /*!< TIMER_T::PWMDTCTL: DTEN Mask           */
N
N#define TIMER_PWMDTCTL_DTCKSEL_Pos       (24)                                              /*!< TIMER_T::PWMDTCTL: DTCKSEL Position    */
N#define TIMER_PWMDTCTL_DTCKSEL_Msk       (0x1ul << TIMER_PWMDTCTL_DTCKSEL_Pos)             /*!< TIMER_T::PWMDTCTL: DTCKSEL Mask        */
N
N#define TIMER_PWMCNT_CNT_Pos             (0)                                               /*!< TIMER_T::PWMCNT: CNT Position          */
N#define TIMER_PWMCNT_CNT_Msk             (0xfffful << TIMER_PWMCNT_CNT_Pos)                /*!< TIMER_T::PWMCNT: CNT Mask              */
N
N#define TIMER_PWMCNT_DIRF_Pos            (16)                                              /*!< TIMER_T::PWMCNT: DIRF Position         */
N#define TIMER_PWMCNT_DIRF_Msk            (0x1ul << TIMER_PWMCNT_DIRF_Pos)                  /*!< TIMER_T::PWMCNT: DIRF Mask             */
N
N#define TIMER_PWMMSKEN_MSKEN0_Pos        (0)                                               /*!< TIMER_T::PWMMSKEN: MSKEN0 Position     */
N#define TIMER_PWMMSKEN_MSKEN0_Msk        (0x1ul << TIMER_PWMMSKEN_MSKEN0_Pos)              /*!< TIMER_T::PWMMSKEN: MSKEN0 Mask         */
N
N#define TIMER_PWMMSKEN_MSKEN1_Pos        (1)                                               /*!< TIMER_T::PWMMSKEN: MSKEN1 Position     */
N#define TIMER_PWMMSKEN_MSKEN1_Msk        (0x1ul << TIMER_PWMMSKEN_MSKEN1_Pos)              /*!< TIMER_T::PWMMSKEN: MSKEN1 Mask         */
N
N#define TIMER_PWMMSK_MSKDAT0_Pos         (0)                                               /*!< TIMER_T::PWMMSK: MSKDAT0 Position      */
N#define TIMER_PWMMSK_MSKDAT0_Msk         (0x1ul << TIMER_PWMMSK_MSKDAT0_Pos)                 /*!< TIMER_T::PWMMSK: MSKDAT0 Mask          */
N
N#define TIMER_PWMMSK_MSKDAT1_Pos         (1)                                               /*!< TIMER_T::PWMMSK: MSKDAT1 Position      */
N#define TIMER_PWMMSK_MSKDAT1_Msk         (0x1ul << TIMER_PWMMSK_MSKDAT1_Pos)                 /*!< TIMER_T::PWMMSK: MSKDAT1 Mask          */
N
N#define TIMER_PWMBNF_BRKNFEN_Pos         (0)                                               /*!< TIMER_T::PWMBNF: BRKNFEN Position        */
N#define TIMER_PWMBNF_BRKNFEN_Msk         (0x1ul << TIMER_PWMBNF_BRKNFEN_Pos)               /*!< TIMER_T::PWMBNF: BRKNFEN Mask            */
N
N#define TIMER_PWMBNF_BRKNFSEL_Pos        (1)                                               /*!< TIMER_T::PWMBNF: BRKNFSEL Position     */
N#define TIMER_PWMBNF_BRKNFSEL_Msk        (0x7ul << TIMER_PWMBNF_BRKNFSEL_Pos)              /*!< TIMER_T::PWMBNF: BRKNFSEL Mask         */
N
N#define TIMER_PWMBNF_BRKFCNT_Pos         (4)                                               /*!< TIMER_T::PWMBNF: BRKFCNT Position      */
N#define TIMER_PWMBNF_BRKFCNT_Msk         (0x7ul << TIMER_PWMBNF_BRKFCNT_Pos)               /*!< TIMER_T::PWMBNF: BRKFCNT Mask          */
N
N#define TIMER_PWMBNF_BRKPINV_Pos         (7)                                               /*!< TIMER_T::PWMBNF: BRKPINV Position      */
N#define TIMER_PWMBNF_BRKPINV_Msk         (0x1ul << TIMER_PWMBNF_BRKPINV_Pos)               /*!< TIMER_T::PWMBNF: BRKPINV Mask          */
N
N#define TIMER_PWMBNF_BKPINSRC_Pos        (16)                                              /*!< TIMER_T::PWMBNF: BKPINSRC Position     */
N#define TIMER_PWMBNF_BKPINSRC_Msk        (0x3ul << TIMER_PWMBNF_BKPINSRC_Pos)              /*!< TIMER_T::PWMBNF: BKPINSRC Mask         */
N
N#define TIMER_PWMFAILBRK_CSSBRKEN_Pos    (0)                                               /*!< TIMER_T::PWMFAILBRK: CSSBRKEN Position */
N#define TIMER_PWMFAILBRK_CSSBRKEN_Msk    (0x1ul << TIMER_PWMFAILBRK_CSSBRKEN_Pos)          /*!< TIMER_T::PWMFAILBRK: CSSBRKEN Mask     */
N
N#define TIMER_PWMFAILBRK_BODBRKEN_Pos    (1)                                               /*!< TIMER_T::PWMFAILBRK: BODBRKEN Position */
N#define TIMER_PWMFAILBRK_BODBRKEN_Msk    (0x1ul << TIMER_PWMFAILBRK_BODBRKEN_Pos)          /*!< TIMER_T::PWMFAILBRK: BODBRKEN Mask     */
N
N#define TIMER_PWMFAILBRK_CORBRKEN_Pos    (3)                                               /*!< TIMER_T::PWMFAILBRK: CORBRKEN Position */
N#define TIMER_PWMFAILBRK_CORBRKEN_Msk    (0x1ul << TIMER_PWMFAILBRK_CORBRKEN_Pos)          /*!< TIMER_T::PWMFAILBRK: CORBRKEN Mask     */
N
N#define TIMER_PWMBRKCTL_CPO0EBEN_Pos     (0)                                               /*!< TIMER_T::PWMBRKCTL: CPO0EBEN Position  */
N#define TIMER_PWMBRKCTL_CPO0EBEN_Msk     (0x1ul << TIMER_PWMBRKCTL_CPO0EBEN_Pos)           /*!< TIMER_T::PWMBRKCTL: CPO0EBEN Mask      */
N
N#define TIMER_PWMBRKCTL_CPO1EBEN_Pos     (1)                                               /*!< TIMER_T::PWMBRKCTL: CPO1EBEN Position  */
N#define TIMER_PWMBRKCTL_CPO1EBEN_Msk     (0x1ul << TIMER_PWMBRKCTL_CPO1EBEN_Pos)           /*!< TIMER_T::PWMBRKCTL: CPO1EBEN Mask      */
N
N#define TIMER_PWMBRKCTL_BRKPEEN_Pos      (4)                                               /*!< TIMER_T::PWMBRKCTL: BRKPEEN Position   */
N#define TIMER_PWMBRKCTL_BRKPEEN_Msk      (0x1ul << TIMER_PWMBRKCTL_BRKPEEN_Pos)            /*!< TIMER_T::PWMBRKCTL: BRKPEEN Mask       */
N
N#define TIMER_PWMBRKCTL_SYSEBEN_Pos      (7)                                               /*!< TIMER_T::PWMBRKCTL: SYSEBEN Position   */
N#define TIMER_PWMBRKCTL_SYSEBEN_Msk      (0x1ul << TIMER_PWMBRKCTL_SYSEBEN_Pos)            /*!< TIMER_T::PWMBRKCTL: SYSEBEN Mask       */
N
N#define TIMER_PWMBRKCTL_CPO0LBEN_Pos     (8)                                               /*!< TIMER_T::PWMBRKCTL: CPO0LBEN Position  */
N#define TIMER_PWMBRKCTL_CPO0LBEN_Msk     (0x1ul << TIMER_PWMBRKCTL_CPO0LBEN_Pos)           /*!< TIMER_T::PWMBRKCTL: CPO0LBEN Mask      */
N
N#define TIMER_PWMBRKCTL_CPO1LBEN_Pos     (9)                                               /*!< TIMER_T::PWMBRKCTL: CPO1LBEN Position  */
N#define TIMER_PWMBRKCTL_CPO1LBEN_Msk     (0x1ul << TIMER_PWMBRKCTL_CPO1LBEN_Pos)           /*!< TIMER_T::PWMBRKCTL: CPO1LBEN Mask      */
N
N#define TIMER_PWMBRKCTL_BRKPLEN_Pos      (12)                                              /*!< TIMER_T::PWMBRKCTL: BRKPLEN Position   */
N#define TIMER_PWMBRKCTL_BRKPLEN_Msk      (0x1ul << TIMER_PWMBRKCTL_BRKPLEN_Pos)            /*!< TIMER_T::PWMBRKCTL: BRKPLEN Mask       */
N
N#define TIMER_PWMBRKCTL_SYSLBEN_Pos      (15)                                              /*!< TIMER_T::PWMBRKCTL: SYSLBEN Position   */
N#define TIMER_PWMBRKCTL_SYSLBEN_Msk      (0x1ul << TIMER_PWMBRKCTL_SYSLBEN_Pos)            /*!< TIMER_T::PWMBRKCTL: SYSLBEN Mask       */
N
N#define TIMER_PWMBRKCTL_BRKAEVEN_Pos     (16)                                              /*!< TIMER_T::PWMBRKCTL: BRKAEVEN Position  */
N#define TIMER_PWMBRKCTL_BRKAEVEN_Msk     (0x3ul << TIMER_PWMBRKCTL_BRKAEVEN_Pos)           /*!< TIMER_T::PWMBRKCTL: BRKAEVEN Mask      */
N
N#define TIMER_PWMBRKCTL_BRKAODD_Pos      (18)                                              /*!< TIMER_T::PWMBRKCTL: BRKAODD Position   */
N#define TIMER_PWMBRKCTL_BRKAODD_Msk      (0x3ul << TIMER_PWMBRKCTL_BRKAODD_Pos)            /*!< TIMER_T::PWMBRKCTL: BRKAODD Mask       */
N
N#define TIMER_PWMPOLCTL_PINV0_Pos        (0)                                               /*!< TIMER_T::PWMPOLCTL: PINV0 Position     */
N#define TIMER_PWMPOLCTL_PINV0_Msk        (0x1ul << TIMER_PWMPOLCTL_PINV0_Pos)              /*!< TIMER_T::PWMPOLCTL: PINV0 Mask         */
N
N#define TIMER_PWMPOLCTL_PINV1_Pos        (1)                                               /*!< TIMER_T::PWMPOLCTL: PINV1 Position     */
N#define TIMER_PWMPOLCTL_PINV1_Msk        (0x1ul << TIMER_PWMPOLCTL_PINV1_Pos)              /*!< TIMER_T::PWMPOLCTL: PINV1 Mask         */
N
N#define TIMER_PWMPOEN_POEN0_Pos          (0)                                               /*!< TIMER_T::PWMPOEN: POEN0 Position       */
N#define TIMER_PWMPOEN_POEN0_Msk          (0x1ul << TIMER_PWMPOEN_POEN0_Pos)                /*!< TIMER_T::PWMPOEN: POEN0 Mask           */
N
N#define TIMER_PWMPOEN_POEN1_Pos          (1)                                               /*!< TIMER_T::PWMPOEN: POEN1 Position       */
N#define TIMER_PWMPOEN_POEN1_Msk          (0x1ul << TIMER_PWMPOEN_POEN1_Pos)                /*!< TIMER_T::PWMPOEN: POEN1 Mask           */
N
N#define TIMER_PWMSWBRK_BRKETRG_Pos       (0)                                               /*!< TIMER_T::PWMSWBRK: BRKETRG Position    */
N#define TIMER_PWMSWBRK_BRKETRG_Msk       (0x1ul << TIMER_PWMSWBRK_BRKETRG_Pos)             /*!< TIMER_T::PWMSWBRK: BRKETRG Mask        */
N
N#define TIMER_PWMSWBRK_BRKLTRG_Pos       (8)                                               /*!< TIMER_T::PWMSWBRK: BRKLTRG Position    */
N#define TIMER_PWMSWBRK_BRKLTRG_Msk       (0x1ul << TIMER_PWMSWBRK_BRKLTRG_Pos)             /*!< TIMER_T::PWMSWBRK: BRKLTRG Mask        */
N
N#define TIMER_PWMINTEN0_ZIEN_Pos         (0)                                               /*!< TIMER_T::PWMINTEN0: ZIEN Position      */
N#define TIMER_PWMINTEN0_ZIEN_Msk         (0x1ul << TIMER_PWMINTEN0_ZIEN_Pos)               /*!< TIMER_T::PWMINTEN0: ZIEN Mask          */
N
N#define TIMER_PWMINTEN0_PIEN_Pos         (1)                                               /*!< TIMER_T::PWMINTEN0: PIEN Position      */
N#define TIMER_PWMINTEN0_PIEN_Msk         (0x1ul << TIMER_PWMINTEN0_PIEN_Pos)               /*!< TIMER_T::PWMINTEN0: PIEN Mask          */
N
N#define TIMER_PWMINTEN0_CMPUIEN_Pos      (2)                                               /*!< TIMER_T::PWMINTEN0: CMPUIEN Position   */
N#define TIMER_PWMINTEN0_CMPUIEN_Msk      (0x1ul << TIMER_PWMINTEN0_CMPUIEN_Pos)            /*!< TIMER_T::PWMINTEN0: CMPUIEN Mask       */
N
N#define TIMER_PWMINTEN0_CMPDIEN_Pos      (3)                                               /*!< TIMER_T::PWMINTEN0: CMPDIEN Position   */
N#define TIMER_PWMINTEN0_CMPDIEN_Msk      (0x1ul << TIMER_PWMINTEN0_CMPDIEN_Pos)            /*!< TIMER_T::PWMINTEN0: CMPDIEN Mask       */
N
N#define TIMER_PWMINTEN1_BRKEIEN_Pos      (0)                                               /*!< TIMER_T::PWMINTEN1: BRKEIEN Position   */
N#define TIMER_PWMINTEN1_BRKEIEN_Msk      (0x1ul << TIMER_PWMINTEN1_BRKEIEN_Pos)            /*!< TIMER_T::PWMINTEN1: BRKEIEN Mask       */
N
N#define TIMER_PWMINTEN1_BRKLIEN_Pos      (8)                                               /*!< TIMER_T::PWMINTEN1: BRKLIEN Position   */
N#define TIMER_PWMINTEN1_BRKLIEN_Msk      (0x1ul << TIMER_PWMINTEN1_BRKLIEN_Pos)            /*!< TIMER_T::PWMINTEN1: BRKLIEN Mask       */
N
N#define TIMER_PWMINTSTS0_ZIF_Pos         (0)                                               /*!< TIMER_T::PWMINTSTS0: ZIF Position      */
N#define TIMER_PWMINTSTS0_ZIF_Msk         (0x1ul << TIMER_PWMINTSTS0_ZIF_Pos)               /*!< TIMER_T::PWMINTSTS0: ZIF Mask          */
N
N#define TIMER_PWMINTSTS0_PIF_Pos         (1)                                               /*!< TIMER_T::PWMINTSTS0: PIF Position      */
N#define TIMER_PWMINTSTS0_PIF_Msk         (0x1ul << TIMER_PWMINTSTS0_PIF_Pos)               /*!< TIMER_T::PWMINTSTS0: PIF Mask          */
N
N#define TIMER_PWMINTSTS0_CMPUIF_Pos      (2)                                               /*!< TIMER_T::PWMINTSTS0: CMPUIF Position   */
N#define TIMER_PWMINTSTS0_CMPUIF_Msk      (0x1ul << TIMER_PWMINTSTS0_CMPUIF_Pos)            /*!< TIMER_T::PWMINTSTS0: CMPUIF Mask       */
N
N#define TIMER_PWMINTSTS0_CMPDIF_Pos      (3)                                               /*!< TIMER_T::PWMINTSTS0: CMPDIF Position   */
N#define TIMER_PWMINTSTS0_CMPDIF_Msk      (0x1ul << TIMER_PWMINTSTS0_CMPDIF_Pos)            /*!< TIMER_T::PWMINTSTS0: CMPDIF Mask       */
N
N#define TIMER_PWMINTSTS1_BRKEIF0_Pos     (0)                                               /*!< TIMER_T::PWMINTSTS1: BRKEIF0 Position  */
N#define TIMER_PWMINTSTS1_BRKEIF0_Msk     (0x1ul << TIMER_PWMINTSTS1_BRKEIF0_Pos)           /*!< TIMER_T::PWMINTSTS1: BRKEIF0 Mask      */
N
N#define TIMER_PWMINTSTS1_BRKEIF1_Pos     (1)                                               /*!< TIMER_T::PWMINTSTS1: BRKEIF1 Position  */
N#define TIMER_PWMINTSTS1_BRKEIF1_Msk     (0x1ul << TIMER_PWMINTSTS1_BRKEIF1_Pos)           /*!< TIMER_T::PWMINTSTS1: BRKEIF1 Mask      */
N
N#define TIMER_PWMINTSTS1_BRKLIF0_Pos     (8)                                               /*!< TIMER_T::PWMINTSTS1: BRKLIF0 Position  */
N#define TIMER_PWMINTSTS1_BRKLIF0_Msk     (0x1ul << TIMER_PWMINTSTS1_BRKLIF0_Pos)           /*!< TIMER_T::PWMINTSTS1: BRKLIF0 Mask      */
N
N#define TIMER_PWMINTSTS1_BRKLIF1_Pos     (9)                                               /*!< TIMER_T::PWMINTSTS1: BRKLIF1 Position  */
N#define TIMER_PWMINTSTS1_BRKLIF1_Msk     (0x1ul << TIMER_PWMINTSTS1_BRKLIF1_Pos)           /*!< TIMER_T::PWMINTSTS1: BRKLIF1 Mask      */
N
N#define TIMER_PWMINTSTS1_BRKESTS0_Pos    (16)                                              /*!< TIMER_T::PWMINTSTS1: BRKESTS0 Position */
N#define TIMER_PWMINTSTS1_BRKESTS0_Msk    (0x1ul << TIMER_PWMINTSTS1_BRKESTS0_Pos)          /*!< TIMER_T::PWMINTSTS1: BRKESTS0 Mask     */
N
N#define TIMER_PWMINTSTS1_BRKESTS1_Pos    (17)                                              /*!< TIMER_T::PWMINTSTS1: BRKESTS1 Position */
N#define TIMER_PWMINTSTS1_BRKESTS1_Msk    (0x1ul << TIMER_PWMINTSTS1_BRKESTS1_Pos)          /*!< TIMER_T::PWMINTSTS1: BRKESTS1 Mask     */
N
N#define TIMER_PWMINTSTS1_BRKLSTS0_Pos    (24)                                              /*!< TIMER_T::PWMINTSTS1: BRKLSTS0 Position */
N#define TIMER_PWMINTSTS1_BRKLSTS0_Msk    (0x1ul << TIMER_PWMINTSTS1_BRKLSTS0_Pos)          /*!< TIMER_T::PWMINTSTS1: BRKLSTS0 Mask     */
N
N#define TIMER_PWMINTSTS1_BRKLSTS1_Pos    (25)                                              /*!< TIMER_T::PWMINTSTS1: BRKLSTS1 Position */
N#define TIMER_PWMINTSTS1_BRKLSTS1_Msk    (0x1ul << TIMER_PWMINTSTS1_BRKLSTS1_Pos)          /*!< TIMER_T::PWMINTSTS1: BRKLSTS1 Mask     */
N
N#define TIMER_PWMADCTS_TRGSEL_Pos        (0)                                               /*!< TIMER_T::PWMADCTS: TRGSEL Position     */
N#define TIMER_PWMADCTS_TRGSEL_Msk        (0x7ul << TIMER_PWMADCTS_TRGSEL_Pos)              /*!< TIMER_T::PWMADCTS: TRGSEL Mask         */
N
N#define TIMER_PWMADCTS_TRGEN_Pos         (7)                                               /*!< TIMER_T::PWMADCTS: TRGEN Position      */
N#define TIMER_PWMADCTS_TRGEN_Msk         (0x1ul << TIMER_PWMADCTS_TRGEN_Pos)               /*!< TIMER_T::PWMADCTS: TRGEN Mask          */
N
N#define TIMER_PWMSCTL_SYNCMODE_Pos       (0)                                               /*!< TIMER_T::PWMSCTL: SYNCMODE Position    */
N#define TIMER_PWMSCTL_SYNCMODE_Msk       (0x3ul << TIMER_PWMSCTL_SYNCMODE_Pos)             /*!< TIMER_T::PWMSCTL: SYNCMODE Mask        */
N
N#define TIMER_PWMSCTL_SYNCSRC_Pos        (8)                                               /*!< TIMER_T::PWMSCTL: SYNCSRC Position     */
N#define TIMER_PWMSCTL_SYNCSRC_Msk        (0x1ul << TIMER_PWMSCTL_SYNCSRC_Pos)              /*!< TIMER_T::PWMSCTL: SYNCSRC Mask         */
N
N#define TIMER_PWMSTRG_STRGEN_Pos         (0)                                               /*!< TIMER_T::PWMSTRG: STRGEN Position      */
N#define TIMER_PWMSTRG_STRGEN_Msk         (0x1ul << TIMER_PWMSTRG_STRGEN_Pos)               /*!< TIMER_T::PWMSTRG: STRGEN Mask          */
N
N#define TIMER_PWMSTATUS_CNTMAXF_Pos      (0)                                               /*!< TIMER_T::PWMSTATUS: CNTMAXF Position   */
N#define TIMER_PWMSTATUS_CNTMAXF_Msk      (0x1ul << TIMER_PWMSTATUS_CNTMAXF_Pos)            /*!< TIMER_T::PWMSTATUS: CNTMAXF Mask       */
N
N#define TIMER_PWMSTATUS_ADCTRGF_Pos      (16)                                              /*!< TIMER_T::PWMSTATUS: ADCTRGF Position   */
N#define TIMER_PWMSTATUS_ADCTRGF_Msk      (0x1ul << TIMER_PWMSTATUS_ADCTRGF_Pos)            /*!< TIMER_T::PWMSTATUS: ADCTRGF Mask       */
N
N#define TIMER_PWMPBUF_PBUF_Pos           (0)                                               /*!< TIMER_T::PWMPBUF: PBUF Position        */
N#define TIMER_PWMPBUF_PBUF_Msk           (0xfffful << TIMER_PWMPBUF_PBUF_Pos)              /*!< TIMER_T::PWMPBUF: PBUF Mask            */
N
N#define TIMER_PWMCMPBUF_CMPBUF_Pos       (0)                                               /*!< TIMER_T::PWMCMPBUF: CMPBUF Position    */
N#define TIMER_PWMCMPBUF_CMPBUF_Msk       (0xfffful << TIMER_PWMCMPBUF_CMPBUF_Pos)          /*!< TIMER_T::PWMCMPBUF: CMPBUF Mask        */
N
N/**@}*/ /* TIMER_CONST */
N/**@}*/ /* end of TIMER register group */
N
N
N
N
N/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
N/**
N    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
N    Memory Mapped Structure for UART Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var UART_T::DAT
N     * Offset: 0x00  UART Receive/Transmit Buffer Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |DAT       |Data Receivinge/Transmit Buffer
N     * |        |          |Write Operation:
N     * |        |          |By writing one byte to this register, the data byte will be stored in transmitter FIFO.
N     * |        |          |The UART Controller will send out the data stored in transmitter FIFO top location through the UART_TXD.
N     * |        |          |Read Operation:
N     * |        |          |By reading this register, the UART controller will return an 8-bit data received from receiver FIFO.
N     * |[8]     |PARITY    |Parity Bit Receive/Transmit Buffer
N     * |        |          |Write Operation:
N     * |        |          |By writing to this bit, the parity bit will be stored in transmitter FIFO.
N     * |        |          |If PBE (UART_LINE[3]) and PSS (UART_LINE[7]) are set, the UART controller will send out this bit follow the DAT (UART_DAT[7:0]) through the UART_TXD.
N     * |        |          |Read Operation:
N     * |        |          |If PBE (UART_LINE[3]) and PSS (UART_LINE[7]) are enabled, the parity bit can be read by this bit.
N     * |        |          |Note: This bit has effect only when PBE (UART_LINE[3]) and PSS (UART_LINE[7]) are set.
N     * @var UART_T::INTEN
N     * Offset: 0x04  UART Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDAIEN    |Receive Data Available Interrupt Enable Bit
N     * |        |          |0 = Receive data available interrupt Disabled.
N     * |        |          |1 = Receive data available interrupt Enabled.
N     * |[1]     |THREIEN   |Transmit Holding Register Empty Interrupt Enable Bit
N     * |        |          |0 = Transmit holding register empty interrupt Disabled.
N     * |        |          |1 = Transmit holding register empty interrupt Enabled.
N     * |[2]     |RLSIEN    |Receive Line Status Interrupt Enable Bit
N     * |        |          |0 = Receive Line Status interrupt Disabled.
N     * |        |          |1 = Receive Line Status interrupt Enabled.
N     * |[3]     |MODEMIEN  |Modem Status Interrupt Enable Bit
N     * |        |          |0 = Modem status interrupt Disabled.
N     * |        |          |1 = Modem status interrupt Enabled.
N     * |[4]     |RXTOIEN   |RX Time-out Interrupt Enable Bit
N     * |        |          |0 = RX time-out interrupt Disabled.
N     * |        |          |1 = RX time-out interrupt Enabled.
N     * |[5]     |BUFERRIEN |Buffer Error Interrupt Enable Bit
N     * |        |          |0 = Buffer error interrupt Disabled.
N     * |        |          |1 = Buffer error interrupt Enabled.
N     * |[6]     |WKIEN     |Wake-up Interrupt Enable Bit
N     * |        |          |0 = Wake-up Interrupt Disabled.
N     * |        |          |1 = Wake-up Interrupt Enabled.
N     * |[8]     |LINIEN    |LIN Bus Interrupt Enable Bit
N     * |        |          |0 = LIN bus interrupt Disabled.
N     * |        |          |1 = LIN bus interrupt Enabled.
N     * |        |          |Note: This bit is used for LIN function mode.
N     * |[11]    |TOCNTEN   |Receive Buffer Time-out Counter Enable Bit
N     * |        |          |0 = Receive Buffer Time-out counter Disabled.
N     * |        |          |1 = Receive Buffer Time-out counter Enabled.
N     * |[12]    |ATORTSEN  |nRTS Auto-flow Control Enable Bit
N     * |        |          |0 = nRTS auto-flow control Disabled.
N     * |        |          |1 = nRTS auto-flow control Enabled.
N     * |        |          |Note: When nRTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTSTRGLV (UART_FIFO[19:16]), the UART will de-assert nRTS signal.
N     * |[13]    |ATOCTSEN  |nCTS Auto-flow Control Enable Bit
N     * |        |          |0 = nCTS auto-flow control Disabled.
N     * |        |          |1 = nCTS auto-flow control Enabled.
N     * |        |          |Note: When nCTS auto-flow is enabled, the UART will send data to external device if nCTS input assert (UART will not send data to device until nCTS is asserted).
N     * |[14]    |TXPDMAEN  |TX PDMA Enable Bit
N     * |        |          |This bit can enable or disable TX PDMA service.
N     * |        |          |0 = TX PDMA Disabled.
N     * |        |          |1 = TX PDMA Enabled.
N     * |[15]    |RXPDMAEN  |RX PDMA Enable Bit
N     * |        |          |This bit can enable or disable RX PDMA service.
N     * |        |          |0 = RX PDMA Disabled.
N     * |        |          |1 = RX PDMA Enabled.
N     * |        |          |Note: If RLSIEN (UART_INTEN[2]) is enabled and HWRLSINT (UART_INTSTS[26]) is set to 1, the RLS (Receive Line Status) Interrupt is caused.
N     * |        |          |If RLS interrupt is caused by Break Error Flag BIF(UART_FIFOSTS[6]), Frame Error Flag FEF(UART_FIFO[5]) or Parity Error Flag PEF(UART_FIFOSTS[4]), UART PDMA receive request operation is stop.
N     * |        |          |Clear Break Error Flag BIF or Frame Error Flag FEF or Parity Error Flag PEF by writing 1 to corresponding BIF, FEF and PEF to make UART PDMA receive request operation continue.
N     * |[18]    |ABRIEN    |Auto-baud Rate Interrupt Enable Bit
N     * |        |          |0 = Auto-baud rate interrupt Disabled.
N     * |        |          |1 = Auto-baud rate interrupt Enabled.
N     * |[22]    |TXENDIEN  |Transmitter Empty Interrupt Enable Bit
N     * |        |          |If TXENDIEN (UART_INTEN[22]) is enabled, the Transmitter Empty interrupt TXENDINT (UART_INTSTS[30]) will be generated when TXENDIF (UART_INTSTS[22]) is set (TX FIFO (UART_DAT) is empty and the STOP bit of the last byte has been transmitted).
N     * |        |          |0 = Transmitter empty interrupt Disabled.
N     * |        |          |1 = Transmitter empty interrupt Enabled.
N     * @var UART_T::FIFO
N     * Offset: 0x08  UART FIFO Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |RXRST     |RX Field Software Reset
N     * |        |          |When RXRST (UART_FIFO[1]) is set, all the byte in the receiver FIFO and RX internal state machine are cleared.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the RX internal state machine and pointers.
N     * |        |          |Note1: This bit will automatically clear at least 3 UART peripheral clock cycles.
N     * |        |          |Note2: Before setting this bit, it should wait for the RXIDLE (UART_FIFOSTS[29]) be set.
N     * |[2]     |TXRST     |TX Field Software Reset
N     * |        |          |When TXRST (UART_FIFO[2]) is set, all the byte in the transmit FIFO and TX internal state machine are cleared.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the TX internal state machine and pointers.
N     * |        |          |Note1: This bit will automatically clear at least 3 UART peripheral clock cycles.
N     * |        |          |Note2: Before setting this bit, it should wait for the TXEMPTYF (UART_FIFOSTS[28]) be set.
N     * |[7:4]   |RFITL     |RX FIFO Interrupt Trigger Level
N     * |        |          |When the number of bytes in the receive FIFO equals the RFITL, the RDAIF (UART_INTSTS[0]) will be set (if RDAIEN (UART_INTEN [0]) enabled, and an interrupt will be generated).
N     * |        |          |0000 = RX FIFO Interrupt Trigger Level is 1 byte.
N     * |        |          |0001 = RX FIFO Interrupt Trigger Level is 4 bytes.
N     * |        |          |0010 = RX FIFO Interrupt Trigger Level is 8 bytes.
N     * |        |          |0011 = RX FIFO Interrupt Trigger Level is 14 bytes.
N     * |        |          |Others = Reserved.
N     * |[8]     |RXOFF     |Receiver Disable Bit
N     * |        |          |The receiver is disabled or not (set 1 to disable receiver).
N     * |        |          |0 = Receiver Enabled.
N     * |        |          |1 = Receiver Disabled.
N     * |        |          |Note: This bit is used for RS-485 Normal Multi-drop mode.
N     * |        |          |It should be programmed before RS485NMM (UART_ALTCTL [8]) is programmed.
N     * |[19:16] |RTSTRGLV  |nRTS Trigger Level for Auto-flow Control Use
N     * |        |          |0000 = nRTS Trigger Level is 1 byte.
N     * |        |          |0001 = nRTS Trigger Level is 4 bytes.
N     * |        |          |0010 = nRTS Trigger Level is 8 bytes.
N     * |        |          |0011 = nRTS Trigger Level is 14 bytes.
N     * |        |          |Others = Reserved.
N     * |        |          |Note: This field is used for auto nRTS flow control.
N     * @var UART_T::LINE
N     * Offset: 0x0C  UART Line Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |WLS       |Word Length Selection
N     * |        |          |This field sets UART word length.
N     * |        |          |00 = 5 bits.
N     * |        |          |01 = 6 bits.
N     * |        |          |10 = 7 bits.
N     * |        |          |11 = 8 bits.
N     * |[2]     |NSB       |Number of STOP Bit
N     * |        |          |0 = One STOP bit is generated in the transmitted data.
N     * |        |          |1 = When select 5-bit word length, 1.5 STOP bit is generated in the transmitted data.
N     * |        |          |When select 6-, 7- and 8-bit word length, 2 STOP bit is generated in the transmitted data.
N     * |[3]     |PBE       |Parity Bit Enable Bit
N     * |        |          |0 = Parity bit generated Disabled.
N     * |        |          |1 = Parity bit generated Enabled.
N     * |        |          |Note: Parity bit is generated on each outgoing character and is checked on each incoming data.
N     * |[4]     |EPE       |Even Parity Enable Bit
N     * |        |          |0 = Odd number of logic 1 is transmitted and checked in each word.
N     * |        |          |1 = Even number of logic 1 is transmitted and checked in each word.
N     * |        |          |Note: This bit has effect only when PBE (UART_LINE[3]) is set.
N     * |[5]     |SPE       |Stick Parity Enable Bit
N     * |        |          |0 = Stick parity Disabled.
N     * |        |          |1 = Stick parity Enabled.
N     * |        |          |Note: If PBE (UART_LINE[3]) and EPE (UART_LINE[4]) are logic 1, the parity bit is transmitted and checked as logic 0.
N     * |        |          |If PBE (UART_LINE[3]) is 1 and EPE (UART_LINE[4]) is 0 then the parity bit is transmitted and checked as 1.
N     * |[6]     |BCB       |Break Control Bit
N     * |        |          |0 = Break Control Disabled.
N     * |        |          |1 = Break Control Enabled.
N     * |        |          |Note: When this bit is set to logic 1, the transmitted serial data output (TX) is forced to the Spacing State (logic 0).
N     * |        |          |This bit acts only on TX line and has no effect on the transmitter logic.
N     * |[7]     |PSS       |Parity Bit Source Selection
N     * |        |          |The parity bit can be selected to be generated and checked automatically or by software.
N     * |        |          |0 = Parity bit is generated by EPE (UART_LINE[4]) and SPE (UART_LINE[5]) setting and checked automatically.
N     * |        |          |1 = Parity bit generated and checked by software.
N     * |        |          |Note1: This bit has effect only when PBE (UART_LINE[3]) is set.
N     * |        |          |Note2: If PSS is 0, the parity bit is transmitted and checked automatically.
N     * |        |          |If PSS is 1, the transmitted parity bit value can be determined by writing PARITY (UART_DAT[8]) and the parity bit can be read by reading PARITY (UART_DAT[8]).
N     * |[8]     |TXDINV    |TX Data Inverted
N     * |        |          |0 = Transmitted data signal inverted Disabled.
N     * |        |          |1 = Transmitted data signal inverted Enabled.
N     * |        |          |Note1: Before setting this bit, TXRXDIS (UART_FUNCSEL[3]) should be set then waited for TXRXACT (UART_FIFOSTS[31]) is cleared.
N     * |        |          |When the configuration is done, cleared TXRXDIS (UART_FUNCSEL[3]) to activate UART controller.
N     * |        |          |Note2: This bit is valid when FUNCSEL (UART_FUNCSEL[1:0]) is select UART, LIN or RS485 function.
N     * |[9]     |RXDINV    |RX Data Inverted
N     * |        |          |0 = Received data signal inverted Disabled.
N     * |        |          |1 = Received data signal inverted Enabled.
N     * |        |          |Note1: Before setting this bit, TXRXDIS (UART_FUNCSEL[3]) should be set then waited for TXRXACT (UART_FIFOSTS[31]) is cleared.
N     * |        |          |When the configuration is done, cleared TXRXDIS (UART_FUNCSEL[3]) to activate UART controller.
N     * |        |          |Note2: This bit is valid when FUNCSEL (UART_FUNCSEL[1:0]) is select UART, LIN or RS485 function.
N     * @var UART_T::MODEM
N     * Offset: 0x10  UART Modem Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |RTS       |nRTS (Request-to-send) Signal Control
N     * |        |          |This bit is direct control internal nRTS signal active or not, and then drive the nRTS pin output with RTSACTLV bit configuration.
N     * |        |          |0 = nRTS signal is active.
N     * |        |          |1 = nRTS signal is inactive.
N     * |        |          |Note1: This nRTS signal control bit is not effective when nRTS auto-flow control is enabled in UART function mode.
N     * |        |          |Note2: This nRTS signal control bit is not effective when RS-485 auto direction mode (AUD) is enabled in RS-485 function mode.
N     * |[9]     |RTSACTLV  |nRTS Pin Active Level
N     * |        |          |This bit defines the active level state of nRTS pin output.
N     * |        |          |0 = nRTS pin output is high level active.
N     * |        |          |1 = nRTS pin output is low level active. (Default)
N     * |        |          |Note3: Before setting this bit, TXRXDIS (UART_FUNCSEL[3]) should be set then waited for TXRXACT (UART_FIFOSTS[31]) is cleared.
N     * |        |          |When the configuration is done, cleared TXRXDIS (UART_FUNCSEL[3]) to activate UART controller.
N     * |[13]    |RTSSTS    |nRTS Pin Status (Read Only)
N     * |        |          |This bit mirror from nRTS pin output of voltage logic status.
N     * |        |          |0 = nRTS pin output is low level voltage logic state.
N     * |        |          |1 = nRTS pin output is high level voltage logic state.
N     * @var UART_T::MODEMSTS
N     * Offset: 0x14  UART Modem Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CTSDETF   |Detect nCTS State Change Flag
N     * |        |          |This bit is set whenever nCTS input has change state, and it will generate Modem interrupt to CPU when MODEMIEN (UART_INTEN [3]) is set to 1.
N     * |        |          |0 = nCTS input has not change state.
N     * |        |          |1 = nCTS input has change state.
N     * |        |          |Note: This bit can be cleared by writing 1 to it.
N     * |[4]     |CTSSTS    |nCTS Pin Status (Read Only)
N     * |        |          |This bit mirror from nCTS pin input of voltage logic status.
N     * |        |          |0 = nCTS pin input is low level voltage logic state.
N     * |        |          |1 = nCTS pin input is high level voltage logic state.
N     * |        |          |Note: This bit echoes when UART controller peripheral clock is enabled, and nCTS multi-function port is selected.
N     * |[8]     |CTSACTLV  |nCTS Pin Active Level
N     * |        |          |This bit defines the active level state of nCTS pin input.
N     * |        |          |0 = nCTS pin input is high level active.
N     * |        |          |1 = nCTS pin input is low level active. (Default)
N     * |        |          |Note: Before setting this bit, TXRXDIS (UART_FUNCSEL[3]) should be set then waited for TXRXACT (UART_FIFOSTS[31]) is cleared.
N     * |        |          |When the configuration is done, cleared TXRXDIS (UART_FUNCSEL[3]) to activate UART controller.
N     * @var UART_T::FIFOSTS
N     * Offset: 0x18  UART FIFO Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RXOVIF    |RX Overflow Error Interrupt Flag
N     * |        |          |This bit is set when RX FIFO overflow.
N     * |        |          |If the number of bytes of received data is greater than RX_FIFO (UART_DAT) size, 16 bytes, this bit will be set.
N     * |        |          |0 = RX FIFO is not overflow.
N     * |        |          |1 = RX FIFO is overflow.
N     * |        |          |Note: This bit can be cleared by writing 1 to it.
N     * |[1]     |ABRDIF    |Auto-baud Rate Detect Interrupt Flag
N     * |        |          |This bit is set to logic 1 when auto-baud rate detect function is finished.
N     * |        |          |0 = Auto-baud rate detect function is not finished.
N     * |        |          |1 = Auto-baud rate detect function is finished.
N     * |        |          |Note: This bit can be cleared by writing 1 to it.
N     * |[2]     |ABRDTOIF  |Auto-baud Rate Detect Time-out Interrupt Flag
N     * |        |          |This bit is set to logic 1 in Auto-baud Rate Detect mode when the baud rate counter is overflow.
N     * |        |          |0 = Auto-baud rate counter is underflow.
N     * |        |          |1 = Auto-baud rate counter is overflow.
N     * |        |          |Note: This bit can be cleared by writing 1 to it.
N     * |[3]     |ADDRDETF  |RS-485 Address Byte Detect Flag
N     * |        |          |0 = Receiver detects a data that is not an address bit (bit 9 = 1).
N     * |        |          |1 = Receiver detects a data that is an address bit (bit 9 = 1).
N     * |        |          |Note1: This field is used for RS-485 function mode and ADDRDEN (UART_ALTCTL[15]) is set to 1 to enable Address detection mode.
N     * |        |          |Note2: This bit can be cleared by writing 1 to it.
N     * |[4]     |PEF       |Parity Error Flag
N     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid parity bit.
N     * |        |          |0 = No parity error is generated.
N     * |        |          |1 = Parity error is generated.
N     * |        |          |Note: This bit can be cleared by writing 1 to it.
N     * |[5]     |FEF       |Framing Error Flag
N     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid stop bit (that is, the stop bit following the last data bit or parity bit is detected as logic 0).
N     * |        |          |0 = No framing error is generated.
N     * |        |          |1 = Framing error is generated.
N     * |        |          |Note: This bit can be cleared by writing 1 to it.
N     * |[6]     |BIF       |Break Interrupt Flag
N     * |        |          |This bit is set to logic 1 whenever the received data input (RX) is held in the spacing state (logic 0) for longer than a full word transmission time (that is, the total time of start bit + data bits + parity + stop bits).
N     * |        |          |0 = No Break interrupt is generated.
N     * |        |          |1 = Break interrupt is generated.
N     * |        |          |Note: This bit can be cleared by writing 1 to it.
N     * |[13:8]  |RXPTR     |RX FIFO Pointer (Read Only)
N     * |        |          |This field indicates the RX FIFO Buffer Pointer.
N     * |        |          |When UART receives one byte from external device, RXPTR increases one.
N     * |        |          |When one byte of RX FIFO is read by CPU, RXPTR decreases one.
N     * |        |          |The Maximum value shown in RXPTR is 15.
N     * |        |          |When the using level of RX FIFO Buffer equal to 16, the RXFULL bit is set to 1 and RXPTR will show 0.
N     * |        |          |As one byte of RX FIFO is read by CPU, the RXFULL bit is cleared to 0 and RXPTR will show 15.
N     * |[14]    |RXEMPTY   |Receiver FIFO Empty (Read Only)
N     * |        |          |This bit initiate RX FIFO empty or not.
N     * |        |          |0 = RX FIFO is not empty.
N     * |        |          |1 = RX FIFO is empty.
N     * |        |          |Note: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high.
N     * |        |          |It will be cleared when UART receives any new data.
N     * |[15]    |RXFULL    |Receiver FIFO Full (Read Only)
N     * |        |          |This bit initiates RX FIFO full or not.
N     * |        |          |0 = RX FIFO is not full.
N     * |        |          |1 = RX FIFO is full.
N     * |        |          |Note: This bit is set when the number of usage in RX FIFO Buffer is equal to 16, otherwise it is cleared by hardware.
N     * |[21:16] |TXPTR     |TX FIFO Pointer (Read Only)
N     * |        |          |This field indicates the TX FIFO Buffer Pointer.
N     * |        |          |When CPU writes one byte into UART_DAT, TXPTR increases one.
N     * |        |          |When one byte of TX FIFO is transferred to Transmitter Shift Register, TXPTR decreases one.
N     * |        |          |The Maximum value shown in TXPTR is 15
N     * |        |          |When the using level of TX FIFO Buffer equal to 16, the TXFULL bit is set to 1 and TXPTR will show 0.
N     * |        |          |As one byte of TX FIFO is transferred to Transmitter Shift Register, the TXFULL bit is cleared to 0 and TXPTR will show 15.
N     * |[22]    |TXEMPTY   |Transmitter FIFO Empty (Read Only)
N     * |        |          |This bit indicates TX FIFO empty or not.
N     * |        |          |0 = TX FIFO is not empty.
N     * |        |          |1 = TX FIFO is empty.
N     * |        |          |Note: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high.
N     * |        |          |It will be cleared when writing data into UART_DAT (TX FIFO not empty).
N     * |[23]    |TXFULL    |Transmitter FIFO Full (Read Only)
N     * |        |          |This bit indicates TX FIFO full or not.
N     * |        |          |0 = TX FIFO is not full.
N     * |        |          |1 = TX FIFO is full.
N     * |        |          |Note: This bit is set when the number of usage in TX FIFO Buffer is equal to 16, otherwise it is cleared by hardware.
N     * |[24]    |TXOVIF    |TX Overflow Error Interrupt Flag
N     * |        |          |If TX FIFO (UART_DAT) is full, an additional write to UART_DAT will cause this bit to logic 1.
N     * |        |          |0 = TX FIFO is not overflow.
N     * |        |          |1 = TX FIFO is overflow.
N     * |        |          |Note: This bit can be cleared by writing 1 to it.
N     * |[28]    |TXEMPTYF  |Transmitter Empty Flag (Read Only)
N     * |        |          |This bit is set by hardware when TX FIFO (UART_DAT) is empty and the STOP bit of the last byte has been transmitted.
N     * |        |          |0 = TX FIFO is not empty or the STOP bit of the last byte has been not transmitted.
N     * |        |          |1 = TX FIFO is empty and the STOP bit of the last byte has been transmitted.
N     * |        |          |Note: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.
N     * |[29]    |RXIDLE    |RX Idle Status (Read Only)
N     * |        |          |This bit is set by hardware when RX is idle.
N     * |        |          |0 = RX is busy.
N     * |        |          |1 = RX is idle. (Default)
N     * |[31]    |TXRXACT   |TX and RX Active Status (Read Only)
N     * |        |          |This bit indicates TX and RX are active or inactive.
N     * |        |          |0 = TX and RX are inactive.
N     * |        |          |1 = TX and RX are active. (Default)
N     * |        |          |Note: When TXRXDIS (UART_FUNCSEL[3]) is set and both TX and RX are in idle state, this bit is cleared.
N     * |        |          |The UART controller can not transmit or receive data at this moment. Otherwise this bit is set.
N     * @var UART_T::INTSTS
N     * Offset: 0x1C  UART Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDAIF     |Receive Data Available Interrupt Flag (Read Only)
N     * |        |          |When the number of bytes in the RX FIFO equals the RFITL then the RDAIF(UART_INTSTS[0]) will be set.
N     * |        |          |If RDAIEN (UART_INTEN [0]) is enabled, the RDA interrupt will be generated.
N     * |        |          |0 = No RDA interrupt flag is generated.
N     * |        |          |1 = RDA interrupt flag is generated.
N     * |        |          |Note: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UART_FIFO[7:4]).
N     * |[1]     |THREIF    |Transmit Holding Register Empty Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register.
N     * |        |          |If THREIEN (UART_INTEN[1]) is enabled, the THRE interrupt will be generated.
N     * |        |          |0 = No THRE interrupt flag is generated.
N     * |        |          |1 = THRE interrupt flag is generated.
N     * |        |          |Note: This bit is read only and it will be cleared when writing data into UART_DAT (TX FIFO not empty).
N     * |[2]     |RLSIF     |Receive Line Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UART_FIFOSTS[6]), FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]), is set).
N     * |        |          |If RLSIEN (UART_INTEN [2]) is enabled, the RLS interrupt will be generated.
N     * |        |          |0 = No RLS interrupt flag is generated.
N     * |        |          |1 = RLS interrupt flag is generated.
N     * |        |          |Note1: In RS-485 function mode, this field is set include receiver detect and received address byte character (bit9 = 1) bit.
N     * |        |          |At the same time, the bit of ADDRDETF (UART_FIFOSTS[3]) is also set.
N     * |        |          |Note2: This bit is read only and reset to 0 when all bits of BIF (UART_FIFOSTS[6]), FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) are cleared.
N     * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF (UART_FIFOSTS[6]) , FEF(UART_FIFOSTS[5]), and PEF(UART_FIFOSTS[4]) and ADDRDETF (UART_FIFOSTS[3]) are cleared.
N     * |[3]     |MODEMIF   |MODEM Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the nCTS pin has state change (CTSDETF (UART_MODEMSTS[0]) = 1)
N     * |        |          |If MODEMIEN (UART_INTEN [3]) is enabled, the Modem interrupt will be generated.
N     * |        |          |0 = No Modem interrupt flag is generated.
N     * |        |          |1 = Modem interrupt flag is generated.
N     * |        |          |Note: This bit is read only and reset to 0 when bit CTSDETF is cleared by a write 1 on CTSDETF(UART_MODEMSTS[0]).
N     * |[4]     |RXTOIF    |RX Time-out Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC (UART_TOUT[7:0])
N     * |        |          |If RXTOIENTOUTIEN (UART_INTEN [4]) is enabled, the Tout RX time-out interrupt will be generated.
N     * |        |          |0 = No RX time-outTime-out interrupt flag is generated.
N     * |        |          |1 = RX time-outTime-out interrupt flag is generated.
N     * |        |          |Note: This bit is read only and user can read UART_DAT (RX is in active) to clear it.
N     * |[5]     |BUFERRIF  |Buffer Error Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the TX FIFO or RX FIFO overflows (TXOVIF (UART_FIFOSTS[24]) or RXOVIF (UART_FIFOSTS[0]) is set)
N     * |        |          |When BUFERRIF (UART_INTSTS[5]) is set, the transfer is not correct.
N     * |        |          |If BUFERRIEN (UART_INTEN [5]) is enabled, the buffer error interrupt will be generated.
N     * |        |          |0 = No buffer error interrupt flag is generated.
N     * |        |          |1 = Buffer error interrupt flag is generated.
N     * |        |          |Note: This bit is cleared if both of RXOVIF(UART_FIFOSTS[0]) and TXOVIF(UART_FIFOSTS[24]) are cleared to 0 by writing 1 to RXOVIF(UART_FIFOSTS[0]) and TXOVIF(UART_FIFOSTS[24]).
N     * |[6]     |WKIF      |UART Wake-up Interrupt Flag (Read Only)
N     * |        |          |This bit is set when TOUTWKF (UART_WKSTS[4]), RS485WKF (UART_WKSTS[3]), RFRTWKF (UART_WKSTS[2]), DATWKIF (UART_WKSTS[1]) or CTSWKIF(UART_IWKSTS[0]) is set to 1.
N     * |        |          |0 = No UART wake-up interrupt flag is generated.
N     * |        |          |1 = UART wake-up interrupt flag is generated.
N     * |        |          |Note: This bit is cleared if all of TOUTWKF, RS485WKF, RFRTWKF, DATWKF and CTSWKF are cleared to 0 by writing 1 to the corresponding interrupt flag.
N     * |[7]     |LINIF     |LIN Bus Interrupt Flag (Read Only)
N     * |        |          |This bit is set when LIN slave header detect (SLVHDETF (UART_LINSTS[0] =1)), LIN break detect (BRKDETF(UART_LINSTS[98]=1)), bit error detect (BITEF(UART_LINSTS[9]=1)), LIN slave ID parity error (SLVIDPEF(UART_LINSTS[2] = 1)) or LIN slave header error detect (SLVHEF (UART_LINSTS[1] =1 ))
N     * |        |          |If LINIEN (UART_INTEN [8]) is enabled the LIN interrupt will be generated.
N     * |        |          |0 = None of SLVHDETF, BRKDETF, BITEF, SLVIDPEF and SLVHEF is generated.
N     * |        |          |1 = At least one of SLVHDETF, BRKDETF, BITEF, SLVIDPEF and SLVHEF is generated.
N     * |        |          |Note: This bit is cleared when SLVHDETF(UART_LINSTS[0]), BRKDETF(UART_LINSTS[8]), BITEF(UART_LINSTS[9]), SLVIDPEF (UART_LINSTS[2]) and SLVHEF(UART_LINSTS[1]) all are cleared and software writing 1 to LINIF(UART_INTSTS[7]).
N     * |[8]     |RDAINT    |Receive Data Available Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if RDAIEN (UART_INTEN[0]) and RDAIF (UART_INTSTS[0]) are both set to 1.
N     * |        |          |0 = No RDA interrupt is generated.
N     * |        |          |1 = RDA interrupt is generated.
N     * |[9]     |THREINT   |Transmit Holding Register Empty Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if THREIEN (UART_INTEN[1]) and THREIF(UART_INTSTS[1]) are both set to 1.
N     * |        |          |0 = No DATETHRE interrupt is generated.
N     * |        |          |1 = THREDATE interrupt is generated.
N     * |[10]    |RLSINT    |Receive Line Status Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if RLSIEN (UART_INTEN[2]) and RLSIF(UART_INTSTS[2]) are both set to 1.
N     * |        |          |0 = No RLS interrupt is generated.
N     * |        |          |1 = RLS interrupt is generated.
N     * |[11]    |MODEMINT  |MODEM Status Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if MODEMIEN(UART_INTEN[3]) and MODEMIF(UART_INTSTS[3]) are both set to 1
N     * |        |          |0 = No Modem interrupt is generated.
N     * |        |          |1 = Modem interrupt is generated..
N     * |[12]    |RXTOINT   |TRX Time-out Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if RXTOIEN (UART_INTEN[4]) and RXTOIF(UART_INTSTS[4]) are both set to 1.
N     * |        |          |0 = No RX time-out interrupt is generated.
N     * |        |          |1 = RX time-out interrupt is generated.
N     * |[13]    |BUFERRINT |Buffer Error Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if BUFERRIEN(UART_INTEN[5]) and BUFERRIF(UART_INTSTS[5]) are both set to 1.
N     * |        |          |0 = No buffer error interrupt is generated.
N     * |        |          |1 = Buffer error interrupt is generated.
N     * |[14]    |WKINT     |UART Wake-up Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if WKIEN (UART_INTEN[6]) and WKIF (UART_INTSTS[6]) are both set to 1.
N     * |        |          |0 = No UART wake-up interrupt is generated.
N     * |        |          |1 = UART wake-up interrupt is generated.
N     * |[15]    |LININT    |LIN Bus Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if LINIEN (UART_INTEN[8]) and LINIF(UART_INTSTS[7]) are both set to 1.
N     * |        |          |0 = No LIN Bus interrupt is generated.
N     * |        |          |1 = The LIN Bus interrupt is generated.
N     * |[18]    |HWRLSIF   |PDMA Mode Receive Line Status Flag (Read Only)
N     * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF (UART_FIFOSTS[6]), FEF (UART_FIFOSTS[5]) and PEF (UART_FIFOSTS[4]) is set).
N     * |        |          |If RLSIEN (UART_INTEN [2]) is enabled, the RLS interrupt will be generated.
N     * |        |          |0 = No RLS interrupt flag is generated in PDMA mode.
N     * |        |          |1 = RLS interrupt flag is generated in PDMA mode.
N     * |        |          |Note1: In RS-485 function mode, this field include receiver detect any address byte received address byte character (bit9 = 1) bit.
N     * |        |          |Note2: In UART function mode, this bit is read only and reset to 0 when all bits of BIF(UART_FIFOSTS[6]) , FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) are cleared.
N     * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UART_FIFOSTS[6]) , FEF(UART_FIFOSTS[5]), and PEF(UART_FIFOSTS[4]) and ADDRDETF (UART_FIFOSTS[3]) are cleared.
N     * |[19]    |HWMODIF   |PDMA Mode MODEM Status Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the nCTS pin has state change (CTSDETF (UART_MODEMSTS[0] =1)).
N     * |        |          |If MODEMIEN (UART_INTEN [3]) is enabled, the Modem interrupt will be generated.
N     * |        |          |0 = No Modem statusinterrupt flag is generated in PDMA mode.
N     * |        |          |1 = Modem status interrupt flag is generated in PDMA mode.
N     * |        |          |Note: This bit is read only and reset to 0 when the bit CTSDETF (UART_MODEMSTS[0]) is cleared by writing 1 on CTSDETF (UART_MODEMSTS[0]).
N     * |[20]    |HWTOIF    |PDMA Mode RX Time-out Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC (UART_TOUT[7:0]).
N     * |        |          |If RXTOIEN (UART_INTEN [4]) is enabled, the Tout RX time-out interrupt will be generated .
N     * |        |          |0 = No RX time-out interrupt flag is generated in PDMA mode.
N     * |        |          |1 = RX time-out interrupt flag is generated in PDMA mode.
N     * |        |          |Note: This bit is read only and user can read UART_DAT (RX is in active) to clear it.
N     * |[21]    |HWBUFEIF  |PDMA Mode Buffer Error Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the TX or RX FIFO overflows (TXOVIF (UART_FIFOSTS [24]) or RXOVIF (UART_FIFOSTS[0]) is set). When BUFERRIF (UART_INTSTS[5]) is set, the transfer maybe is not correct.
N     * |        |          |If BUFERRIEN (UART_INTEN [5]) is enabled, the buffer error interrupt will be generated.
N     * |        |          |0 = No buffer error interrupt flag is generated in PDMA mode.
N     * |        |          |1 = Buffer error interrupt flag is generated in PDMA mode.
N     * |        |          |Note: This bit is cleared when both TXOVIF (UART_FIFOSTS[24]]) and RXOVIF (UART_FIFOSTS[0]) are cleared.
N     * |[22]    |TXENDIF   |Transmitter Empty Interrupt Flag (Read Only)
N     * |        |          |This bit is set when TX FIFO (UART_DAT) is empty and the STOP bit of the last byte has been transmitted (TXEMPTYF (UART_FIFOSTS[28]) is set).
N     * |        |          |If TXENDIEN (UART_INTEN[22]) is enabled, the Transmitter Empty interrupt will be generated.
N     * |        |          |0 = No transmitter empty interrupt flag is generated.
N     * |        |          |1 = Transmitter empty interrupt flag is generated.
N     * |        |          |Note: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.
N     * |[26]    |HWRLSINT  |PDMA Mode Receive Line Status Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if RLSIEN (UART_INTEN[2]) and HWRLSIF(UART_INTSTS[18]) are both set to 1.
N     * |        |          |0 = No RLS interrupt is generated in PDMA mode.
N     * |        |          |1 = RLS interrupt is generated in PDMA mode.
N     * |[27]    |HWMODINT  |PDMA Mode MODEM Status Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if MODEMIEN (UART_INTEN[3]) and HWMODIF(UART_INTSTS[19]) are both set to 1.
N     * |        |          |0 = No Modem interrupt is generated in PDMA mode.
N     * |        |          |1 = Modem interrupt is generated in PDMA mode.
N     * |[28]    |HWTOINT   |PDMA Mode RX Time-out Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if RXTOIEN (UART_INTEN[4]) and HWTOIF(UART_INTSTS[20]) are both set to 1.
N     * |        |          |0 = No RX time-out interrupt is generated in PDMA mode.
N     * |        |          |1 = RX time-out interrupt is generated in PDMA mode.
N     * |[29]    |HWBUFEINT |PDMA Mode Buffer Error Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if BUFERRIEN (UART_INTEN[5]) and HWBUFEIF (UART_INTSTS[21]) are both set to 1.
N     * |        |          |0 = No buffer error interrupt is generated in PDMA mode.
N     * |        |          |1 = Buffer error interrupt is generated in PDMA mode.
N     * |[30]    |TXENDINT  |Transmitter Empty Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if TXENDIEN (UART_INTEN[22]) and TXENDIF(UART_INTSTS[22]) are both set to 1.
N     * |        |          |0 = No Transmitter Empty interrupt is generated.
N     * |        |          |1 = Transmitter Empty interrupt is generated.
N     * |[31]    |ABRINT    |Auto-baud Rate Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if ABRIEN (UART_INTEN[18]) and ABRIF (UART_ALTCTL[17]) are both set to 1.
N     * |        |          |0 = No Auto-baud Rate interrupt is generated.
N     * |        |          |1 = The Auto-baud Rate interrupt is generated.
N     * @var UART_T::TOUT
N     * Offset: 0x20  UART Time-out Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |TOIC      |Time-out Interrupt Comparator
N     * |        |          |The time-out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word if time out counter is enabled by setting TOCNTEN (UART_INTEN[11]).
N     * |        |          |Once the content of time-out counter is equal to that of time-out interrupt comparator (TOIC (UART_TOUT[7:0])), a receiver time-out interrupt (RXTOINT(UART_INTSTS[12])) is generated if RXTOIEN (UART_INTEN [4]) enabled.
N     * |        |          |A new incoming data word or RX FIFO empty will clear RXTOIF (UART_INTSTS[4]).
N     * |        |          |In order to avoid receiver time-out interrupt generation immediately during one character is being received, TOIC value should be set between 40 and 255.
N     * |        |          |So, for example, if TOIC is set with 40, the time-out interrupt is generated after four characters are not received when 1 stop bit and no parity check is set for UART transfer.
N     * |[15:8]  |DLY       |TX Delay Time Value
N     * |        |          |This field is used to programming the transfer delay time between the last stop bit and next start bit.
N     * |        |          |The unit is bit time.
N     * @var UART_T::BAUD
N     * Offset: 0x24  UART Baud Rate Divider Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |BRD       |Baud Rate Divider
N     * |        |          |The field indicates the baud rate divider. This filed is used in baud rate calculation.
N     * |[27:24] |EDIVM1    |Extra Divider for BAUD Rate Mode 1
N     * |        |          |This field is used for baud rate calculation in mode 1 and has no effect for baud rate calculation in mode 0 and mode 2.
N     * |[28]    |BAUDM0    |BAUD Rate Mode Selection Bit 0
N     * |        |          |This bit is baud rate mode selection bit 0.
N     * |        |          |UART provides three baud rate calculation modes.
N     * |        |          |This bit combines with BAUDM1 (UART_BAUD[29]) to select baud rate calculation mode.
N     * |[29]    |BAUDM1    |BAUD Rate Mode Selection Bit 1
N     * |        |          |This bit is baud rate mode selection bit 1.
N     * |        |          |UART provides three baud rate calculation modes.
N     * |        |          |This bit combines with BAUDM0 (UART_BAUD[28]) to select baud rate calculation mode.
N     * |        |          |Note: In IrDA mode must be operated in mode 0.
N     * @var UART_T::IRDA
N     * Offset: 0x28  UART IrDA Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |TXEN      |IrDA Receiver/Transmitter Selection Enable Bit
N     * |        |          |0 = IrDA Transmitter Disabled and Receiver Enabled. (Default)
N     * |        |          |1 = IrDA Transmitter Enabled and Receiver Disabled.
N     * |        |          |Note: In IrDA mode, the BAUDM1 (UART_BAUD [29]) register must be disabled, the baud equation must be Clock / (16 * (BRD + 2)).
N     * |[5]     |TXINV     |IrDA Inverse Transmitting Output Signal
N     * |        |          |0 = None inverse transmitting signal. (Default).
N     * |        |          |1 = Inverse transmitting output signal.
N     * |        |          |Note1: Before setting this bit, TXRXDIS (UART_FUNCSEL[3]) should be set then waited for TXRXACT (UART_FIFOSTS[31]) is cleared.
N     * |        |          |When the configuration is done, cleared TXRXDIS (UART_FUNCSEL[3]) to activate UART controller.
N     * |        |          |Note2: This bit is valid when FUNCSEL (UART_FUNCSEL[1:0]) is select IrDA function.
N     * |[6]     |RXINV     |IrDA Inverse Receive Input Signal
N     * |        |          |0 = None inverse receiving input signal.
N     * |        |          |1 = Inverse receiving input signal. (Default)
N     * |        |          |Note1: Before setting this bit, TXRXDIS (UART_FUNCSEL[3]) should be set then waited for TXRXACT (UART_FIFOSTS[31]) is cleared.
N     * |        |          |When the configuration is done, cleared TXRXDIS (UART_FUNCSEL[3]) to activate UART controller.
N     * |        |          |Note2: This bit is valid when FUNCSEL (UART_FUNCSEL[1:0]) is select IrDA function.
N     * @var UART_T::ALTCTL
N     * Offset: 0x2C  UART Alternate Control/Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |BRKFL     |UART LIN Break Field Length
N     * |        |          |This field indicates a 4-bit LIN TX break field count.
N     * |        |          |Note1: This break field length is BRKFL + 1.
N     * |        |          |Note2: According to LIN spec, the reset value is 0xC (break field length = 13).
N     * |[6]     |LINRXEN   |LIN RX Enable Bit
N     * |        |          |0 = LIN RX mode Disabled.
N     * |        |          |1 = LIN RX mode Enabled.
N     * |[7]     |LINTXEN   |LIN TX Break Mode Enable Bit
N     * |        |          |0 = LIN TX Break mode Disabled.
N     * |        |          |1 = LIN TX Break mode Enabled.
N     * |        |          |Note: When TX break field transfer operation finished, this bit will be cleared automatically.
N     * |[8]     |RS485NMM  |RS-485 Normal Multi-drop Operation Mode (NMM)
N     * |        |          |0 = RS-485 Normal Multi-drop Operation mode (NMM) Disabled.
N     * |        |          |1 = RS-485 Normal Multi-drop Operation mode (NMM) Enabled.
N     * |        |          |Note: It cannot be active with RS-485_AAD operation mode.
N     * |[9]     |RS485AAD  |RS-485 Auto Address Detection Operation Mode (AAD)
N     * |        |          |0 = RS-485 Auto Address Detection Operation mode (AAD) Disabled.
N     * |        |          |1 = RS-485 Auto Address Detection Operation mode (AAD) Enabled.
N     * |        |          |Note: It cannot be active with RS-485_NMM operation mode.
N     * |[10]    |RS485AUD  |RS-485 Auto Direction Function (AUD)
N     * |        |          |0 = RS-485 Auto Direction Operation function (AUD) Disabled.
N     * |        |          |1 = RS-485 Auto Direction Operation function (AUD) Enabled.
N     * |        |          |Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.
N     * |[15]    |ADDRDEN   |RS-485 Address Detection Enable Bit
N     * |        |          |This bit is used to enable RS-485 Address Detection mode.
N     * |        |          |0 = Address detection mode Disabled.
N     * |        |          |1 = Address detection mode Enabled.
N     * |        |          |Note: This bit is used for RS-485 any operation mode.
N     * |[17]    |ABRIF     |Auto-baud Rate Interrupt Flag (Read Only)
N     * |        |          |This bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABRIEN(UART_INTEN [18]) is set then the auto-baud rate interrupt will be generated.
N     * |        |          |0 = No auto-baud rate interrupt flag is generated.
N     * |        |          |1 = Auto-baud rate interrupt flag is generated.
N     * |        |          |Note: This bit can be cleared by writing 1 to ABRDTOIF (UART_FIFOSTS[2]) and ABRDIF(UART_FIFOSTS[1]).
N     * |[18]    |ABRDEN    |Auto-baud Rate Detect Enable Bit
N     * |        |          |0 = Auto-baud rate detect function Disabled.
N     * |        |          |1 = Auto-baud rate detect function Enabled.
N     * |        |          |Note : This bit is cleared automatically after auto-baud detection is finished.
N     * |[20:19] |ABRDBITS  |Auto-baud Rate Detect Bit Length
N     * |        |          |00 = 1-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x01.
N     * |        |          |01 = 2-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x02.
N     * |        |          |10 = 4-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x08.
N     * |        |          |11 = 8-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x80.
N     * |        |          |Note : The calculation of bit number includes the START bit.
N     * |[31:24] |ADDRMV    |Address Match Value
N     * |        |          |This field contains the RS-485 address match values.
N     * |        |          |Note: This field is used for RS-485 auto address detection mode.
N     * @var UART_T::FUNCSEL
N     * Offset: 0x30  UART Function Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |FUNCSEL   |Function Select
N     * |        |          |00 = UART function.
N     * |        |          |01 = LIN function.
N     * |        |          |10 = IrDA function.
N     * |        |          |11 = RS-485 function.
N     * |[3]     |TXRXDIS   |TX and RX Disable Bit
N     * |        |          |Setting this bit can disable TX and RX.
N     * |        |          |0 = TX and RX Enabled.
N     * |        |          |1 = TX and RX Disabled.
N     * |        |          |Note: The TX and RX will not disable immediately when this bit is set.
N     * |        |          |The TX and RX compelet current task before disable TX and RX.
N     * |        |          |When TX and RX disable, the TXRXACT (UART_FIFOSTS[31]) is cleared.
N     * @var UART_T::LINCTL
N     * Offset: 0x34  UART LIN Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SLVEN     |LIN Slave Mode Enable Bit
N     * |        |          |0 = LIN slave mode Disabled.
N     * |        |          |1 = LIN slave mode Enabled.
N     * |[1]     |SLVHDEN   |LIN Slave Header Detection Enable Bit
N     * |        |          |0 = LIN slave header detection Disabled.
N     * |        |          |1 = LIN slave header detection Enabled.
N     * |        |          |Note1: This bit only valid when in LIN slave mode (SLVEN (UART_LINCTL[0]) = 1).
N     * |        |          |Note2: In LIN function mode, when detect header field (break + sync + frame ID), SLVHDETF (UART_LINSTS [0]) flag will be asserted.
N     * |        |          |If the LINIEN (UART_INTEN[8]) = 1, an interrupt will be generated.
N     * |[2]     |SLVAREN   |LIN Slave Automatic Resynchronization Mode Enable Bit
N     * |        |          |0 = LIN automatic resynchronization Disabled.
N     * |        |          |1 = LIN automatic resynchronization Enabled.
N     * |        |          |Note1: This bit only valid when in LIN slave mode (SLVEN (UART_LINCTL[0]) = 1).
N     * |        |          |Note2: When operation in Automatic Resynchronization mode, the baud rate setting must be mode2 (BAUDM1 (UART_BAUD [29]) and BAUDM0 (UART_BAUD [28]) must be 1).
N     * |[3]     |SLVDUEN   |LIN Slave Divider Update Method Enable Bit
N     * |        |          |0 = UART_BAUD updated is written by software (if no automatic resynchronization update occurs at the same time).
N     * |        |          |1 = UART_BAUD is updated at the next received character
N     * |        |          |User must set the bit before checksum reception.
N     * |        |          |Note1: This bit only valid when in LIN slave mode (SLVEN (UART_LINCTL[0]) = 1).
N     * |        |          |Note2: This bit used for LIN Slave Automatic Resynchronization mode.
N     * |        |          |(for Non-Automatic Resynchronization mode, this bit should be kept cleared).
N     * |[4]     |MUTE      |LIN Mute Mode Enable Bit
N     * |        |          |0 = LIN mute mode Disabled.
N     * |        |          |1 = LIN mute mode Enabled.
N     * |[8]     |SENDH     |LIN TX Send Header Enable Bit
N     * |        |          |The LIN TX header can be "break field" or "break and sync field" or "break, sync and frame ID field", it is depend on setting HSEL (UART_LINCTL[23:22]).
N     * |        |          |0 = Send LIN TX header Disabled.
N     * |        |          |1 = Send LIN TX header Enabled.
N     * |        |          |Note1: These registers are This bit is shadow registers bit of LINTXEN (UART_ALTCTL [7]); user can read/write it by setting LINTXEN (UART_ALTCTL [7]) or SENDH (UART_LINCTL [8]).
N     * |        |          |Note2: When transmitter header field (it may be "break" or "break + sync" or "break + sync + frame ID" selected by HSEL (UART_LINCTL[23:22]) field) transfer operation finished, this bit will be cleared automatically.
N     * |[9]     |IDPEN     |LIN ID Parity Enable Bit
N     * |        |          |0 = LIN frame ID parity Disabled.
N     * |        |          |1 = LIN frame ID parity Enabled.
N     * |        |          |Note1: This bit can be used for LIN master to sending header field (SENDH (UART_LINCTL[8])) = 1 and HSEL (UART_LINCTL[23:22]) = 10) or be used for enable LIN slave received frame ID parity checked.
N     * |        |          |Note2: This bit is only used when the operation header transmitter is in HSEL (UART_LINCTL[23:22]) = 10.
N     * |[10]    |BRKDETEN  |LIN Break Detection Enable Bit
N     * |        |          |When detect consecutive dominant greater than 11 bits, and are followed by a delimiter character, the BRKDETF (UART_LINSTS[8]) flag is set in UART_LINSTS register at the end of break field.
N     * |        |          |If the LINIEN (UART_INTEN [8])=1, an interrupt will be generated.
N     * |        |          |0 = LIN break detection Disabled.
N     * |        |          |1 = LIN break detection Enabled.
N     * |[11]    |LINRXOFF  |LIN Receiver Disable Bit
N     * |        |          |If the receiver is enabled (LINRXOFF (UART_LINCTL[11]) = 0), all received byte data will be accepted and stored in the RX FIFO, and if the receiver is disabled (LINRXOFF (UART_LINCTL[11] = 1), all received byte data will be ignore.
N     * |        |          |0 = LIN receiver Enabled.
N     * |        |          |1 = LIN receiver Disabled.
N     * |        |          |Note: This bit is only valid when operating in LIN function mode (FUNCSEL (UART_FUNCSEL[1:0]) = 01).
N     * |[12]    |BITERREN  |Bit Error Detect Enable Bit
N     * |        |          |0 = Bit error detection function Disabled.
N     * |        |          |1 = Bit error detection function Enabled.
N     * |        |          |Note: In LIN function mode, when occur bit error, the BITEF (UART_LINSTS[9]) flag will be asserted.
N     * |        |          |If the LINIEN (UART_INTEN[8]) = 1, an interrupt will be generated.
N     * |[19:16] |BRKFL     |LIN Break Field Length
N     * |        |          |This field indicates a 4-bit LIN TX break field count.
N     * |        |          |Note1: These registers are shadow registers of BRKFL (UART_ALTCTL[3:0]), User can read/write it by setting BRKFL (UART_ALTCTL[3:0]) or BRKFL (UART_LINCTL[19:16]).
N     * |        |          |Note2: This break field length is BRKFL + 1.
N     * |        |          |Note3: According to LIN spec, the reset value is 12 (break field length = 13).
N     * |[21:20] |BSL       |LIN Break/Sync Delimiter Length
N     * |        |          |00 = The LIN break/sync delimiter length is 1-bit time.
N     * |        |          |01 = The LIN break/sync delimiter length is 2-bit time.
N     * |        |          |10 = The LIN break/sync delimiter length is 3-bit time.
N     * |        |          |11 = The LIN break/sync delimiter length is 4-bit time.
N     * |        |          |Note: This bit used for LIN master to sending header field.
N     * |[23:22] |HSEL      |LIN Header Select
N     * |        |          |00 = The LIN header includes break field.
N     * |        |          |01 = The LIN header includes break field and sync field.
N     * |        |          |10 = The LIN header includes break field, ync field and frame ID field.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: This bit is used to master mode for LIN to send header field (SENDH (UART_LINCTL [8]) = 1) or used to slave to indicates exit from mute mode condition (MUTE (UART_LINCTL[4] = 1).
N     * |[31:24] |PID       |LIN PID Bits
N     * |        |          |This field contains the LIN frame ID value when in LIN function mode, the frame ID parity can be generated by software or hardware depends on IDPEN (UART_LINCTL[9]) = 1.
N     * |        |          |If the parity generated by hardware, user fill ID0~ID5 , (PID [29:24] ), hardware will calculate P0 (PID[30]) and P1 (PID[31]), otherwise user must filled frame ID and parity in this field.
N     * |        |          |Note1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first).
N     * |        |          |Note2: This field can be used for LIN master mode or slave mode.
N     * @var UART_T::LINSTS
N     * Offset: 0x38  UART LIN Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SLVHDETF  |LIN Slave Header Detection Flag
N     * |        |          |This bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared by writing 1 to it.
N     * |        |          |0 = LIN header not detected.
N     * |        |          |1 = LIN header detected (break + sync + frame ID).
N     * |        |          |Note1: This bitcan be cleared by writing 1 to it.
N     * |        |          |Note2: This bit is only valid when in LIN slave mode (SLVEN (UART_LINCTL [0]) = 1) and enable LIN slave header detection function (SLVHDEN (UART_LINCTL [1])).
N     * |        |          |Note3: When enable ID parity check IDPEN (UART_LINCTL [9]), if hardware detect complete header (u201Cbreak + sync + frame IDu201D), the SLVHDETF will be set whether the frame ID correct or not.
N     * |[1]     |SLVHEF    |LIN Slave Header Error Flag
N     * |        |          |This bit is set by hardware when a LIN header error is detected in LIN slave mode and be cleared by writing 1 to it.
N     * |        |          |The header errors include "break delimiter is too short (less than 0.5 bit time)", "frame error in sync field or Identifier fieldu", "sync field data is not 0x55 in Non-Automatic Resynchronization modeu", "sync field deviation error with Automatic Resynchronization modeu", "sync field measure time-out with Automatic Resynchronization mode" and "LIN header reception time-out".
N     * |        |          |0 = LIN header error not detected.
N     * |        |          |1 = LIN header error detected.
N     * |        |          |Note1: This bit can be cleared by writing 1 to it.
N     * |        |          |Note2: This bit is only valid when UART is operated in LIN slave mode (SLVEN (UART_LINCTL [0]) = 1) and enables LIN slave header detection function (SLVHDEN (UART_LINCTL [1])).
N     * |[2]     |SLVIDPEF  |LIN Slave ID Parity Error Flag
N     * |        |          |This bit is set by hardware when receipted frame ID parity is not correct.
N     * |        |          |0 = No active.
N     * |        |          |1 = Receipted frame ID parity is not correct.
N     * |        |          |Note1: This can be cleared by writing 1 to it.
N     * |        |          |Note2: This bit is only valid when in LIN slave mode (SLVEN (UART_LINCTL [0])= 1) and enable LIN frame ID parity check function IDPEN (UART_LINCTL [9]).
N     * |[3]     |SLVSYNCF  |LIN Slave Sync Field
N     * |        |          |This bit indicates that the LIN sync field is being analyzed in Automatic Resynchronization mode.
N     * |        |          |When the receiver header have some error been detect, user must reset the internal circuit to re-search new frame header by writing 1 to this bit.
N     * |        |          |0 = The current character is not at LIN sync state.
N     * |        |          |1 = The current character is at LIN sync state.
N     * |        |          |Note1: This bit is only valid when in LIN Slave mode (SLVEN(UART_LINCTL[0]) = 1).
N     * |        |          |Note2: This bit can be cleared by writing 1 to it.
N     * |        |          |Note3: When writing 1 to it, hardware will reload the initial baud rate and re-search a new frame header.
N     * |[8]     |BRKDETF   |LIN Break Detection Flag
N     * |        |          |This bit is set by hardware when a break is detected and be cleared by writing 1 to it through software.
N     * |        |          |0 = LIN break not detected.
N     * |        |          |1 = LIN break detected.
N     * |        |          |Note1: This bitcan be cleared by writing 1 to it.
N     * |        |          |Note2: This bit is only valid when LIN break detection function is enabled (BRKDETEN (UART_LINCTL[10]) =1).
N     * |[9]     |BITEF     |Bit Error Detect Status Flag (Read Only)
N     * |        |          |At TX transfer state, hardware will monitoring the bus state, if the input pin (UART_RXD) state not equals to the output pin (UART_TXD) state, BITEF (UART_LINSTS[9]) will be set.
N     * |        |          |When occur bit error, if the LINIEN (UART_INTEN[8]) = 1, an interrupt will be generated.
N     * |        |          |0 = Bit error not detected.
N     * |        |          |1 = Bit error detected.
N     * |        |          |Note1: This bit can be cleared by writing 1 to it.
N     * |        |          |Note2: This bit is only valid when enable bit error detection function (BITERREN (UART_LINCTL [12]) = 1).
N     * @var UART_T::BRCOMP
N     * Offset: 0x3C  UART Baud Rate Compensation Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8:0]   |BRCOMP    |Baud Rate Compensation Patten
N     * |        |          |These 9-bits are used to define the relative bit is compensated or not.
N     * |        |          |BRCOMP[7:0] is used to define the compensation of UART_DAT[7:0] and BRCOMP[8] is used to define the parity bit.
N     * |[31]    |BRCOMPDEC |Baud Rate Compensation Decrease
N     * |        |          |0 = Positive (increase one module clock) compensation for each compensated bit.
N     * |        |          |1 = Negative (decrease one module clock) compensation for each compensated bit.
N     * @var UART_T::WKCTL
N     * Offset: 0x40  UART Wake-up Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WKCTSEN   |nCTS Wake-up Enable Bit
N     * |        |          |0 = nCTS Wake-up system function Disabled.
N     * |        |          |1 = nCTS Wake-up system function Enabled, when the system is in Power-down mode, an external nCTS change will wake-up system from Power-down mode.
N     * |[1]     |WKDATEN   |Incoming Data Wake-up Enable Bit
N     * |        |          |0 = Incoming data wake-up system function Disabled.
N     * |        |          |1 = Incoming data wake-up system function Enabled, when the system is in Power-down mode, incoming data will wake-up system from Power-down mode.
N     * |[2]     |WKRFRTEN  |Received Data FIFO Reached Threshold Wake-up Enable Bit
N     * |        |          |0 = Received Data FIFO reached threshold wake-up system function Disabled.
N     * |        |          |1 = Received Data FIFO reached threshold wake-up system function Enabled, when the system is .
N     * |        |          |in Power-down mode, Received Data FIFO reached threshold will wake-up system from Power-down mode.
N     * |[3]     |WKRS485EN |RS-485 Address Match (AAD Mode) Wake-up Enable Bit
N     * |        |          |0 = RS-485 Address Match (AAD mode) wake-up system function Disabled.
N     * |        |          |1 = RS-485 Address Match (AAD mode) wake-up system function Enabled, when the system is in Power-down mode, RS-485 Address Match will wake-up system from Power-down mode.
N     * |        |          |Note: This bit is used for RS-485 Auto Address Detection (AAD) mode in RS-485 function mode and ADDRDEN (UART_ALTCTL[15]) is set to 1.
N     * |[4]     |WKTOUTEN  |Received Data FIFO Reached Threshold Time-out Wake-up Enable Bit
N     * |        |          |0 = Received Data FIFO reached threshold time-out wake-up system function Disabled.
N     * |        |          |1 = Received Data FIFO reached threshold time-out wake-up system function Enabled, when the system is in Power-down mode, Received Data FIFO reached threshold time-out will wake-up system from Power-down mode.
N     * |        |          |Note: It is suggest the function is enabled when the WKRFRTEN (UART_WKCTL[2]) is set to 1.
N     * @var UART_T::WKSTS
N     * Offset: 0x44  UART Wake-up Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CTSWKF    |nCTS Wake-up Flag
N     * |        |          |This bit is set if chip wake-up from power-down state by nCTS wake-up.
N     * |        |          |0 = Chip stays in power-down state.
N     * |        |          |1 = Chip wake-up from power-down state by nCTS wake-up.
N     * |        |          |Note1: If WKCTSEN (UART_WKCTL[0]) is enabled, the nCTS wake-up cause this bit is set to 1.
N     * |        |          |Note2: This bit can be cleared by writing 1 to it.
N     * |[1]     |DATWKF    |Incoming Data Wake-up Flag
N     * |        |          |This bit is set if chip wake-up from power-down state by data wake-up.
N     * |        |          |0 = Chip stays in power-down state.
N     * |        |          |1 = Chip wake-up from power-down state by Incoming Data wake-up.
N     * |        |          |Note1: If WKDATEN (UART_WKCTL[1]) is enabled, the Incoming Data wake-up cause this bit is set to 1.
N     * |        |          |Note2: This bit can be cleared by writing 1 to it.
N     * |[2]     |RFRTWKF   |Received Data FIFO Reached Threshold Wake-up Flag
N     * |        |          |This bit is set if chip wake-up from power-down state by Received Data FIFO reached threshold wake-up.
N     * |        |          |0 = Chip stays in power-down state.
N     * |        |          |1 = Chip wake-up from power-down state by Received Data FIFO Reached Threshold wake-up.
N     * |        |          |Note1: If WKRFRTEN (UART_WKCTL[2]) is enabled, the Received Data FIFO Reached Threshold wake-up cause this bit is set to 1.
N     * |        |          |Note2: This bit can be cleared by writing 1 to it.
N     * |[3]     |RS485WKF  |RS-485 Address Match (AAD Mode) Wake-up Flag
N     * |        |          |This bit is set if chip wake-up from power-down state by RS-485 Address Match (AAD mode).
N     * |        |          |0 = Chip stays in power-down state.
N     * |        |          |1 = Chip wake-up from power-down state by RS-485 Address Match (AAD mode) wake-up.
N     * |        |          |Note1: If WKRS485EN (UART_WKCTL[3]) is enabled, the RS-485 Address Match (AAD mode) wake-up cause this bit is set to 1.
N     * |        |          |Note2: This bit can be cleared by writing 1 to it.
N     * |[4]     |TOUTWKF   |Received Data FIFO Threshold Time-out Wake-up Flag
N     * |        |          |This bit is set if chip wake-up from power-down state by Received Data FIFO Threshold Time-out wake-up.
N     * |        |          |0 = Chip stays in power-down state.
N     * |        |          |1 = Chip wake-up from power-down state by Received Data FIFO reached threshold time-out wake-up.
N     * |        |          |Note1: If WKTOUTEN (UART_WKCTL[4]) is enabled, the Received Data FIFO reached threshold time-out wake-up cause this bit is set to 1.
N     * |        |          |Note2: This bit can be cleared by writing 1 to it.
N     * @var UART_T::DWKCOMP
N     * Offset: 0x48  UART Imcoming Data Wake-up Compensation Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |STCOMP    |Start Bit Compensation Value
N     * |        |          |These bits field indicate how many clock cycle selected by UART_CLK do the UART controller can get the 1st bit (start bit) when the device is wake-up from power-down mode.
N     * |        |          |Note: It is valid only when WKDATEN (UART_WKCTL[1]) is set.
N     */
N
N
N    __IO uint32_t DAT;                   /*!< [0x0000] UART Receive/Transmit Buffer Register                            */
X    volatile uint32_t DAT;                    
N    __IO uint32_t INTEN;                 /*!< [0x0004] UART Interrupt Enable Register                                   */
X    volatile uint32_t INTEN;                  
N    __IO uint32_t FIFO;                  /*!< [0x0008] UART FIFO Control Register                                       */
X    volatile uint32_t FIFO;                   
N    __IO uint32_t LINE;                  /*!< [0x000c] UART Line Control Register                                       */
X    volatile uint32_t LINE;                   
N    __IO uint32_t MODEM;                 /*!< [0x0010] UART Modem Control Register                                      */
X    volatile uint32_t MODEM;                  
N    __IO uint32_t MODEMSTS;              /*!< [0x0014] UART Modem Status Register                                       */
X    volatile uint32_t MODEMSTS;               
N    __IO uint32_t FIFOSTS;               /*!< [0x0018] UART FIFO Status Register                                        */
X    volatile uint32_t FIFOSTS;                
N    __IO uint32_t INTSTS;                /*!< [0x001c] UART Interrupt Status Register                                   */
X    volatile uint32_t INTSTS;                 
N    __IO uint32_t TOUT;                  /*!< [0x0020] UART Time-out Register                                           */
X    volatile uint32_t TOUT;                   
N    __IO uint32_t BAUD;                  /*!< [0x0024] UART Baud Rate Divider Register                                  */
X    volatile uint32_t BAUD;                   
N    __IO uint32_t IRDA;                  /*!< [0x0028] UART IrDA Control Register                                       */
X    volatile uint32_t IRDA;                   
N    __IO uint32_t ALTCTL;                /*!< [0x002c] UART Alternate Control/Status Register                           */
X    volatile uint32_t ALTCTL;                 
N    __IO uint32_t FUNCSEL;               /*!< [0x0030] UART Function Select Register                                    */
X    volatile uint32_t FUNCSEL;                
N    __IO uint32_t LINCTL;                /*!< [0x0034] UART LIN Control Register                                        */
X    volatile uint32_t LINCTL;                 
N    __IO uint32_t LINSTS;                /*!< [0x0038] UART LIN Status Register                                         */
X    volatile uint32_t LINSTS;                 
N    __IO uint32_t BRCOMP;                /*!< [0x003c] UART Baud Rate Compensation Register                             */
X    volatile uint32_t BRCOMP;                 
N    __IO uint32_t WKCTL;                 /*!< [0x0040] UART Wake-up Control Register                                    */
X    volatile uint32_t WKCTL;                  
N    __IO uint32_t WKSTS;                 /*!< [0x0044] UART Wake-up Status Register                                     */
X    volatile uint32_t WKSTS;                  
N    __IO uint32_t DWKCOMP;               /*!< [0x0048] UART Imcoming Data Wake-up Compensation Register                 */
X    volatile uint32_t DWKCOMP;                
N
N
N} UART_T;
N
N/**
N    @addtogroup UART_CONST UART Bit Field Definition
N    Constant Definitions for UART Controller
N@{ */
N
N#define UART_DAT_DAT_Pos                 (0)                                               /*!< UART_T::DAT: DAT Position              */
N#define UART_DAT_DAT_Msk                 (0xfful << UART_DAT_DAT_Pos)                      /*!< UART_T::DAT: DAT Mask                  */
N
N#define UART_DAT_PARITY_Pos              (8)                                               /*!< UART_T::DAT: PARITY Position           */
N#define UART_DAT_PARITY_Msk              (0x1ul << UART_DAT_PARITY_Pos)                    /*!< UART_T::DAT: PARITY Mask               */
N
N#define UART_INTEN_RDAIEN_Pos            (0)                                               /*!< UART_T::INTEN: RDAIEN Position         */
N#define UART_INTEN_RDAIEN_Msk            (0x1ul << UART_INTEN_RDAIEN_Pos)                  /*!< UART_T::INTEN: RDAIEN Mask             */
N
N#define UART_INTEN_THREIEN_Pos           (1)                                               /*!< UART_T::INTEN: THREIEN Position        */
N#define UART_INTEN_THREIEN_Msk           (0x1ul << UART_INTEN_THREIEN_Pos)                 /*!< UART_T::INTEN: THREIEN Mask            */
N
N#define UART_INTEN_RLSIEN_Pos            (2)                                               /*!< UART_T::INTEN: RLSIEN Position         */
N#define UART_INTEN_RLSIEN_Msk            (0x1ul << UART_INTEN_RLSIEN_Pos)                  /*!< UART_T::INTEN: RLSIEN Mask             */
N
N#define UART_INTEN_MODEMIEN_Pos          (3)                                               /*!< UART_T::INTEN: MODEMIEN Position       */
N#define UART_INTEN_MODEMIEN_Msk          (0x1ul << UART_INTEN_MODEMIEN_Pos)                /*!< UART_T::INTEN: MODEMIEN Mask           */
N
N#define UART_INTEN_RXTOIEN_Pos           (4)                                               /*!< UART_T::INTEN: RXTOIEN Position        */
N#define UART_INTEN_RXTOIEN_Msk           (0x1ul << UART_INTEN_RXTOIEN_Pos)                 /*!< UART_T::INTEN: RXTOIEN Mask            */
N
N#define UART_INTEN_BUFERRIEN_Pos         (5)                                               /*!< UART_T::INTEN: BUFERRIEN Position      */
N#define UART_INTEN_BUFERRIEN_Msk         (0x1ul << UART_INTEN_BUFERRIEN_Pos)               /*!< UART_T::INTEN: BUFERRIEN Mask          */
N
N#define UART_INTEN_WKIEN_Pos             (6)                                               /*!< UART_T::INTEN: WKIEN Position          */
N#define UART_INTEN_WKIEN_Msk             (0x1ul << UART_INTEN_WKIEN_Pos)                   /*!< UART_T::INTEN: WKIEN Mask              */
N
N#define UART_INTEN_LINIEN_Pos            (8)                                               /*!< UART_T::INTEN: LINIEN Position         */
N#define UART_INTEN_LINIEN_Msk            (0x1ul << UART_INTEN_LINIEN_Pos)                  /*!< UART_T::INTEN: LINIEN Mask             */
N
N#define UART_INTEN_TOCNTEN_Pos           (11)                                              /*!< UART_T::INTEN: TOCNTEN Position        */
N#define UART_INTEN_TOCNTEN_Msk           (0x1ul << UART_INTEN_TOCNTEN_Pos)                 /*!< UART_T::INTEN: TOCNTEN Mask            */
N
N#define UART_INTEN_ATORTSEN_Pos          (12)                                              /*!< UART_T::INTEN: ATORTSEN Position       */
N#define UART_INTEN_ATORTSEN_Msk          (0x1ul << UART_INTEN_ATORTSEN_Pos)                /*!< UART_T::INTEN: ATORTSEN Mask           */
N
N#define UART_INTEN_ATOCTSEN_Pos          (13)                                              /*!< UART_T::INTEN: ATOCTSEN Position       */
N#define UART_INTEN_ATOCTSEN_Msk          (0x1ul << UART_INTEN_ATOCTSEN_Pos)                /*!< UART_T::INTEN: ATOCTSEN Mask           */
N
N#define UART_INTEN_TXPDMAEN_Pos          (14)                                              /*!< UART_T::INTEN: TXPDMAEN Position       */
N#define UART_INTEN_TXPDMAEN_Msk          (0x1ul << UART_INTEN_TXPDMAEN_Pos)                /*!< UART_T::INTEN: TXPDMAEN Mask           */
N
N#define UART_INTEN_RXPDMAEN_Pos          (15)                                              /*!< UART_T::INTEN: RXPDMAEN Position       */
N#define UART_INTEN_RXPDMAEN_Msk          (0x1ul << UART_INTEN_RXPDMAEN_Pos)                /*!< UART_T::INTEN: RXPDMAEN Mask           */
N
N#define UART_INTEN_ABRIEN_Pos            (18)                                              /*!< UART_T::INTEN: ABRIEN Position         */
N#define UART_INTEN_ABRIEN_Msk            (0x1ul << UART_INTEN_ABRIEN_Pos)                  /*!< UART_T::INTEN: ABRIEN Mask             */
N
N#define UART_INTEN_TXENDIEN_Pos          (22)                                              /*!< UART_T::INTEN: TXENDIEN Position       */
N#define UART_INTEN_TXENDIEN_Msk          (0x1ul << UART_INTEN_TXENDIEN_Pos)                /*!< UART_T::INTEN: TXENDIEN Mask           */
N
N#define UART_FIFO_RXRST_Pos              (1)                                               /*!< UART_T::FIFO: RXRST Position           */
N#define UART_FIFO_RXRST_Msk              (0x1ul << UART_FIFO_RXRST_Pos)                    /*!< UART_T::FIFO: RXRST Mask               */
N
N#define UART_FIFO_TXRST_Pos              (2)                                               /*!< UART_T::FIFO: TXRST Position           */
N#define UART_FIFO_TXRST_Msk              (0x1ul << UART_FIFO_TXRST_Pos)                    /*!< UART_T::FIFO: TXRST Mask               */
N
N#define UART_FIFO_RFITL_Pos              (4)                                               /*!< UART_T::FIFO: RFITL Position           */
N#define UART_FIFO_RFITL_Msk              (0xful << UART_FIFO_RFITL_Pos)                    /*!< UART_T::FIFO: RFITL Mask               */
N
N#define UART_FIFO_RXOFF_Pos              (8)                                               /*!< UART_T::FIFO: RXOFF Position           */
N#define UART_FIFO_RXOFF_Msk              (0x1ul << UART_FIFO_RXOFF_Pos)                    /*!< UART_T::FIFO: RXOFF Mask               */
N
N#define UART_FIFO_RTSTRGLV_Pos           (16)                                              /*!< UART_T::FIFO: RTSTRGLV Position        */
N#define UART_FIFO_RTSTRGLV_Msk           (0xful << UART_FIFO_RTSTRGLV_Pos)                 /*!< UART_T::FIFO: RTSTRGLV Mask            */
N
N#define UART_LINE_WLS_Pos                (0)                                               /*!< UART_T::LINE: WLS Position             */
N#define UART_LINE_WLS_Msk                (0x3ul << UART_LINE_WLS_Pos)                      /*!< UART_T::LINE: WLS Mask                 */
N
N#define UART_LINE_NSB_Pos                (2)                                               /*!< UART_T::LINE: NSB Position             */
N#define UART_LINE_NSB_Msk                (0x1ul << UART_LINE_NSB_Pos)                      /*!< UART_T::LINE: NSB Mask                 */
N
N#define UART_LINE_PBE_Pos                (3)                                               /*!< UART_T::LINE: PBE Position             */
N#define UART_LINE_PBE_Msk                (0x1ul << UART_LINE_PBE_Pos)                      /*!< UART_T::LINE: PBE Mask                 */
N
N#define UART_LINE_EPE_Pos                (4)                                               /*!< UART_T::LINE: EPE Position             */
N#define UART_LINE_EPE_Msk                (0x1ul << UART_LINE_EPE_Pos)                      /*!< UART_T::LINE: EPE Mask                 */
N
N#define UART_LINE_SPE_Pos                (5)                                               /*!< UART_T::LINE: SPE Position             */
N#define UART_LINE_SPE_Msk                (0x1ul << UART_LINE_SPE_Pos)                      /*!< UART_T::LINE: SPE Mask                 */
N
N#define UART_LINE_BCB_Pos                (6)                                               /*!< UART_T::LINE: BCB Position             */
N#define UART_LINE_BCB_Msk                (0x1ul << UART_LINE_BCB_Pos)                      /*!< UART_T::LINE: BCB Mask                 */
N
N#define UART_LINE_PSS_Pos                (7)                                               /*!< UART_T::LINE: PSS Position             */
N#define UART_LINE_PSS_Msk                (0x1ul << UART_LINE_PSS_Pos)                      /*!< UART_T::LINE: PSS Mask                 */
N
N#define UART_LINE_TXDINV_Pos             (8)                                               /*!< UART_T::LINE: TXDINV Position          */
N#define UART_LINE_TXDINV_Msk             (0x1ul << UART_LINE_TXDINV_Pos)                   /*!< UART_T::LINE: TXDINV Mask              */
N
N#define UART_LINE_RXDINV_Pos             (9)                                               /*!< UART_T::LINE: RXDINV Position          */
N#define UART_LINE_RXDINV_Msk             (0x1ul << UART_LINE_RXDINV_Pos)                   /*!< UART_T::LINE: RXDINV Mask              */
N
N#define UART_MODEM_RTS_Pos               (1)                                               /*!< UART_T::MODEM: RTS Position            */
N#define UART_MODEM_RTS_Msk               (0x1ul << UART_MODEM_RTS_Pos)                     /*!< UART_T::MODEM: RTS Mask                */
N
N#define UART_MODEM_RTSACTLV_Pos          (9)                                               /*!< UART_T::MODEM: RTSACTLV Position       */
N#define UART_MODEM_RTSACTLV_Msk          (0x1ul << UART_MODEM_RTSACTLV_Pos)                /*!< UART_T::MODEM: RTSACTLV Mask           */
N
N#define UART_MODEM_RTSSTS_Pos            (13)                                              /*!< UART_T::MODEM: RTSSTS Position         */
N#define UART_MODEM_RTSSTS_Msk            (0x1ul << UART_MODEM_RTSSTS_Pos)                  /*!< UART_T::MODEM: RTSSTS Mask             */
N
N#define UART_MODEMSTS_CTSDETF_Pos        (0)                                               /*!< UART_T::MODEMSTS: CTSDETF Position     */
N#define UART_MODEMSTS_CTSDETF_Msk        (0x1ul << UART_MODEMSTS_CTSDETF_Pos)              /*!< UART_T::MODEMSTS: CTSDETF Mask         */
N
N#define UART_MODEMSTS_CTSSTS_Pos         (4)                                               /*!< UART_T::MODEMSTS: CTSSTS Position      */
N#define UART_MODEMSTS_CTSSTS_Msk         (0x1ul << UART_MODEMSTS_CTSSTS_Pos)               /*!< UART_T::MODEMSTS: CTSSTS Mask          */
N
N#define UART_MODEMSTS_CTSACTLV_Pos       (8)                                               /*!< UART_T::MODEMSTS: CTSACTLV Position    */
N#define UART_MODEMSTS_CTSACTLV_Msk       (0x1ul << UART_MODEMSTS_CTSACTLV_Pos)             /*!< UART_T::MODEMSTS: CTSACTLV Mask        */
N
N#define UART_FIFOSTS_RXOVIF_Pos          (0)                                               /*!< UART_T::FIFOSTS: RXOVIF Position       */
N#define UART_FIFOSTS_RXOVIF_Msk          (0x1ul << UART_FIFOSTS_RXOVIF_Pos)                /*!< UART_T::FIFOSTS: RXOVIF Mask           */
N
N#define UART_FIFOSTS_ABRDIF_Pos          (1)                                               /*!< UART_T::FIFOSTS: ABRDIF Position       */
N#define UART_FIFOSTS_ABRDIF_Msk          (0x1ul << UART_FIFOSTS_ABRDIF_Pos)                /*!< UART_T::FIFOSTS: ABRDIF Mask           */
N
N#define UART_FIFOSTS_ABRDTOIF_Pos        (2)                                               /*!< UART_T::FIFOSTS: ABRDTOIF Position     */
N#define UART_FIFOSTS_ABRDTOIF_Msk        (0x1ul << UART_FIFOSTS_ABRDTOIF_Pos)              /*!< UART_T::FIFOSTS: ABRDTOIF Mask         */
N
N#define UART_FIFOSTS_ADDRDETF_Pos        (3)                                               /*!< UART_T::FIFOSTS: ADDRDETF Position     */
N#define UART_FIFOSTS_ADDRDETF_Msk        (0x1ul << UART_FIFOSTS_ADDRDETF_Pos)              /*!< UART_T::FIFOSTS: ADDRDETF Mask         */
N
N#define UART_FIFOSTS_PEF_Pos             (4)                                               /*!< UART_T::FIFOSTS: PEF Position          */
N#define UART_FIFOSTS_PEF_Msk             (0x1ul << UART_FIFOSTS_PEF_Pos)                   /*!< UART_T::FIFOSTS: PEF Mask              */
N
N#define UART_FIFOSTS_FEF_Pos             (5)                                               /*!< UART_T::FIFOSTS: FEF Position          */
N#define UART_FIFOSTS_FEF_Msk             (0x1ul << UART_FIFOSTS_FEF_Pos)                   /*!< UART_T::FIFOSTS: FEF Mask              */
N
N#define UART_FIFOSTS_BIF_Pos             (6)                                               /*!< UART_T::FIFOSTS: BIF Position          */
N#define UART_FIFOSTS_BIF_Msk             (0x1ul << UART_FIFOSTS_BIF_Pos)                   /*!< UART_T::FIFOSTS: BIF Mask              */
N
N#define UART_FIFOSTS_RXPTR_Pos           (8)                                               /*!< UART_T::FIFOSTS: RXPTR Position        */
N#define UART_FIFOSTS_RXPTR_Msk           (0x3ful << UART_FIFOSTS_RXPTR_Pos)                /*!< UART_T::FIFOSTS: RXPTR Mask            */
N
N#define UART_FIFOSTS_RXEMPTY_Pos         (14)                                              /*!< UART_T::FIFOSTS: RXEMPTY Position      */
N#define UART_FIFOSTS_RXEMPTY_Msk         (0x1ul << UART_FIFOSTS_RXEMPTY_Pos)               /*!< UART_T::FIFOSTS: RXEMPTY Mask          */
N
N#define UART_FIFOSTS_RXFULL_Pos          (15)                                              /*!< UART_T::FIFOSTS: RXFULL Position       */
N#define UART_FIFOSTS_RXFULL_Msk          (0x1ul << UART_FIFOSTS_RXFULL_Pos)                /*!< UART_T::FIFOSTS: RXFULL Mask           */
N
N#define UART_FIFOSTS_TXPTR_Pos           (16)                                              /*!< UART_T::FIFOSTS: TXPTR Position        */
N#define UART_FIFOSTS_TXPTR_Msk           (0x3ful << UART_FIFOSTS_TXPTR_Pos)                /*!< UART_T::FIFOSTS: TXPTR Mask            */
N
N#define UART_FIFOSTS_TXEMPTY_Pos         (22)                                              /*!< UART_T::FIFOSTS: TXEMPTY Position      */
N#define UART_FIFOSTS_TXEMPTY_Msk         (0x1ul << UART_FIFOSTS_TXEMPTY_Pos)               /*!< UART_T::FIFOSTS: TXEMPTY Mask          */
N
N#define UART_FIFOSTS_TXFULL_Pos          (23)                                              /*!< UART_T::FIFOSTS: TXFULL Position       */
N#define UART_FIFOSTS_TXFULL_Msk          (0x1ul << UART_FIFOSTS_TXFULL_Pos)                /*!< UART_T::FIFOSTS: TXFULL Mask           */
N
N#define UART_FIFOSTS_TXOVIF_Pos          (24)                                              /*!< UART_T::FIFOSTS: TXOVIF Position       */
N#define UART_FIFOSTS_TXOVIF_Msk          (0x1ul << UART_FIFOSTS_TXOVIF_Pos)                /*!< UART_T::FIFOSTS: TXOVIF Mask           */
N
N#define UART_FIFOSTS_TXEMPTYF_Pos        (28)                                              /*!< UART_T::FIFOSTS: TXEMPTYF Position     */
N#define UART_FIFOSTS_TXEMPTYF_Msk        (0x1ul << UART_FIFOSTS_TXEMPTYF_Pos)              /*!< UART_T::FIFOSTS: TXEMPTYF Mask         */
N
N#define UART_FIFOSTS_RXIDLE_Pos          (29)                                              /*!< UART_T::FIFOSTS: RXIDLE Position       */
N#define UART_FIFOSTS_RXIDLE_Msk          (0x1ul << UART_FIFOSTS_RXIDLE_Pos)                /*!< UART_T::FIFOSTS: RXIDLE Mask           */
N
N#define UART_FIFOSTS_TXRXACT_Pos         (31)                                              /*!< UART_T::FIFOSTS: TXRXACT Position      */
N#define UART_FIFOSTS_TXRXACT_Msk         (0x1ul << UART_FIFOSTS_TXRXACT_Pos)               /*!< UART_T::FIFOSTS: TXRXACT Mask          */
N
N#define UART_INTSTS_RDAIF_Pos            (0)                                               /*!< UART_T::INTSTS: RDAIF Position         */
N#define UART_INTSTS_RDAIF_Msk            (0x1ul << UART_INTSTS_RDAIF_Pos)                  /*!< UART_T::INTSTS: RDAIF Mask             */
N
N#define UART_INTSTS_THREIF_Pos           (1)                                               /*!< UART_T::INTSTS: THREIF Position        */
N#define UART_INTSTS_THREIF_Msk           (0x1ul << UART_INTSTS_THREIF_Pos)                 /*!< UART_T::INTSTS: THREIF Mask            */
N
N#define UART_INTSTS_RLSIF_Pos            (2)                                               /*!< UART_T::INTSTS: RLSIF Position         */
N#define UART_INTSTS_RLSIF_Msk            (0x1ul << UART_INTSTS_RLSIF_Pos)                  /*!< UART_T::INTSTS: RLSIF Mask             */
N
N#define UART_INTSTS_MODEMIF_Pos          (3)                                               /*!< UART_T::INTSTS: MODEMIF Position       */
N#define UART_INTSTS_MODEMIF_Msk          (0x1ul << UART_INTSTS_MODEMIF_Pos)                /*!< UART_T::INTSTS: MODEMIF Mask           */
N
N#define UART_INTSTS_RXTOIF_Pos           (4)                                               /*!< UART_T::INTSTS: RXTOIF Position        */
N#define UART_INTSTS_RXTOIF_Msk           (0x1ul << UART_INTSTS_RXTOIF_Pos)                 /*!< UART_T::INTSTS: RXTOIF Mask            */
N
N#define UART_INTSTS_BUFERRIF_Pos         (5)                                               /*!< UART_T::INTSTS: BUFERRIF Position      */
N#define UART_INTSTS_BUFERRIF_Msk         (0x1ul << UART_INTSTS_BUFERRIF_Pos)               /*!< UART_T::INTSTS: BUFERRIF Mask          */
N
N#define UART_INTSTS_WKIF_Pos             (6)                                               /*!< UART_T::INTSTS: WKIF Position          */
N#define UART_INTSTS_WKIF_Msk             (0x1ul << UART_INTSTS_WKIF_Pos)                   /*!< UART_T::INTSTS: WKIF Mask              */
N
N#define UART_INTSTS_LINIF_Pos            (7)                                               /*!< UART_T::INTSTS: LINIF Position         */
N#define UART_INTSTS_LINIF_Msk            (0x1ul << UART_INTSTS_LINIF_Pos)                  /*!< UART_T::INTSTS: LINIF Mask             */
N
N#define UART_INTSTS_RDAINT_Pos           (8)                                               /*!< UART_T::INTSTS: RDAINT Position        */
N#define UART_INTSTS_RDAINT_Msk           (0x1ul << UART_INTSTS_RDAINT_Pos)                 /*!< UART_T::INTSTS: RDAINT Mask            */
N
N#define UART_INTSTS_THREINT_Pos          (9)                                               /*!< UART_T::INTSTS: THREINT Position       */
N#define UART_INTSTS_THREINT_Msk          (0x1ul << UART_INTSTS_THREINT_Pos)                /*!< UART_T::INTSTS: THREINT Mask           */
N
N#define UART_INTSTS_RLSINT_Pos           (10)                                              /*!< UART_T::INTSTS: RLSINT Position        */
N#define UART_INTSTS_RLSINT_Msk           (0x1ul << UART_INTSTS_RLSINT_Pos)                 /*!< UART_T::INTSTS: RLSINT Mask            */
N
N#define UART_INTSTS_MODEMINT_Pos         (11)                                              /*!< UART_T::INTSTS: MODEMINT Position      */
N#define UART_INTSTS_MODEMINT_Msk         (0x1ul << UART_INTSTS_MODEMINT_Pos)               /*!< UART_T::INTSTS: MODEMINT Mask          */
N
N#define UART_INTSTS_RXTOINT_Pos          (12)                                              /*!< UART_T::INTSTS: RXTOINT Position       */
N#define UART_INTSTS_RXTOINT_Msk          (0x1ul << UART_INTSTS_RXTOINT_Pos)                /*!< UART_T::INTSTS: RXTOINT Mask           */
N
N#define UART_INTSTS_BUFERRINT_Pos        (13)                                              /*!< UART_T::INTSTS: BUFERRINT Position     */
N#define UART_INTSTS_BUFERRINT_Msk        (0x1ul << UART_INTSTS_BUFERRINT_Pos)              /*!< UART_T::INTSTS: BUFERRINT Mask         */
N
N#define UART_INTSTS_WKINT_Pos            (14)                                              /*!< UART_T::INTSTS: WKINT Position         */
N#define UART_INTSTS_WKINT_Msk            (0x1ul << UART_INTSTS_WKINT_Pos)                  /*!< UART_T::INTSTS: WKINT Mask             */
N
N#define UART_INTSTS_LININT_Pos           (15)                                              /*!< UART_T::INTSTS: LININT Position        */
N#define UART_INTSTS_LININT_Msk           (0x1ul << UART_INTSTS_LININT_Pos)                 /*!< UART_T::INTSTS: LININT Mask            */
N
N#define UART_INTSTS_HWRLSIF_Pos          (18)                                              /*!< UART_T::INTSTS: HWRLSIF Position       */
N#define UART_INTSTS_HWRLSIF_Msk          (0x1ul << UART_INTSTS_HWRLSIF_Pos)                /*!< UART_T::INTSTS: HWRLSIF Mask           */
N
N#define UART_INTSTS_HWMODIF_Pos          (19)                                              /*!< UART_T::INTSTS: HWMODIF Position       */
N#define UART_INTSTS_HWMODIF_Msk          (0x1ul << UART_INTSTS_HWMODIF_Pos)                /*!< UART_T::INTSTS: HWMODIF Mask           */
N
N#define UART_INTSTS_HWTOIF_Pos           (20)                                              /*!< UART_T::INTSTS: HWTOIF Position        */
N#define UART_INTSTS_HWTOIF_Msk           (0x1ul << UART_INTSTS_HWTOIF_Pos)                 /*!< UART_T::INTSTS: HWTOIF Mask            */
N
N#define UART_INTSTS_HWBUFEIF_Pos         (21)                                              /*!< UART_T::INTSTS: HWBUFEIF Position      */
N#define UART_INTSTS_HWBUFEIF_Msk         (0x1ul << UART_INTSTS_HWBUFEIF_Pos)               /*!< UART_T::INTSTS: HWBUFEIF Mask          */
N
N#define UART_INTSTS_TXENDIF_Pos          (22)                                              /*!< UART_T::INTSTS: TXENDIF Position       */
N#define UART_INTSTS_TXENDIF_Msk          (0x1ul << UART_INTSTS_TXENDIF_Pos)                /*!< UART_T::INTSTS: TXENDIF Mask           */
N
N#define UART_INTSTS_HWRLSINT_Pos         (26)                                              /*!< UART_T::INTSTS: HWRLSINT Position      */
N#define UART_INTSTS_HWRLSINT_Msk         (0x1ul << UART_INTSTS_HWRLSINT_Pos)               /*!< UART_T::INTSTS: HWRLSINT Mask          */
N
N#define UART_INTSTS_HWMODINT_Pos         (27)                                              /*!< UART_T::INTSTS: HWMODINT Position      */
N#define UART_INTSTS_HWMODINT_Msk         (0x1ul << UART_INTSTS_HWMODINT_Pos)               /*!< UART_T::INTSTS: HWMODINT Mask          */
N
N#define UART_INTSTS_HWTOINT_Pos          (28)                                              /*!< UART_T::INTSTS: HWTOINT Position       */
N#define UART_INTSTS_HWTOINT_Msk          (0x1ul << UART_INTSTS_HWTOINT_Pos)                /*!< UART_T::INTSTS: HWTOINT Mask           */
N
N#define UART_INTSTS_HWBUFEINT_Pos        (29)                                              /*!< UART_T::INTSTS: HWBUFEINT Position     */
N#define UART_INTSTS_HWBUFEINT_Msk        (0x1ul << UART_INTSTS_HWBUFEINT_Pos)              /*!< UART_T::INTSTS: HWBUFEINT Mask         */
N
N#define UART_INTSTS_TXENDINT_Pos         (30)                                              /*!< UART_T::INTSTS: TXENDINT Position      */
N#define UART_INTSTS_TXENDINT_Msk         (0x1ul << UART_INTSTS_TXENDINT_Pos)               /*!< UART_T::INTSTS: TXENDINT Mask          */
N
N#define UART_INTSTS_ABRINT_Pos           (31)                                              /*!< UART_T::INTSTS: ABRINT Position        */
N#define UART_INTSTS_ABRINT_Msk           (0x1ul << UART_INTSTS_ABRINT_Pos)                 /*!< UART_T::INTSTS: ABRINT Mask            */
N
N#define UART_TOUT_TOIC_Pos               (0)                                               /*!< UART_T::TOUT: TOIC Position            */
N#define UART_TOUT_TOIC_Msk               (0xfful << UART_TOUT_TOIC_Pos)                    /*!< UART_T::TOUT: TOIC Mask                */
N
N#define UART_TOUT_DLY_Pos                (8)                                               /*!< UART_T::TOUT: DLY Position             */
N#define UART_TOUT_DLY_Msk                (0xfful << UART_TOUT_DLY_Pos)                     /*!< UART_T::TOUT: DLY Mask                 */
N
N#define UART_BAUD_BRD_Pos                (0)                                               /*!< UART_T::BAUD: BRD Position             */
N#define UART_BAUD_BRD_Msk                (0xfffful << UART_BAUD_BRD_Pos)                   /*!< UART_T::BAUD: BRD Mask                 */
N
N#define UART_BAUD_EDIVM1_Pos             (24)                                              /*!< UART_T::BAUD: EDIVM1 Position          */
N#define UART_BAUD_EDIVM1_Msk             (0xful << UART_BAUD_EDIVM1_Pos)                   /*!< UART_T::BAUD: EDIVM1 Mask              */
N
N#define UART_BAUD_BAUDM0_Pos             (28)                                              /*!< UART_T::BAUD: BAUDM0 Position          */
N#define UART_BAUD_BAUDM0_Msk             (0x1ul << UART_BAUD_BAUDM0_Pos)                   /*!< UART_T::BAUD: BAUDM0 Mask              */
N
N#define UART_BAUD_BAUDM1_Pos             (29)                                              /*!< UART_T::BAUD: BAUDM1 Position          */
N#define UART_BAUD_BAUDM1_Msk             (0x1ul << UART_BAUD_BAUDM1_Pos)                   /*!< UART_T::BAUD: BAUDM1 Mask              */
N
N#define UART_IRDA_TXEN_Pos               (1)                                               /*!< UART_T::IRDA: TXEN Position            */
N#define UART_IRDA_TXEN_Msk               (0x1ul << UART_IRDA_TXEN_Pos)                     /*!< UART_T::IRDA: TXEN Mask                */
N
N#define UART_IRDA_TXINV_Pos              (5)                                               /*!< UART_T::IRDA: TXINV Position           */
N#define UART_IRDA_TXINV_Msk              (0x1ul << UART_IRDA_TXINV_Pos)                    /*!< UART_T::IRDA: TXINV Mask               */
N
N#define UART_IRDA_RXINV_Pos              (6)                                               /*!< UART_T::IRDA: RXINV Position           */
N#define UART_IRDA_RXINV_Msk              (0x1ul << UART_IRDA_RXINV_Pos)                    /*!< UART_T::IRDA: RXINV Mask               */
N
N#define UART_ALTCTL_BRKFL_Pos            (0)                                               /*!< UART_T::ALTCTL: BRKFL Position         */
N#define UART_ALTCTL_BRKFL_Msk            (0xful << UART_ALTCTL_BRKFL_Pos)                  /*!< UART_T::ALTCTL: BRKFL Mask             */
N
N#define UART_ALTCTL_LINRXEN_Pos          (6)                                               /*!< UART_T::ALTCTL: LINRXEN Position       */
N#define UART_ALTCTL_LINRXEN_Msk          (0x1ul << UART_ALTCTL_LINRXEN_Pos)                /*!< UART_T::ALTCTL: LINRXEN Mask           */
N
N#define UART_ALTCTL_LINTXEN_Pos          (7)                                               /*!< UART_T::ALTCTL: LINTXEN Position       */
N#define UART_ALTCTL_LINTXEN_Msk          (0x1ul << UART_ALTCTL_LINTXEN_Pos)                /*!< UART_T::ALTCTL: LINTXEN Mask           */
N
N#define UART_ALTCTL_RS485NMM_Pos         (8)                                               /*!< UART_T::ALTCTL: RS485NMM Position      */
N#define UART_ALTCTL_RS485NMM_Msk         (0x1ul << UART_ALTCTL_RS485NMM_Pos)               /*!< UART_T::ALTCTL: RS485NMM Mask          */
N
N#define UART_ALTCTL_RS485AAD_Pos         (9)                                               /*!< UART_T::ALTCTL: RS485AAD Position      */
N#define UART_ALTCTL_RS485AAD_Msk         (0x1ul << UART_ALTCTL_RS485AAD_Pos)               /*!< UART_T::ALTCTL: RS485AAD Mask          */
N
N#define UART_ALTCTL_RS485AUD_Pos         (10)                                              /*!< UART_T::ALTCTL: RS485AUD Position      */
N#define UART_ALTCTL_RS485AUD_Msk         (0x1ul << UART_ALTCTL_RS485AUD_Pos)               /*!< UART_T::ALTCTL: RS485AUD Mask          */
N
N#define UART_ALTCTL_ADDRDEN_Pos          (15)                                              /*!< UART_T::ALTCTL: ADDRDEN Position       */
N#define UART_ALTCTL_ADDRDEN_Msk          (0x1ul << UART_ALTCTL_ADDRDEN_Pos)                /*!< UART_T::ALTCTL: ADDRDEN Mask           */
N
N#define UART_ALTCTL_ABRIF_Pos            (17)                                              /*!< UART_T::ALTCTL: ABRIF Position         */
N#define UART_ALTCTL_ABRIF_Msk            (0x1ul << UART_ALTCTL_ABRIF_Pos)                  /*!< UART_T::ALTCTL: ABRIF Mask             */
N
N#define UART_ALTCTL_ABRDEN_Pos           (18)                                              /*!< UART_T::ALTCTL: ABRDEN Position        */
N#define UART_ALTCTL_ABRDEN_Msk           (0x1ul << UART_ALTCTL_ABRDEN_Pos)                 /*!< UART_T::ALTCTL: ABRDEN Mask            */
N
N#define UART_ALTCTL_ABRDBITS_Pos         (19)                                              /*!< UART_T::ALTCTL: ABRDBITS Position      */
N#define UART_ALTCTL_ABRDBITS_Msk         (0x3ul << UART_ALTCTL_ABRDBITS_Pos)               /*!< UART_T::ALTCTL: ABRDBITS Mask          */
N
N#define UART_ALTCTL_ADDRMV_Pos           (24)                                              /*!< UART_T::ALTCTL: ADDRMV Position        */
N#define UART_ALTCTL_ADDRMV_Msk           (0xfful << UART_ALTCTL_ADDRMV_Pos)                /*!< UART_T::ALTCTL: ADDRMV Mask            */
N
N#define UART_FUNCSEL_FUNCSEL_Pos         (0)                                               /*!< UART_T::FUNCSEL: FUNCSEL Position      */
N#define UART_FUNCSEL_FUNCSEL_Msk         (0x3ul << UART_FUNCSEL_FUNCSEL_Pos)               /*!< UART_T::FUNCSEL: FUNCSEL Mask          */
N
N#define UART_FUNCSEL_TXRXDIS_Pos         (3)                                               /*!< UART_T::FUNCSEL: TXRXDIS Position      */
N#define UART_FUNCSEL_TXRXDIS_Msk         (0x1ul << UART_FUNCSEL_TXRXDIS_Pos)               /*!< UART_T::FUNCSEL: TXRXDIS Mask          */
N
N#define UART_LINCTL_SLVEN_Pos            (0)                                               /*!< UART_T::LINCTL: SLVEN Position         */
N#define UART_LINCTL_SLVEN_Msk            (0x1ul << UART_LINCTL_SLVEN_Pos)                  /*!< UART_T::LINCTL: SLVEN Mask             */
N
N#define UART_LINCTL_SLVHDEN_Pos          (1)                                               /*!< UART_T::LINCTL: SLVHDEN Position       */
N#define UART_LINCTL_SLVHDEN_Msk          (0x1ul << UART_LINCTL_SLVHDEN_Pos)                /*!< UART_T::LINCTL: SLVHDEN Mask           */
N
N#define UART_LINCTL_SLVAREN_Pos          (2)                                               /*!< UART_T::LINCTL: SLVAREN Position       */
N#define UART_LINCTL_SLVAREN_Msk          (0x1ul << UART_LINCTL_SLVAREN_Pos)                /*!< UART_T::LINCTL: SLVAREN Mask           */
N
N#define UART_LINCTL_SLVDUEN_Pos          (3)                                               /*!< UART_T::LINCTL: SLVDUEN Position       */
N#define UART_LINCTL_SLVDUEN_Msk          (0x1ul << UART_LINCTL_SLVDUEN_Pos)                /*!< UART_T::LINCTL: SLVDUEN Mask           */
N
N#define UART_LINCTL_MUTE_Pos             (4)                                               /*!< UART_T::LINCTL: MUTE Position          */
N#define UART_LINCTL_MUTE_Msk             (0x1ul << UART_LINCTL_MUTE_Pos)                   /*!< UART_T::LINCTL: MUTE Mask              */
N
N#define UART_LINCTL_SENDH_Pos            (8)                                               /*!< UART_T::LINCTL: SENDH Position         */
N#define UART_LINCTL_SENDH_Msk            (0x1ul << UART_LINCTL_SENDH_Pos)                  /*!< UART_T::LINCTL: SENDH Mask             */
N
N#define UART_LINCTL_IDPEN_Pos            (9)                                               /*!< UART_T::LINCTL: IDPEN Position         */
N#define UART_LINCTL_IDPEN_Msk            (0x1ul << UART_LINCTL_IDPEN_Pos)                  /*!< UART_T::LINCTL: IDPEN Mask             */
N
N#define UART_LINCTL_BRKDETEN_Pos         (10)                                              /*!< UART_T::LINCTL: BRKDETEN Position      */
N#define UART_LINCTL_BRKDETEN_Msk         (0x1ul << UART_LINCTL_BRKDETEN_Pos)               /*!< UART_T::LINCTL: BRKDETEN Mask          */
N
N#define UART_LINCTL_LINRXOFF_Pos         (11)                                              /*!< UART_T::LINCTL: LINRXOFF Position      */
N#define UART_LINCTL_LINRXOFF_Msk         (0x1ul << UART_LINCTL_LINRXOFF_Pos)               /*!< UART_T::LINCTL: LINRXOFF Mask          */
N
N#define UART_LINCTL_BITERREN_Pos         (12)                                              /*!< UART_T::LINCTL: BITERREN Position      */
N#define UART_LINCTL_BITERREN_Msk         (0x1ul << UART_LINCTL_BITERREN_Pos)               /*!< UART_T::LINCTL: BITERREN Mask          */
N
N#define UART_LINCTL_BRKFL_Pos            (16)                                              /*!< UART_T::LINCTL: BRKFL Position         */
N#define UART_LINCTL_BRKFL_Msk            (0xful << UART_LINCTL_BRKFL_Pos)                  /*!< UART_T::LINCTL: BRKFL Mask             */
N
N#define UART_LINCTL_BSL_Pos              (20)                                              /*!< UART_T::LINCTL: BSL Position           */
N#define UART_LINCTL_BSL_Msk              (0x3ul << UART_LINCTL_BSL_Pos)                    /*!< UART_T::LINCTL: BSL Mask               */
N
N#define UART_LINCTL_HSEL_Pos             (22)                                              /*!< UART_T::LINCTL: HSEL Position          */
N#define UART_LINCTL_HSEL_Msk             (0x3ul << UART_LINCTL_HSEL_Pos)                   /*!< UART_T::LINCTL: HSEL Mask              */
N
N#define UART_LINCTL_PID_Pos              (24)                                              /*!< UART_T::LINCTL: PID Position           */
N#define UART_LINCTL_PID_Msk              (0xfful << UART_LINCTL_PID_Pos)                   /*!< UART_T::LINCTL: PID Mask               */
N
N#define UART_LINSTS_SLVHDETF_Pos         (0)                                               /*!< UART_T::LINSTS: SLVHDETF Position      */
N#define UART_LINSTS_SLVHDETF_Msk         (0x1ul << UART_LINSTS_SLVHDETF_Pos)               /*!< UART_T::LINSTS: SLVHDETF Mask          */
N
N#define UART_LINSTS_SLVHEF_Pos           (1)                                               /*!< UART_T::LINSTS: SLVHEF Position        */
N#define UART_LINSTS_SLVHEF_Msk           (0x1ul << UART_LINSTS_SLVHEF_Pos)                 /*!< UART_T::LINSTS: SLVHEF Mask            */
N
N#define UART_LINSTS_SLVIDPEF_Pos         (2)                                               /*!< UART_T::LINSTS: SLVIDPEF Position      */
N#define UART_LINSTS_SLVIDPEF_Msk         (0x1ul << UART_LINSTS_SLVIDPEF_Pos)               /*!< UART_T::LINSTS: SLVIDPEF Mask          */
N
N#define UART_LINSTS_SLVSYNCF_Pos         (3)                                               /*!< UART_T::LINSTS: SLVSYNCF Position      */
N#define UART_LINSTS_SLVSYNCF_Msk         (0x1ul << UART_LINSTS_SLVSYNCF_Pos)               /*!< UART_T::LINSTS: SLVSYNCF Mask          */
N
N#define UART_LINSTS_BRKDETF_Pos          (8)                                               /*!< UART_T::LINSTS: BRKDETF Position       */
N#define UART_LINSTS_BRKDETF_Msk          (0x1ul << UART_LINSTS_BRKDETF_Pos)                /*!< UART_T::LINSTS: BRKDETF Mask           */
N
N#define UART_LINSTS_BITEF_Pos            (9)                                               /*!< UART_T::LINSTS: BITEF Position         */
N#define UART_LINSTS_BITEF_Msk            (0x1ul << UART_LINSTS_BITEF_Pos)                  /*!< UART_T::LINSTS: BITEF Mask             */
N
N#define UART_BRCOMP_BRCOMP_Pos           (0)                                               /*!< UART_T::BRCOMP: BRCOMP Position        */
N#define UART_BRCOMP_BRCOMP_Msk           (0x1fful << UART_BRCOMP_BRCOMP_Pos)               /*!< UART_T::BRCOMP: BRCOMP Mask            */
N
N#define UART_BRCOMP_BRCOMPDEC_Pos        (31)                                              /*!< UART_T::BRCOMP: BRCOMPDEC Position     */
N#define UART_BRCOMP_BRCOMPDEC_Msk        (0x1ul << UART_BRCOMP_BRCOMPDEC_Pos)              /*!< UART_T::BRCOMP: BRCOMPDEC Mask         */
N
N#define UART_WKCTL_WKCTSEN_Pos           (0)                                               /*!< UART_T::WKCTL: WKCTSEN Position        */
N#define UART_WKCTL_WKCTSEN_Msk           (0x1ul << UART_WKCTL_WKCTSEN_Pos)                 /*!< UART_T::WKCTL: WKCTSEN Mask            */
N
N#define UART_WKCTL_WKDATEN_Pos           (1)                                               /*!< UART_T::WKCTL: WKDATEN Position        */
N#define UART_WKCTL_WKDATEN_Msk           (0x1ul << UART_WKCTL_WKDATEN_Pos)                 /*!< UART_T::WKCTL: WKDATEN Mask            */
N
N#define UART_WKCTL_WKRFRTEN_Pos          (2)                                               /*!< UART_T::WKCTL: WKRFRTEN Position       */
N#define UART_WKCTL_WKRFRTEN_Msk          (0x1ul << UART_WKCTL_WKRFRTEN_Pos)                /*!< UART_T::WKCTL: WKRFRTEN Mask           */
N
N#define UART_WKCTL_WKRS485EN_Pos         (3)                                               /*!< UART_T::WKCTL: WKRS485EN Position      */
N#define UART_WKCTL_WKRS485EN_Msk         (0x1ul << UART_WKCTL_WKRS485EN_Pos)               /*!< UART_T::WKCTL: WKRS485EN Mask          */
N
N#define UART_WKCTL_WKTOUTEN_Pos          (4)                                               /*!< UART_T::WKCTL: WKTOUTEN Position       */
N#define UART_WKCTL_WKTOUTEN_Msk          (0x1ul << UART_WKCTL_WKTOUTEN_Pos)                /*!< UART_T::WKCTL: WKTOUTEN Mask           */
N
N#define UART_WKSTS_CTSWKF_Pos            (0)                                               /*!< UART_T::WKSTS: CTSWKF Position         */
N#define UART_WKSTS_CTSWKF_Msk            (0x1ul << UART_WKSTS_CTSWKF_Pos)                  /*!< UART_T::WKSTS: CTSWKF Mask             */
N
N#define UART_WKSTS_DATWKF_Pos            (1)                                               /*!< UART_T::WKSTS: DATWKF Position         */
N#define UART_WKSTS_DATWKF_Msk            (0x1ul << UART_WKSTS_DATWKF_Pos)                  /*!< UART_T::WKSTS: DATWKF Mask             */
N
N#define UART_WKSTS_RFRTWKF_Pos           (2)                                               /*!< UART_T::WKSTS: RFRTWKF Position        */
N#define UART_WKSTS_RFRTWKF_Msk           (0x1ul << UART_WKSTS_RFRTWKF_Pos)                 /*!< UART_T::WKSTS: RFRTWKF Mask            */
N
N#define UART_WKSTS_RS485WKF_Pos          (3)                                               /*!< UART_T::WKSTS: RS485WKF Position       */
N#define UART_WKSTS_RS485WKF_Msk          (0x1ul << UART_WKSTS_RS485WKF_Pos)                /*!< UART_T::WKSTS: RS485WKF Mask           */
N
N#define UART_WKSTS_TOUTWKF_Pos           (4)                                               /*!< UART_T::WKSTS: TOUTWKF Position        */
N#define UART_WKSTS_TOUTWKF_Msk           (0x1ul << UART_WKSTS_TOUTWKF_Pos)                 /*!< UART_T::WKSTS: TOUTWKF Mask            */
N
N#define UART_DWKCOMP_STCOMP_Pos          (0)                                               /*!< UART_T::DWKCOMP: STCOMP Position       */
N#define UART_DWKCOMP_STCOMP_Msk          (0xfffful << UART_DWKCOMP_STCOMP_Pos)             /*!< UART_T::DWKCOMP: STCOMP Mask           */
N
N/**@}*/ /* UART_CONST */
N/**@}*/ /* end of UART register group */
N
N
N/*---------------------- I2C Mode of USCI Controller -------------------------*/
N/**
N    @addtogroup UI2C I2C Mode of USCI Controller(UI2C)
N    Memory Mapped Structure for UI2C Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var UI2C_T::CTL
N     * Offset: 0x00  USCI Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |FUNMODE   |Function Mode
N     * |        |          |This bit field selects the protocol for this USCI controller.
N     * |        |          |Selecting a protocol that is not available or a reserved combination disables the USCI.
N     * |        |          |When switching between two protocols, the USCI has to be disabled before selecting a new protocol.
N     * |        |          |Simultaneously, the USCI will be reset when user write 000 to FUNMODE.
N     * |        |          |000 = The USCI is disabled. All protocol related state machines are set to idle state.
N     * |        |          |001 = The SPI protocol is selected.
N     * |        |          |010 = The UART protocol is selected.
N     * |        |          |100 = The I2C protocol is selected.
N     * |        |          |Note: Other bit combinations are reserved.
N     * @var UI2C_T::BRGEN
N     * Offset: 0x08  USCI Baud Rate Generator Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RCLKSEL   |Reference Clock Source Selection
N     * |        |          |This bit selects the source signal of reference clock (fREF_CLK).
N     * |        |          |0 = Peripheral device clock fPCLK.
N     * |        |          |1 = Reserved.
N     * |[1]     |PTCLKSEL  |Protocol Clock Source Selection
N     * |        |          |This bit selects the source signal of protocol clock (fPROT_CLK).
N     * |        |          |0 = Reference clock fREF_CLK.
N     * |        |          |1 = fREF_CLK2 (its frequency is half of fREF_CLK).
N     * |[3:2]   |SPCLKSEL  |Sample Clock Source Selection
N     * |        |          |This bit field used for the clock source selection of a sample clock (fSAMP_CLK) for the protocol processor.
N     * |        |          |00 = fSAMP_CLK = fDIV_CLK.
N     * |        |          |01 = fSAMP_CLK = fPROT_CLK.
N     * |        |          |10 = fSAMP_CLK = fSCLK.
N     * |        |          |11 = fSAMP_CLK = fREF_CLK.
N     * |[4]     |TMCNTEN   |Time Measurement Counter Enable Bit
N     * |        |          |This bit enables the 10-bit timing measurement counter.
N     * |        |          |0 = Time measurement counter is Disabled.
N     * |        |          |1 = Time measurement counter is Enabled.
N     * |[5]     |TMCNTSRC  |Time Measurement Counter Clock Source Selection
N     * |        |          |0 = Time measurement counter with fPROT_CLK.
N     * |        |          |1 = Time measurement counter with fDIV_CLK.
N     * |[9:8]   |PDSCNT    |Pre-divider for Sample Counter
N     * |        |          |This bit field defines the divide ratio of the clock division from sample clock fSAMP_CLK.
N     * |        |          |The divided frequency fPDS_CNT = fSAMP_CLK / (PDSCNT+1).
N     * |[14:10] |DSCNT     |Denominator for Sample Counter
N     * |        |          |This bit field defines the divide ratio of the sample clock fSAMP_CLK.
N     * |        |          |The divided frequency fDS_CNT = fPDS_CNT / (DSCNT+1).
N     * |        |          |Note: The maximum value of DSCNT is 0xF on UART mode and suggest to set over 4 to confirm the receiver data is sampled in right value.
N     * |[25:16] |CLKDIV    |Clock Divider
N     * |        |          |This bit field defines the ratio between the protocol clock frequency fPROT_CLK and the clock divider frequency fDIV_CLK (fDIV_CLK = fPROT_CLK / (CLKDIV+1) ).
N     * |        |          |Note: In UART function, it can be updated by hardware in the 4th falling edge of the input data 0x55 when the auto baud rate function (ABREN(UI2C_PROTCTL[6])) is enabled
N     * |        |          |The revised value is the average bit time between bit 5 and bit 6
N     * |        |          |The user can use revised CLKDIV and new BRDETITV (UI2C_PROTCTL[24:16]) to calculate the precise baud rate.
N     * @var UI2C_T::LINECTL
N     * Offset: 0x2C  USCI Line Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |LSB       |LSB First Transmission Selection
N     * |        |          |0 = The MSB, which bit of transmit/receive data buffer depends on the setting of DWIDTH, is transmitted/received first.
N     * |        |          |1 = The LSB, the bit 0 of data buffer, will be transmitted/received first.
N     * |[11:8]  |DWIDTH    |Word Length of Transmission
N     * |        |          |This bit field defines the data word length (amount of bits) for reception and transmission
N     * |        |          |The data word is always right-aligned in the data buffer.
N     * |        |          |USCI support word length from 4 to 16 bits.
N     * |        |          |0x0: The data word contains 16 bits located at bit positions [15:0].
N     * |        |          |0x1: Reserved.
N     * |        |          |0x2: Reserved.
N     * |        |          |0x3: Reserved.
N     * |        |          |0x4: The data word contains 4 bits located at bit positions [3:0].
N     * |        |          |0x5: The data word contains 5 bits located at bit positions [4:0].
N     * |        |          |...
N     * |        |          |0xF: The data word contains 15 bits located at bit positions [14:0].
N     * |        |          |Note: In I2C protocol, the length must be configured as 8 bits.
N     * @var UI2C_T::TXDAT
N     * Offset: 0x30  USCI Transmit Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |TXDAT     |Transmit Data
N     * |        |          |Software can use this bit field to write 16-bit transmit data for transmission.
N     * @var UI2C_T::RXDAT
N     * Offset: 0x34  USCI Receive Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RXDAT     |Received Data
N     * |        |          |This bit field monitors the received data which stored in receive data buffer.
N     * |        |          |Note 1: In I2C protocol, only use RXDAT[7:0].
N     * @var UI2C_T::DEVADDR0
N     * Offset: 0x44  USCI Device Address Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[9:0]   |DEVADDR   |Device Address
N     * |        |          |In I2C protocol, this bit field contains the programmed slave address.
N     * |        |          |If the first received address byte are b1111 0AAX, the AA bits are compared to the bits DEVADDR[9:8] to check for address match, where the X is R/W bit.
N     * |        |          |Then the second address byte is also compared to DEVADDR[7:0].
N     * |        |          |Note: When I2C operating in 7-bit address mode, only use DEVADDR[6:0].
N     * @var UI2C_T::DEVADDR1
N     * Offset: 0x48  USCI Device Address Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[9:0]   |DEVADDR   |Device Address
N     * |        |          |In I2C protocol, this bit field contains the programmed slave address.
N     * |        |          |If the first received address byte are b1111 0AAX, the AA bits are compared to the bits DEVADDR[9:8] to check for address match, where the X is R/W bit.
N     * |        |          |Then the second address byte is also compared to DEVADDR[7:0].
N     * |        |          |Note: When I2C operating in 7-bit address mode, only use DEVADDR[6:0].
N     * @var UI2C_T::ADDRMSK0
N     * Offset: 0x4C  USCI Device Address Mask Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[9:0]   |ADDRMSK   |USCI Device Address Mask
N     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register).
N     * |        |          |1 = Mask Enabled (the received corresponding address bit is donu2019t care).
N     * |        |          |USCI support multiple address recognition with two address mask register.
N     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care
N     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
N     * @var UI2C_T::ADDRMSK1
N     * Offset: 0x50  USCI Device Address Mask Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[9:0]   |ADDRMSK   |USCI Device Address Mask
N     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register).
N     * |        |          |1 = Mask Enabled (the received corresponding address bit is donu2019t care).
N     * |        |          |USCI support multiple address recognition with two address mask register.
N     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care
N     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
N     * @var UI2C_T::WKCTL
N     * Offset: 0x54  USCI Wake-up Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WKEN      |Wake-up Enable Bit
N     * |        |          |0 = Wake-up function Disabled.
N     * |        |          |1 = Wake-up function Enabled.
N     * |[1]     |WKADDREN  |Wake-up Address Match Enable Bit
N     * |        |          |0 = The chip is woken up according data toggle.
N     * |        |          |1 = The chip is woken up according address match.
N     * @var UI2C_T::WKSTS
N     * Offset: 0x58  USCI Wake-up Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WKF       |Wake-up Flag
N     * |        |          |When chip is woken up from Power-down mode, this bit is set to 1.
N     * |        |          |Software can write 1 to clear this bit.
N     * @var UI2C_T::PROTCTL
N     * Offset: 0x5C  USCI Protocol Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GCFUNC    |General Call Function
N     * |        |          |0 = General Call Function Disabled.
N     * |        |          |1 = General Call Function Enabled.
N     * |[1]     |AA        |Assert Acknowledge Control
N     * |        |          |When AA=1 prior to address or data received, an acknowledged (low level to SDA) will be returned during the acknowledge clock pulse on the SCL line when 1.) A slave is acknowledging the address sent from master, 2.) The receiver devices are acknowledging the data sent by transmitter.
N     * |        |          |When AA=0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse on the SCL line.
N     * |[2]     |STO       |I2C STOP Control
N     * |        |          |In Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this bit will be cleared by hardware automatically.
N     * |        |          |In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode when bus error (UI2C_PROTSTS.ERRIF = 1).
N     * |[3]     |STA       |I2C START Control
N     * |        |          |Setting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.
N     * |[4]     |ADDR10EN  |Address 10-bit Function Enable Bit
N     * |        |          |0 = Address match 10 bit function is disabled.
N     * |        |          |1 = Address match 10 bit function is enabled.
N     * |[5]     |PTRG      |I2C Protocol Trigger
N     * |        |          |When a new state is present in the UI2C_PROTSTS register, if the related interrupt enable bits are set, the I2C interrupt is requested.
N     * |        |          |It must write one by software to this bit after the related interrupt flags are set to 1 and the I2C protocol function will go ahead until the STOP is active or the PROTEN is disabled.
N     * |        |          |0 = I2C's stretch disabled and the I2C protocol function will go ahead.
N     * |        |          |1 = I2C's stretch active.
N     * |[8]     |SCLOUTEN  |SCL Output Enable Bit
N     * |        |          |This bit enables monitor pulling SCL to low.
N     * |        |          |This monitor will pull SCL to low until it has had time to respond to an I2C interrupt.
N     * |        |          |0 = SCL output will be forced high due to open drain mechanism.
N     * |        |          |1 = I2C module may act as a slave peripheral just like in normal operation, the I2C holds the clock line low until it has had time to clear I2C interrupt.
N     * |[9]     |MONEN     |Monitor Mode Enable Bit
N     * |        |          |This bit enables monitor mode.
N     * |        |          |In monitor mode the SDA output will be put in high impedance mode.
N     * |        |          |This prevents the I2C module from outputting data of any kind (including ACK) onto the I2C data bus.
N     * |        |          |0 = The monitor mode is disabled.
N     * |        |          |1 = The monitor mode is enabled.
N     * |        |          |Note: Depending on the state of the SCLOUTEN bit, the SCL output may be also forced high, preventing the module from having control over the I2C clock line.
N     * |[25:16] |TOCNT     |Time-out Clock Cycle
N     * |        |          |This bit field indicates how many clock cycle selected by TMCNTSRC (UI2C_BRGEN [5]) when each interrupt flags are clear.
N     * |        |          |The time-out is enable when TOCNT bigger than 0.
N     * |        |          |Note: The TMCNTSRC (UI2C_BRGEN [5]) must be set zero on I2C mode.
N     * |[31]    |PROTEN    |I2C Protocol Enable Bit
N     * |        |          |0 = I2C Protocol disable.
N     * |        |          |1 = I2C Protocol enable.
N     * @var UI2C_T::PROTIEN
N     * Offset: 0x60  USCI Protocol Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TOIEN     |Time-out Interrupt Enable Control
N     * |        |          |In I2C protocol, this bit enables the interrupt generation in case of a time-out event.
N     * |        |          |0 = The time-out interrupt is disabled.
N     * |        |          |1 = The time-out interrupt is enabled.
N     * |[1]     |STARIEN   |Start Condition Received Interrupt Enable Control
N     * |        |          |This bit enables the generation of a protocol interrupt if a start condition is detected.
N     * |        |          |0 = The start condition interrupt is disabled.
N     * |        |          |1 = The start condition interrupt is enabled.
N     * |[2]     |STORIEN   |Stop Condition Received Interrupt Enable Control
N     * |        |          |This bit enables the generation of a protocol interrupt if a stop condition is detected.
N     * |        |          |0 = The stop condition interrupt is disabled.
N     * |        |          |1 = The stop condition interrupt is enabled.
N     * |[3]     |NACKIEN   |Non - Acknowledge Interrupt Enable Control
N     * |        |          |This bit enables the generation of a protocol interrupt if a non-acknowledge is detected by a master.
N     * |        |          |0 = The non-acknowledge interrupt is disabled.
N     * |        |          |1 = The non-acknowledge interrupt is enabled.
N     * |[4]     |ARBLOIEN  |Arbitration Lost Interrupt Enable Control
N     * |        |          |This bit enables the generation of a protocol interrupt if an arbitration lost event is detected.
N     * |        |          |0 = The arbitration lost interrupt is disabled.
N     * |        |          |1 = The arbitration lost interrupt is enabled.
N     * |[5]     |ERRIEN    |Error Interrupt Enable Control
N     * |        |          |This bit enables the generation of a protocol interrupt if an I2C error condition is detected (indicated by ERR (UI2C_PROTSTS [16])).
N     * |        |          |0 = The error interrupt is disabled.
N     * |        |          |1 = The error interrupt is enabled.
N     * |[6]     |ACKIEN    |Acknowledge Interrupt Enable Control
N     * |        |          |This bit enables the generation of a protocol interrupt if an acknowledge is detected by a master.
N     * |        |          |0 = The acknowledge interrupt is disabled.
N     * |        |          |1 = The acknowledge interrupt is enabled.
N     * @var UI2C_T::PROTSTS
N     * Offset: 0x64  USCI Protocol Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5]     |TOIF      |Time-out Interrupt Flag
N     * |        |          |0 = A time-out interrupt status has not occurred.
N     * |        |          |1 = A time-out interrupt status has occurred.
N     * |        |          |Note: It is cleared by software writing one into this bit.
N     * |[6]     |ONBUSY    |On Bus Busy
N     * |        |          |Indicates that a communication is in progress on the bus.
N     * |        |          |It is set by hardware when a START condition is detected.
N     * |        |          |It is cleared by hardware when a STOP condition is detected.
N     * |        |          |0 = The bus is IDLE (both SCLK and SDA High).
N     * |        |          |1 = The bus is busy.
N     * |[8]     |STARIF    |Start Condition Received Interrupt Flag
N     * |        |          |This bit indicates that a start condition or repeated start condition has been detected on master mode.
N     * |        |          |However, this bit also indicates that a repeated start condition has been detected on slave mode.
N     * |        |          |A protocol interrupt can be generated if UI2C_PROTCTL.STARIEN = 1.
N     * |        |          |0 = A start condition has not yet been detected.
N     * |        |          |1 = A start condition has been detected.
N     * |        |          |It is cleared by software writing one into this bit.
N     * |[9]     |STORIF    |Stop Condition Received Interrupt Flag
N     * |        |          |This bit indicates that a stop condition has been detected on the I2C bus lines.
N     * |        |          |A protocol interrupt can be generated if UI2C_PROTCTL.STORIEN = 1.
N     * |        |          |0 = A stop condition has not yet been detected.
N     * |        |          |1 = A stop condition has been detected.
N     * |        |          |It is cleared by software writing one into this bit.
N     * |[10]    |NACKIF    |Non - Acknowledge Received Interrupt Flag
N     * |        |          |This bit indicates that a non - acknowledge has been received in master mode.
N     * |        |          |This bit is not set in slave mode.
N     * |        |          |A protocol interrupt can be generated if UI2C_PROTCTL.NACKIEN = 1.
N     * |        |          |0 = A non - acknowledge has not been received.
N     * |        |          |1 = A non - acknowledge has been received.
N     * |        |          |It is cleared by software writing one into this bit.
N     * |[11]    |ARBLOIF   |Arbitration Lost Interrupt Flag
N     * |        |          |This bit indicates that an arbitration has been lost.
N     * |        |          |A protocol interrupt can be generated if UI2C_PROTCTL.ARBLOIEN = 1.
N     * |        |          |0 = An arbitration has not been lost.
N     * |        |          |1 = An arbitration has been lost.
N     * |        |          |It is cleared by software writing one into this bit.
N     * |[12]    |ERRIF     |Error Interrupt Flag
N     * |        |          |This bit indicates that a Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame.
N     * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.
N     * |        |          |A protocol interrupt can be generated if UI2C_PROTCTL.ERRIEN = 1.
N     * |        |          |0 = An I2C error has not been detected.
N     * |        |          |1 = An I2C error has been detected.
N     * |        |          |It is cleared by software writing one into this bit.
N     * |        |          |Note: This bit is set when slave mode, user must write one into STO register to the defined "not addressed" slave mode.
N     * |[13]    |ACKIF     |Acknowledge Received Interrupt Flag
N     * |        |          |This bit indicates that an acknowledge has been received in master mode.
N     * |        |          |This bit is not set in slave mode.
N     * |        |          |A protocol interrupt can be generated if UI2C_PROTCTL.ACKIEN = 1.
N     * |        |          |0 = An acknowledge has not been received.
N     * |        |          |1 = An acknowledge has been received.
N     * |        |          |It is cleared by software writing one into this bit.
N     * |[14]    |SLASEL    |Slave Select Status
N     * |        |          |This bit indicates that this device has been selected as slave.
N     * |        |          |0 = The device is not selected as slave.
N     * |        |          |1 = The device is selected as slave.
N     * |        |          |Note: This bit has no interrupt signal, and it will be cleared automatically by hardware.
N     * |[15]    |SLAREAD   |Slave Read Request Status
N     * |        |          |This bit indicates that a slave read request has been detected.
N     * |        |          |0 = A slave read request has not been detected.
N     * |        |          |1 = A slave read request has been detected.
N     * |        |          |Note: This bit has no interrupt signal, and it will be cleared automatically by hardware.
N     * |[16]    |WKAKDONE  |Wakeup Address Frame Acknowledge Bit Done
N     * |        |          |0 = The ACK bit cycle of address match frame isn't done.
N     * |        |          |1 = The ACK bit cycle of address match frame is done in power-down.
N     * |        |          |Note: This bit can't release when WKUPIF is set.
N     * |[17]    |WRSTSWK   |Read/Write Status Bit in Address Wakeup Frame
N     * |        |          |0 = Write command be record on the address match wakeup frame.
N     * |        |          |1 = Read command be record on the address match wakeup frame.
N     * |[18]    |BUSHANG   |Bus Hang-up
N     * |        |          |This bit indicates bus hang-up status.
N     * |        |          |There is 4-bit counter count when SCL hold high and refer fSAMP_CLK.
N     * |        |          |The hang-up counter will count to overflow and set this bit when SDA is low.
N     * |        |          |The counter will be reset by falling edge of SCL signal.
N     * |        |          |0 = The bus is normal status for transmission.
N     * |        |          |1 = The bus is hang-up status for transmission.
N     * |        |          |Note: This bit has no interrupt signal, and it will be cleared automatically by hardware.
N     * |[19]    |ERRARBLO  |Error Arbitration Lost
N     * |        |          |This bit indicates bus arbitration lost due to bigger noise which is can't be filtered by input processor.
N     * |        |          |The I2C can send start condition when ERRARBLO is set.
N     * |        |          |Thus this bit doesn't be cared on slave mode.
N     * |        |          |0 = The bus is normal status for transmission.
N     * |        |          |1 = The bus is error arbitration lost status for transmission.
N     * |        |          |Note: This bit has no interrupt signal, and it will be cleared automatically by hardware.
N     * @var UI2C_T::ADMAT
N     * Offset: 0x88  I2C Slave Match Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ADMAT0    |USCI Address 0 Match Status Register
N     * |        |          |When address 0 is matched, hardware will inform which address used.
N     * |        |          |This bit will set to 1, and software can write 1 to clear this bit.
N     * |[1]     |ADMAT1    |USCI Address 1 Match Status Register
N     * |        |          |When address 1 is matched, hardware will inform which address used.
N     * |        |          |This bit will set to 1, and software can write 1 to clear this bit.
N     * @var UI2C_T::TMCTL
N     * Offset: 0x8C  I2C Timing Configure Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |STCTL     |Setup Time Configure Control Register
N     * |        |          |This field is used to generate a delay timing between SDA edge and SCL rising edge in transmission mode.
N     * |        |          |The delay setup time is numbers of peripheral clock = STCTL x fPCLK.
N     * |[11:6]  |HTCTL     |Hold Time Configure Control Register
N     * |        |          |This field is used to generate the delay timing between SCL falling edge SDA edge in transmission mode.
N     * |        |          |The delay hold time is numbers of peripheral clock = HTCTL x fPCLK.
N     */
N    __IO uint32_t CTL;                   /*!< [0x0000] USCI Control Register                                            */
X    volatile uint32_t CTL;                    
N    __I  uint32_t RESERVE0[1];
X    volatile const  uint32_t RESERVE0[1];
N    __IO uint32_t BRGEN;                 /*!< [0x0008] USCI Baud Rate Generator Register                                */
X    volatile uint32_t BRGEN;                  
N    __I  uint32_t RESERVE1[8];
X    volatile const  uint32_t RESERVE1[8];
N    __IO uint32_t LINECTL;               /*!< [0x002c] USCI Line Control Register                                       */
X    volatile uint32_t LINECTL;                
N    __O  uint32_t TXDAT;                 /*!< [0x0030] USCI Transmit Data Register                                      */
X    volatile  uint32_t TXDAT;                  
N    __I  uint32_t RXDAT;                 /*!< [0x0034] USCI Receive Data Register                                       */
X    volatile const  uint32_t RXDAT;                  
N    __I  uint32_t RESERVE2[3];
X    volatile const  uint32_t RESERVE2[3];
N    __IO uint32_t DEVADDR0;              /*!< [0x0044] USCI Device Address Register 0                                   */
X    volatile uint32_t DEVADDR0;               
N    __IO uint32_t DEVADDR1;              /*!< [0x0048] USCI Device Address Register 1                                   */
X    volatile uint32_t DEVADDR1;               
N    __IO uint32_t ADDRMSK0;              /*!< [0x004c] USCI Device Address Mask Register 0                              */
X    volatile uint32_t ADDRMSK0;               
N    __IO uint32_t ADDRMSK1;              /*!< [0x0050] USCI Device Address Mask Register 1                              */
X    volatile uint32_t ADDRMSK1;               
N    __IO uint32_t WKCTL;                 /*!< [0x0054] USCI Wake-up Control Register                                    */
X    volatile uint32_t WKCTL;                  
N    __IO uint32_t WKSTS;                 /*!< [0x0058] USCI Wake-up Status Register                                     */
X    volatile uint32_t WKSTS;                  
N    __IO uint32_t PROTCTL;               /*!< [0x005c] USCI Protocol Control Register                                   */
X    volatile uint32_t PROTCTL;                
N    __IO uint32_t PROTIEN;               /*!< [0x0060] USCI Protocol Interrupt Enable Register                          */
X    volatile uint32_t PROTIEN;                
N    __IO uint32_t PROTSTS;               /*!< [0x0064] USCI Protocol Status Register                                    */
X    volatile uint32_t PROTSTS;                
N    __I  uint32_t RESERVE3[8];
X    volatile const  uint32_t RESERVE3[8];
N    __IO uint32_t ADMAT;                 /*!< [0x0088] I2C Slave Match Address Register                                 */
X    volatile uint32_t ADMAT;                  
N    __IO uint32_t TMCTL;                 /*!< [0x008c] I2C Timing Configure Control Register                            */
X    volatile uint32_t TMCTL;                  
N
N} UI2C_T;
N
N/**
N    @addtogroup UI2C_CONST UI2C Bit Field Definition
N    Constant Definitions for UI2C Controller
N@{ */
N
N#define UI2C_CTL_FUNMODE_Pos             (0)                                               /*!< UI2C_T::CTL: FUNMODE Position          */
N#define UI2C_CTL_FUNMODE_Msk             (0x7ul << UI2C_CTL_FUNMODE_Pos)                   /*!< UI2C_T::CTL: FUNMODE Mask              */
N
N#define UI2C_BRGEN_RCLKSEL_Pos           (0)                                               /*!< UI2C_T::BRGEN: RCLKSEL Position        */
N#define UI2C_BRGEN_RCLKSEL_Msk           (0x1ul << UI2C_BRGEN_RCLKSEL_Pos)                 /*!< UI2C_T::BRGEN: RCLKSEL Mask            */
N
N#define UI2C_BRGEN_PTCLKSEL_Pos          (1)                                               /*!< UI2C_T::BRGEN: PTCLKSEL Position       */
N#define UI2C_BRGEN_PTCLKSEL_Msk          (0x1ul << UI2C_BRGEN_PTCLKSEL_Pos)                /*!< UI2C_T::BRGEN: PTCLKSEL Mask           */
N
N#define UI2C_BRGEN_SPCLKSEL_Pos          (2)                                               /*!< UI2C_T::BRGEN: SPCLKSEL Position       */
N#define UI2C_BRGEN_SPCLKSEL_Msk          (0x3ul << UI2C_BRGEN_SPCLKSEL_Pos)                /*!< UI2C_T::BRGEN: SPCLKSEL Mask           */
N
N#define UI2C_BRGEN_TMCNTEN_Pos           (4)                                               /*!< UI2C_T::BRGEN: TMCNTEN Position        */
N#define UI2C_BRGEN_TMCNTEN_Msk           (0x1ul << UI2C_BRGEN_TMCNTEN_Pos)                 /*!< UI2C_T::BRGEN: TMCNTEN Mask            */
N
N#define UI2C_BRGEN_TMCNTSRC_Pos          (5)                                               /*!< UI2C_T::BRGEN: TMCNTSRC Position       */
N#define UI2C_BRGEN_TMCNTSRC_Msk          (0x1ul << UI2C_BRGEN_TMCNTSRC_Pos)                /*!< UI2C_T::BRGEN: TMCNTSRC Mask           */
N
N#define UI2C_BRGEN_PDSCNT_Pos            (8)                                               /*!< UI2C_T::BRGEN: PDSCNT Position         */
N#define UI2C_BRGEN_PDSCNT_Msk            (0x3ul << UI2C_BRGEN_PDSCNT_Pos)                  /*!< UI2C_T::BRGEN: PDSCNT Mask             */
N
N#define UI2C_BRGEN_DSCNT_Pos             (10)                                              /*!< UI2C_T::BRGEN: DSCNT Position          */
N#define UI2C_BRGEN_DSCNT_Msk             (0x1ful << UI2C_BRGEN_DSCNT_Pos)                  /*!< UI2C_T::BRGEN: DSCNT Mask              */
N
N#define UI2C_BRGEN_CLKDIV_Pos            (16)                                              /*!< UI2C_T::BRGEN: CLKDIV Position         */
N#define UI2C_BRGEN_CLKDIV_Msk            (0x3fful << UI2C_BRGEN_CLKDIV_Pos)                /*!< UI2C_T::BRGEN: CLKDIV Mask             */
N
N#define UI2C_LINECTL_LSB_Pos             (0)                                               /*!< UI2C_T::LINECTL: LSB Position          */
N#define UI2C_LINECTL_LSB_Msk             (0x1ul << UI2C_LINECTL_LSB_Pos)                   /*!< UI2C_T::LINECTL: LSB Mask              */
N
N#define UI2C_LINECTL_DWIDTH_Pos          (8)                                               /*!< UI2C_T::LINECTL: DWIDTH Position       */
N#define UI2C_LINECTL_DWIDTH_Msk          (0xful << UI2C_LINECTL_DWIDTH_Pos)                /*!< UI2C_T::LINECTL: DWIDTH Mask           */
N
N#define UI2C_TXDAT_TXDAT_Pos             (0)                                               /*!< UI2C_T::TXDAT: TXDAT Position          */
N#define UI2C_TXDAT_TXDAT_Msk             (0xfffful << UI2C_TXDAT_TXDAT_Pos)                /*!< UI2C_T::TXDAT: TXDAT Mask              */
N
N#define UI2C_RXDAT_RXDAT_Pos             (0)                                               /*!< UI2C_T::RXDAT: RXDAT Position          */
N#define UI2C_RXDAT_RXDAT_Msk             (0xfffful << UI2C_RXDAT_RXDAT_Pos)                /*!< UI2C_T::RXDAT: RXDAT Mask              */
N
N#define UI2C_DEVADDR0_DEVADDR_Pos        (0)                                               /*!< UI2C_T::DEVADDR0: DEVADDR Position     */
N#define UI2C_DEVADDR0_DEVADDR_Msk        (0x3fful << UI2C_DEVADDR0_DEVADDR_Pos)            /*!< UI2C_T::DEVADDR0: DEVADDR Mask         */
N
N#define UI2C_DEVADDR1_DEVADDR_Pos        (0)                                               /*!< UI2C_T::DEVADDR1: DEVADDR Position     */
N#define UI2C_DEVADDR1_DEVADDR_Msk        (0x3fful << UI2C_DEVADDR1_DEVADDR_Pos)            /*!< UI2C_T::DEVADDR1: DEVADDR Mask         */
N
N#define UI2C_ADDRMSK0_ADDRMSK_Pos        (0)                                               /*!< UI2C_T::ADDRMSK0: ADDRMSK Position     */
N#define UI2C_ADDRMSK0_ADDRMSK_Msk        (0x3fful << UI2C_ADDRMSK0_ADDRMSK_Pos)            /*!< UI2C_T::ADDRMSK0: ADDRMSK Mask         */
N
N#define UI2C_ADDRMSK1_ADDRMSK_Pos        (0)                                               /*!< UI2C_T::ADDRMSK1: ADDRMSK Position     */
N#define UI2C_ADDRMSK1_ADDRMSK_Msk        (0x3fful << UI2C_ADDRMSK1_ADDRMSK_Pos)            /*!< UI2C_T::ADDRMSK1: ADDRMSK Mask         */
N
N#define UI2C_WKCTL_WKEN_Pos              (0)                                               /*!< UI2C_T::WKCTL: WKEN Position           */
N#define UI2C_WKCTL_WKEN_Msk              (0x1ul << UI2C_WKCTL_WKEN_Pos)                    /*!< UI2C_T::WKCTL: WKEN Mask               */
N
N#define UI2C_WKCTL_WKADDREN_Pos          (1)                                               /*!< UI2C_T::WKCTL: WKADDREN Position       */
N#define UI2C_WKCTL_WKADDREN_Msk          (0x1ul << UI2C_WKCTL_WKADDREN_Pos)                /*!< UI2C_T::WKCTL: WKADDREN Mask           */
N
N#define UI2C_WKSTS_WKF_Pos               (0)                                               /*!< UI2C_T::WKSTS: WKF Position            */
N#define UI2C_WKSTS_WKF_Msk               (0x1ul << UI2C_WKSTS_WKF_Pos)                     /*!< UI2C_T::WKSTS: WKF Mask                */
N
N#define UI2C_PROTCTL_GCFUNC_Pos          (0)                                               /*!< UI2C_T::PROTCTL: GCFUNC Position       */
N#define UI2C_PROTCTL_GCFUNC_Msk          (0x1ul << UI2C_PROTCTL_GCFUNC_Pos)                /*!< UI2C_T::PROTCTL: GCFUNC Mask           */
N
N#define UI2C_PROTCTL_AA_Pos              (1)                                               /*!< UI2C_T::PROTCTL: AA Position           */
N#define UI2C_PROTCTL_AA_Msk              (0x1ul << UI2C_PROTCTL_AA_Pos)                    /*!< UI2C_T::PROTCTL: AA Mask               */
N
N#define UI2C_PROTCTL_STO_Pos             (2)                                               /*!< UI2C_T::PROTCTL: STO Position          */
N#define UI2C_PROTCTL_STO_Msk             (0x1ul << UI2C_PROTCTL_STO_Pos)                   /*!< UI2C_T::PROTCTL: STO Mask              */
N
N#define UI2C_PROTCTL_STA_Pos             (3)                                               /*!< UI2C_T::PROTCTL: STA Position          */
N#define UI2C_PROTCTL_STA_Msk             (0x1ul << UI2C_PROTCTL_STA_Pos)                   /*!< UI2C_T::PROTCTL: STA Mask              */
N
N#define UI2C_PROTCTL_ADDR10EN_Pos        (4)                                               /*!< UI2C_T::PROTCTL: ADDR10EN Position     */
N#define UI2C_PROTCTL_ADDR10EN_Msk        (0x1ul << UI2C_PROTCTL_ADDR10EN_Pos)              /*!< UI2C_T::PROTCTL: ADDR10EN Mask         */
N
N#define UI2C_PROTCTL_PTRG_Pos            (5)                                               /*!< UI2C_T::PROTCTL: PTRG Position         */
N#define UI2C_PROTCTL_PTRG_Msk            (0x1ul << UI2C_PROTCTL_PTRG_Pos)                  /*!< UI2C_T::PROTCTL: PTRG Mask             */
N
N#define UI2C_PROTCTL_SCLOUTEN_Pos        (8)                                               /*!< UI2C_T::PROTCTL: SCLOUTEN Position     */
N#define UI2C_PROTCTL_SCLOUTEN_Msk        (0x1ul << UI2C_PROTCTL_SCLOUTEN_Pos)              /*!< UI2C_T::PROTCTL: SCLOUTEN Mask         */
N
N#define UI2C_PROTCTL_MONEN_Pos           (9)                                               /*!< UI2C_T::PROTCTL: MONEN Position        */
N#define UI2C_PROTCTL_MONEN_Msk           (0x1ul << UI2C_PROTCTL_MONEN_Pos)                 /*!< UI2C_T::PROTCTL: MONEN Mask            */
N
N#define UI2C_PROTCTL_TOCNT_Pos           (16)                                              /*!< UI2C_T::PROTCTL: TOCNT Position        */
N#define UI2C_PROTCTL_TOCNT_Msk           (0x3fful << UI2C_PROTCTL_TOCNT_Pos)               /*!< UI2C_T::PROTCTL: TOCNT Mask            */
N
N#define UI2C_PROTCTL_PROTEN_Pos          (31)                                              /*!< UI2C_T::PROTCTL: PROTEN Position       */
N#define UI2C_PROTCTL_PROTEN_Msk          (0x1ul << UI2C_PROTCTL_PROTEN_Pos)                /*!< UI2C_T::PROTCTL: PROTEN Mask           */
N
N#define UI2C_PROTIEN_TOIEN_Pos           (0)                                               /*!< UI2C_T::PROTIEN: TOIEN Position        */
N#define UI2C_PROTIEN_TOIEN_Msk           (0x1ul << UI2C_PROTIEN_TOIEN_Pos)                 /*!< UI2C_T::PROTIEN: TOIEN Mask            */
N
N#define UI2C_PROTIEN_STARIEN_Pos         (1)                                               /*!< UI2C_T::PROTIEN: STARIEN Position      */
N#define UI2C_PROTIEN_STARIEN_Msk         (0x1ul << UI2C_PROTIEN_STARIEN_Pos)               /*!< UI2C_T::PROTIEN: STARIEN Mask          */
N
N#define UI2C_PROTIEN_STORIEN_Pos         (2)                                               /*!< UI2C_T::PROTIEN: STORIEN Position      */
N#define UI2C_PROTIEN_STORIEN_Msk         (0x1ul << UI2C_PROTIEN_STORIEN_Pos)               /*!< UI2C_T::PROTIEN: STORIEN Mask          */
N
N#define UI2C_PROTIEN_NACKIEN_Pos         (3)                                               /*!< UI2C_T::PROTIEN: NACKIEN Position      */
N#define UI2C_PROTIEN_NACKIEN_Msk         (0x1ul << UI2C_PROTIEN_NACKIEN_Pos)               /*!< UI2C_T::PROTIEN: NACKIEN Mask          */
N
N#define UI2C_PROTIEN_ARBLOIEN_Pos        (4)                                               /*!< UI2C_T::PROTIEN: ARBLOIEN Position     */
N#define UI2C_PROTIEN_ARBLOIEN_Msk        (0x1ul << UI2C_PROTIEN_ARBLOIEN_Pos)              /*!< UI2C_T::PROTIEN: ARBLOIEN Mask         */
N
N#define UI2C_PROTIEN_ERRIEN_Pos          (5)                                               /*!< UI2C_T::PROTIEN: ERRIEN Position       */
N#define UI2C_PROTIEN_ERRIEN_Msk          (0x1ul << UI2C_PROTIEN_ERRIEN_Pos)                /*!< UI2C_T::PROTIEN: ERRIEN Mask           */
N
N#define UI2C_PROTIEN_ACKIEN_Pos          (6)                                               /*!< UI2C_T::PROTIEN: ACKIEN Position       */
N#define UI2C_PROTIEN_ACKIEN_Msk          (0x1ul << UI2C_PROTIEN_ACKIEN_Pos)                /*!< UI2C_T::PROTIEN: ACKIEN Mask           */
N
N#define UI2C_PROTSTS_TOIF_Pos            (5)                                               /*!< UI2C_T::PROTSTS: TOIF Position         */
N#define UI2C_PROTSTS_TOIF_Msk            (0x1ul << UI2C_PROTSTS_TOIF_Pos)                  /*!< UI2C_T::PROTSTS: TOIF Mask             */
N
N#define UI2C_PROTSTS_ONBUSY_Pos          (6)                                               /*!< UI2C_T::PROTSTS: ONBUSY Position       */
N#define UI2C_PROTSTS_ONBUSY_Msk          (0x1ul << UI2C_PROTSTS_ONBUSY_Pos)                /*!< UI2C_T::PROTSTS: ONBUSY Mask           */
N
N#define UI2C_PROTSTS_STARIF_Pos          (8)                                               /*!< UI2C_T::PROTSTS: STARIF Position       */
N#define UI2C_PROTSTS_STARIF_Msk          (0x1ul << UI2C_PROTSTS_STARIF_Pos)                /*!< UI2C_T::PROTSTS: STARIF Mask           */
N
N#define UI2C_PROTSTS_STORIF_Pos          (9)                                               /*!< UI2C_T::PROTSTS: STORIF Position       */
N#define UI2C_PROTSTS_STORIF_Msk          (0x1ul << UI2C_PROTSTS_STORIF_Pos)                /*!< UI2C_T::PROTSTS: STORIF Mask           */
N
N#define UI2C_PROTSTS_NACKIF_Pos          (10)                                              /*!< UI2C_T::PROTSTS: NACKIF Position       */
N#define UI2C_PROTSTS_NACKIF_Msk          (0x1ul << UI2C_PROTSTS_NACKIF_Pos)                /*!< UI2C_T::PROTSTS: NACKIF Mask           */
N
N#define UI2C_PROTSTS_ARBLOIF_Pos         (11)                                              /*!< UI2C_T::PROTSTS: ARBLOIF Position      */
N#define UI2C_PROTSTS_ARBLOIF_Msk         (0x1ul << UI2C_PROTSTS_ARBLOIF_Pos)               /*!< UI2C_T::PROTSTS: ARBLOIF Mask          */
N
N#define UI2C_PROTSTS_ERRIF_Pos           (12)                                              /*!< UI2C_T::PROTSTS: ERRIF Position        */
N#define UI2C_PROTSTS_ERRIF_Msk           (0x1ul << UI2C_PROTSTS_ERRIF_Pos)                 /*!< UI2C_T::PROTSTS: ERRIF Mask            */
N
N#define UI2C_PROTSTS_ACKIF_Pos           (13)                                              /*!< UI2C_T::PROTSTS: ACKIF Position        */
N#define UI2C_PROTSTS_ACKIF_Msk           (0x1ul << UI2C_PROTSTS_ACKIF_Pos)                 /*!< UI2C_T::PROTSTS: ACKIF Mask            */
N
N#define UI2C_PROTSTS_SLASEL_Pos          (14)                                              /*!< UI2C_T::PROTSTS: SLASEL Position       */
N#define UI2C_PROTSTS_SLASEL_Msk          (0x1ul << UI2C_PROTSTS_SLASEL_Pos)                /*!< UI2C_T::PROTSTS: SLASEL Mask           */
N
N#define UI2C_PROTSTS_SLAREAD_Pos         (15)                                              /*!< UI2C_T::PROTSTS: SLAREAD Position      */
N#define UI2C_PROTSTS_SLAREAD_Msk         (0x1ul << UI2C_PROTSTS_SLAREAD_Pos)               /*!< UI2C_T::PROTSTS: SLAREAD Mask          */
N
N#define UI2C_PROTSTS_WKAKDONE_Pos        (16)                                              /*!< UI2C_T::PROTSTS: WKAKDONE Position     */
N#define UI2C_PROTSTS_WKAKDONE_Msk        (0x1ul << UI2C_PROTSTS_WKAKDONE_Pos)              /*!< UI2C_T::PROTSTS: WKAKDONE Mask         */
N
N#define UI2C_PROTSTS_WRSTSWK_Pos         (17)                                              /*!< UI2C_T::PROTSTS: WRSTSWK Position      */
N#define UI2C_PROTSTS_WRSTSWK_Msk         (0x1ul << UI2C_PROTSTS_WRSTSWK_Pos)               /*!< UI2C_T::PROTSTS: WRSTSWK Mask          */
N
N#define UI2C_PROTSTS_BUSHANG_Pos         (18)                                              /*!< UI2C_T::PROTSTS: BUSHANG Position      */
N#define UI2C_PROTSTS_BUSHANG_Msk         (0x1ul << UI2C_PROTSTS_BUSHANG_Pos)               /*!< UI2C_T::PROTSTS: BUSHANG Mask          */
N
N#define UI2C_PROTSTS_ERRARBLO_Pos        (19)                                              /*!< UI2C_T::PROTSTS: ERRARBLO Position     */
N#define UI2C_PROTSTS_ERRARBLO_Msk        (0x1ul << UI2C_PROTSTS_ERRARBLO_Pos)              /*!< UI2C_T::PROTSTS: ERRARBLO Mask         */
N
N#define UI2C_ADMAT_ADMAT0_Pos            (0)                                               /*!< UI2C_T::ADMAT: ADMAT0 Position         */
N#define UI2C_ADMAT_ADMAT0_Msk            (0x1ul << UI2C_ADMAT_ADMAT0_Pos)                  /*!< UI2C_T::ADMAT: ADMAT0 Mask             */
N
N#define UI2C_ADMAT_ADMAT1_Pos            (1)                                               /*!< UI2C_T::ADMAT: ADMAT1 Position         */
N#define UI2C_ADMAT_ADMAT1_Msk            (0x1ul << UI2C_ADMAT_ADMAT1_Pos)                  /*!< UI2C_T::ADMAT: ADMAT1 Mask             */
N
N#define UI2C_TMCTL_STCTL_Pos             (0)                                               /*!< UI2C_T::TMCTL: STCTL Position          */
N#define UI2C_TMCTL_STCTL_Msk             (0x3ful << UI2C_TMCTL_STCTL_Pos)                  /*!< UI2C_T::TMCTL: STCTL Mask              */
N
N#define UI2C_TMCTL_HTCTL_Pos             (6)                                               /*!< UI2C_T::TMCTL: HTCTL Position          */
N#define UI2C_TMCTL_HTCTL_Msk             (0x3ful << UI2C_TMCTL_HTCTL_Pos)                  /*!< UI2C_T::TMCTL: HTCTL Mask              */
N
N/**@}*/ /* UI2C_CONST */
N/**@}*/ /* end of UI2C register group */
N
N
N/*---------------------- USB Device Controller -------------------------*/
N/**
N    @addtogroup USBD USB Device Controller(USBD)
N    Memory Mapped Structure for USBD Controller
N@{ */
N
N
N
N/**
N  * @brief USBD endpoints register
N  */
Ntypedef struct
N{
N    /**
N     * @var USBD_EP_T::BUFSEG
N     * Offset: 0x500/0x510/0x520/0x530/0x540/0x550/0x560/0x570  Endpoint Buffer Segmentation Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8:3]   |BUFSEG    |Endpoint Buffer Segmentation
N     * |        |          |It is used to indicate the offset address for each endpoint with the USB SRAM starting address The effective starting address of the endpoint is
N     * |        |          |USBD_SRAM address + { BUFSEG[8:3], 3u2019b000}
N     * |        |          |Where the USBD_SRAM address = USBD_BA+0x100h.
N     * |        |          |Refer to the section 6.17.5.76.21.5.7 for the endpoint SRAM structure and its description.
N     * @var USBD_EP_T::MXPLD
N     * Offset: 0x504/0x514/0x524/0x534/0x544/0x554/0x564/0x574  Endpoint Maximal Payload Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8:0]   |MXPLD     |Maximal Payload
N     * |        |          |Define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token)
N     * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
N     * |        |          |(1) When the register is written by CPU,
N     * |        |          |For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready.
N     * |        |          |For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
N     * |        |          |(2) When the register is read by CPU,
N     * |        |          |For IN token, the value of MXPLD is indicated by the data length be transmitted to host
N     * |        |          |For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
N     * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.
N     * @var USBD_EP_T::CFG
N     * Offset: 0x508/0x518/0x528/0x538/0x548/0x558/0x568/0x578  Endpoint Configuration Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |EPNUM     |Endpoint Number
N     * |        |          |These bits are used to define the endpoint number of the current endpoint
N     * |[4]     |ISOCH     |Isochronous Endpoint
N     * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
N     * |        |          |0 = No Isochronous endpoint.
N     * |        |          |1 = Isochronous endpoint.
N     * |[6:5]   |STATE     |Endpoint STATE
N     * |        |          |00 = Endpoint is Disabled.
N     * |        |          |01 = Out endpoint.
N     * |        |          |10 = IN endpoint.
N     * |        |          |11 = Undefined.
N     * |[7]     |DSQSYNC   |Data Sequence Synchronization
N     * |        |          |0 = DATA0 PID.
N     * |        |          |1 = DATA1 PID.
N     * |        |          |Note: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction
N     * |        |          |hardware will toggle automatically in IN token base on the bit.
N     * |[9]     |CSTALL    |Clear STALL Response
N     * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
N     * |        |          |1 = Clear the device to response STALL handshake in setup stage.
N     * @var USBD_EP_T::CFGP
N     * Offset: 0x50C/0x51C/0x52C/0x53C/0x54C/0x55C/0x56C/0x57C  Endpoint Set Stall and Clear In/Out Ready Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CLRRDY    |Clear Ready
N     * |        |          |When the USBD_MXPLDx register is set by user, it means that the endpoint is ready to transmit or receive data
N     * |        |          |If the user wants to disable this transaction before the transaction start, users can set this bit to 1 to disable it and it is auto clear to 0.
N     * |        |          |For IN token, write u20181u2019 to clear the IN token had ready to transmit the data to USB.
N     * |        |          |For OUT token, write u20181u2019 to clear the OUT token had ready to receive the data from USB.
N     * |        |          |This bit is write 1 only and is always 0 when it is read back.
N     * |[1]     |SSTALL    |Set STALL
N     * |        |          |0 = Disable the device to response STALL.
N     * |        |          |1 = Set the device to respond STALL automatically.
N     */
N    __IO uint32_t BUFSEG;                /*!< [0x0000] Endpoint Buffer Segmentation Register                            */
X    volatile uint32_t BUFSEG;                 
N    __IO uint32_t MXPLD;                 /*!< [0x0004] Endpoint Maximal Payload Register                                */
X    volatile uint32_t MXPLD;                  
N    __IO uint32_t CFG;                   /*!< [0x0008] Endpoint Configuration Register                                  */
X    volatile uint32_t CFG;                    
N    __IO uint32_t CFGP;                  /*!< [0x000c] Endpoint Set Stall and Clear In/Out Ready Control Register       */
X    volatile uint32_t CFGP;                   
N
N} USBD_EP_T;
N
Ntypedef struct
N{
N
N
N    /**
N     * @var USBD_T::INTEN
N     * Offset: 0x00  USB Device Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BUSIEN    |Bus Event Interrupt Enable Bit
N     * |        |          |0 = BUS Event Interrupt Disabled.
N     * |        |          |1 = BUS Event Interrupt Enabled.
N     * |[1]     |USBIEN    |USB Event Interrupt Enable Bit
N     * |        |          |0 = USB Event Interrupt Disabled.
N     * |        |          |1 = USB Event Interrupt Enabled.
N     * |[2]     |VBDETIEN  |VBUS Detection Interrupt Enable Bit
N     * |        |          |0 = VBUS Detection Interrupt Disabled.
N     * |        |          |1 = VBUS Detection Interrupt Enabled.
N     * |[3]     |WKIDLEIEN |USB Wake-up Idle Interrupt Enable Bit
N     * |        |          |0 = Wake-up Idle Interrupt Disabled.
N     * |        |          |1 = Wake-up Idle Interrupt Enabled.
N     * |[4]     |SOFIEN    |Start of Frame Interrupt Enable Bit
N     * |        |          |0 = SOF Interrupt Disabled.
N     * |        |          |1 = SOF Interrupt Enabled.
N     * |[8]     |WKEN      |Wake-up Function Enable Bit
N     * |        |          |0 = USB Wake-up Function Disabled.
N     * |        |          |1 = USB Wake-up Function Enabled.
N     * |[15]    |INNAKEN   |Active NAK Function and Its Status in IN Token
N     * |        |          |0 = When device responds NAK after receiving IN token, IN NAK status will not be updated to USBD_EPSTS register, so that the USB interrupt event will not be asserted.
N     * |        |          |1 = IN NAK status will be updated to USBD_EPSTS register and the USB interrupt event will be asserted, when the device responds NAK after receiving IN token.
N     * @var USBD_T::INTSTS
N     * Offset: 0x04  USB Device Interrupt Event Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BUSIF     |BUS Interrupt Status
N     * |        |          |The BUS event means that there is one of the suspense or the resume function in the bus.
N     * |        |          |0 = No BUS event occurred.
N     * |        |          |1 = Bus event occurred; check USBD_ATTR[3:0] and USBD_ATTR[13:12] to know which kind of bus event was occurred, cleared by write 1 to USBD_INTSTS[0].
N     * |[1]     |USBIF     |USB Event Interrupt Status
N     * |        |          |The USB event includes the SETUP Token, IN Token, OUT ACK, ISO IN, or ISO OUT events in the bus.
N     * |        |          |0 = No USB event occurred.
N     * |        |          |1 = USB event occurred, check EPSTS0~5[2:0] to know which kind of USB event was occurred, cleared by write 1 to USBD_INTSTS[1] or EPSTS0~7 and SETUP (USBD_INTSTS[31]).
N     * |[2]     |VBDETIF   |VBUS Detection Interrupt Status
N     * |        |          |0 = There is not attached/detached event in the USB.
N     * |        |          |1 = There is attached/detached event in the USB bus and it is cleared by write 1 to USBD_INTSTS[2].
N     * |[3]     |WKIDLEIF  |No-event-wake-up Interrupt Status
N     * |        |          |0 = WKIDLE event does not occur.
N     * |        |          |1 = No-event-wake-up event occurred, cleared by write 1 to USBD_INTSTS[3].
N     * |[4]     |SOFIF     |Start of Frame Interrupt Status
N     * |        |          |0 = SOF event does not occur.
N     * |        |          |1 = SOF event occurred, cleared by write 1 to USBD_INTSTS[4].
N     * |[16]    |EPEVT0    |Endpoint 0u2019s USB Event Status
N     * |        |          |0 = No event occurred in endpoint 0.
N     * |        |          |1 = USB event occurred on Endpoint 0, check USBD_EPSTS[10:8] to know which kind of USB event was occurred, cleared by write 1 to USBD_INTSTS[16] or USBD_INTSTS[1].
N     * |[17]    |EPEVT1    |Endpoint 1u2019s USB Event Status
N     * |        |          |0 = No event occurred in endpoint 1.
N     * |        |          |1 = USB event occurred on Endpoint 1, check USBD_EPSTS[13:11] to know which kind of USB event was occurred, cleared by write 1 to USBD_INTSTS[17] or USBD_INTSTS[1].
N     * |[18]    |EPEVT2    |Endpoint 2u2019s USB Event Status
N     * |        |          |0 = No event occurred in endpoint 2.
N     * |        |          |1 = USB event occurred on Endpoint 2, check USBD_EPSTS[16:14] to know which kind of USB event was occurred, cleared by write 1 to USBD_INTSTS[18] or USBD_INTSTS[1].
N     * |[19]    |EPEVT3    |Endpoint 3u2019s USB Event Status
N     * |        |          |0 = No event occurred in endpoint 3.
N     * |        |          |1 = USB event occurred on Endpoint 3, check USBD_EPSTS[19:17] to know which kind of USB event was occurred, cleared by write 1 to USBD_INTSTS[19] or USBD_INTSTS[1].
N     * |[20]    |EPEVT4    |Endpoint 4u2019s USB Event Status
N     * |        |          |0 = No event occurred in endpoint 4.
N     * |        |          |1 = USB event occurred on Endpoint 4, check USBD_EPSTS[22:20] to know which kind of USB event was occurred, cleared by write 1 to USBD_INTSTS[20] or USBD_INTSTS[1].
N     * |[21]    |EPEVT5    |Endpoint 5u2019s USB Event Status
N     * |        |          |0 = No event occurred in endpoint 5.
N     * |        |          |1 = USB event occurred on Endpoint 5, check USBD_EPSTS[25:23] to know which kind of USB event was occurred, cleared by write 1 to USBD_INTSTS[21] or USBD_INTSTS[1].
N     * |[22]    |EPEVT6    |Endpoint 6u2019s USB Event Status
N     * |        |          |0 = No event occurred in endpoint 6.
N     * |        |          |1 = USB event occurred on Endpoint 6, check USBD_EPSTS[28:26] to know which kind of USB event was occurred, cleared by write 1 to USBD_INTSTS[22] or USBD_INTSTS[1].
N     * |[23]    |EPEVT7    |Endpoint 7u2019s USB Event Status
N     * |        |          |0 = No event occurred in endpoint 7.
N     * |        |          |1 = USB event occurred on Endpoint 7, check USBD_EPSTS[31:29] to know which kind of USB event was occurred, cleared by write 1 to USBD_INTSTS[23] or USBD_INTSTS[1].
N     * |[31]    |SETUP     |Setup Event Status
N     * |        |          |0 = No Setup event.
N     * |        |          |1 = Setup event occurred, cleared by write 1 to USBD_INTSTS[31].
N     * @var USBD_T::FADDR
N     * Offset: 0x08  USB Device Function Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[6:0]   |FADDR     |USB Device Function Address
N     * @var USBD_T::EPSTS
N     * Offset: 0x0C  USB Device Endpoint Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7]     |OV        |Overrun
N     * |        |          |It indicates that the received data is over the maximum payload number or not.
N     * |        |          |0 = No overrun.
N     * |        |          |1 = Out Data is more than the Max Payload in MXPLD register or the Setup Data is more than 8 Bytes.
N     * |[10:8]  |EPSTS0    |Endpoint 0 Status
N     * |        |          |These bits are used to indicate the current status of this endpoint
N     * |        |          |000 = In ACK.
N     * |        |          |001 = In NAK.
N     * |        |          |010 = Out Packet Data0 ACK.
N     * |        |          |110 = Out Packet Data1 ACK.
N     * |        |          |011 = Setup ACK.
N     * |        |          |111 = Isochronous transfer end.
N     * |[13:11] |EPSTS1    |Endpoint 1 Status
N     * |        |          |These bits are used to indicate the current status of this endpoint
N     * |        |          |000 = In ACK.
N     * |        |          |001 = In NAK.
N     * |        |          |010 = Out Packet Data0 ACK.
N     * |        |          |110 = Out Packet Data1 ACK.
N     * |        |          |011 = Setup ACK.
N     * |        |          |111 = Isochronous transfer end.
N     * |[16:14] |EPSTS2    |Endpoint 2 Status
N     * |        |          |These bits are used to indicate the current status of this endpoint
N     * |        |          |000 = In ACK.
N     * |        |          |001 = In NAK.
N     * |        |          |010 = Out Packet Data0 ACK.
N     * |        |          |110 = Out Packet Data1 ACK.
N     * |        |          |011 = Setup ACK.
N     * |        |          |111 = Isochronous transfer end.
N     * |[19:17] |EPSTS3    |Endpoint 3 Status
N     * |        |          |These bits are used to indicate the current status of this endpoint
N     * |        |          |000 = In ACK.
N     * |        |          |001 = In NAK.
N     * |        |          |010 = Out Packet Data0 ACK.
N     * |        |          |110 = Out Packet Data1 ACK.
N     * |        |          |011 = Setup ACK.
N     * |        |          |111 = Isochronous transfer end.
N     * |[22:20] |EPSTS4    |Endpoint 4 Status
N     * |        |          |These bits are used to indicate the current status of this endpoint
N     * |        |          |000 = In ACK.
N     * |        |          |001 = In NAK.
N     * |        |          |010 = Out Packet Data0 ACK.
N     * |        |          |110 = Out Packet Data1 ACK.
N     * |        |          |011 = Setup ACK.
N     * |        |          |111 = Isochronous transfer end.
N     * |[25:23] |EPSTS5    |Endpoint 5 Status
N     * |        |          |These bits are used to indicate the current status of this endpoint
N     * |        |          |000 = In ACK.
N     * |        |          |001 = In NAK.
N     * |        |          |010 = Out Packet Data0 ACK.
N     * |        |          |110 = Out Packet Data1 ACK.
N     * |        |          |011 = Setup ACK.
N     * |        |          |111 = Isochronous transfer end.
N     * |[28:26] |EPSTS6    |Endpoint 6 Status
N     * |        |          |These bits are used to indicate the current status of this endpoint
N     * |        |          |000 = In ACK.
N     * |        |          |001 = In NAK.
N     * |        |          |010 = Out Packet Data0 ACK.
N     * |        |          |110 = Out Packet Data1 ACK.
N     * |        |          |011 = Setup ACK.
N     * |        |          |111 = Isochronous transfer end.
N     * |[31:29] |EPSTS7    |Endpoint 7 Status
N     * |        |          |These bits are used to indicate the current status of this endpoint
N     * |        |          |000 = In ACK.
N     * |        |          |001 = In NAK.
N     * |        |          |010 = Out Packet Data0 ACK.
N     * |        |          |110 = Out Packet Data1 ACK.
N     * |        |          |011 = Setup ACK.
N     * |        |          |111 = Isochronous transfer end.
N     * @var USBD_T::ATTR
N     * Offset: 0x10  USB Device Bus Status and Attribution Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |USBRST    |USB Reset Status
N     * |        |          |0 = Bus no reset.
N     * |        |          |1 = Bus reset when SE0 (single-ended 0) more than 2.5us.
N     * |        |          |Note: This bit is read only.
N     * |[1]     |SUSPEND   |Suspend Status
N     * |        |          |0 = Bus no suspend.
N     * |        |          |1 = Bus idle more than 3ms, either cable is plugged off or host is sleeping.
N     * |        |          |Note: This bit is read only.
N     * |[2]     |RESUME    |Resume Status
N     * |        |          |0 = No bus resume.
N     * |        |          |1 = Resume from suspend.
N     * |        |          |Note: This bit is read only.
N     * |[3]     |TOUT      |Time-out Status
N     * |        |          |0 = No time-out.
N     * |        |          |1 = No Bus response more than 18 bits time.
N     * |        |          |Note: This bit is read only.
N     * |[4]     |PHYEN     |PHY Transceiver Function Enable Bit
N     * |        |          |0 = PHY transceiver function Disabled.
N     * |        |          |1 = PHY transceiver function Enabled.
N     * |[5]     |RWAKEUP   |Remote Wake-up
N     * |        |          |0 = Release the USB bus from K state.
N     * |        |          |1 = Force USB bus to K (USB_D+ low, USB_D-: high) state, used for remote wake-up.
N     * |[7]     |USBEN     |USB Controller Enable Bit
N     * |        |          |0 = USB Controller Disabled.
N     * |        |          |1 = USB Controller Enabled.
N     * |[8]     |DPPUEN    |Pull-up Resistor on USB_DP Enable Bit
N     * |        |          |0 = Pull-up resistor in USB_D+ bus Disabled.
N     * |        |          |1 = Pull-up resistor in USB_D+ bus Active.
N     * |[10]    |BYTEM     |CPU Access USB SRAM Size Mode Selection
N     * |        |          |0 = Word mode: The size of the transfer from CPU to USB SRAM can be Word only.
N     * |        |          |1 = Byte mode: The size of the transfer from CPU to USB SRAM can be Byte only.
N     * |[11]    |LPMACK    |LPM Token Acknowledge Enable
N     * |        |          |The NYET/ACK will be returned only on a successful LPM transaction if no errors in both the EXT token and the LPM token and a valid bLinkState = 0001 (L1) is received, else ERROR and STALL will be returned automatically, respectively.
N     * |        |          |0= the valid LPM Token will be NYET.
N     * |        |          |1= the valid LPM Token will be ACK.
N     * |[12]    |L1SUSPEND |LPM L1 Suspend
N     * |        |          |0 = Bus no L1 state suspend.
N     * |        |          |1 = This bit is set by the hardware when LPM command to enter the L1 state is successfully received and acknowledged.
N     * |        |          |Note: This bit is read only.
N     * |[13]    |L1RESUME  |LPM L1 Resume
N     * |        |          |0 = Bus no LPM L1 state resume.
N     * |        |          |1 = LPM L1 state Resume from LPM L1 state suspend.
N     * |        |          |Note: This bit is read only.
N     * @var USBD_T::VBUSDET
N     * Offset: 0x14  USB Device VBUS Detection Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |VBUSDET   |Device VBUS Detection
N     * |        |          |0 = Controller is not attached to the USB host.
N     * |        |          |1 = Controller is attached to the USB host.
N     * @var USBD_T::STBUFSEG
N     * Offset: 0x18  Setup Token Buffer Segmentation Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8:3]   |STBUFSEG  |SETUP Token Buffer Segmentation
N     * |        |          |It is used to indicate the offset address for the SETUP token with the USB Device SRAM starting address The effective starting address is
N     * |        |          |USBD_SRAM address + {STBUFSEG[8:3], 3u2019b000}
N     * |        |          |Where the USBD_SRAM address = USBD_BA+0x100h.
N     * |        |          |Note: It is used for SETUP token only.
N     * @var USBD_T::LPMATTR
N     * Offset: 0x88  USB LPM Attribution Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |LPMLINKSTS|LPM Linke State
N     * |        |          |These bits contain the bLinkState received with last ACK LPM Token
N     * |[7:4]   |LPMBESL   |LPM Best Effort Service Latency
N     * |        |          |These bits contain the BESL value received with last ACK LPM Token
N     * |[8]     |LPMRWAKUP |LPM Remote Wakeup
N     * |        |          |This bit contains the bRemoteWake value received with last ACK LPM Token
N     * @var USBD_T::FN
N     * Offset: 0x8C  USB Frame number Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[10:0]  |FN        |Frame Number
N     * |        |          |These bits contain the 11-bits frame number in the last received SOF packet.
N     * @var USBD_T::SE0
N     * Offset: 0x90  USB Device Drive SE0 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SE0       |Drive Single Ended Zero in USB Bus
N     * |        |          |The Single Ended Zero (SE0) is when both lines (USB_D+ and USB_D-) are being pulled low.
N     * |        |          |0 = Normal operation.
N     * |        |          |1 = Force USB PHY transceiver to drive SE0.
N     */
N
N    __IO uint32_t INTEN;                 /*!< [0x0000] USB Device Interrupt Enable Register                             */
X    volatile uint32_t INTEN;                  
N    __IO uint32_t INTSTS;                /*!< [0x0004] USB Device Interrupt Event Status Register                       */
X    volatile uint32_t INTSTS;                 
N    __IO uint32_t FADDR;                 /*!< [0x0008] USB Device Function Address Register                             */
X    volatile uint32_t FADDR;                  
N    __I  uint32_t EPSTS;                 /*!< [0x000c] USB Device Endpoint Status Register                              */
X    volatile const  uint32_t EPSTS;                  
N    __IO uint32_t ATTR;                  /*!< [0x0010] USB Device Bus Status and Attribution Register                   */
X    volatile uint32_t ATTR;                   
N    __I  uint32_t VBUSDET;               /*!< [0x0014] USB Device VBUS Detection Register                               */
X    volatile const  uint32_t VBUSDET;                
N    __IO uint32_t STBUFSEG;              /*!< [0x0018] Setup Token Buffer Segmentation Register                         */
X    volatile uint32_t STBUFSEG;               
N    __I  uint32_t RESERVE0[27];
X    volatile const  uint32_t RESERVE0[27];
N    __I  uint32_t LPMATTR;               /*!< [0x0088] USB LPM Attribution Register                                     */
X    volatile const  uint32_t LPMATTR;                
N    __I  uint32_t FN;                    /*!< [0x008c] USB Frame number Register                                        */
X    volatile const  uint32_t FN;                     
N    __IO uint32_t SE0;                   /*!< [0x0090] USB Device Drive SE0 Control Register                            */
X    volatile uint32_t SE0;                    
N    __I  uint32_t RESERVE1[283];
X    volatile const  uint32_t RESERVE1[283];
N    USBD_EP_T EP[8];                     /*!< [0x0500~0x57C] USB Device Endpoints                                       */
N
N} USBD_T;
N
N/**
N    @addtogroup USBD_CONST USBD Bit Field Definition
N    Constant Definitions for USBD Controller
N@{ */
N
N#define USBD_INTEN_BUSIEN_Pos            (0)                                               /*!< USBD_T::INTEN: BUSIEN Position         */
N#define USBD_INTEN_BUSIEN_Msk            (0x1ul << USBD_INTEN_BUSIEN_Pos)                  /*!< USBD_T::INTEN: BUSIEN Mask             */
N
N#define USBD_INTEN_USBIEN_Pos            (1)                                               /*!< USBD_T::INTEN: USBIEN Position         */
N#define USBD_INTEN_USBIEN_Msk            (0x1ul << USBD_INTEN_USBIEN_Pos)                  /*!< USBD_T::INTEN: USBIEN Mask             */
N
N#define USBD_INTEN_VBDETIEN_Pos          (2)                                               /*!< USBD_T::INTEN: VBDETIEN Position       */
N#define USBD_INTEN_VBDETIEN_Msk          (0x1ul << USBD_INTEN_VBDETIEN_Pos)                /*!< USBD_T::INTEN: VBDETIEN Mask           */
N
N#define USBD_INTEN_WKIDLEIEN_Pos         (3)                                               /*!< USBD_T::INTEN: WKIDLEIEN Position      */
N#define USBD_INTEN_WKIDLEIEN_Msk         (0x1ul << USBD_INTEN_WKIDLEIEN_Pos)               /*!< USBD_T::INTEN: WKIDLEIEN Mask          */
N
N#define USBD_INTEN_SOFIEN_Pos            (4)                                               /*!< USBD_T::INTEN: SOFIEN Position         */
N#define USBD_INTEN_SOFIEN_Msk            (0x1ul << USBD_INTEN_SOFIEN_Pos)                  /*!< USBD_T::INTEN: SOFIEN Mask             */
N
N#define USBD_INTEN_WKEN_Pos              (8)                                               /*!< USBD_T::INTEN: WKEN Position           */
N#define USBD_INTEN_WKEN_Msk              (0x1ul << USBD_INTEN_WKEN_Pos)                    /*!< USBD_T::INTEN: WKEN Mask               */
N
N#define USBD_INTEN_INNAKEN_Pos           (15)                                              /*!< USBD_T::INTEN: INNAKEN Position        */
N#define USBD_INTEN_INNAKEN_Msk           (0x1ul << USBD_INTEN_INNAKEN_Pos)                 /*!< USBD_T::INTEN: INNAKEN Mask            */
N
N#define USBD_INTSTS_BUSIF_Pos            (0)                                               /*!< USBD_T::INTSTS: BUSIF Position         */
N#define USBD_INTSTS_BUSIF_Msk            (0x1ul << USBD_INTSTS_BUSIF_Pos)                  /*!< USBD_T::INTSTS: BUSIF Mask             */
N
N#define USBD_INTSTS_USBIF_Pos            (1)                                               /*!< USBD_T::INTSTS: USBIF Position         */
N#define USBD_INTSTS_USBIF_Msk            (0x1ul << USBD_INTSTS_USBIF_Pos)                  /*!< USBD_T::INTSTS: USBIF Mask             */
N
N#define USBD_INTSTS_VBDETIF_Pos          (2)                                               /*!< USBD_T::INTSTS: VBDETIF Position       */
N#define USBD_INTSTS_VBDETIF_Msk          (0x1ul << USBD_INTSTS_VBDETIF_Pos)                /*!< USBD_T::INTSTS: VBDETIF Mask           */
N
N#define USBD_INTSTS_WKIDLEIF_Pos         (3)                                               /*!< USBD_T::INTSTS: WKIDLEIF Position      */
N#define USBD_INTSTS_WKIDLEIF_Msk         (0x1ul << USBD_INTSTS_WKIDLEIF_Pos)               /*!< USBD_T::INTSTS: WKIDLEIF Mask          */
N
N#define USBD_INTSTS_SOFIF_Pos            (4)                                               /*!< USBD_T::INTSTS: SOFIF Position         */
N#define USBD_INTSTS_SOFIF_Msk            (0x1ul << USBD_INTSTS_SOFIF_Pos)                  /*!< USBD_T::INTSTS: SOFIF Mask             */
N
N#define USBD_INTSTS_EPEVT0_Pos           (16)                                              /*!< USBD_T::INTSTS: EPEVT0 Position        */
N#define USBD_INTSTS_EPEVT0_Msk           (0x1ul << USBD_INTSTS_EPEVT0_Pos)                 /*!< USBD_T::INTSTS: EPEVT0 Mask            */
N
N#define USBD_INTSTS_EPEVT1_Pos           (17)                                              /*!< USBD_T::INTSTS: EPEVT1 Position        */
N#define USBD_INTSTS_EPEVT1_Msk           (0x1ul << USBD_INTSTS_EPEVT1_Pos)                 /*!< USBD_T::INTSTS: EPEVT1 Mask            */
N
N#define USBD_INTSTS_EPEVT2_Pos           (18)                                              /*!< USBD_T::INTSTS: EPEVT2 Position        */
N#define USBD_INTSTS_EPEVT2_Msk           (0x1ul << USBD_INTSTS_EPEVT2_Pos)                 /*!< USBD_T::INTSTS: EPEVT2 Mask            */
N
N#define USBD_INTSTS_EPEVT3_Pos           (19)                                              /*!< USBD_T::INTSTS: EPEVT3 Position        */
N#define USBD_INTSTS_EPEVT3_Msk           (0x1ul << USBD_INTSTS_EPEVT3_Pos)                 /*!< USBD_T::INTSTS: EPEVT3 Mask            */
N
N#define USBD_INTSTS_EPEVT4_Pos           (20)                                              /*!< USBD_T::INTSTS: EPEVT4 Position        */
N#define USBD_INTSTS_EPEVT4_Msk           (0x1ul << USBD_INTSTS_EPEVT4_Pos)                 /*!< USBD_T::INTSTS: EPEVT4 Mask            */
N
N#define USBD_INTSTS_EPEVT5_Pos           (21)                                              /*!< USBD_T::INTSTS: EPEVT5 Position        */
N#define USBD_INTSTS_EPEVT5_Msk           (0x1ul << USBD_INTSTS_EPEVT5_Pos)                 /*!< USBD_T::INTSTS: EPEVT5 Mask            */
N
N#define USBD_INTSTS_EPEVT6_Pos           (22)                                              /*!< USBD_T::INTSTS: EPEVT6 Position        */
N#define USBD_INTSTS_EPEVT6_Msk           (0x1ul << USBD_INTSTS_EPEVT6_Pos)                 /*!< USBD_T::INTSTS: EPEVT6 Mask            */
N
N#define USBD_INTSTS_EPEVT7_Pos           (23)                                              /*!< USBD_T::INTSTS: EPEVT7 Position        */
N#define USBD_INTSTS_EPEVT7_Msk           (0x1ul << USBD_INTSTS_EPEVT7_Pos)                 /*!< USBD_T::INTSTS: EPEVT7 Mask            */
N
N#define USBD_INTSTS_SETUP_Pos            (31)                                              /*!< USBD_T::INTSTS: SETUP Position         */
N#define USBD_INTSTS_SETUP_Msk            (0x1ul << USBD_INTSTS_SETUP_Pos)                  /*!< USBD_T::INTSTS: SETUP Mask             */
N
N#define USBD_FADDR_FADDR_Pos             (0)                                               /*!< USBD_T::FADDR: FADDR Position          */
N#define USBD_FADDR_FADDR_Msk             (0x7ful << USBD_FADDR_FADDR_Pos)                  /*!< USBD_T::FADDR: FADDR Mask              */
N
N#define USBD_EPSTS_OV_Pos                (7)                                               /*!< USBD_T::EPSTS: OV Position             */
N#define USBD_EPSTS_OV_Msk                (0x1ul << USBD_EPSTS_OV_Pos)                      /*!< USBD_T::EPSTS: OV Mask                 */
N
N#define USBD_EPSTS_EPSTS0_Pos            (8)                                               /*!< USBD_T::EPSTS: EPSTS0 Position         */
N#define USBD_EPSTS_EPSTS0_Msk            (0x7ul << USBD_EPSTS_EPSTS0_Pos)                  /*!< USBD_T::EPSTS: EPSTS0 Mask             */
N
N#define USBD_EPSTS_EPSTS1_Pos            (11)                                              /*!< USBD_T::EPSTS: EPSTS1 Position         */
N#define USBD_EPSTS_EPSTS1_Msk            (0x7ul << USBD_EPSTS_EPSTS1_Pos)                  /*!< USBD_T::EPSTS: EPSTS1 Mask             */
N
N#define USBD_EPSTS_EPSTS2_Pos            (14)                                              /*!< USBD_T::EPSTS: EPSTS2 Position         */
N#define USBD_EPSTS_EPSTS2_Msk            (0x7ul << USBD_EPSTS_EPSTS2_Pos)                  /*!< USBD_T::EPSTS: EPSTS2 Mask             */
N
N#define USBD_EPSTS_EPSTS3_Pos            (17)                                              /*!< USBD_T::EPSTS: EPSTS3 Position         */
N#define USBD_EPSTS_EPSTS3_Msk            (0x7ul << USBD_EPSTS_EPSTS3_Pos)                  /*!< USBD_T::EPSTS: EPSTS3 Mask             */
N
N#define USBD_EPSTS_EPSTS4_Pos            (20)                                              /*!< USBD_T::EPSTS: EPSTS4 Position         */
N#define USBD_EPSTS_EPSTS4_Msk            (0x7ul << USBD_EPSTS_EPSTS4_Pos)                  /*!< USBD_T::EPSTS: EPSTS4 Mask             */
N
N#define USBD_EPSTS_EPSTS5_Pos            (23)                                              /*!< USBD_T::EPSTS: EPSTS5 Position         */
N#define USBD_EPSTS_EPSTS5_Msk            (0x7ul << USBD_EPSTS_EPSTS5_Pos)                  /*!< USBD_T::EPSTS: EPSTS5 Mask             */
N
N#define USBD_EPSTS_EPSTS6_Pos            (26)                                              /*!< USBD_T::EPSTS: EPSTS6 Position         */
N#define USBD_EPSTS_EPSTS6_Msk            (0x7ul << USBD_EPSTS_EPSTS6_Pos)                  /*!< USBD_T::EPSTS: EPSTS6 Mask             */
N
N#define USBD_EPSTS_EPSTS7_Pos            (29)                                              /*!< USBD_T::EPSTS: EPSTS7 Position         */
N#define USBD_EPSTS_EPSTS7_Msk            (0x7ul << USBD_EPSTS_EPSTS7_Pos)                  /*!< USBD_T::EPSTS: EPSTS7 Mask             */
N
N#define USBD_ATTR_USBRST_Pos             (0)                                               /*!< USBD_T::ATTR: USBRST Position          */
N#define USBD_ATTR_USBRST_Msk             (0x1ul << USBD_ATTR_USBRST_Pos)                   /*!< USBD_T::ATTR: USBRST Mask              */
N
N#define USBD_ATTR_SUSPEND_Pos            (1)                                               /*!< USBD_T::ATTR: SUSPEND Position         */
N#define USBD_ATTR_SUSPEND_Msk            (0x1ul << USBD_ATTR_SUSPEND_Pos)                  /*!< USBD_T::ATTR: SUSPEND Mask             */
N
N#define USBD_ATTR_RESUME_Pos             (2)                                               /*!< USBD_T::ATTR: RESUME Position          */
N#define USBD_ATTR_RESUME_Msk             (0x1ul << USBD_ATTR_RESUME_Pos)                   /*!< USBD_T::ATTR: RESUME Mask              */
N
N#define USBD_ATTR_TOUT_Pos               (3)                                               /*!< USBD_T::ATTR: TOUT Position            */
N#define USBD_ATTR_TOUT_Msk               (0x1ul << USBD_ATTR_TOUT_Pos)                     /*!< USBD_T::ATTR: TOUT Mask                */
N
N#define USBD_ATTR_PHYEN_Pos              (4)                                               /*!< USBD_T::ATTR: PHYEN Position           */
N#define USBD_ATTR_PHYEN_Msk              (0x1ul << USBD_ATTR_PHYEN_Pos)                    /*!< USBD_T::ATTR: PHYEN Mask               */
N
N#define USBD_ATTR_RWAKEUP_Pos            (5)                                               /*!< USBD_T::ATTR: RWAKEUP Position         */
N#define USBD_ATTR_RWAKEUP_Msk            (0x1ul << USBD_ATTR_RWAKEUP_Pos)                  /*!< USBD_T::ATTR: RWAKEUP Mask             */
N
N#define USBD_ATTR_USBEN_Pos              (7)                                               /*!< USBD_T::ATTR: USBEN Position           */
N#define USBD_ATTR_USBEN_Msk              (0x1ul << USBD_ATTR_USBEN_Pos)                    /*!< USBD_T::ATTR: USBEN Mask               */
N
N#define USBD_ATTR_DPPUEN_Pos             (8)                                               /*!< USBD_T::ATTR: DPPUEN Position          */
N#define USBD_ATTR_DPPUEN_Msk             (0x1ul << USBD_ATTR_DPPUEN_Pos)                   /*!< USBD_T::ATTR: DPPUEN Mask              */
N
N#define USBD_ATTR_BYTEM_Pos              (10)                                              /*!< USBD_T::ATTR: BYTEM Position           */
N#define USBD_ATTR_BYTEM_Msk              (0x1ul << USBD_ATTR_BYTEM_Pos)                    /*!< USBD_T::ATTR: BYTEM Mask               */
N
N#define USBD_ATTR_LPMACK_Pos             (11)                                              /*!< USBD_T::ATTR: LPMACK Position          */
N#define USBD_ATTR_LPMACK_Msk             (0x1ul << USBD_ATTR_LPMACK_Pos)                   /*!< USBD_T::ATTR: LPMACK Mask              */
N
N#define USBD_ATTR_L1SUSPEND_Pos          (12)                                              /*!< USBD_T::ATTR: L1SUSPEND Position       */
N#define USBD_ATTR_L1SUSPEND_Msk          (0x1ul << USBD_ATTR_L1SUSPEND_Pos)                /*!< USBD_T::ATTR: L1SUSPEND Mask           */
N
N#define USBD_ATTR_L1RESUME_Pos           (13)                                              /*!< USBD_T::ATTR: L1RESUME Position        */
N#define USBD_ATTR_L1RESUME_Msk           (0x1ul << USBD_ATTR_L1RESUME_Pos)                 /*!< USBD_T::ATTR: L1RESUME Mask            */
N
N#define USBD_VBUSDET_VBUSDET_Pos         (0)                                               /*!< USBD_T::VBUSDET: VBUSDET Position      */
N#define USBD_VBUSDET_VBUSDET_Msk         (0x1ul << USBD_VBUSDET_VBUSDET_Pos)               /*!< USBD_T::VBUSDET: VBUSDET Mask          */
N
N#define USBD_STBUFSEG_STBUFSEG_Pos       (3)                                               /*!< USBD_T::STBUFSEG: STBUFSEG Position    */
N#define USBD_STBUFSEG_STBUFSEG_Msk       (0x3ful << USBD_STBUFSEG_STBUFSEG_Pos)            /*!< USBD_T::STBUFSEG: STBUFSEG Mask        */
N
N#define USBD_LPMATTR_LPMLINKSTS_Pos      (0)                                               /*!< USBD_T::LPMATTR: LPMLINKSTS Position   */
N#define USBD_LPMATTR_LPMLINKSTS_Msk      (0xful << USBD_LPMATTR_LPMLINKSTS_Pos)            /*!< USBD_T::LPMATTR: LPMLINKSTS Mask       */
N
N#define USBD_LPMATTR_LPMBESL_Pos         (4)                                               /*!< USBD_T::LPMATTR: LPMBESL Position      */
N#define USBD_LPMATTR_LPMBESL_Msk         (0xful << USBD_LPMATTR_LPMBESL_Pos)               /*!< USBD_T::LPMATTR: LPMBESL Mask          */
N
N#define USBD_LPMATTR_LPMRWAKUP_Pos       (8)                                               /*!< USBD_T::LPMATTR: LPMRWAKUP Position    */
N#define USBD_LPMATTR_LPMRWAKUP_Msk       (0x1ul << USBD_LPMATTR_LPMRWAKUP_Pos)             /*!< USBD_T::LPMATTR: LPMRWAKUP Mask        */
N
N#define USBD_FN_FN_Pos                   (0)                                               /*!< USBD_T::FN: FN Position                */
N#define USBD_FN_FN_Msk                   (0x7fful << USBD_FN_FN_Pos)                       /*!< USBD_T::FN: FN Mask                    */
N
N#define USBD_SE0_SE0_Pos                 (0)                                               /*!< USBD_T::SE0: SE0 Position              */
N#define USBD_SE0_SE0_Msk                 (0x1ul << USBD_SE0_SE0_Pos)                       /*!< USBD_T::SE0: SE0 Mask                  */
N
N#define USBD_BUFSEG_BUFSEG_Pos          (3)                                                /*!< USBD_EP_T::BUFSEG: BUFSEG Position     */
N#define USBD_BUFSEG_BUFSEG_Msk          (0x3ful << USBD_BUFSEG_BUFSEG_Pos)                 /*!< USBD_EP_T::BUFSEG: BUFSEG Mask         */
N
N#define USBD_MXPLD_MXPLD_Pos            (0)                                                /*!< USBD_EP_T::MXPLD: MXPLD Position       */
N#define USBD_MXPLD_MXPLD_Msk            (0x1fful << USBD_MXPLD_MXPLD_Pos)                  /*!< USBD_EP_T::MXPLD: MXPLD Mask           */
N
N#define USBD_CFG_EPNUM_Pos              (0)                                                /*!< USBD_EP_T::CFG: EPNUM Position         */
N#define USBD_CFG_EPNUM_Msk              (0xful << USBD_CFG_EPNUM_Pos)                      /*!< USBD_EP_T::CFG: EPNUM Mask             */
N
N#define USBD_CFG_ISOCH_Pos              (4)                                                /*!< USBD_EP_T::CFG: ISOCH Position         */
N#define USBD_CFG_ISOCH_Msk              (0x1ul << USBD_CFG_ISOCH_Pos)                      /*!< USBD_EP_T::CFG: ISOCH Mask             */
N
N#define USBD_CFG_STATE_Pos              (5)                                                /*!< USBD_EP_T::CFG: STATE Position         */
N#define USBD_CFG_STATE_Msk              (0x3ul << USBD_CFG_STATE_Pos)                      /*!< USBD_EP_T::CFG: STATE Mask             */
N
N#define USBD_CFG_DSQSYNC_Pos            (7)                                                /*!< USBD_EP_T::CFG: DSQSYNC Position       */
N#define USBD_CFG_DSQSYNC_Msk            (0x1ul << USBD_CFG_DSQSYNC_Pos)                    /*!< USBD_EP_T::CFG: DSQSYNC Mask           */
N
N#define USBD_CFG_CSTALL_Pos             (9)                                                /*!< USBD_EP_T::CFG: CSTALL Position        */
N#define USBD_CFG_CSTALL_Msk             (0x1ul << USBD_CFG_CSTALL_Pos)                     /*!< USBD_EP_T::CFG: CSTALL Mask            */
N
N#define USBD_CFGP_CLRRDY_Pos            (0)                                                /*!< USBD_EP_T::CFGP: CLRRDY Position       */
N#define USBD_CFGP_CLRRDY_Msk            (0x1ul << USBD_CFGP_CLRRDY_Pos)                    /*!< USBD_EP_T::CFGP: CLRRDY Mask           */
N
N#define USBD_CFGP_SSTALL_Pos            (1)                                                /*!< USBD_EP_T::CFGP: SSTALL Position       */
N#define USBD_CFGP_SSTALL_Msk            (0x1ul << USBD_CFGP_SSTALL_Pos)                    /*!< USBD_EP_T::CFGP: SSTALL Mask           */
N
N
N/**@}*/ /* USBD_CONST */
N/**@}*/ /* end of USBD register group */
N
N
N/*---------------------- SPI Mode of USCI Controller -------------------------*/
N/**
N    @addtogroup USPI SPI Mode of USCI Controller(USPI)
N    Memory Mapped Structure for USPI Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var USPI_T::CTL
N     * Offset: 0x00  USCI Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |FUNMODE   |Function Mode
N     * |        |          |This bit field selects the protocol for this USCI controller
N     * |        |          |Selecting a protocol that is not available or a reserved combination disables the USCI
N     * |        |          |When switching between two protocols, the USCI has to be disabled before selecting a new protocol
N     * |        |          |Simultaneously, the USCI will be reset when user write 000 to FUNMODE.
N     * |        |          |000 = The USCI is disabled. All protocol related state machines are set to idle state.
N     * |        |          |001 = The SPI protocol is selected.
N     * |        |          |010 = The UART protocol is selected.
N     * |        |          |100 = The I2C protocol is selected.
N     * |        |          |Note: Other bit combinations are reserved.
N     * @var USPI_T::INTEN
N     * Offset: 0x04  USCI Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |TXSTIEN   |Transmit Start Interrupt Enable Bit
N     * |        |          |This bit enables the interrupt generation in case of a transmit start event.
N     * |        |          |0 = The transmit start interrupt is disabled.
N     * |        |          |1 = The transmit start interrupt is enabled.
N     * |[2]     |TXENDIEN  |Transmit End Interrupt Enable Bit
N     * |        |          |This bit enables the interrupt generation in case of a transmit finish event.
N     * |        |          |0 = The transmit finish interrupt is disabled.
N     * |        |          |1 = The transmit finish interrupt is enabled.
N     * |[3]     |RXSTIEN   |Receive Start Interrupt Enable Bit
N     * |        |          |This bit enables the interrupt generation in case of a receive start event.
N     * |        |          |0 = The receive start interrupt is disabled.
N     * |        |          |1 = The receive start interrupt is enabled.
N     * |[4]     |RXENDIEN  |Receive End Interrupt Enable Bit
N     * |        |          |This bit enables the interrupt generation in case of a receive finish event.
N     * |        |          |0 = The receive end interrupt is disabled.
N     * |        |          |1 = The receive end interrupt is enabled.
N     * @var USPI_T::BRGEN
N     * Offset: 0x08  USCI Baud Rate Generator Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RCLKSEL   |Reference Clock Source Selection
N     * |        |          |This bit selects the source of reference clock (fREF_CLK).
N     * |        |          |0 = Peripheral device clock fPCLK.
N     * |        |          |1 = Reserved.
N     * |[1]     |PTCLKSEL  |Protocol Clock Source Selection
N     * |        |          |This bit selects the source of protocol clock (fPROT_CLK).
N     * |        |          |0 = Reference clock fREF_CLK.
N     * |        |          |1 = fREF_CLK2 (its frequency is half of fREF_CLK).
N     * |[3:2]   |SPCLKSEL  |Sample Clock Source Selection
N     * |        |          |This bit field used for the clock source selection of sample clock (fSAMP_CLK) for the protocol processor.
N     * |        |          |00 = fDIV_CLK.
N     * |        |          |01 = fPROT_CLK.
N     * |        |          |10 = fSCLK.
N     * |        |          |11 = fREF_CLK.
N     * |[4]     |TMCNTEN   |Time Measurement Counter Enable Bit
N     * |        |          |This bit enables the 10-bit timing measurement counter.
N     * |        |          |0 = Time measurement counter is Disabled.
N     * |        |          |1 = Time measurement counter is Enabled.
N     * |[5]     |TMCNTSRC  |Time Measurement Counter Clock Source Selection
N     * |        |          |0 = Time measurement counter with fPROT_CLK.
N     * |        |          |1 = Time measurement counter with fDIV_CLK.
N     * |[25:16] |CLKDIV    |Clock Divider
N     * |        |          |This bit field defines the ratio between the protocol clock frequency fPROT_CLK and the clock divider frequency fDIV_CLK (fDIV_CLK = fPROT_CLK / (CLKDIV+1) ).
N     * |        |          |Note: In UART function, it can be updated by hardware in the 4th falling edge of the input data 0x55 when the auto baud rate function (ABREN(USPI_PROTCTL[6])) is enabled
N     * |        |          |The revised value is the average bit time between bit 5 and bit 6
N     * |        |          |The user can use revised CLKDIV and new BRDETITV (USPI_PROTCTL[24:16]) to calculate the precise baud rate.
N     * @var USPI_T::DATIN0
N     * Offset: 0x10  USCI Input Data Signal Configuration Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SYNCSEL   |Input   Signal Synchronization Selection
N     * |        |          |This bit   selects if the un-synchronized input signal (with optionally inverted) or the   synchronized (and optionally filtered) signal can be used as input for the   data shift unit.
N     * |        |          |0 = The   un-synchronized signal can be taken as input for the data shift unit.
N     * |        |          |1 = The   synchronized signal can be taken as input for the data shift unit.
N     * |        |          |Note: In SPI protocol, we suggest this bit   should be set as 0.
N     * |[2]     |ININV     |Input   Signal Inverse Selection
N     * |        |          |This bit   defines the inverter enable of the input asynchronous signal.
N     * |        |          |0 = The   un-synchronized input signal will not be inverted.
N     * |        |          |1 = The   un-synchronized input signal will be inverted.
N     * |        |          |Note: In SPI protocol, we suggest this bit   should be set as 0.
N     * @var USPI_T::CTLIN0
N     * Offset: 0x20  USCI Input Control Signal Configuration Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SYNCSEL   |Input   Synchronization Signal Selection
N     * |        |          |This bit   selects if the un-synchronized input signal (with optionally inverted) or the   synchronized (and optionally filtered) signal can be used as input for the   data shift unit.
N     * |        |          |0 = The   un-synchronized signal can be taken as input for the data shift unit.
N     * |        |          |1 = The   synchronized signal can be taken as input for the data shift unit.
N     * |        |          |Note: In SPI protocol, we suggest this bit   should be set as 0.
N     * |[2]     |ININV     |Input   Signal Inverse Selection
N     * |        |          |This bit   defines the inverter enable of the input asynchronous signal.
N     * |        |          |0 = The   un-synchronized input signal will not be inverted.
N     * |        |          |1 = The   un-synchronized input signal will be inverted.
N     * @var USPI_T::CLKIN
N     * Offset: 0x28  USCI Input Clock Signal Configuration Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SYNCSEL   |Input   Synchronization Signal Selection
N     * |        |          |This bit   selects if the un-synchronized input signal or the synchronized (and   optionally filtered) signal can be used as input for the data shift unit.
N     * |        |          |0 = The   un-synchronized signal can be taken as input for the data shift unit.
N     * |        |          |1 = The   synchronized signal can be taken as input for the data shift unit.
N     * |        |          |Note: In SPI protocol, we suggest this bit   should be set as 0.
N     * @var USPI_T::LINECTL
N     * Offset: 0x2C  USCI Line Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |LSB       |LSB First Transmission Selection
N     * |        |          |0 = The MSB, which bit of transmit/receive data buffer depends on the setting of DWIDTH, is transmitted/received first.
N     * |        |          |1 = The LSB, the bit 0 of data buffer, will be transmitted/received first.
N     * |[5]     |DATOINV   |Data Output Inverse Selection
N     * |        |          |This bit defines the relation between the internal shift data value and the output data signal of USCIx_DAT0/1 pin.
N     * |        |          |0 = Data output level is not inverted.
N     * |        |          |1 = Data output level is inverted.
N     * |[7]     |CTLOINV   |Control Signal Output Inverse Selection
N     * |        |          |This bit defines the relation between the internal control signal and the output control signal.
N     * |        |          |0 = No effect.
N     * |        |          |1 = The control signal will be inverted before its output.
N     * |        |          |Note: The control signal has different definitions in different protocol
N     * |        |          |In SPI protocol, the control signal means slave select signal
N     * |[11:8]  |DWIDTH    |Word Length of Transmission
N     * |        |          |This bit field defines the data word length (amount of bits) for reception and transmission
N     * |        |          |The data word is always right-aligned in the data buffer
N     * |        |          |USCI support word length from 4 to 16 bits.
N     * |        |          |0x0: The data word contains 16 bits located at bit positions [15:0].
N     * |        |          |0x1: Reserved.
N     * |        |          |0x2: Reserved.
N     * |        |          |0x3: Reserved.
N     * |        |          |0x4: The data word contains 4 bits located at bit positions [3:0].
N     * |        |          |0x5: The data word contains 5 bits located at bit positions [4:0].
N     * |        |          |...
N     * |        |          |0xF: The data word contains 15 bits located at bit positions [14:0].
N     * @var USPI_T::TXDAT
N     * Offset: 0x30  USCI Transmit Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |TXDAT     |Transmit Data
N     * |        |          |Software can use this bit field to write 16-bit transmit data for transmission
N     * |        |          |In order to avoid overwriting the transmit data, user have to check TXEMPTY (USPI_BUFSTS[8]) status before writing transmit data into this bit field.
N     * |[16]    |PORTDIR   |Port Direction Control
N     * |        |          |This bit field is only available while USCI operates in SPI protocol (FUNMODE = 0x1) with half-duplex transfer
N     * |        |          |It is used to define the direction of the data port pin
N     * |        |          |When software writes USPI_TXDAT register, the transmit data and its port direction are settled simultaneously.
N     * |        |          |0 = The data pin is configured as output mode.
N     * |        |          |1 = The data pin is configured as input mode.
N     * @var USPI_T::RXDAT
N     * Offset: 0x34  USCI Receive Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RXDAT     |Received Data
N     * |        |          |This bit field monitors the received data which stored in receive data buffer.
N     * @var USPI_T::BUFCTL
N     * Offset: 0x38  USCI Transmit/Receive Buffer Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[6]     |TXUDRIEN  |Slave Transmit Under-run Interrupt Enable
N     * |        |          |0 = Transmit under-run interrupt Disabled.
N     * |        |          |1 = Transmit under-run interrupt Enabled.
N     * |[7]     |TXCLR     |Clear Transmit Buffer
N     * |        |          |0 = No effect.
N     * |        |          |1 = The transmit buffer is cleared
N     * |        |          |Should only be used while the buffer is not taking part in data traffic.
N     * |        |          |Note: It is cleared automatically after one PCLK cycle.
N     * |[14]    |RXOVIEN   |Receive Buffer Overrun Interrupt Enable Control
N     * |        |          |0 = Receive overrun interrupt Disabled.
N     * |        |          |1 = Receive overrun interrupt Enabled.
N     * |[15]    |RXCLR     |Clear Receive Buffer
N     * |        |          |0 = No effect.
N     * |        |          |1 = The receive buffer is cleared
N     * |        |          |Should only be used while the buffer is not taking part in data traffic.
N     * |        |          |Note: It is cleared automatically after one PCLK cycle.
N     * |[16]    |TXRST     |Transmit Reset
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the transmit-related counters, state machine, and the content of transmit shift register and data buffer.
N     * |        |          |Note: It is cleared automatically after one PCLK cycle.
N     * |[17]    |RXRST     |Receive Reset
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the receive-related counters, state machine, and the content of receive shift register and data buffer.
N     * |        |          |Note: It is cleared automatically after one PCLK cycle.
N     * @var USPI_T::BUFSTS
N     * Offset: 0x3C  USCI Transmit/Receive Buffer Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RXEMPTY   |Receive Buffer Empty Indicator
N     * |        |          |0 = Receive buffer is not empty.
N     * |        |          |1 = Receive buffer is empty.
N     * |[1]     |RXFULL    |Receive Buffer Full Indicator
N     * |        |          |0 = Receive buffer is not full.
N     * |        |          |1 = Receive buffer is full.
N     * |[3]     |RXOVIF    |Receive Buffer Overrun Interrupt Status
N     * |        |          |This bit indicates that a receive buffer overrun event has been detected
N     * |        |          |If RXOVIEN (USPI_BUFCTL[14]) is enabled, the corresponding interrupt request is activated
N     * |        |          |It is cleared by software writes 1 to this bit.
N     * |        |          |0 = A receive buffer overrun event has not been detected.
N     * |        |          |1 = A receive buffer overrun event has been detected.
N     * |[8]     |TXEMPTY   |Transmit Buffer Empty Indicator
N     * |        |          |0 = Transmit buffer is not empty.
N     * |        |          |1 = Transmit buffer is empty and available for the next transmission datum.
N     * |[9]     |TXFULL    |Transmit Buffer Full Indicator
N     * |        |          |0 = Transmit buffer is not full.
N     * |        |          |1 = Transmit buffer is full.
N     * |[11]    |TXUDRIF   |Transmit Buffer Under-run Interrupt Status
N     * |        |          |This bit indicates that a transmit buffer under-run event has been detected
N     * |        |          |If enabled by TXUDRIEN (USPI_BUFCTL[6]), the corresponding interrupt request is activated
N     * |        |          |It is cleared by software writes 1 to this bit
N     * |        |          |0 = A transmit buffer under-run event has not been detected.
N     * |        |          |1 = A transmit buffer under-run event has been detected.
N     * @var USPI_T::WKCTL
N     * Offset: 0x54  USCI Wake-up Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WKEN      |Wake-up Enable Bit
N     * |        |          |0 = Wake-up function Disabled.
N     * |        |          |1 = Wake-up function Enabled.
N     * |[1]     |WKADDREN  |Wake-up Address Match Enable Bit
N     * |        |          |0 = The chip is woken up according data toggle.
N     * |        |          |1 = The chip is woken up according address match.
N     * |[2]     |PDBOPT    |Power Down Blocking Option
N     * |        |          |0 = If user attempts to enter Power-down mode by executing WFI while the protocol is in transferring, MCU will stop the transfer and enter Power-down mode immediately.
N     * |        |          |1 = If user attempts to enter Power-down mode by executing WFI while the protocol is in transferring, the on-going transfer will not be stopped and MCU will enter idle mode immediately.
N     * @var USPI_T::WKSTS
N     * Offset: 0x58  USCI Wake-up Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WKF       |Wake-up Flag
N     * |        |          |When chip is woken up from Power-down mode, this bit is set to 1
N     * |        |          |Software can write 1 to clear this bit.
N     * @var USPI_T::PROTCTL
N     * Offset: 0x5C  USCI Protocol Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SLAVE     |Slave Mode Selection
N     * |        |          |0 = Master mode.
N     * |        |          |1 = Slave mode.
N     * |[1]     |SLV3WIRE  |Slave 3-wire Mode Selection (Slave Only)
N     * |        |          |The SPI protocol can work with 3-wire interface (without slave select signal) in Slave mode.
N     * |        |          |0 = 4-wire bi-direction interface.
N     * |        |          |1 = 3-wire bi-direction interface.
N     * |[2]     |SS        |Slave Select Control (Master Only)
N     * |        |          |If AUTOSS bit is cleared, setting this bit to 1 will set the slave select signal to active state, and setting this bit to 0 will set the slave select signal back to inactive state.
N     * |        |          |If the AUTOSS function is enabled (AUTOSS = 1), the setting value of this bit will not affect the current state of slave select signal.
N     * |        |          |Note: In SPI protocol, the internal slave select signal is active high.
N     * |[3]     |AUTOSS    |Automatic Slave Select Function Enable (Master Only)
N     * |        |          |0 = Slave select signal will be controlled by the setting value of SS (USPI_PROTCTL[2]) bit.
N     * |        |          |1 = Slave select signal will be generated automatically
N     * |        |          |The slave select signal will be asserted by the SPI controller when transmit/receive is started, and will be de-asserted after each transmit/receive is finished.
N     * |[7:6]   |SCLKMODE  |Serial Bus Clock Mode
N     * |        |          |This bit field defines the SCLK idle status, data transmit, and data receive edge.
N     * |        |          |MODE0 = The idle state of SPI clock is low level
N     * |        |          |Data is transmitted with falling edge and received with rising edge.
N     * |        |          |MODE1 = The idle state of SPI clock is low level
N     * |        |          |Data is transmitted with rising edge and received with falling edge.
N     * |        |          |MODE2 = The idle state of SPI clock is high level
N     * |        |          |Data is transmitted with rising edge and received with falling edge.
N     * |        |          |MODE3 = The idle state of SPI clock is high level
N     * |        |          |Data is transmitted with falling edge and received with rising edge.
N     * |[11:8]  |SUSPITV   |Suspend Interval (Master Only)
N     * |        |          |This bit field provides the configurable suspend interval between two successive transmit/receive transaction in a transfer
N     * |        |          |The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word and the first clock edge of the following transaction word
N     * |        |          |The default value is 0x3
N     * |        |          |The period of the suspend interval is obtained according to the following equation.
N     * |        |          |(SUSPITV[3:0] + 0.5) * period of SPI_CLK clock cycle
N     * |        |          |Example:
N     * |        |          |SUSPITV = 0x0 u2026. 0.5 SPI_CLK clock cycle.
N     * |        |          |SUSPITV = 0x1 u2026. 1.5 SPI_CLK clock cycle.
N     * |        |          |u2026u2026
N     * |        |          |SUSPITV = 0xE u2026. 14.5 SPI_CLK clock cycle.
N     * |        |          |SUSPITV = 0xF u2026. 15.5 SPI_CLK clock cycle.
N     * |[14:12] |TSMSEL    |Transmit Data Mode Selection
N     * |        |          |This bit field describes how receive and transmit data is shifted in and out.
N     * |        |          |TSMSEL = 000b: Full-duplex SPI.
N     * |        |          |TSMSEL = 100b: Half-duplex SPI.
N     * |        |          |Other values are reserved.
N     * |        |          |Note: Changing the value of this bit field will produce the TXRST and RXRST to clear the TX/RX data buffer automatically.
N     * |[25:16] |SLVTOCNT  |Slave Mode Time-out Period (Slave Only)
N     * |        |          |In Slave mode, this bit field is used for Slave time-out period
N     * |        |          |This bit field indicates how many clock periods (selected by TMCNTSRC, USPI_BRGEN[5]) between the two edges of input SCLK will assert the Slave time-out event
N     * |        |          |Writing 0x0 into this bit field will disable the Slave time-out function.
N     * |        |          |Example: Assume SLVTOCNT is 0x0A and TMCNTSRC (USPI_BRGEN[5]) is 1, it means the time-out event will occur if the state of SPI bus clock pin is not changed more than (10+1) periods of fDIV_CLK.
N     * |[28]    |TXUDRPOL  |Transmit Under-run Data Polarity (for Slave)
N     * |        |          |This bit defines the transmitting data level when no data is available for transferring.
N     * |        |          |0 = The output data level is 0 if TX under-run event occurs.
N     * |        |          |1 = The output data level is 1 if TX under-run event occurs.
N     * |[31]    |PROTEN    |SPI Protocol Enable
N     * |        |          |0 = SPI Protocol Disabled.
N     * |        |          |1 = SPI Protocol Enabled.
N     * @var USPI_T::PROTIEN
N     * Offset: 0x60  USCI Protocol Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SSINAIEN  |Slave Select Inactive Interrupt Enable Control
N     * |        |          |This bit enables/disables the generation of a slave select interrupt if the slave select changes to inactive.
N     * |        |          |0 = Slave select inactive interrupt generation Disabled.
N     * |        |          |1 = Slave select inactive interrupt generation Enabled.
N     * |[1]     |SSACTIEN  |Slave Select Active Interrupt Enable Control
N     * |        |          |This bit enables/disables the generation of a slave select interrupt if the slave select changes to active.
N     * |        |          |0 = Slave select active interrupt generation Disabled.
N     * |        |          |1 = Slave select active interrupt generation Enabled.
N     * |[2]     |SLVTOIEN  |Slave Time-out Interrupt Enable Control
N     * |        |          |In SPI protocol, this bit enables the interrupt generation in case of a Slave time-out event.
N     * |        |          |0 = The Slave time-out interrupt Disabled.
N     * |        |          |1 = The Slave time-out interrupt Enabled.
N     * |[3]     |SLVBEIEN  |Slave Mode Bit Count Error Interrupt Enable Control
N     * |        |          |If data transfer is terminated by slave time-out or slave select inactive event in Slave mode, so that the transmit/receive data bit count does not match the setting of DWIDTH (USPI_LINECTL[11:8])
N     * |        |          |Bit count error event occurs.
N     * |        |          |0 = The Slave mode bit count error interrupt Disabled.
N     * |        |          |1 = The Slave mode bit count error interrupt Enabled.
N     * @var USPI_T::PROTSTS
N     * Offset: 0x64  USCI Protocol Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |TXSTIF    |Transmit Start Interrupt Flag
N     * |        |          |0 = Transmit start event does not occur.
N     * |        |          |1 = Transmit start event occurs.
N     * |        |          |Note: It is cleared by software writes 1 to this bit
N     * |[2]     |TXENDIF   |Transmit End Interrupt Flag
N     * |        |          |0 = Transmit end event does not occur.
N     * |        |          |1 = Transmit end event occurs.
N     * |        |          |Note: It is cleared by software writes 1 to this bit
N     * |[3]     |RXSTIF    |Receive Start Interrupt Flag
N     * |        |          |0 = Receive start event does not occur.
N     * |        |          |1 = Receive start event occurs.
N     * |        |          |Note: It is cleared by software writes 1 to this bit
N     * |[4]     |RXENDIF   |Receive End Interrupt Flag
N     * |        |          |0 = Receive end event does not occur.
N     * |        |          |1 = Receive end event occurs.
N     * |        |          |Note: It is cleared by software writes 1 to this bit
N     * |[5]     |SLVTOIF   |Slave Time-out Interrupt Flag (for Slave Only)
N     * |        |          |0 = Slave time-out event does not occur.
N     * |        |          |1 = Slave time-out event occurs.
N     * |        |          |Note: It is cleared by software writes 1 to this bit
N     * |[6]     |SLVBEIF   |Slave Bit Count Error Interrupt Flag (for Slave Only)
N     * |        |          |0 = Slave bit count error event does not occur.
N     * |        |          |1 = Slave bit count error event occurs.
N     * |        |          |Note: It is cleared by software writes 1 to this bit.
N     * |[8]     |SSINAIF   |Slave Select Inactive Interrupt Flag (for Slave Only)
N     * |        |          |This bit indicates that the internal slave select signal has changed to inactive
N     * |        |          |It is cleared by software writes 1 to this bit
N     * |        |          |0 = The slave select signal has not changed to inactive.
N     * |        |          |1 = The slave select signal has changed to inactive.
N     * |        |          |Note: The internal slave select signal is active high.
N     * |[9]     |SSACTIF   |Slave Select Active Interrupt Flag (for Slave Only)
N     * |        |          |This bit indicates that the internal slave select signal has changed to active
N     * |        |          |It is cleared by software writes one to this bit
N     * |        |          |0 = The slave select signal has not changed to active.
N     * |        |          |1 = The slave select signal has changed to active.
N     * |        |          |Note: The internal slave select signal is active high.
N     * |[16]    |SSLINE    |Slave Select Line Bus Status (Read Only)
N     * |        |          |This bit is only available in Slave mode
N     * |        |          |It used to monitor the current status of the input slave select signal on the bus.
N     * |        |          |0 = The slave select line status is 0.
N     * |        |          |1 = The slave select line status is 1.
N     * |[17]    |BUSY      |Busy Status (Read Only)
N     * |        |          |0 = SPI is in idle state.
N     * |        |          |1 = SPI is in busy state.
N     * |        |          |The following listing are the bus busy conditions:
N     * |        |          |a. USPI_PROTCTL[31] = 1 and the TXEMPTY = 0.
N     * |        |          |b. For SPI Master mode, the TXEMPTY = 1 but the current transaction is not finished yet.
N     * |        |          |c
N     * |        |          |For SPI Slave mode, the USPI_PROTCTL[31] = 1 and there is serial clock input into the SPI core logic when slave select is active.
N     * |        |          |d
N     * |        |          |For SPI Slave mode, the USPI_PROTCTL[31] = 1 and the transmit buffer or transmit shift register is not empty even if the slave select is inactive.
N     * |[18]    |SLVUDR    |Slave Mode Transmit Under-run Status (Read Only)
N     * |        |          |In Slave mode, if there is no available transmit data in buffer while transmit data shift out caused by input serial bus clock, this status flag will be set to 1
N     * |        |          |This bit indicates whether the current shift-out data of word transmission is switched to TXUDRPOL (USPI_PROTCTL[28]) or not.
N     * |        |          |0 = Slave transmit under-run event does not occur.
N     * |        |          |1 = Slave transmit under-run event occurs.
N     */
N    __IO uint32_t CTL;                   /*!< [0x0000] USCI Control Register                                            */
X    volatile uint32_t CTL;                    
N    __IO uint32_t INTEN;                 /*!< [0x0004] USCI Interrupt Enable Register                                   */
X    volatile uint32_t INTEN;                  
N    __IO uint32_t BRGEN;                 /*!< [0x0008] USCI Baud Rate Generator Register                                */
X    volatile uint32_t BRGEN;                  
N    __I  uint32_t RESERVE0[1];
X    volatile const  uint32_t RESERVE0[1];
N    __IO uint32_t DATIN0;                /*!< [0x0010] USCI Input Data Signal Configuration Register 0                  */
X    volatile uint32_t DATIN0;                 
N    __I  uint32_t RESERVE1[3];
X    volatile const  uint32_t RESERVE1[3];
N    __IO uint32_t CTLIN0;                /*!< [0x0020] USCI Input Control Signal Configuration Register 0               */
X    volatile uint32_t CTLIN0;                 
N    __I  uint32_t RESERVE2[1];
X    volatile const  uint32_t RESERVE2[1];
N    __IO uint32_t CLKIN;                 /*!< [0x0028] USCI Input Clock Signal Configuration Register                   */
X    volatile uint32_t CLKIN;                  
N    __IO uint32_t LINECTL;               /*!< [0x002c] USCI Line Control Register                                       */
X    volatile uint32_t LINECTL;                
N    __O  uint32_t TXDAT;                 /*!< [0x0030] USCI Transmit Data Register                                      */
X    volatile  uint32_t TXDAT;                  
N    __I  uint32_t RXDAT;                 /*!< [0x0034] USCI Receive Data Register                                       */
X    volatile const  uint32_t RXDAT;                  
N    __IO uint32_t BUFCTL;                /*!< [0x0038] USCI Transmit/Receive Buffer Control Register                    */
X    volatile uint32_t BUFCTL;                 
N    __IO uint32_t BUFSTS;                /*!< [0x003c] USCI Transmit/Receive Buffer Status Register                     */
X    volatile uint32_t BUFSTS;                 
N    __I  uint32_t RESERVE3[5];
X    volatile const  uint32_t RESERVE3[5];
N    __IO uint32_t WKCTL;                 /*!< [0x0054] USCI Wake-up Control Register                                    */
X    volatile uint32_t WKCTL;                  
N    __IO uint32_t WKSTS;                 /*!< [0x0058] USCI Wake-up Status Register                                     */
X    volatile uint32_t WKSTS;                  
N    __IO uint32_t PROTCTL;               /*!< [0x005c] USCI Protocol Control Register                                   */
X    volatile uint32_t PROTCTL;                
N    __IO uint32_t PROTIEN;               /*!< [0x0060] USCI Protocol Interrupt Enable Register                          */
X    volatile uint32_t PROTIEN;                
N    __IO uint32_t PROTSTS;               /*!< [0x0064] USCI Protocol Status Register                                    */
X    volatile uint32_t PROTSTS;                
N
N} USPI_T;
N
N/**
N    @addtogroup USPI_CONST USPI Bit Field Definition
N    Constant Definitions for USPI Controller
N@{ */
N
N#define USPI_CTL_FUNMODE_Pos             (0)                                               /*!< USPI_T::CTL: FUNMODE Position          */
N#define USPI_CTL_FUNMODE_Msk             (0x7ul << USPI_CTL_FUNMODE_Pos)                   /*!< USPI_T::CTL: FUNMODE Mask              */
N
N#define USPI_INTEN_TXSTIEN_Pos           (1)                                               /*!< USPI_T::INTEN: TXSTIEN Position        */
N#define USPI_INTEN_TXSTIEN_Msk           (0x1ul << USPI_INTEN_TXSTIEN_Pos)                 /*!< USPI_T::INTEN: TXSTIEN Mask            */
N
N#define USPI_INTEN_TXENDIEN_Pos          (2)                                               /*!< USPI_T::INTEN: TXENDIEN Position       */
N#define USPI_INTEN_TXENDIEN_Msk          (0x1ul << USPI_INTEN_TXENDIEN_Pos)                /*!< USPI_T::INTEN: TXENDIEN Mask           */
N
N#define USPI_INTEN_RXSTIEN_Pos           (3)                                               /*!< USPI_T::INTEN: RXSTIEN Position        */
N#define USPI_INTEN_RXSTIEN_Msk           (0x1ul << USPI_INTEN_RXSTIEN_Pos)                 /*!< USPI_T::INTEN: RXSTIEN Mask            */
N
N#define USPI_INTEN_RXENDIEN_Pos          (4)                                               /*!< USPI_T::INTEN: RXENDIEN Position       */
N#define USPI_INTEN_RXENDIEN_Msk          (0x1ul << USPI_INTEN_RXENDIEN_Pos)                /*!< USPI_T::INTEN: RXENDIEN Mask           */
N
N#define USPI_BRGEN_RCLKSEL_Pos           (0)                                               /*!< USPI_T::BRGEN: RCLKSEL Position        */
N#define USPI_BRGEN_RCLKSEL_Msk           (0x1ul << USPI_BRGEN_RCLKSEL_Pos)                 /*!< USPI_T::BRGEN: RCLKSEL Mask            */
N
N#define USPI_BRGEN_PTCLKSEL_Pos          (1)                                               /*!< USPI_T::BRGEN: PTCLKSEL Position       */
N#define USPI_BRGEN_PTCLKSEL_Msk          (0x1ul << USPI_BRGEN_PTCLKSEL_Pos)                /*!< USPI_T::BRGEN: PTCLKSEL Mask           */
N
N#define USPI_BRGEN_SPCLKSEL_Pos          (2)                                               /*!< USPI_T::BRGEN: SPCLKSEL Position       */
N#define USPI_BRGEN_SPCLKSEL_Msk          (0x3ul << USPI_BRGEN_SPCLKSEL_Pos)                /*!< USPI_T::BRGEN: SPCLKSEL Mask           */
N
N#define USPI_BRGEN_TMCNTEN_Pos           (4)                                               /*!< USPI_T::BRGEN: TMCNTEN Position        */
N#define USPI_BRGEN_TMCNTEN_Msk           (0x1ul << USPI_BRGEN_TMCNTEN_Pos)                 /*!< USPI_T::BRGEN: TMCNTEN Mask            */
N
N#define USPI_BRGEN_TMCNTSRC_Pos          (5)                                               /*!< USPI_T::BRGEN: TMCNTSRC Position       */
N#define USPI_BRGEN_TMCNTSRC_Msk          (0x1ul << USPI_BRGEN_TMCNTSRC_Pos)                /*!< USPI_T::BRGEN: TMCNTSRC Mask           */
N
N#define USPI_BRGEN_CLKDIV_Pos            (16)                                              /*!< USPI_T::BRGEN: CLKDIV Position         */
N#define USPI_BRGEN_CLKDIV_Msk            (0x3fful << USPI_BRGEN_CLKDIV_Pos)                /*!< USPI_T::BRGEN: CLKDIV Mask             */
N
N#define USPI_DATIN0_SYNCSEL_Pos          (0)                                               /*!< USPI_T::DATIN0: SYNCSEL Position       */
N#define USPI_DATIN0_SYNCSEL_Msk          (0x1ul << USPI_DATIN0_SYNCSEL_Pos)                /*!< USPI_T::DATIN0: SYNCSEL Mask           */
N
N#define USPI_DATIN0_ININV_Pos            (2)                                               /*!< USPI_T::DATIN0: ININV Position         */
N#define USPI_DATIN0_ININV_Msk            (0x1ul << USPI_DATIN0_ININV_Pos)                  /*!< USPI_T::DATIN0: ININV Mask             */
N
N#define USPI_CTLIN0_SYNCSEL_Pos          (0)                                               /*!< USPI_T::CTLIN0: SYNCSEL Position       */
N#define USPI_CTLIN0_SYNCSEL_Msk          (0x1ul << USPI_CTLIN0_SYNCSEL_Pos)                /*!< USPI_T::CTLIN0: SYNCSEL Mask           */
N
N#define USPI_CTLIN0_ININV_Pos            (2)                                               /*!< USPI_T::CTLIN0: ININV Position         */
N#define USPI_CTLIN0_ININV_Msk            (0x1ul << USPI_CTLIN0_ININV_Pos)                  /*!< USPI_T::CTLIN0: ININV Mask             */
N
N#define USPI_CLKIN_SYNCSEL_Pos           (0)                                               /*!< USPI_T::CLKIN: SYNCSEL Position        */
N#define USPI_CLKIN_SYNCSEL_Msk           (0x1ul << USPI_CLKIN_SYNCSEL_Pos)                 /*!< USPI_T::CLKIN: SYNCSEL Mask            */
N
N#define USPI_LINECTL_LSB_Pos             (0)                                               /*!< USPI_T::LINECTL: LSB Position          */
N#define USPI_LINECTL_LSB_Msk             (0x1ul << USPI_LINECTL_LSB_Pos)                   /*!< USPI_T::LINECTL: LSB Mask              */
N
N#define USPI_LINECTL_DATOINV_Pos         (5)                                               /*!< USPI_T::LINECTL: DATOINV Position      */
N#define USPI_LINECTL_DATOINV_Msk         (0x1ul << USPI_LINECTL_DATOINV_Pos)               /*!< USPI_T::LINECTL: DATOINV Mask          */
N
N#define USPI_LINECTL_CTLOINV_Pos         (7)                                               /*!< USPI_T::LINECTL: CTLOINV Position      */
N#define USPI_LINECTL_CTLOINV_Msk         (0x1ul << USPI_LINECTL_CTLOINV_Pos)               /*!< USPI_T::LINECTL: CTLOINV Mask          */
N
N#define USPI_LINECTL_DWIDTH_Pos          (8)                                               /*!< USPI_T::LINECTL: DWIDTH Position       */
N#define USPI_LINECTL_DWIDTH_Msk          (0xful << USPI_LINECTL_DWIDTH_Pos)                /*!< USPI_T::LINECTL: DWIDTH Mask           */
N
N#define USPI_TXDAT_TXDAT_Pos             (0)                                               /*!< USPI_T::TXDAT: TXDAT Position          */
N#define USPI_TXDAT_TXDAT_Msk             (0xfffful << USPI_TXDAT_TXDAT_Pos)                /*!< USPI_T::TXDAT: TXDAT Mask              */
N
N#define USPI_TXDAT_PORTDIR_Pos           (16)                                              /*!< USPI_T::TXDAT: PORTDIR Position        */
N#define USPI_TXDAT_PORTDIR_Msk           (0x1ul << USPI_TXDAT_PORTDIR_Pos)                 /*!< USPI_T::TXDAT: PORTDIR Mask            */
N
N#define USPI_RXDAT_RXDAT_Pos             (0)                                               /*!< USPI_T::RXDAT: RXDAT Position          */
N#define USPI_RXDAT_RXDAT_Msk             (0xfffful << USPI_RXDAT_RXDAT_Pos)                /*!< USPI_T::RXDAT: RXDAT Mask              */
N
N#define USPI_BUFCTL_TXUDRIEN_Pos         (6)                                               /*!< USPI_T::BUFCTL: TXUDRIEN Position      */
N#define USPI_BUFCTL_TXUDRIEN_Msk         (0x1ul << USPI_BUFCTL_TXUDRIEN_Pos)               /*!< USPI_T::BUFCTL: TXUDRIEN Mask          */
N
N#define USPI_BUFCTL_TXCLR_Pos            (7)                                               /*!< USPI_T::BUFCTL: TXCLR Position         */
N#define USPI_BUFCTL_TXCLR_Msk            (0x1ul << USPI_BUFCTL_TXCLR_Pos)                  /*!< USPI_T::BUFCTL: TXCLR Mask             */
N
N#define USPI_BUFCTL_RXOVIEN_Pos          (14)                                              /*!< USPI_T::BUFCTL: RXOVIEN Position       */
N#define USPI_BUFCTL_RXOVIEN_Msk          (0x1ul << USPI_BUFCTL_RXOVIEN_Pos)                /*!< USPI_T::BUFCTL: RXOVIEN Mask           */
N
N#define USPI_BUFCTL_RXCLR_Pos            (15)                                              /*!< USPI_T::BUFCTL: RXCLR Position         */
N#define USPI_BUFCTL_RXCLR_Msk            (0x1ul << USPI_BUFCTL_RXCLR_Pos)                  /*!< USPI_T::BUFCTL: RXCLR Mask             */
N
N#define USPI_BUFCTL_TXRST_Pos            (16)                                              /*!< USPI_T::BUFCTL: TXRST Position         */
N#define USPI_BUFCTL_TXRST_Msk            (0x1ul << USPI_BUFCTL_TXRST_Pos)                  /*!< USPI_T::BUFCTL: TXRST Mask             */
N
N#define USPI_BUFCTL_RXRST_Pos            (17)                                              /*!< USPI_T::BUFCTL: RXRST Position         */
N#define USPI_BUFCTL_RXRST_Msk            (0x1ul << USPI_BUFCTL_RXRST_Pos)                  /*!< USPI_T::BUFCTL: RXRST Mask             */
N
N#define USPI_BUFSTS_RXEMPTY_Pos          (0)                                               /*!< USPI_T::BUFSTS: RXEMPTY Position       */
N#define USPI_BUFSTS_RXEMPTY_Msk          (0x1ul << USPI_BUFSTS_RXEMPTY_Pos)                /*!< USPI_T::BUFSTS: RXEMPTY Mask           */
N
N#define USPI_BUFSTS_RXFULL_Pos           (1)                                               /*!< USPI_T::BUFSTS: RXFULL Position        */
N#define USPI_BUFSTS_RXFULL_Msk           (0x1ul << USPI_BUFSTS_RXFULL_Pos)                 /*!< USPI_T::BUFSTS: RXFULL Mask            */
N
N#define USPI_BUFSTS_RXOVIF_Pos           (3)                                               /*!< USPI_T::BUFSTS: RXOVIF Position        */
N#define USPI_BUFSTS_RXOVIF_Msk           (0x1ul << USPI_BUFSTS_RXOVIF_Pos)                 /*!< USPI_T::BUFSTS: RXOVIF Mask            */
N
N#define USPI_BUFSTS_TXEMPTY_Pos          (8)                                               /*!< USPI_T::BUFSTS: TXEMPTY Position       */
N#define USPI_BUFSTS_TXEMPTY_Msk          (0x1ul << USPI_BUFSTS_TXEMPTY_Pos)                /*!< USPI_T::BUFSTS: TXEMPTY Mask           */
N
N#define USPI_BUFSTS_TXFULL_Pos           (9)                                               /*!< USPI_T::BUFSTS: TXFULL Position        */
N#define USPI_BUFSTS_TXFULL_Msk           (0x1ul << USPI_BUFSTS_TXFULL_Pos)                 /*!< USPI_T::BUFSTS: TXFULL Mask            */
N
N#define USPI_BUFSTS_TXUDRIF_Pos          (11)                                              /*!< USPI_T::BUFSTS: TXUDRIF Position       */
N#define USPI_BUFSTS_TXUDRIF_Msk          (0x1ul << USPI_BUFSTS_TXUDRIF_Pos)                /*!< USPI_T::BUFSTS: TXUDRIF Mask           */
N
N#define USPI_WKCTL_WKEN_Pos              (0)                                               /*!< USPI_T::WKCTL: WKEN Position           */
N#define USPI_WKCTL_WKEN_Msk              (0x1ul << USPI_WKCTL_WKEN_Pos)                    /*!< USPI_T::WKCTL: WKEN Mask               */
N
N#define USPI_WKCTL_WKADDREN_Pos          (1)                                               /*!< USPI_T::WKCTL: WKADDREN Position       */
N#define USPI_WKCTL_WKADDREN_Msk          (0x1ul << USPI_WKCTL_WKADDREN_Pos)                /*!< USPI_T::WKCTL: WKADDREN Mask           */
N
N#define USPI_WKCTL_PDBOPT_Pos            (2)                                               /*!< USPI_T::WKCTL: PDBOPT Position         */
N#define USPI_WKCTL_PDBOPT_Msk            (0x1ul << USPI_WKCTL_PDBOPT_Pos)                  /*!< USPI_T::WKCTL: PDBOPT Mask             */
N
N#define USPI_WKSTS_WKF_Pos               (0)                                               /*!< USPI_T::WKSTS: WKF Position            */
N#define USPI_WKSTS_WKF_Msk               (0x1ul << USPI_WKSTS_WKF_Pos)                     /*!< USPI_T::WKSTS: WKF Mask                */
N
N#define USPI_PROTCTL_SLAVE_Pos           (0)                                               /*!< USPI_T::PROTCTL: SLAVE Position        */
N#define USPI_PROTCTL_SLAVE_Msk           (0x1ul << USPI_PROTCTL_SLAVE_Pos)                 /*!< USPI_T::PROTCTL: SLAVE Mask            */
N
N#define USPI_PROTCTL_SLV3WIRE_Pos        (1)                                               /*!< USPI_T::PROTCTL: SLV3WIRE Position     */
N#define USPI_PROTCTL_SLV3WIRE_Msk        (0x1ul << USPI_PROTCTL_SLV3WIRE_Pos)              /*!< USPI_T::PROTCTL: SLV3WIRE Mask         */
N
N#define USPI_PROTCTL_SS_Pos              (2)                                               /*!< USPI_T::PROTCTL: SS Position           */
N#define USPI_PROTCTL_SS_Msk              (0x1ul << USPI_PROTCTL_SS_Pos)                    /*!< USPI_T::PROTCTL: SS Mask               */
N
N#define USPI_PROTCTL_AUTOSS_Pos          (3)                                               /*!< USPI_T::PROTCTL: AUTOSS Position       */
N#define USPI_PROTCTL_AUTOSS_Msk          (0x1ul << USPI_PROTCTL_AUTOSS_Pos)                /*!< USPI_T::PROTCTL: AUTOSS Mask           */
N
N#define USPI_PROTCTL_SCLKMODE_Pos        (6)                                               /*!< USPI_T::PROTCTL: SCLKMODE Position     */
N#define USPI_PROTCTL_SCLKMODE_Msk        (0x3ul << USPI_PROTCTL_SCLKMODE_Pos)              /*!< USPI_T::PROTCTL: SCLKMODE Mask         */
N
N#define USPI_PROTCTL_SUSPITV_Pos         (8)                                               /*!< USPI_T::PROTCTL: SUSPITV Position      */
N#define USPI_PROTCTL_SUSPITV_Msk         (0xful << USPI_PROTCTL_SUSPITV_Pos)               /*!< USPI_T::PROTCTL: SUSPITV Mask          */
N
N#define USPI_PROTCTL_TSMSEL_Pos          (12)                                              /*!< USPI_T::PROTCTL: TSMSEL Position       */
N#define USPI_PROTCTL_TSMSEL_Msk          (0x7ul << USPI_PROTCTL_TSMSEL_Pos)                /*!< USPI_T::PROTCTL: TSMSEL Mask           */
N
N#define USPI_PROTCTL_SLVTOCNT_Pos        (16)                                              /*!< USPI_T::PROTCTL: SLVTOCNT Position     */
N#define USPI_PROTCTL_SLVTOCNT_Msk        (0x3fful << USPI_PROTCTL_SLVTOCNT_Pos)            /*!< USPI_T::PROTCTL: SLVTOCNT Mask         */
N
N#define USPI_PROTCTL_TXUDRPOL_Pos        (28)                                              /*!< USPI_T::PROTCTL: TXUDRPOL Position     */
N#define USPI_PROTCTL_TXUDRPOL_Msk        (0x1ul << USPI_PROTCTL_TXUDRPOL_Pos)              /*!< USPI_T::PROTCTL: TXUDRPOL Mask         */
N
N#define USPI_PROTCTL_PROTEN_Pos          (31)                                              /*!< USPI_T::PROTCTL: PROTEN Position       */
N#define USPI_PROTCTL_PROTEN_Msk          (0x1ul << USPI_PROTCTL_PROTEN_Pos)                /*!< USPI_T::PROTCTL: PROTEN Mask           */
N
N#define USPI_PROTIEN_SSINAIEN_Pos        (0)                                               /*!< USPI_T::PROTIEN: SSINAIEN Position     */
N#define USPI_PROTIEN_SSINAIEN_Msk        (0x1ul << USPI_PROTIEN_SSINAIEN_Pos)              /*!< USPI_T::PROTIEN: SSINAIEN Mask         */
N
N#define USPI_PROTIEN_SSACTIEN_Pos        (1)                                               /*!< USPI_T::PROTIEN: SSACTIEN Position     */
N#define USPI_PROTIEN_SSACTIEN_Msk        (0x1ul << USPI_PROTIEN_SSACTIEN_Pos)              /*!< USPI_T::PROTIEN: SSACTIEN Mask         */
N
N#define USPI_PROTIEN_SLVTOIEN_Pos        (2)                                               /*!< USPI_T::PROTIEN: SLVTOIEN Position     */
N#define USPI_PROTIEN_SLVTOIEN_Msk        (0x1ul << USPI_PROTIEN_SLVTOIEN_Pos)              /*!< USPI_T::PROTIEN: SLVTOIEN Mask         */
N
N#define USPI_PROTIEN_SLVBEIEN_Pos        (3)                                               /*!< USPI_T::PROTIEN: SLVBEIEN Position     */
N#define USPI_PROTIEN_SLVBEIEN_Msk        (0x1ul << USPI_PROTIEN_SLVBEIEN_Pos)              /*!< USPI_T::PROTIEN: SLVBEIEN Mask         */
N
N#define USPI_PROTSTS_TXSTIF_Pos          (1)                                               /*!< USPI_T::PROTSTS: TXSTIF Position       */
N#define USPI_PROTSTS_TXSTIF_Msk          (0x1ul << USPI_PROTSTS_TXSTIF_Pos)                /*!< USPI_T::PROTSTS: TXSTIF Mask           */
N
N#define USPI_PROTSTS_TXENDIF_Pos         (2)                                               /*!< USPI_T::PROTSTS: TXENDIF Position      */
N#define USPI_PROTSTS_TXENDIF_Msk         (0x1ul << USPI_PROTSTS_TXENDIF_Pos)               /*!< USPI_T::PROTSTS: TXENDIF Mask          */
N
N#define USPI_PROTSTS_RXSTIF_Pos          (3)                                               /*!< USPI_T::PROTSTS: RXSTIF Position       */
N#define USPI_PROTSTS_RXSTIF_Msk          (0x1ul << USPI_PROTSTS_RXSTIF_Pos)                /*!< USPI_T::PROTSTS: RXSTIF Mask           */
N
N#define USPI_PROTSTS_RXENDIF_Pos         (4)                                               /*!< USPI_T::PROTSTS: RXENDIF Position      */
N#define USPI_PROTSTS_RXENDIF_Msk         (0x1ul << USPI_PROTSTS_RXENDIF_Pos)               /*!< USPI_T::PROTSTS: RXENDIF Mask          */
N
N#define USPI_PROTSTS_SLVTOIF_Pos         (5)                                               /*!< USPI_T::PROTSTS: SLVTOIF Position      */
N#define USPI_PROTSTS_SLVTOIF_Msk         (0x1ul << USPI_PROTSTS_SLVTOIF_Pos)               /*!< USPI_T::PROTSTS: SLVTOIF Mask          */
N
N#define USPI_PROTSTS_SLVBEIF_Pos         (6)                                               /*!< USPI_T::PROTSTS: SLVBEIF Position      */
N#define USPI_PROTSTS_SLVBEIF_Msk         (0x1ul << USPI_PROTSTS_SLVBEIF_Pos)               /*!< USPI_T::PROTSTS: SLVBEIF Mask          */
N
N#define USPI_PROTSTS_SSINAIF_Pos         (8)                                               /*!< USPI_T::PROTSTS: SSINAIF Position      */
N#define USPI_PROTSTS_SSINAIF_Msk         (0x1ul << USPI_PROTSTS_SSINAIF_Pos)               /*!< USPI_T::PROTSTS: SSINAIF Mask          */
N
N#define USPI_PROTSTS_SSACTIF_Pos         (9)                                               /*!< USPI_T::PROTSTS: SSACTIF Position      */
N#define USPI_PROTSTS_SSACTIF_Msk         (0x1ul << USPI_PROTSTS_SSACTIF_Pos)               /*!< USPI_T::PROTSTS: SSACTIF Mask          */
N
N#define USPI_PROTSTS_SSLINE_Pos          (16)                                              /*!< USPI_T::PROTSTS: SSLINE Position       */
N#define USPI_PROTSTS_SSLINE_Msk          (0x1ul << USPI_PROTSTS_SSLINE_Pos)                /*!< USPI_T::PROTSTS: SSLINE Mask           */
N
N#define USPI_PROTSTS_BUSY_Pos            (17)                                              /*!< USPI_T::PROTSTS: BUSY Position         */
N#define USPI_PROTSTS_BUSY_Msk            (0x1ul << USPI_PROTSTS_BUSY_Pos)                  /*!< USPI_T::PROTSTS: BUSY Mask             */
N
N#define USPI_PROTSTS_SLVUDR_Pos          (18)                                              /*!< USPI_T::PROTSTS: SLVUDR Position       */
N#define USPI_PROTSTS_SLVUDR_Msk          (0x1ul << USPI_PROTSTS_SLVUDR_Pos)                /*!< USPI_T::PROTSTS: SLVUDR Mask           */
N
N/**@}*/ /* USPI_CONST */
N/**@}*/ /* end of USPI register group */
N
N
N/*---------------------- UART Mode of USCI Controller -------------------------*/
N/**
N    @addtogroup UUART UART Mode of USCI Controller(UUART)
N    Memory Mapped Structure for UUART Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var UUART_T::CTL
N     * Offset: 0x00  USCI Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |FUNMODE   |Function Mode
N     * |        |          |This bit field selects the protocol for this USCI controller.
N     * |        |          |Selecting a protocol that is not available or a reserved combination disables the USCI.
N     * |        |          |When switching between two protocols, the USCI has to be disabled before selecting a new protocol.
N     * |        |          |Simultaneously, the USCI will be reset when user write 000 to FUNMODE.
N     * |        |          |000 = The USCI is disabled. All protocol related state machines are set to idle state.
N     * |        |          |001 = The SPI protocol is selected.
N     * |        |          |010 = The UART protocol is selected.
N     * |        |          |100 = The I2C protocol is selected.
N     * |        |          |Note: Other bit combinations are reserved.
N     * @var UUART_T::INTEN
N     * Offset: 0x04  USCI Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |TXSTIEN   |Transmit Start Interrupt Enable Bit
N     * |        |          |This bit enables the interrupt generation in case of a transmit start event.
N     * |        |          |0 = The transmit start interrupt is disabled.
N     * |        |          |1 = The transmit start interrupt is enabled.
N     * |[2]     |TXENDIEN  |Transmit End Interrupt Enable Bit
N     * |        |          |This bit enables the interrupt generation in case of a transmit finish event.
N     * |        |          |0 = The transmit finish interrupt is disabled.
N     * |        |          |1 = The transmit finish interrupt is enabled.
N     * |[3]     |RXSTIEN   |Receive Start Interrupt Enable Bit
N     * |        |          |This bit enables the interrupt generation in case of a receive start event.
N     * |        |          |0 = The receive start interrupt is disabled.
N     * |        |          |1 = The receive start interrupt is enabled.
N     * |[4]     |RXENDIEN  |Receive End Interrupt Enable Bit
N     * |        |          |This bit enables the interrupt generation in case of a receive finish event.
N     * |        |          |0 = The receive end interrupt is disabled.
N     * |        |          |1 = The receive end interrupt is enabled.
N     * @var UUART_T::BRGEN
N     * Offset: 0x08  USCI Baud Rate Generator Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RCLKSEL   |Reference Clock Source Selection
N     * |        |          |This bit selects the source signal of reference clock (fREF_CLK).
N     * |        |          |0 = Peripheral device clock fPCLK.
N     * |        |          |1 = Reserved.
N     * |[1]     |PTCLKSEL  |Protocol Clock Source Selection
N     * |        |          |This bit selects the source signal of protocol clock (fPROT_CLK).
N     * |        |          |0 = Reference clock fREF_CLK.
N     * |        |          |1 = fREF_CLK2 (its frequency is half of fREF_CLK).
N     * |[3:2]   |SPCLKSEL  |Sample Clock Source Selection
N     * |        |          |This bit field used for the clock source selection of a sample clock (fSAMP_CLK) for the protocol processor.
N     * |        |          |00 = fSAMP_CLK = fDIV_CLK.
N     * |        |          |01 = fSAMP_CLK = fPROT_CLK.
N     * |        |          |10 = fSAMP_CLK = fSCLK.
N     * |        |          |11 = fSAMP_CLK = fREF_CLK.
N     * |[4]     |TMCNTEN   |Timing Measurement Counter Enable Bit
N     * |        |          |This bit enables the 10-bit timing measurement counter.
N     * |        |          |0 = Timing measurement counter is Disabled.
N     * |        |          |1 = Timing measurement counter is Enabled.
N     * |[5]     |TMCNTSRC  |Timing Measurement Counter Clock Source Selection
N     * |        |          |0 = Timing measurement counter with fPROT_CLK.
N     * |        |          |1 = Timing measurement counter with fDIV_CLK.
N     * |[9:8]   |PDSCNT    |Pre-divider for Sample Counter
N     * |        |          |This bit field defines the divide ratio of the clock division from sample clock fSAMP_CLK.
N     * |        |          |The divided frequency fPDS_CNT = fSAMP_CLK / (PDSCNT+1).
N     * |[14:10] |DSCNT     |Denominator for Sample Counter
N     * |        |          |This bit field defines the divide ratio of the sample clock fSAMP_CLK.
N     * |        |          |The divided frequency fDS_CNT = fPDS_CNT / (DSCNT+1).
N     * |        |          |Note: The maximum value of DSCNT is 0xF on UART mode and suggest to set over 4 to confirm the receiver data is sampled in right value
N     * |[25:16] |CLKDIV    |Clock Divider
N     * |        |          |This bit field defines the ratio between the protocol clock frequency fPROT_CLK and the clock divider frequency fDIV_CLK (fDIV_CLK = fPROT_CLK / (CLKDIV+1) ).
N     * |        |          |Note: In UART function, it can be updated by hardware in the 4th falling edge of the input data 0x55 when the auto baud rate function (ABREN(UUART_PROTCTL[6])) is enabled.
N     * |        |          |The revised value is the average bit time between bit 5 and bit 6.
N     * |        |          |The user can use revised CLKDIV and new BRDETITV (UUART_PROTCTL[24:16]) to calculate the precise baud rate.
N     * @var UUART_T::DATIN0
N     * Offset: 0x10  USCI Input Data Signal Configuration Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SYNCSEL   |Input Signal Synchronization Selection
N     * |        |          |This bit selects if the un-synchronized input signal (with optionally inverted) or the synchronized (and optionally filtered) signal can be used as input for the data shift unit.
N     * |        |          |0 = The un-synchronized signal can be taken as input for the data shift unit.
N     * |        |          |1 = The synchronized signal can be taken as input for the data shift unit.
N     * |[2]     |ININV     |Input Signal Inverse Selection
N     * |        |          |This bit defines the inverter enable of the input asynchronous signal.
N     * |        |          |0 = The un-synchronized input signal will not be inverted.
N     * |        |          |1 = The un-synchronized input signal will be inverted.
N     * |[4:3]   |EDGEDET   |Input Signal Edge Detection Mode
N     * |        |          |This bit field selects which edge actives the trigger event of input data signal.
N     * |        |          |00 = The trigger event activation is disabled.
N     * |        |          |01 = A rising edge activates the trigger event of input data signal.
N     * |        |          |10 = A falling edge activates the trigger event of input data signal.
N     * |        |          |11 = Both edges activate the trigger event of input data signal.
N     * |        |          |Note: In UART function mode, it is suggested to set this bit field as 10.
N     * @var UUART_T::CTLIN0
N     * Offset: 0x20  USCI Input Control Signal Configuration Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SYNCSEL   |Input Synchronization Signal Selection
N     * |        |          |This bit selects if the un-synchronized input signal (with optionally inverted) or the synchronized (and optionally filtered) signal can be used as input for the data shift unit.
N     * |        |          |0 = The un-synchronized signal can be taken as input for the data shift unit.
N     * |        |          |1 = The synchronized signal can be taken as input for the data shift unit.
N     * |[2]     |ININV     |Input Signal Inverse Selection
N     * |        |          |This bit defines the inverter enable of the input asynchronous signal.
N     * |        |          |0 = The un-synchronized input signal will not be inverted.
N     * |        |          |1 = The un-synchronized input signal will be inverted.
N     * @var UUART_T::CLKIN
N     * Offset: 0x28  USCI Input Clock Signal Configuration Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SYNCSEL   |Input Synchronization Signal Selection
N     * |        |          |This bit selects if the un-synchronized input signal or the synchronized (and optionally filtered) signal can be used as input for the data shift unit.
N     * |        |          |0 = The un-synchronized signal can be taken as input for the data shift unit.
N     * |        |          |1 = The synchronized signal can be taken as input for the data shift unit.
N     * @var UUART_T::LINECTL
N     * Offset: 0x2C  USCI Line Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |LSB       |LSB First Transmission Selection
N     * |        |          |0 = The MSB, which bit of transmit/receive data buffer depends on the setting of DWIDTH, is transmitted/received first.
N     * |        |          |1 = The LSB, the bit 0 of data buffer, will be transmitted/received first.
N     * |[5]     |DATOINV   |Data Output Inverse Selection
N     * |        |          |This bit defines the relation between the internal shift data value and the output data signal of USCIx_DAT1 pin.
N     * |        |          |0 = The value of USCIx_DAT1 is equal to the data shift register.
N     * |        |          |1 = The value of USCIx_DAT1 is the inversion of data shift register.
N     * |[7]     |CTLOINV   |Control Signal Output Inverse Selection
N     * |        |          |This bit defines the relation between the internal control signal and the output control signal.
N     * |        |          |0 = No effect.
N     * |        |          |1 = The control signal will be inverted before its output.
N     * |        |          |Note: In UART protocol, the control signal means nRTS signal.
N     * |[11:8]  |DWIDTH    |Word Length of Transmission
N     * |        |          |This bit field defines the data word length (amount of bits) for reception and transmission.
N     * |        |          |The data word is always right-aligned in the data buffer.
N     * |        |          |USCI support word length from 4 to 16 bits.
N     * |        |          |0x0: The data word contains 16 bits located at bit positions [15:0].
N     * |        |          |0x1: Reserved.
N     * |        |          |0x2: Reserved.
N     * |        |          |0x3: Reserved.
N     * |        |          |0x4: The data word contains 4 bits located at bit positions [3:0].
N     * |        |          |0x5: The data word contains 5 bits located at bit positions [4:0].
N     * |        |          |...
N     * |        |          |0xF: The data word contains 15 bits located at bit positions [14:0].
N     * |        |          |Note: In UART protocol, the length can be configured as 6~13 bits.
N     * @var UUART_T::TXDAT
N     * Offset: 0x30  USCI Transmit Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |TXDAT     |Transmit Data
N     * |        |          |Software can use this bit field to write 16-bit transmit data for transmission.
N     * @var UUART_T::RXDAT
N     * Offset: 0x34  USCI Receive Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RXDAT     |Received Data
N     * |        |          |This bit field monitors the received data which stored in receive data buffer.
N     * |        |          |Note: RXDAT[15:13] indicate the same frame status of BREAK, FRMERR and PARITYERR (UUART_PROTSTS[7:5]).
N     * @var UUART_T::BUFCTL
N     * Offset: 0x38  USCI Transmit/Receive Buffer Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7]     |TXCLR     |Clear Transmit Buffer
N     * |        |          |0 = No effect.
N     * |        |          |1 = The transmit buffer is cleared (filling level is cleared and output pointer is set to input pointer value).
N     * |        |          |Should only be used while the buffer is not taking part in data traffic.
N     * |        |          |Note: It is cleared automatically after one PCLK cycle.
N     * |[14]    |RXOVIEN   |Receive Buffer Overrun Error Interrupt Enable Control
N     * |        |          |0 = Receive overrun interrupt Disabled.
N     * |        |          |1 = Receive overrun interrupt Enabled.
N     * |[15]    |RXCLR     |Clear Receive Buffer
N     * |        |          |0 = No effect.
N     * |        |          |1 = The receive buffer is cleared (filling level is cleared and output pointer is set to input pointer value).
N     * |        |          |Should only be used while the buffer is not taking part in data traffic.
N     * |        |          |Note: It is cleared automatically after one PCLK cycle.
N     * |[16]    |TXRST     |Transmit Reset
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the transmit-related counters, state machine, and the content of transmit shift register and data buffer.
N     * |        |          |Note: It is cleared automatically after one PCLK cycle.
N     * |[17]    |RXRST     |Receive Reset
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the receive-related counters, state machine, and the content of receive shift register and data buffer.
N     * |        |          |Note 1: It is cleared automatically after one PCLK cycle.
N     * |        |          |Note 2: It is suggest to check the RXBUSY (UUART_PROTSTS[10]) before this bit will be set to 1.
N     * @var UUART_T::BUFSTS
N     * Offset: 0x3C  USCI Transmit/Receive Buffer Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RXEMPTY   |Receive Buffer Empty Indicator
N     * |        |          |0 = Receive buffer is not empty.
N     * |        |          |1 = Receive buffer is empty.
N     * |[1]     |RXFULL    |Receive Buffer Full Indicator
N     * |        |          |0 = Receive buffer is not full.
N     * |        |          |1 = Receive buffer is full.
N     * |[3]     |RXOVIF    |Receive Buffer Over-run Error Interrupt Status
N     * |        |          |This bit indicates that a receive buffer overrun error event has been detected.
N     * |        |          |If RXOVIEN (UUART_BUFCTL[14]) is enabled, the corresponding interrupt request is activated.
N     * |        |          |It is cleared by software writes 1 to this bit.
N     * |        |          |0 = A receive buffer overrun error event has not been detected.
N     * |        |          |1 = A receive buffer overrun error event has been detected.
N     * |[8]     |TXEMPTY   |Transmit Buffer Empty Indicator
N     * |        |          |0 = Transmit buffer is not empty.
N     * |        |          |1 = Transmit buffer is empty.
N     * |[9]     |TXFULL    |Transmit Buffer Full Indicator
N     * |        |          |0 = Transmit buffer is not full.
N     * |        |          |1 = Transmit buffer is full.
N     * @var UUART_T::WKCTL
N     * Offset: 0x54  USCI Wake-up Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WKEN      |Wake-up Enable Bit
N     * |        |          |0 = Wake-up function Disabled.
N     * |        |          |1 = Wake-up function Enabled.
N     * |[2]     |PDBOPT    |Power Down Blocking Option
N     * |        |          |0 = If user attempts to enter Power-down mode by executing WFI while the protocol is in transferring, MCU will stop the transfer and enter Power-down mode immediately.
N     * |        |          |1 = If user attempts to enter Power-down mode by executing WFI while the protocol is in transferring, the on-going transfer will not be stopped and MCU will enter idle mode immediately.
N     * @var UUART_T::WKSTS
N     * Offset: 0x58  USCI Wake-up Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WKF       |Wake-up Flag
N     * |        |          |When chip is woken up from Power-down mode, this bit is set to 1.
N     * |        |          |Software can write 1 to clear this bit.
N     * @var UUART_T::PROTCTL
N     * Offset: 0x5C  USCI Protocol Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |STOPB     |Stop Bits
N     * |        |          |This bit defines the number of stop bits in an UART frame.
N     * |        |          |0 = The number of stop bits is 1.
N     * |        |          |1 = The number of stop bits is 2.
N     * |[1]     |PARITYEN  |Parity Enable Bit
N     * |        |          |This bit defines the parity bit is enabled in an UART frame.
N     * |        |          |0 = The parity bit Disabled.
N     * |        |          |1 = The parity bit Enabled.
N     * |[2]     |EVENPARITY|Even Parity Enable Bit
N     * |        |          |0 = Odd number of logic 1 is transmitted and checked in each word.
N     * |        |          |1 = Even number of logic 1 is transmitted and checked in each word.
N     * |        |          |Note: This bit has effect only when PARITYEN is set.
N     * |[3]     |RTSAUTOEN |nRTS Auto-flow Control Enable
N     * |        |          |When nRTS auto-flow is enabled, if the receiver buffer is full (RXFULL (UUART_BUFSTS[1] = 1)), the UART will de-assert nRTS signal.
N     * |        |          |0 = nRTS auto-flow control Disabled.
N     * |        |          |1 = nRTS auto-flow control Enabled.
N     * |        |          |Note: This bit has effect only when the RTSAUDIREN is not set.
N     * |[4]     |CTSAUTOEN |nCTS Auto-flow Control Enable Bit
N     * |        |          |When nCTS auto-flow is enabled, the UART will send data to external device when nCTS input assert (UART will not send data to device if nCTS input is dis-asserted).
N     * |        |          |0 = nCTS auto-flow control Disabled.
N     * |        |          |1 = nCTS auto-flow control Enabled.
N     * |[5]     |RTSAUDIREN|nRTS Auto Direction Enable Bit
N     * |        |          |When nRTS auto direction is enabled, if the transmitted bytes in the TX buffer is empty, the UART will reassert nRTS signal.
N     * |        |          |0 = nRTS auto direction control Disabled.
N     * |        |          |1 = nRTS auto direction control Enabled.
N     * |        |          |Note 1: This bit is used for nRTS auto direction control for RS485.
N     * |        |          |Note 2: This bit has effect only when the RTSAUTOEN is not set.
N     * |[6]     |ABREN     |Auto-baud Rate Detect Enable Bit
N     * |        |          |0 = Auto-baud rate detect function Disabled.
N     * |        |          |1 = Auto-baud rate detect function Enabled.
N     * |        |          |Note: When the auto-baud rate detect operation finishes, hardware will clear this bit.
N     * |        |          |The associated interrupt ABRDETIF (USCI_PROTST[9]) will be generated (If ARBIEN (UUART_PROTIEN [1]) is enabled).
N     * |[9]     |DATWKEN   |Data Wake-up Mode Enable Bit
N     * |        |          |0 = Data wake-up mode Disabled.
N     * |        |          |1 = Data wake-up mode Enabled.
N     * |[10]    |CTSWKEN   |nCTS Wake-up Mode Enable Bit
N     * |        |          |0 = nCTS wake-up mode Disabled.
N     * |        |          |1 = nCTS wake-up mode Enabled.
N     * |[14:11] |WAKECNT   |Wake-up Counter
N     * |        |          |These bits field indicate how many clock cycle selected by fPDS_CNT do the slave can get the 1st bit (start bit) when the device is wake-up from Power-down mode.
N     * |[24:16] |BRDETITV  |Baud Rate Detection Interval
N     * |        |          |This bit fields indicate how many clock cycle selected by TMCNTSRC (UUART_BRGEN [5]) does the slave calculates the baud rate in one bits.
N     * |        |          |The order of the bus shall be 1 and 0 step by step (e.g. the input data pattern shall be 0x55).
N     * |        |          |The user can read the value to know the current input baud rate of the bus whenever the ABRDETIF (UUART_PROTCTL[9]) is set.
N     * |        |          |Note: This bit can be cleared to 0 by software writing 1 to the BRDETITV.
N     * |[26]    |STICKEN   |Stick Parity Enable Bit
N     * |        |          |0 = Stick parity Disabled.
N     * |        |          |1 = Stick parity Enabled.
N     * |[29]    |BCEN      |Transmit Break Control Enable Bit
N     * |        |          |0 = Transmit Break Control Disabled.
N     * |        |          |1 = Transmit Break Control Enabled.
N     * |        |          |Note: When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0).
N     * |        |          |This bit acts only on TX line and has no effect on the transmitter logic.
N     * |[31]    |PROTEN    |UART Protocol Enable Bit
N     * |        |          |0 = UART Protocol Disabled.
N     * |        |          |1 = UART Protocol Enabled.
N     * @var UUART_T::PROTIEN
N     * Offset: 0x60  USCI Protocol Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |ABRIEN    |Auto-baud Rate Interrupt Enable Bit
N     * |        |          |0 = Auto-baud rate interrupt Disabled.
N     * |        |          |1 = Auto-baud rate interrupt Enabled.
N     * |[2]     |RLSIEN    |Receive Line Status Interrupt Enable Bit
N     * |        |          |0 = Receive line status interrupt Disabled.
N     * |        |          |1 = Receive line status interrupt Enabled.
N     * |        |          |Note: UUART_PROTSTS[7:5] indicates the current interrupt event for receive line status interrupt.
N     * @var UUART_T::PROTSTS
N     * Offset: 0x64  USCI Protocol Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |TXSTIF    |Transmit Start Interrupt Flag
N     * |        |          |0 = A transmit start interrupt status has not occurred.
N     * |        |          |1 = A transmit start interrupt status has occurred.
N     * |        |          |Note 1: It is cleared by software writing one into this bit.
N     * |        |          |Note 2: Used for user to load next transmit data when there is no data in transmit buffer.
N     * |[2]     |TXENDIF   |Transmit End Interrupt Flag
N     * |        |          |0 = A transmit end interrupt status has not occurred.
N     * |        |          |1 = A transmit end interrupt status has occurred.
N     * |        |          |Note: It is cleared by software writing one into this bit.
N     * |[3]     |RXSTIF    |Receive Start Interrupt Flag
N     * |        |          |0 = A receive start interrupt status has not occurred.
N     * |        |          |1 = A receive start interrupt status has occurred.
N     * |        |          |Note: It is cleared by software writing one into this bit.
N     * |[4]     |RXENDIF   |Receive End Interrupt Flag
N     * |        |          |0 = A receive finish interrupt status has not occurred.
N     * |        |          |1 = A receive finish interrupt status has occurred.
N     * |        |          |Note: It is cleared by software writing one into this bit.
N     * |[5]     |PARITYERR |Parity Error Flag
N     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid parity bit.
N     * |        |          |0 = No parity error is generated.
N     * |        |          |1 = Parity error is generated.
N     * |        |          |Note: This bit can be cleared by write 1 among the BREAK, FRMERR and PARITYERR bits.
N     * |[6]     |FRMERR    |Framing Error Flag
N     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid stop bit (that is, the stop bit following the last data bit or parity bit is detected as logic 0).
N     * |        |          |0 = No framing error is generated.
N     * |        |          |1 = Framing error is generated.
N     * |        |          |Note: This bit can be cleared by write 1 among the BREAK, FRMERR and PARITYERR bits.
N     * |[7]     |BREAK     |Break Flag
N     * |        |          |This bit is set to logic 1 whenever the received data input (RX) is held in the spacing state (logic 0) for longer than a full word transmission time (that is, the total time of "start bit + data bits + parity + stop bits").
N     * |        |          |0 = No Break is generated.
N     * |        |          |1 = Break is generated in the receiver bus.
N     * |        |          |Note: This bit can be cleared by write 1 among the BREAK, FRMERR and PARITYERR bits.
N     * |[9]     |ABRDETIF  |Auto-baud Rate Interrupt Flag
N     * |        |          |This bit is set when auto-baud rate detection is done among the falling edge of the input data.
N     * |        |          |If the ABRIEN (UUART_PROTCTL[6]) is set, the auto-baud rate interrupt will be generated.
N     * |        |          |This bit can be set 4 times when the input data pattern is 0x55 and it is cleared before the next falling edge of the input bus.
N     * |        |          |0 = Auto-baud rate detect function is not done.
N     * |        |          |1 = One Bit auto-baud rate detect function is done.
N     * |        |          |Note: This bit can be cleared by writing 1 to it.
N     * |[10]    |RXBUSY    |RX Bus Status Flag (Read Only)
N     * |        |          |This bit indicates the busy status of the receiver.
N     * |        |          |0 = The receiver is Idle.
N     * |        |          |1 = The receiver is BUSY.
N     * |[11]    |ABERRSTS  |Auto-baud Rate Error Status
N     * |        |          |This bit is set when auto-baud rate detection counter overrun.
N     * |        |          |When the auto-baud rate counter overrun, the user shall revise the CLKDIV (UUART_BRGEN[25:16]) value and enable ABREN (UUART_PROTCTL[6]) to detect the correct baud rate again.
N     * |        |          |0 = Auto-baud rate detect counter is not overrun.
N     * |        |          |1 = Auto-baud rate detect counter is overrun.
N     * |        |          |Note 1: This bit is set at the same time of ABRDETIF.
N     * |        |          |Note 2: This bit can be cleared by writing 1 to ABRDETIF or ABERRSTS.
N     * |[16]    |CTSSYNCLV |nCTS Synchronized Level Status (Read Only)
N     * |        |          |This bit used to indicate the current status of the internal synchronized nCTS signal.
N     * |        |          |0 = The internal synchronized nCTS is low.
N     * |        |          |1 = The internal synchronized nCTS is high.
N     * |[17]    |CTSLV     |nCTS Pin Status (Read Only)
N     * |        |          |This bit used to monitor the current status of nCTS pin input.
N     * |        |          |0 = nCTS pin input is low level voltage logic state.
N     * |        |          |1 = nCTS pin input is high level voltage logic state.
N     */
N    __IO uint32_t CTL;                   /*!< [0x0000] USCI Control Register                                            */
X    volatile uint32_t CTL;                    
N    __IO uint32_t INTEN;                 /*!< [0x0004] USCI Interrupt Enable Register                                   */
X    volatile uint32_t INTEN;                  
N    __IO uint32_t BRGEN;                 /*!< [0x0008] USCI Baud Rate Generator Register                                */
X    volatile uint32_t BRGEN;                  
N    __I  uint32_t RESERVE0[1];
X    volatile const  uint32_t RESERVE0[1];
N    __IO uint32_t DATIN0;                /*!< [0x0010] USCI Input Data Signal Configuration Register 0                  */
X    volatile uint32_t DATIN0;                 
N    __I  uint32_t RESERVE1[3];
X    volatile const  uint32_t RESERVE1[3];
N    __IO uint32_t CTLIN0;                /*!< [0x0020] USCI Input Control Signal Configuration Register 0               */
X    volatile uint32_t CTLIN0;                 
N    __I  uint32_t RESERVE2[1];
X    volatile const  uint32_t RESERVE2[1];
N    __IO uint32_t CLKIN;                 /*!< [0x0028] USCI Input Clock Signal Configuration Register                   */
X    volatile uint32_t CLKIN;                  
N    __IO uint32_t LINECTL;               /*!< [0x002c] USCI Line Control Register                                       */
X    volatile uint32_t LINECTL;                
N    __O  uint32_t TXDAT;                 /*!< [0x0030] USCI Transmit Data Register                                      */
X    volatile  uint32_t TXDAT;                  
N    __I  uint32_t RXDAT;                 /*!< [0x0034] USCI Receive Data Register                                       */
X    volatile const  uint32_t RXDAT;                  
N    __IO uint32_t BUFCTL;                /*!< [0x0038] USCI Transmit/Receive Buffer Control Register                    */
X    volatile uint32_t BUFCTL;                 
N    __IO uint32_t BUFSTS;                /*!< [0x003c] USCI Transmit/Receive Buffer Status Register                     */
X    volatile uint32_t BUFSTS;                 
N    __I  uint32_t RESERVE3[5];
X    volatile const  uint32_t RESERVE3[5];
N    __IO uint32_t WKCTL;                 /*!< [0x0054] USCI Wake-up Control Register                                    */
X    volatile uint32_t WKCTL;                  
N    __IO uint32_t WKSTS;                 /*!< [0x0058] USCI Wake-up Status Register                                     */
X    volatile uint32_t WKSTS;                  
N    __IO uint32_t PROTCTL;               /*!< [0x005c] USCI Protocol Control Register                                   */
X    volatile uint32_t PROTCTL;                
N    __IO uint32_t PROTIEN;               /*!< [0x0060] USCI Protocol Interrupt Enable Register                          */
X    volatile uint32_t PROTIEN;                
N    __IO uint32_t PROTSTS;               /*!< [0x0064] USCI Protocol Status Register                                    */
X    volatile uint32_t PROTSTS;                
N
N} UUART_T;
N
N/**
N    @addtogroup UUART_CONST UUART Bit Field Definition
N    Constant Definitions for UUART Controller
N@{ */
N
N#define UUART_CTL_FUNMODE_Pos            (0)                                               /*!< UUART_T::CTL: FUNMODE Position         */
N#define UUART_CTL_FUNMODE_Msk            (0x7ul << UUART_CTL_FUNMODE_Pos)                  /*!< UUART_T::CTL: FUNMODE Mask             */
N
N#define UUART_INTEN_TXSTIEN_Pos          (1)                                               /*!< UUART_T::INTEN: TXSTIEN Position       */
N#define UUART_INTEN_TXSTIEN_Msk          (0x1ul << UUART_INTEN_TXSTIEN_Pos)                /*!< UUART_T::INTEN: TXSTIEN Mask           */
N
N#define UUART_INTEN_TXENDIEN_Pos         (2)                                               /*!< UUART_T::INTEN: TXENDIEN Position      */
N#define UUART_INTEN_TXENDIEN_Msk         (0x1ul << UUART_INTEN_TXENDIEN_Pos)               /*!< UUART_T::INTEN: TXENDIEN Mask          */
N
N#define UUART_INTEN_RXSTIEN_Pos          (3)                                               /*!< UUART_T::INTEN: RXSTIEN Position       */
N#define UUART_INTEN_RXSTIEN_Msk          (0x1ul << UUART_INTEN_RXSTIEN_Pos)                /*!< UUART_T::INTEN: RXSTIEN Mask           */
N
N#define UUART_INTEN_RXENDIEN_Pos         (4)                                               /*!< UUART_T::INTEN: RXENDIEN Position      */
N#define UUART_INTEN_RXENDIEN_Msk         (0x1ul << UUART_INTEN_RXENDIEN_Pos)               /*!< UUART_T::INTEN: RXENDIEN Mask          */
N
N#define UUART_BRGEN_RCLKSEL_Pos          (0)                                               /*!< UUART_T::BRGEN: RCLKSEL Position       */
N#define UUART_BRGEN_RCLKSEL_Msk          (0x1ul << UUART_BRGEN_RCLKSEL_Pos)                /*!< UUART_T::BRGEN: RCLKSEL Mask           */
N
N#define UUART_BRGEN_PTCLKSEL_Pos         (1)                                               /*!< UUART_T::BRGEN: PTCLKSEL Position      */
N#define UUART_BRGEN_PTCLKSEL_Msk         (0x1ul << UUART_BRGEN_PTCLKSEL_Pos)               /*!< UUART_T::BRGEN: PTCLKSEL Mask          */
N
N#define UUART_BRGEN_SPCLKSEL_Pos         (2)                                               /*!< UUART_T::BRGEN: SPCLKSEL Position      */
N#define UUART_BRGEN_SPCLKSEL_Msk         (0x3ul << UUART_BRGEN_SPCLKSEL_Pos)               /*!< UUART_T::BRGEN: SPCLKSEL Mask          */
N
N#define UUART_BRGEN_TMCNTEN_Pos          (4)                                               /*!< UUART_T::BRGEN: TMCNTEN Position       */
N#define UUART_BRGEN_TMCNTEN_Msk          (0x1ul << UUART_BRGEN_TMCNTEN_Pos)                /*!< UUART_T::BRGEN: TMCNTEN Mask           */
N
N#define UUART_BRGEN_TMCNTSRC_Pos         (5)                                               /*!< UUART_T::BRGEN: TMCNTSRC Position      */
N#define UUART_BRGEN_TMCNTSRC_Msk         (0x1ul << UUART_BRGEN_TMCNTSRC_Pos)               /*!< UUART_T::BRGEN: TMCNTSRC Mask          */
N
N#define UUART_BRGEN_PDSCNT_Pos           (8)                                               /*!< UUART_T::BRGEN: PDSCNT Position        */
N#define UUART_BRGEN_PDSCNT_Msk           (0x3ul << UUART_BRGEN_PDSCNT_Pos)                 /*!< UUART_T::BRGEN: PDSCNT Mask            */
N
N#define UUART_BRGEN_DSCNT_Pos            (10)                                              /*!< UUART_T::BRGEN: DSCNT Position         */
N#define UUART_BRGEN_DSCNT_Msk            (0x1ful << UUART_BRGEN_DSCNT_Pos)                 /*!< UUART_T::BRGEN: DSCNT Mask             */
N
N#define UUART_BRGEN_CLKDIV_Pos           (16)                                              /*!< UUART_T::BRGEN: CLKDIV Position        */
N#define UUART_BRGEN_CLKDIV_Msk           (0x3fful << UUART_BRGEN_CLKDIV_Pos)               /*!< UUART_T::BRGEN: CLKDIV Mask            */
N
N#define UUART_DATIN0_SYNCSEL_Pos         (0)                                               /*!< UUART_T::DATIN0: SYNCSEL Position      */
N#define UUART_DATIN0_SYNCSEL_Msk         (0x1ul << UUART_DATIN0_SYNCSEL_Pos)               /*!< UUART_T::DATIN0: SYNCSEL Mask          */
N
N#define UUART_DATIN0_ININV_Pos           (2)                                               /*!< UUART_T::DATIN0: ININV Position        */
N#define UUART_DATIN0_ININV_Msk           (0x1ul << UUART_DATIN0_ININV_Pos)                 /*!< UUART_T::DATIN0: ININV Mask            */
N
N#define UUART_DATIN0_EDGEDET_Pos         (3)                                               /*!< UUART_T::DATIN0: EDGEDET Position      */
N#define UUART_DATIN0_EDGEDET_Msk         (0x3ul << UUART_DATIN0_EDGEDET_Pos)               /*!< UUART_T::DATIN0: EDGEDET Mask          */
N
N#define UUART_CTLIN0_SYNCSEL_Pos         (0)                                               /*!< UUART_T::CTLIN0: SYNCSEL Position      */
N#define UUART_CTLIN0_SYNCSEL_Msk         (0x1ul << UUART_CTLIN0_SYNCSEL_Pos)               /*!< UUART_T::CTLIN0: SYNCSEL Mask          */
N
N#define UUART_CTLIN0_ININV_Pos           (2)                                               /*!< UUART_T::CTLIN0: ININV Position        */
N#define UUART_CTLIN0_ININV_Msk           (0x1ul << UUART_CTLIN0_ININV_Pos)                 /*!< UUART_T::CTLIN0: ININV Mask            */
N
N#define UUART_CLKIN_SYNCSEL_Pos          (0)                                               /*!< UUART_T::CLKIN: SYNCSEL Position       */
N#define UUART_CLKIN_SYNCSEL_Msk          (0x1ul << UUART_CLKIN_SYNCSEL_Pos)                /*!< UUART_T::CLKIN: SYNCSEL Mask           */
N
N#define UUART_LINECTL_LSB_Pos            (0)                                               /*!< UUART_T::LINECTL: LSB Position         */
N#define UUART_LINECTL_LSB_Msk            (0x1ul << UUART_LINECTL_LSB_Pos)                  /*!< UUART_T::LINECTL: LSB Mask             */
N
N#define UUART_LINECTL_DATOINV_Pos        (5)                                               /*!< UUART_T::LINECTL: DATOINV Position     */
N#define UUART_LINECTL_DATOINV_Msk        (0x1ul << UUART_LINECTL_DATOINV_Pos)              /*!< UUART_T::LINECTL: DATOINV Mask         */
N
N#define UUART_LINECTL_CTLOINV_Pos        (7)                                               /*!< UUART_T::LINECTL: CTLOINV Position     */
N#define UUART_LINECTL_CTLOINV_Msk        (0x1ul << UUART_LINECTL_CTLOINV_Pos)              /*!< UUART_T::LINECTL: CTLOINV Mask         */
N
N#define UUART_LINECTL_DWIDTH_Pos         (8)                                               /*!< UUART_T::LINECTL: DWIDTH Position      */
N#define UUART_LINECTL_DWIDTH_Msk         (0xful << UUART_LINECTL_DWIDTH_Pos)               /*!< UUART_T::LINECTL: DWIDTH Mask          */
N
N#define UUART_TXDAT_TXDAT_Pos            (0)                                               /*!< UUART_T::TXDAT: TXDAT Position         */
N#define UUART_TXDAT_TXDAT_Msk            (0xfffful << UUART_TXDAT_TXDAT_Pos)               /*!< UUART_T::TXDAT: TXDAT Mask             */
N
N#define UUART_RXDAT_RXDAT_Pos            (0)                                               /*!< UUART_T::RXDAT: RXDAT Position         */
N#define UUART_RXDAT_RXDAT_Msk            (0xfffful << UUART_RXDAT_RXDAT_Pos)               /*!< UUART_T::RXDAT: RXDAT Mask             */
N
N#define UUART_BUFCTL_TXCLR_Pos           (7)                                               /*!< UUART_T::BUFCTL: TXCLR Position        */
N#define UUART_BUFCTL_TXCLR_Msk           (0x1ul << UUART_BUFCTL_TXCLR_Pos)                 /*!< UUART_T::BUFCTL: TXCLR Mask            */
N
N#define UUART_BUFCTL_RXOVIEN_Pos         (14)                                              /*!< UUART_T::BUFCTL: RXOVIEN Position      */
N#define UUART_BUFCTL_RXOVIEN_Msk         (0x1ul << UUART_BUFCTL_RXOVIEN_Pos)               /*!< UUART_T::BUFCTL: RXOVIEN Mask          */
N
N#define UUART_BUFCTL_RXCLR_Pos           (15)                                              /*!< UUART_T::BUFCTL: RXCLR Position        */
N#define UUART_BUFCTL_RXCLR_Msk           (0x1ul << UUART_BUFCTL_RXCLR_Pos)                 /*!< UUART_T::BUFCTL: RXCLR Mask            */
N
N#define UUART_BUFCTL_TXRST_Pos           (16)                                              /*!< UUART_T::BUFCTL: TXRST Position        */
N#define UUART_BUFCTL_TXRST_Msk           (0x1ul << UUART_BUFCTL_TXRST_Pos)                 /*!< UUART_T::BUFCTL: TXRST Mask            */
N
N#define UUART_BUFCTL_RXRST_Pos           (17)                                              /*!< UUART_T::BUFCTL: RXRST Position        */
N#define UUART_BUFCTL_RXRST_Msk           (0x1ul << UUART_BUFCTL_RXRST_Pos)                 /*!< UUART_T::BUFCTL: RXRST Mask            */
N
N#define UUART_BUFSTS_RXEMPTY_Pos         (0)                                               /*!< UUART_T::BUFSTS: RXEMPTY Position      */
N#define UUART_BUFSTS_RXEMPTY_Msk         (0x1ul << UUART_BUFSTS_RXEMPTY_Pos)               /*!< UUART_T::BUFSTS: RXEMPTY Mask          */
N
N#define UUART_BUFSTS_RXFULL_Pos          (1)                                               /*!< UUART_T::BUFSTS: RXFULL Position       */
N#define UUART_BUFSTS_RXFULL_Msk          (0x1ul << UUART_BUFSTS_RXFULL_Pos)                /*!< UUART_T::BUFSTS: RXFULL Mask           */
N
N#define UUART_BUFSTS_RXOVIF_Pos          (3)                                               /*!< UUART_T::BUFSTS: RXOVIF Position       */
N#define UUART_BUFSTS_RXOVIF_Msk          (0x1ul << UUART_BUFSTS_RXOVIF_Pos)                /*!< UUART_T::BUFSTS: RXOVIF Mask           */
N
N#define UUART_BUFSTS_TXEMPTY_Pos         (8)                                               /*!< UUART_T::BUFSTS: TXEMPTY Position      */
N#define UUART_BUFSTS_TXEMPTY_Msk         (0x1ul << UUART_BUFSTS_TXEMPTY_Pos)               /*!< UUART_T::BUFSTS: TXEMPTY Mask          */
N
N#define UUART_BUFSTS_TXFULL_Pos          (9)                                               /*!< UUART_T::BUFSTS: TXFULL Position       */
N#define UUART_BUFSTS_TXFULL_Msk          (0x1ul << UUART_BUFSTS_TXFULL_Pos)                /*!< UUART_T::BUFSTS: TXFULL Mask           */
N
N#define UUART_WKCTL_WKEN_Pos             (0)                                               /*!< UUART_T::WKCTL: WKEN Position          */
N#define UUART_WKCTL_WKEN_Msk             (0x1ul << UUART_WKCTL_WKEN_Pos)                   /*!< UUART_T::WKCTL: WKEN Mask              */
N
N#define UUART_WKCTL_PDBOPT_Pos           (2)                                               /*!< UUART_T::WKCTL: PDBOPT Position        */
N#define UUART_WKCTL_PDBOPT_Msk           (0x1ul << UUART_WKCTL_PDBOPT_Pos)                 /*!< UUART_T::WKCTL: PDBOPT Mask            */
N
N#define UUART_WKSTS_WKF_Pos              (0)                                               /*!< UUART_T::WKSTS: WKF Position           */
N#define UUART_WKSTS_WKF_Msk              (0x1ul << UUART_WKSTS_WKF_Pos)                    /*!< UUART_T::WKSTS: WKF Mask               */
N
N#define UUART_PROTCTL_STOPB_Pos          (0)                                               /*!< UUART_T::PROTCTL: STOPB Position       */
N#define UUART_PROTCTL_STOPB_Msk          (0x1ul << UUART_PROTCTL_STOPB_Pos)                /*!< UUART_T::PROTCTL: STOPB Mask           */
N
N#define UUART_PROTCTL_PARITYEN_Pos       (1)                                               /*!< UUART_T::PROTCTL: PARITYEN Position    */
N#define UUART_PROTCTL_PARITYEN_Msk       (0x1ul << UUART_PROTCTL_PARITYEN_Pos)             /*!< UUART_T::PROTCTL: PARITYEN Mask        */
N
N#define UUART_PROTCTL_EVENPARITY_Pos     (2)                                               /*!< UUART_T::PROTCTL: EVENPARITY Position  */
N#define UUART_PROTCTL_EVENPARITY_Msk     (0x1ul << UUART_PROTCTL_EVENPARITY_Pos)           /*!< UUART_T::PROTCTL: EVENPARITY Mask      */
N
N#define UUART_PROTCTL_RTSAUTOEN_Pos      (3)                                               /*!< UUART_T::PROTCTL: RTSAUTOEN Position   */
N#define UUART_PROTCTL_RTSAUTOEN_Msk      (0x1ul << UUART_PROTCTL_RTSAUTOEN_Pos)            /*!< UUART_T::PROTCTL: RTSAUTOEN Mask       */
N
N#define UUART_PROTCTL_CTSAUTOEN_Pos      (4)                                               /*!< UUART_T::PROTCTL: CTSAUTOEN Position   */
N#define UUART_PROTCTL_CTSAUTOEN_Msk      (0x1ul << UUART_PROTCTL_CTSAUTOEN_Pos)            /*!< UUART_T::PROTCTL: CTSAUTOEN Mask       */
N
N#define UUART_PROTCTL_RTSAUDIREN_Pos     (5)                                               /*!< UUART_T::PROTCTL: RTSAUDIREN Position  */
N#define UUART_PROTCTL_RTSAUDIREN_Msk     (0x1ul << UUART_PROTCTL_RTSAUDIREN_Pos)           /*!< UUART_T::PROTCTL: RTSAUDIREN Mask      */
N
N#define UUART_PROTCTL_ABREN_Pos          (6)                                               /*!< UUART_T::PROTCTL: ABREN Position       */
N#define UUART_PROTCTL_ABREN_Msk          (0x1ul << UUART_PROTCTL_ABREN_Pos)                /*!< UUART_T::PROTCTL: ABREN Mask           */
N
N#define UUART_PROTCTL_DATWKEN_Pos        (9)                                               /*!< UUART_T::PROTCTL: DATWKEN Position     */
N#define UUART_PROTCTL_DATWKEN_Msk        (0x1ul << UUART_PROTCTL_DATWKEN_Pos)              /*!< UUART_T::PROTCTL: DATWKEN Mask         */
N
N#define UUART_PROTCTL_CTSWKEN_Pos        (10)                                              /*!< UUART_T::PROTCTL: CTSWKEN Position     */
N#define UUART_PROTCTL_CTSWKEN_Msk        (0x1ul << UUART_PROTCTL_CTSWKEN_Pos)              /*!< UUART_T::PROTCTL: CTSWKEN Mask         */
N
N#define UUART_PROTCTL_WAKECNT_Pos        (11)                                              /*!< UUART_T::PROTCTL: WAKECNT Position     */
N#define UUART_PROTCTL_WAKECNT_Msk        (0xful << UUART_PROTCTL_WAKECNT_Pos)              /*!< UUART_T::PROTCTL: WAKECNT Mask         */
N
N#define UUART_PROTCTL_BRDETITV_Pos       (16)                                              /*!< UUART_T::PROTCTL: BRDETITV Position    */
N#define UUART_PROTCTL_BRDETITV_Msk       (0x1fful << UUART_PROTCTL_BRDETITV_Pos)           /*!< UUART_T::PROTCTL: BRDETITV Mask        */
N
N#define UUART_PROTCTL_STICKEN_Pos        (26)                                              /*!< UUART_T::PROTCTL: STICKEN Position     */
N#define UUART_PROTCTL_STICKEN_Msk        (0x1ul << UUART_PROTCTL_STICKEN_Pos)              /*!< UUART_T::PROTCTL: STICKEN Mask         */
N
N#define UUART_PROTCTL_BCEN_Pos           (29)                                              /*!< UUART_T::PROTCTL: BCEN Position        */
N#define UUART_PROTCTL_BCEN_Msk           (0x1ul << UUART_PROTCTL_BCEN_Pos)                 /*!< UUART_T::PROTCTL: BCEN Mask            */
N
N#define UUART_PROTCTL_PROTEN_Pos         (31)                                              /*!< UUART_T::PROTCTL: PROTEN Position      */
N#define UUART_PROTCTL_PROTEN_Msk         (0x1ul << UUART_PROTCTL_PROTEN_Pos)               /*!< UUART_T::PROTCTL: PROTEN Mask          */
N
N#define UUART_PROTIEN_ABRIEN_Pos         (1)                                               /*!< UUART_T::PROTIEN: ABRIEN Position      */
N#define UUART_PROTIEN_ABRIEN_Msk         (0x1ul << UUART_PROTIEN_ABRIEN_Pos)               /*!< UUART_T::PROTIEN: ABRIEN Mask          */
N
N#define UUART_PROTIEN_RLSIEN_Pos         (2)                                               /*!< UUART_T::PROTIEN: RLSIEN Position      */
N#define UUART_PROTIEN_RLSIEN_Msk         (0x1ul << UUART_PROTIEN_RLSIEN_Pos)               /*!< UUART_T::PROTIEN: RLSIEN Mask          */
N
N#define UUART_PROTSTS_TXSTIF_Pos         (1)                                               /*!< UUART_T::PROTSTS: TXSTIF Position      */
N#define UUART_PROTSTS_TXSTIF_Msk         (0x1ul << UUART_PROTSTS_TXSTIF_Pos)               /*!< UUART_T::PROTSTS: TXSTIF Mask          */
N
N#define UUART_PROTSTS_TXENDIF_Pos        (2)                                               /*!< UUART_T::PROTSTS: TXENDIF Position     */
N#define UUART_PROTSTS_TXENDIF_Msk        (0x1ul << UUART_PROTSTS_TXENDIF_Pos)              /*!< UUART_T::PROTSTS: TXENDIF Mask         */
N
N#define UUART_PROTSTS_RXSTIF_Pos         (3)                                               /*!< UUART_T::PROTSTS: RXSTIF Position      */
N#define UUART_PROTSTS_RXSTIF_Msk         (0x1ul << UUART_PROTSTS_RXSTIF_Pos)               /*!< UUART_T::PROTSTS: RXSTIF Mask          */
N
N#define UUART_PROTSTS_RXENDIF_Pos        (4)                                               /*!< UUART_T::PROTSTS: RXENDIF Position     */
N#define UUART_PROTSTS_RXENDIF_Msk        (0x1ul << UUART_PROTSTS_RXENDIF_Pos)              /*!< UUART_T::PROTSTS: RXENDIF Mask         */
N
N#define UUART_PROTSTS_PARITYERR_Pos      (5)                                               /*!< UUART_T::PROTSTS: PARITYERR Position   */
N#define UUART_PROTSTS_PARITYERR_Msk      (0x1ul << UUART_PROTSTS_PARITYERR_Pos)            /*!< UUART_T::PROTSTS: PARITYERR Mask       */
N
N#define UUART_PROTSTS_FRMERR_Pos         (6)                                               /*!< UUART_T::PROTSTS: FRMERR Position      */
N#define UUART_PROTSTS_FRMERR_Msk         (0x1ul << UUART_PROTSTS_FRMERR_Pos)               /*!< UUART_T::PROTSTS: FRMERR Mask          */
N
N#define UUART_PROTSTS_BREAK_Pos          (7)                                               /*!< UUART_T::PROTSTS: BREAK Position       */
N#define UUART_PROTSTS_BREAK_Msk          (0x1ul << UUART_PROTSTS_BREAK_Pos)                /*!< UUART_T::PROTSTS: BREAK Mask           */
N
N#define UUART_PROTSTS_ABRDETIF_Pos       (9)                                               /*!< UUART_T::PROTSTS: ABRDETIF Position    */
N#define UUART_PROTSTS_ABRDETIF_Msk       (0x1ul << UUART_PROTSTS_ABRDETIF_Pos)             /*!< UUART_T::PROTSTS: ABRDETIF Mask        */
N
N#define UUART_PROTSTS_RXBUSY_Pos         (10)                                              /*!< UUART_T::PROTSTS: RXBUSY Position      */
N#define UUART_PROTSTS_RXBUSY_Msk         (0x1ul << UUART_PROTSTS_RXBUSY_Pos)               /*!< UUART_T::PROTSTS: RXBUSY Mask          */
N
N#define UUART_PROTSTS_ABERRSTS_Pos       (11)                                              /*!< UUART_T::PROTSTS: ABERRSTS Position    */
N#define UUART_PROTSTS_ABERRSTS_Msk       (0x1ul << UUART_PROTSTS_ABERRSTS_Pos)             /*!< UUART_T::PROTSTS: ABERRSTS Mask        */
N
N#define UUART_PROTSTS_CTSSYNCLV_Pos      (16)                                              /*!< UUART_T::PROTSTS: CTSSYNCLV Position   */
N#define UUART_PROTSTS_CTSSYNCLV_Msk      (0x1ul << UUART_PROTSTS_CTSSYNCLV_Pos)            /*!< UUART_T::PROTSTS: CTSSYNCLV Mask       */
N
N#define UUART_PROTSTS_CTSLV_Pos          (17)                                              /*!< UUART_T::PROTSTS: CTSLV Position       */
N#define UUART_PROTSTS_CTSLV_Msk          (0x1ul << UUART_PROTSTS_CTSLV_Pos)                /*!< UUART_T::PROTSTS: CTSLV Mask           */
N
N/**@}*/ /* UUART_CONST */
N/**@}*/ /* end of UUART register group */
N
N
N
N/*---------------------- Watch Dog Timer Controller -------------------------*/
N/**
N    @addtogroup WDT Watch Dog Timer Controller(WDT)
N    Memory Mapped Structure for WDT Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var WDT_T::CTL
N     * Offset: 0x00  WDT Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |RSTEN     |WDT Time-out Reset Enable Control (Write Protect)
N     * |        |          |Setting this bit will enable the WDT time-out reset system function If the WDT up counter value has not been cleared after the specific WDT reset delay period expires.
N     * |        |          |0 = WDT time-out reset system function Disabled.
N     * |        |          |1 = WDT time-out reset system function Enabled.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[2]     |RSTF      |WDT Time-out Reset Flag
N     * |        |          |This bit indicates the system has been reset by WDT time-out reset system event or not.
N     * |        |          |0 = WDT time-out reset system event did not occur.
N     * |        |          |1 = WDT time-out reset system event has been occurred.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[3]     |IF        |WDT Time-out Interrupt Flag
N     * |        |          |This bit will set to 1 while WDT up counter value reaches the selected WDT time-out interval
N     * |        |          |0 = WDT time-out interrupt event interrupt did not occur.
N     * |        |          |1 = WDT time-out interrupt interrupt event occurred.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[4]     |WKEN      |WDT Time-out Wake-up Function Control (Write Protect)
N     * |        |          |If this bit is set to 1, while WDT time-out interrupt flag IF (WDT_CTL[3]) is generated to 1 and interrupt enable bit INTEN (WDT_CTL[6]) is enabled, the WDT time-out interrupt signal will generate a event to trigger CPU wake-up trigger event to chip.
N     * |        |          |0 = Trigger wWake-up trigger event function Disabled if WDT time-out interrupt signal generated.
N     * |        |          |1 = Trigger wWake-up trigger event function Enabled if WDT time-out interrupt signal generated.
N     * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |        |          |Note2: Chip can be woken-up by while WDT time-out interrupt signal generated only if WDT clock source is selected to 10 kHz (LIRC (10 kHz) or LXT (32 kHz).
N     * |[5]     |WKF       |WDT Time-out Wake-up Flag (Write Protect)
N     * |        |          |This bit indicates the WDT time-out event has triggered interruptchip wake-up or not.flag status of WDT
N     * |        |          |0 = WDT does not cause chip wake-up.
N     * |        |          |1 = Chip wake-up from Idle or Power-down mode if when WDT time-out interrupt signal is generated.
N     * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |        |          |Note2: This bit is cleared by writing 1 to it.
N     * |[6]     |INTEN     |WDT Time-out Interrupt Enable Control (Write Protect)
N     * |        |          |If this bit is enabled, when WDT time-out event occurs, the IF (WDT_CTL[3]) will be set to 1 andthe WDT time-out interrupt signal is generated and inform to CPU.
N     * |        |          |0 = WDT time-out interrupt Disabled.
N     * |        |          |1 = WDT time-out interrupt Enabled.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[7]     |WDTEN     |WDT Enable Control (Write Protect)
N     * |        |          |0 = Set WDT counter stopDisabled, and (This action will reset the internal up counter value will be reset also).
N     * |        |          |1 = Set WDT counter start Enabled.
N     * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |        |          |Note2: Perform enable or disable WDTEN bit needs 2 * WDT_CLK period to become active, user can read SYNC (WDT_CTL[30]) to check enabe/disable command is completed or not.
N     * |        |          |Note32: If CWDTEN[2:0] (combined by with Config0[31] and Config0[4:3]) bits is not configure to 0x111, this bit is forced as 1 and user cannot change this bit to 0.
N     * |        |          |Note3: This bit disabled needs 2 * WDT_CLK.
N     * |[10:8]  |TOUTSEL   |WDT Time-out Interval Selection (Write Protect)
N     * |        |          |These three bits select the time-out interval period after for the WDT starts counting.
N     * |        |          |000 = 24 * WDT_CLK.
N     * |        |          |001 = 26 * WDT_CLK.
N     * |        |          |010 = 28 * WDT_CLK.
N     * |        |          |011 = 210 * WDT_CLK.
N     * |        |          |100 = 212 * WDT_CLK.
N     * |        |          |101 = 214 * WDT_CLK.
N     * |        |          |110 = 216 * WDT_CLK.
N     * |        |          |111 = 218 * WDT_CLK.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[30]    |SYNC      |WDT Enable Control SYNC SYNC Flag Indicator (Read Only)
N     * |        |          |If usDue to synchronization, software er can check execute enable/disable this flag after enable WDTEN (WDT_CTL[7]), this flag can be indicated enable/disable WDTEN function is becomecompleted or not active or not..
N     * |        |          |SYNC delay is
N     * |        |          |0 = Set WDTEN bit is WDT enable control synccompletedhronizing is completion.
N     * |        |          |1 = Set WDTEN bit WDT enable control is synchronizing and not become active yet..
N     * |        |          |Note: Perform enable or disable WDTEN bit
N     * |        |          |This bit enabled needs 2 * WDT_CLK period to become active.
N     * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control (Write Protect)
N     * |        |          |0 = ICE debug mode acknowledgement affects WDT counting.
N     * |        |          |WDT up counter will be held while CPU is held by ICE.
N     * |        |          |1 = ICE debug mode acknowledgement Disabled.
N     * |        |          |WDT up counter will keep going no matter CPU is held by ICE or not.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * @var WDT_T::ALTCTL
N     * Offset: 0x04  WDT Alternative Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |RSTDSEL   |WDT Reset Delay Period Selection (Write Protect)
N     * |        |          |When WDT time-out event happened, user has a time named WDT Reset Delay Period to clear execute WDT counter by setting RSTCNT (WDT_CTL[0]) reset to prevent WDT time-out reset system occurredhappened
N     * |        |          |User can select a suitable setting of RSTDSEL for different application programWDT Reset Delay Period.
N     * |        |          |00 = WDT Reset Delay Period is 1026 * WDT_CLK.
N     * |        |          |01 = WDT Reset Delay Period is 130 * WDT_CLK.
N     * |        |          |10 = WDT Reset Delay Period is 18 * WDT_CLK.
N     * |        |          |11 = WDT Reset Delay Period is 3 * WDT_CLK.
N     * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |        |          |Note2: This register will be reset to 0 if WDT time-out reset system event occurredhappened.
N     * @var WDT_T::RSTCNT
N     * Offset: 0x08  WDT Reset Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |RSTCNT    |WDT Reset Counter Register
N     * |        |          |Writing 0x00005AA5 to this register field will reset the internal 18-bit WDT up counter value to 0.
N     * |        |          |Note: This WDT_RSTCNT is not write protected, but this RSTCNT (WDT_CTL[0]) is write protected.
N     * |        |          |Note: Perform RSTCNT to reset counter needs 2 * WDT_CLK period to become active.
N     */
N    __IO uint32_t CTL;                   /*!< [0x0000] WDT Control Register                                             */
X    volatile uint32_t CTL;                    
N    __IO uint32_t ALTCTL;                /*!< [0x0004] WDT Alternative Control Register                                 */
X    volatile uint32_t ALTCTL;                 
N    __O  uint32_t RSTCNT;                /*!< [0x0008] WDT Reset Counter Register                                       */
X    volatile  uint32_t RSTCNT;                 
N
N} WDT_T;
N
N/**
N    @addtogroup WDT_CONST WDT Bit Field Definition
N    Constant Definitions for WDT Controller
N@{ */
N
N#define WDT_CTL_RSTEN_Pos                (1)                                               /*!< WDT_T::CTL: RSTEN Position             */
N#define WDT_CTL_RSTEN_Msk                (0x1ul << WDT_CTL_RSTEN_Pos)                      /*!< WDT_T::CTL: RSTEN Mask                 */
N
N#define WDT_CTL_RSTF_Pos                 (2)                                               /*!< WDT_T::CTL: RSTF Position              */
N#define WDT_CTL_RSTF_Msk                 (0x1ul << WDT_CTL_RSTF_Pos)                       /*!< WDT_T::CTL: RSTF Mask                  */
N
N#define WDT_CTL_IF_Pos                   (3)                                               /*!< WDT_T::CTL: IF Position                */
N#define WDT_CTL_IF_Msk                   (0x1ul << WDT_CTL_IF_Pos)                         /*!< WDT_T::CTL: IF Mask                    */
N
N#define WDT_CTL_WKEN_Pos                 (4)                                               /*!< WDT_T::CTL: WKEN Position              */
N#define WDT_CTL_WKEN_Msk                 (0x1ul << WDT_CTL_WKEN_Pos)                       /*!< WDT_T::CTL: WKEN Mask                  */
N
N#define WDT_CTL_WKF_Pos                  (5)                                               /*!< WDT_T::CTL: WKF Position               */
N#define WDT_CTL_WKF_Msk                  (0x1ul << WDT_CTL_WKF_Pos)                        /*!< WDT_T::CTL: WKF Mask                   */
N
N#define WDT_CTL_INTEN_Pos                (6)                                               /*!< WDT_T::CTL: INTEN Position             */
N#define WDT_CTL_INTEN_Msk                (0x1ul << WDT_CTL_INTEN_Pos)                      /*!< WDT_T::CTL: INTEN Mask                 */
N
N#define WDT_CTL_WDTEN_Pos                (7)                                               /*!< WDT_T::CTL: WDTEN Position             */
N#define WDT_CTL_WDTEN_Msk                (0x1ul << WDT_CTL_WDTEN_Pos)                      /*!< WDT_T::CTL: WDTEN Mask                 */
N
N#define WDT_CTL_TOUTSEL_Pos              (8)                                               /*!< WDT_T::CTL: TOUTSEL Position           */
N#define WDT_CTL_TOUTSEL_Msk              (0x7ul << WDT_CTL_TOUTSEL_Pos)                    /*!< WDT_T::CTL: TOUTSEL Mask               */
N
N#define WDT_CTL_SYNC_Pos                 (30)                                              /*!< WDT_T::CTL: SYNC Position              */
N#define WDT_CTL_SYNC_Msk                 (0x1ul << WDT_CTL_SYNC_Pos)                       /*!< WDT_T::CTL: SYNC Mask                  */
N
N#define WDT_CTL_ICEDEBUG_Pos             (31)                                              /*!< WDT_T::CTL: ICEDEBUG Position          */
N#define WDT_CTL_ICEDEBUG_Msk             (0x1ul << WDT_CTL_ICEDEBUG_Pos)                   /*!< WDT_T::CTL: ICEDEBUG Mask              */
N
N#define WDT_ALTCTL_RSTDSEL_Pos           (0)                                               /*!< WDT_T::ALTCTL: RSTDSEL Position        */
N#define WDT_ALTCTL_RSTDSEL_Msk           (0x3ul << WDT_ALTCTL_RSTDSEL_Pos)                 /*!< WDT_T::ALTCTL: RSTDSEL Mask            */
N
N#define WDT_RSTCNT_RSTCNT_Pos            (0)                                               /*!< WDT_T::RSTCNT: RSTCNT Position         */
N#define WDT_RSTCNT_RSTCNT_Msk            (0xfffffffful << WDT_RSTCNT_RSTCNT_Pos)           /*!< WDT_T::RSTCNT: RSTCNT Mask             */
N
N
N/**@}*/ /* WDT_CONST */
N/**@}*/ /* end of WDT register group */
N
N
N/*---------------------- Window Watchdog Timer -------------------------*/
N/**
N    @addtogroup WWDT Window Watchdog Timer(WWDT)
N    Memory Mapped Structure for WWDT Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var WWDT_T::RLDCNT
N     * Offset: 0x00  WWDT Reload Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |RLDCNT    |WWDT Reload Counter Register
N     * |        |          |Writing only 0x00005AA5 to this register will reload the WWDT counter value to 0x3F.
N     * |        |          |Note1: User can only write executeWWDT_RLDCNT register tothe reload WWDT counter value command when current current WWDT counter valueCNTDAT (WWDT_CNT[5:0]) is between 10 and CMPDAT (WWDT_CTL[21:16])
N     * |        |          |If user writes 0x00005AA5 in WWDT_RLDCNT register when current current CNTDATWWDT counter value is larger than CMPDAT, WWDT reset signal system event will be generated immediately.
N     * |        |          |Note2: Execute WWDT counter relaod always needs (WWDT_CLK *3) period to reload CNTDAT to 0x3F and intrenal prescale counter will be reset also.
N     * @var WWDT_T::CTL
N     * Offset: 0x04  WWDT Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WWDTEN    |WWDT Enable Control Bit
N     * |        |          |Set this bit to enable start WWDT counter counting.
N     * |        |          |0 = WWDT counter is stopped.
N     * |        |          |1 = WWDT counter is starting counting.
N     * |[1]     |INTEN     |WWDT Interrupt Enable Control Bit
N     * |        |          |If this bit is enabled, when WWDTIF (WWDT_STATUS[0]) is set to 1, the WWDT counter compare match interrupt signal is generated and inform to CPU.
N     * |        |          |0 = WWDT counter compare match interrupt Disabled.
N     * |        |          |1 = WWDT counter compare match interrupt Enabled.
N     * |[11:8]  |PSCSEL    |WWDT Counter Prescale Period Selection
N     * |        |          |0000 = Pre-scale is 1; Max time-out period is 1 * 64 * WWDT_CLK.
N     * |        |          |0001 = Pre-scale is 2; Max time-out period is 2 * 64 * WWDT_CLK.
N     * |        |          |0010 = Pre-scale is 4; Max time-out period is 4 * 64 * WWDT_CLK.
N     * |        |          |0011 = Pre-scale is 8; Max time-out period is 8 * 64 * WWDT_CLK.
N     * |        |          |0100 = Pre-scale is 16; Max time-out period is 16 * 64 * WWDT_CLK.
N     * |        |          |0101 = Pre-scale is 32; Max time-out period is 32 * 64 * WWDT_CLK.
N     * |        |          |0110 = Pre-scale is 64; Max time-out period is 64 * 64 * WWDT_CLK.
N     * |        |          |0111 = Pre-scale is 128; Max time-out period is 128 * 64 * WWDT_CLK.
N     * |        |          |1000 = Pre-scale is 192; Max time-out period is 192 * 64 * WWDT_CLK.
N     * |        |          |1001 = Pre-scale is 256; Max time-out period is 256 * 64 * WWDT_CLK.
N     * |        |          |1010 = Pre-scale is 384; Max time-out period is 384 * 64 * WWDT_CLK.
N     * |        |          |1011 = Pre-scale is 512; Max time-out period is 512 * 64 * WWDT_CLK.
N     * |        |          |1100 = Pre-scale is 768; Max time-out period is 768 * 64 * WWDT_CLK.
N     * |        |          |1101 = Pre-scale is 1024; Max time-out period is 1024 * 64 * WWDT_CLK.
N     * |        |          |1110 = Pre-scale is 1536; Max time-out period is 1536 * 64 * WWDT_CLK.
N     * |        |          |1111 = Pre-scale is 2048; Max time-out period is 2048 * 64 * WWDT_CLK.
N     * |[21:16] |CMPDAT    |WWDT Window Compare RegisterValue
N     * |        |          |Set this register field to adjust the valid reload window interval when WWDTIF (WWDT_STATUS[0]) is generated..
N     * |        |          |Note: User can only write WWDT_RLDCNT register to reload WWDT counter value when current WWDT CNTDAT (WWDT_CNT[5:]) iscounter value between 10 and CMPDAT
N     * |        |          |If user writes 0x00005AA5 in WWDT_RLDCNT register when current WWDT counter valueCNTDAT is larger than CMPDAT, WWDT reset system event signal will be generated immediately.
N     * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control
N     * |        |          |0 = ICE debug mode acknowledgement effects WWDT counter counting.
N     * |        |          |WWDT down counter will be held while CPU is held by ICE.
N     * |        |          |1 = ICE debug mode acknowledgement Disabled.
N     * |        |          |WWDT down counter will keep going counting no matter CPU is held by ICE or not.
N     * @var WWDT_T::STATUS
N     * Offset: 0x08  WWDT Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WWDTIF    |WWDT Compare Match Interrupt Flag
N     * |        |          |This bit indicates the that current CNTDAT (WWDT_CNT[5:0]) matches the CMPDAT (WWDT_CTL[21:16])interrupt flag status of WWDT while WWDT counter value matches CMPDAT (WWDT_CTL[21:16]).
N     * |        |          |0 = No effect.
N     * |        |          |1 = WWDT WWDT CNTDAT counter value matches the CMPDAT.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[1]     |WWDTRF    |WWDT Timer-out Reset System Flag
N     * |        |          |If this bit is set to 1, itThis bit indicates the that system has been reset by WWDT counter time-out reset system event.or not.
N     * |        |          |0 = WWDT time-out reset system event did not occur.
N     * |        |          |1 = WWDT time-out reset system event occurred.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * @var WWDT_T::CNT
N     * Offset: 0x0C  WWDT Counter Value Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |CNTDAT    |WWDT Counter Value
N     * |        |          |CNTDAT will be updated continuously to monitor 6-bit WWDT down counter value.
N     */
N    __O  uint32_t RLDCNT;                /*!< [0x0000] WWDT Reload Counter Register                                     */
X    volatile  uint32_t RLDCNT;                 
N    __IO uint32_t CTL;                   /*!< [0x0004] WWDT Control Register                                            */
X    volatile uint32_t CTL;                    
N    __IO uint32_t STATUS;                /*!< [0x0008] WWDT Status Register                                             */
X    volatile uint32_t STATUS;                 
N    __I  uint32_t CNT;                   /*!< [0x000c] WWDT Counter Value Register                                      */
X    volatile const  uint32_t CNT;                    
N
N} WWDT_T;
N
N/**
N    @addtogroup WWDT_CONST WWDT Bit Field Definition
N    Constant Definitions for WWDT Controller
N@{ */
N
N#define WWDT_RLDCNT_RLDCNT_Pos           (0)                                               /*!< WWDT_T::RLDCNT: RLDCNT Position        */
N#define WWDT_RLDCNT_RLDCNT_Msk           (0xfffffffful << WWDT_RLDCNT_RLDCNT_Pos)          /*!< WWDT_T::RLDCNT: RLDCNT Mask            */
N
N#define WWDT_CTL_WWDTEN_Pos              (0)                                               /*!< WWDT_T::CTL: WWDTEN Position           */
N#define WWDT_CTL_WWDTEN_Msk              (0x1ul << WWDT_CTL_WWDTEN_Pos)                    /*!< WWDT_T::CTL: WWDTEN Mask               */
N
N#define WWDT_CTL_INTEN_Pos               (1)                                               /*!< WWDT_T::CTL: INTEN Position            */
N#define WWDT_CTL_INTEN_Msk               (0x1ul << WWDT_CTL_INTEN_Pos)                     /*!< WWDT_T::CTL: INTEN Mask                */
N
N#define WWDT_CTL_PSCSEL_Pos              (8)                                               /*!< WWDT_T::CTL: PSCSEL Position           */
N#define WWDT_CTL_PSCSEL_Msk              (0xful << WWDT_CTL_PSCSEL_Pos)                    /*!< WWDT_T::CTL: PSCSEL Mask               */
N
N#define WWDT_CTL_CMPDAT_Pos              (16)                                              /*!< WWDT_T::CTL: CMPDAT Position           */
N#define WWDT_CTL_CMPDAT_Msk              (0x3ful << WWDT_CTL_CMPDAT_Pos)                   /*!< WWDT_T::CTL: CMPDAT Mask               */
N
N#define WWDT_CTL_ICEDEBUG_Pos            (31)                                              /*!< WWDT_T::CTL: ICEDEBUG Position         */
N#define WWDT_CTL_ICEDEBUG_Msk            (0x1ul << WWDT_CTL_ICEDEBUG_Pos)                  /*!< WWDT_T::CTL: ICEDEBUG Mask             */
N
N#define WWDT_STATUS_WWDTIF_Pos           (0)                                               /*!< WWDT_T::STATUS: WWDTIF Position        */
N#define WWDT_STATUS_WWDTIF_Msk           (0x1ul << WWDT_STATUS_WWDTIF_Pos)                 /*!< WWDT_T::STATUS: WWDTIF Mask            */
N
N#define WWDT_STATUS_WWDTRF_Pos           (1)                                               /*!< WWDT_T::STATUS: WWDTRF Position        */
N#define WWDT_STATUS_WWDTRF_Msk           (0x1ul << WWDT_STATUS_WWDTRF_Pos)                 /*!< WWDT_T::STATUS: WWDTRF Mask            */
N
N#define WWDT_CNT_CNTDAT_Pos              (0)                                               /*!< WWDT_T::CNT: CNTDAT Position           */
N#define WWDT_CNT_CNTDAT_Msk              (0x3ful << WWDT_CNT_CNTDAT_Pos)                   /*!< WWDT_T::CNT: CNTDAT Mask               */
N
N/**@}*/ /* WWDT_CONST */
N/**@}*/ /* end of WWDT register group */
N
N
N/**@}*/ /* end of REGISTER group */
N
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/** @addtogroup PERIPHERAL_BASE Peripheral Memory Base
N  Memory Mapped Structure for Series Peripheral
N  @{
N */
N/* Peripheral and SRAM base address */
N#define FLASH_BASE          ((     uint32_t)0x00000000)
N#define SRAM_BASE           ((     uint32_t)0x20000000)
N#define AHB_BASE            ((     uint32_t)0x50000000)
N#define APB1_BASE           ((     uint32_t)0x40000000)
N#define APB2_BASE           ((     uint32_t)0x40100000)
N
N/* Peripheral memory map */
N#define GPIO_BASE           (AHB_BASE       + 0x4000)                   /*!< GPIO Base Address                                   */
N#define PA_BASE             (GPIO_BASE              )                   /*!< GPIO PA Base Address                                */
N#define PB_BASE             (GPIO_BASE      + 0x0040)                   /*!< GPIO PB Base Address                                */
N#define PC_BASE             (GPIO_BASE      + 0x0080)                   /*!< GPIO PC Base Address                                */
N#define PD_BASE             (GPIO_BASE      + 0x00C0)                   /*!< GPIO PD Base Address                                */
N#define PE_BASE             (GPIO_BASE      + 0x0100)                   /*!< GPIO PE Base Address                                */
N#define PF_BASE             (GPIO_BASE      + 0x0140)                   /*!< GPIO PF Base Address                                */
N#define GPIO_DBCTL_BASE     (GPIO_BASE      + 0x0180)                   /*!< GPIO De-bounce Cycle Control Base Address           */
N#define GPIO_PIN_DATA_BASE  (GPIO_BASE      + 0x0200)                   /*!< GPIO Pin Data Input/Output Control Base Address     */
N
N#define UART0_BASE          (APB1_BASE      + 0x50000)                  /*!< UART0 Base Address                               */
N#define UART1_BASE          (APB2_BASE      + 0x50000)                  /*!< UART1 Base Address                               */
N#define UART2_BASE          (APB2_BASE      + 0x54000)                  /*!< UART2 Base Address                               */
N
N#define TIMER0_BASE         (APB1_BASE      + 0x10000)                  /*!< Timer0 Base Address                              */
N#define TIMER1_BASE         (APB1_BASE      + 0x10100)                  /*!< Timer1 Base Address                              */
N#define TIMER2_BASE         (APB2_BASE      + 0x10000)                  /*!< Timer2 Base Address                              */
N#define TIMER3_BASE         (APB2_BASE      + 0x10100)                  /*!< Timer3 Base Address                              */
N
N#define WDT_BASE            (APB1_BASE      + 0x4000)                   /*!< Watch Dog Timer Base Address                     */
N
N#define WWDT_BASE           (APB1_BASE      + 0x4100)                   /*!< Window Watch Dog Timer Base Address              */
N
N#define SPI0_BASE           (APB1_BASE      + 0x30000)                  /*!< SPI0 Base Address                                */
N#define SPI1_BASE           (APB1_BASE      + 0x34000)                  /*!< SPI1 Base Address                                */
N
N#define I2C0_BASE           (APB1_BASE      + 0x20000)                  /*!< I2C0 Base Address                                */
N#define I2C1_BASE           (APB2_BASE      + 0x20000)                  /*!< I2C1 Base Address                                */
N
N#define RTC_BASE            (APB1_BASE      + 0x08000)                  /*!< RTC Base Address                                 */
N
N#define ADC_BASE            (APB1_BASE      + 0xE0000)                  /*!< ADC Base Address                                 */
N
N#define ACMP01_BASE         (APB1_BASE      + 0xD0000)                  /*!< ACMP01 Base Address                              */
N
N#define CLK_BASE            (AHB_BASE       + 0x00200)                  /*!< System Clock Controller Base Address             */
N
N#define SYS_BASE            (AHB_BASE       + 0x00000)                  /*!< System Global Controller Base Address            */
N
N#define INT_BASE            (AHB_BASE       + 0x00300)                  /*!< Interrupt Source Controller Base Address         */
N
N#define FMC_BASE            (AHB_BASE       + 0x0C000)                  /*!< Flash Memory Controller Base Address             */
N
N#define PWM0_BASE           (APB1_BASE      + 0x40000)                  /*!< PWM0 Base Address                                */
N#define PWM1_BASE           (APB2_BASE      + 0x40000)                  /*!< PWM1 Base Address                                */
N
N#define SC0_BASE            (APB2_BASE      + 0x90000)                  /*!< SC0 Base Address                                 */
N#define SC1_BASE            (APB2_BASE      + 0x94000)                  /*!< SC1 Base Address                                 */
N
N#define EBI_BASE            (AHB_BASE       + 0x10000)                  /*!< EBI Base Address                                 */
N
N#define HDIV_BASE           (AHB_BASE       + 0x14000)                  /*!< HDIV Base Address                                */
N
N#define CRC_BASE            (AHB_BASE       + 0x18000)                  /*!< CRC Base Address                                 */
N
N#define USBD_BASE           (APB1_BASE      + 0x60000)                  /*!< USB Device Base Address                          */
N
N#define PDMA_BASE           (AHB_BASE       + 0x08000)                  /*!< PDMA Base Address                                */
N
N
N#define USCI0_BASE           (APB1_BASE      + 0x70000)
N#define USCI1_BASE           (APB2_BASE      + 0x70000)
N#define USCI2_BASE           (APB1_BASE      + 0x74000)
N
N/**@}*/ /* PERIPHERAL */
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N
N/** @addtogroup PMODULE Peripheral Pointer
N  The Declaration of Peripheral Pointer
N  @{
N */
N#define PA                  ((GPIO_T *) PA_BASE)                        /*!< GPIO PORTA Configuration Struct                        */
N#define PB                  ((GPIO_T *) PB_BASE)                        /*!< GPIO PORTB Configuration Struct                        */
N#define PC                  ((GPIO_T *) PC_BASE)                        /*!< GPIO PORTC Configuration Struct                        */
N#define PD                  ((GPIO_T *) PD_BASE)                        /*!< GPIO PORTD Configuration Struct                        */
N#define PE                  ((GPIO_T *) PE_BASE)                        /*!< GPIO PORTE Configuration Struct                        */
N#define PF                  ((GPIO_T *) PF_BASE)                        /*!< GPIO PORTF Configuration Struct                        */
N#define GPIO                ((GPIO_DBCTL_T *) GPIO_DBCTL_BASE)          /*!< Interrupt De-bounce Cycle Control Configuration Struct */
N
N#define UART0               ((UART_T *) UART0_BASE)                     /*!< UART0 Configuration Struct                       */
N#define UART1               ((UART_T *) UART1_BASE)                     /*!< UART1 Configuration Struct                       */
N#define UART2               ((UART_T *) UART2_BASE)                     /*!< UART2 Configuration Struct                       */
N
N#define TIMER0              ((TIMER_T *) TIMER0_BASE)                   /*!< TIMER0 Configuration Struct                      */
N#define TIMER1              ((TIMER_T *) TIMER1_BASE)                   /*!< TIMER1 Configuration Struct                      */
N#define TIMER2              ((TIMER_T *) TIMER2_BASE)                   /*!< TIMER2 Configuration Struct                      */
N#define TIMER3              ((TIMER_T *) TIMER3_BASE)                   /*!< TIMER3 Configuration Struct                      */
N
N#define WDT                 ((WDT_T *) WDT_BASE)                        /*!< Watch Dog Timer Configuration Struct             */
N
N#define WWDT                ((WWDT_T *) WWDT_BASE)                      /*!< Window Watch Dog Timer Configuration Struct      */
N
N#define SPI0                ((SPI_T *) SPI0_BASE)                       /*!< SPI0 Configuration Struct                        */
N#define SPI1                ((SPI_T *) SPI1_BASE)                       /*!< SPI1 Configuration Struct                        */
N
N#define I2C0                ((I2C_T *) I2C0_BASE)                       /*!< I2C0 Configuration Struct                        */
N#define I2C1                ((I2C_T *) I2C1_BASE)                       /*!< I2C1 Configuration Struct                        */
N
N#define RTC                 ((RTC_T *) RTC_BASE)                        /*!< RTC Configuration Struct                         */
N
N#define ADC                 ((ADC_T *) ADC_BASE)                        /*!< ADC Configuration Struct                         */
N
N#define ACMP01              ((ACMP_T *) ACMP01_BASE)                    /*!< ACMP01 Configuration Struct                      */
N
N#define CLK                 ((CLK_T *) CLK_BASE)                        /*!< System Clock Controller Configuration Struct     */
N
N#define SYS                 ((SYS_T *) SYS_BASE)                        /*!< System Global Controller Configuration Struct    */
N
N#define SYSINT              ((SYS_INT_T *) INT_BASE)                    /*!< Interrupt Source Controller Configuration Struct */
N
N#define FMC                 ((FMC_T *) FMC_BASE)                        /*!< Flash Memory Controller */
N
N#define PWM0                ((PWM_T *) PWM0_BASE)                       /*!< PWM0 Configuration Struct                        */
N#define PWM1                ((PWM_T *) PWM1_BASE)                       /*!< PWM1 Configuration Struct                        */
N
N#define SC0                 ((SC_T *) SC0_BASE)                         /*!< SC0 Configuration Struct                         */
N#define SC1                 ((SC_T *) SC1_BASE)                         /*!< SC1 Configuration Struct                         */
N
N#define EBI                 ((EBI_T *) EBI_BASE)                        /*!< EBI Configuration Struct                         */
N
N#define HDIV                ((HDIV_T *) HDIV_BASE)                      /*!< HDIV Configuration Struct                        */
N
N#define CRC                 ((CRC_T *) CRC_BASE)                        /*!< CRC Configuration Struct                         */
N
N#define USBD                ((USBD_T *) USBD_BASE)                      /*!< USB Device Configuration Struct                  */
N
N#define PDMA                ((PDMA_T *) PDMA_BASE)                      /*!< PDMA Configuration Struct                        */
N
N#define UI2C0               ((UI2C_T *) USCI0_BASE)                     /*!< UI2C0 Configuration Struct                       */
N#define UI2C1               ((UI2C_T *) USCI1_BASE)                     /*!< UI2C1 Configuration Struct                       */
N#define UI2C2               ((UI2C_T *) USCI2_BASE)                     /*!< UI2C2 Configuration Struct                       */
N
N#define USPI0               ((USPI_T *) USCI0_BASE)                     /*!< USPI0 Configuration Struct                       */
N#define USPI1               ((USPI_T *) USCI1_BASE)                     /*!< USPI1 Configuration Struct                       */
N#define USPI2               ((USPI_T *) USCI2_BASE)                     /*!< USPI2 Configuration Struct                       */
N
N#define UUART0              ((UUART_T *) USCI0_BASE)                    /*!< UUART0 Configuration Struct                      */
N#define UUART1              ((UUART_T *) USCI1_BASE)                    /*!< UUART1 Configuration Struct                      */
N#define UUART2              ((UUART_T *) USCI2_BASE)                    /*!< UUART2 Configuration Struct                      */
N/**@}*/ /* end of group PMODULE */
N
N
N//=============================================================================
Ntypedef volatile unsigned char  vu8;
Ntypedef volatile unsigned long  vu32;
Ntypedef volatile unsigned short vu16;
N#define M8(adr)  (*((vu8  *) (adr)))
N#define M16(adr) (*((vu16 *) (adr)))
N#define M32(adr) (*((vu32 *) (adr)))
N
N#define outpw(port,value)   (*((volatile unsigned int *)(port))=(value))
N#define inpw(port)          ((*((volatile unsigned int *)(port))))
N#define outpb(port,value)   (*((volatile unsigned char *)(port))=(value))
N#define inpb(port)          ((*((volatile unsigned char *)(port))))
N#define outps(port,value)   (*((volatile unsigned short *)(port))=(value))
N#define inps(port)          ((*((volatile unsigned short *)(port))))
N
N#define outp32(port,value)  (*((volatile unsigned int *)(port))=(value))
N#define inp32(port)         ((*((volatile unsigned int *)(port))))
N#define outp8(port,value)   (*((volatile unsigned char *)(port))=(value))
N#define inp8(port)          ((*((volatile unsigned char *)(port))))
N#define outp16(port,value)  (*((volatile unsigned short *)(port))=(value))
N#define inp16(port)         ((*((volatile unsigned short *)(port))))
N
N
N#define E_SUCCESS   0
N#ifndef NULL
S#define NULL        0
N#endif
N
N#define TRUE        1
N#define FALSE       0
N
N#define ENABLE      1
N#define DISABLE     0
N
N/* Bit Mask Definitions */
N#define BIT0    0x00000001
N#define BIT1    0x00000002
N#define BIT2    0x00000004
N#define BIT3    0x00000008
N#define BIT4    0x00000010
N#define BIT5    0x00000020
N#define BIT6    0x00000040
N#define BIT7    0x00000080
N#define BIT8    0x00000100
N#define BIT9    0x00000200
N#define BIT10   0x00000400
N#define BIT11   0x00000800
N#define BIT12   0x00001000
N#define BIT13   0x00002000
N#define BIT14   0x00004000
N#define BIT15   0x00008000
N#define BIT16   0x00010000
N#define BIT17   0x00020000
N#define BIT18   0x00040000
N#define BIT19   0x00080000
N#define BIT20   0x00100000
N#define BIT21   0x00200000
N#define BIT22   0x00400000
N#define BIT23   0x00800000
N#define BIT24   0x01000000
N#define BIT25   0x02000000
N#define BIT26   0x04000000
N#define BIT27   0x08000000
N#define BIT28   0x10000000
N#define BIT29   0x20000000
N#define BIT30   0x40000000
N#define BIT31   0x80000000
N
N
N/* Byte Mask Definitions */
N#define BYTE0_Msk               (0x000000FF)
N#define BYTE1_Msk               (0x0000FF00)
N#define BYTE2_Msk               (0x00FF0000)
N#define BYTE3_Msk               (0xFF000000)
N
N#define _GET_BYTE0(u32Param)    (((u32Param) & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
N#define _GET_BYTE1(u32Param)    (((u32Param) & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
N#define _GET_BYTE2(u32Param)    (((u32Param) & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
N#define _GET_BYTE3(u32Param)    (((u32Param) & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
N
N
N/******************************************************************************/
N/*                         Peripheral header files                            */
N/******************************************************************************/
N#include "sys.h"
L 1 "..\lib\StdDriver\inc\sys.h" 1
N/**************************************************************************//**
N * @file     SYS.h
N * @version  V3
N * $Revision: 18 $
N * $Date: 17/04/28 5:38p $
N * @brief    NUC029xGE series System Manager (SYS) driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __SYS_H__
N#define __SYS_H__
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup SYS_Driver SYS Driver
N  @{
N*/
N
N/** @addtogroup SYS_EXPORTED_CONSTANTS SYS Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Module Reset Control Resister constant definitions.                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_RST    ((0x0<<24)|SYS_IPRST0_PDMARST_Pos)      /*!< PDMA reset is one of the SYS_ResetModule parameter */
N#define EBI_RST     ((0x0<<24)|SYS_IPRST0_EBIRST_Pos)       /*!< EBI reset is one of the SYS_ResetModule parameter */
N#define HDIV_RST    ((0x0<<24)|SYS_IPRST0_HDIVRST_Pos)      /*!< HDIV reset is one of the SYS_ResetModule parameter */
N#define CRC_RST     ((0x0<<24)|SYS_IPRST0_CRCRST_Pos)       /*!< CRC reset is one of the SYS_ResetModule parameter */
N
N#define GPIO_RST    ((0x4<<24)|SYS_IPRST1_GPIORST_Pos)      /*!< GPIO reset is one of the SYS_ResetModule parameter */
N#define TMR0_RST    ((0x4<<24)|SYS_IPRST1_TMR0RST_Pos)      /*!< TMR0 reset is one of the SYS_ResetModule parameter */
N#define TMR1_RST    ((0x4<<24)|SYS_IPRST1_TMR1RST_Pos)      /*!< TMR1 reset is one of the SYS_ResetModule parameter */
N#define TMR2_RST    ((0x4<<24)|SYS_IPRST1_TMR2RST_Pos)      /*!< TMR2 reset is one of the SYS_ResetModule parameter */
N#define TMR3_RST    ((0x4<<24)|SYS_IPRST1_TMR3RST_Pos)      /*!< TMR3 reset is one of the SYS_ResetModule parameter */
N#define I2C0_RST    ((0x4<<24)|SYS_IPRST1_I2C0RST_Pos)      /*!< I2C0 reset is one of the SYS_ResetModule parameter */
N#define I2C1_RST    ((0x4<<24)|SYS_IPRST1_I2C1RST_Pos)      /*!< I2C1 reset is one of the SYS_ResetModule parameter */
N#define SPI0_RST    ((0x4<<24)|SYS_IPRST1_SPI0RST_Pos)      /*!< SPI0 reset is one of the SYS_ResetModule parameter */
N#define SPI1_RST    ((0x4<<24)|SYS_IPRST1_SPI1RST_Pos)      /*!< SPI1 reset is one of the SYS_ResetModule parameter */
N#define UART0_RST   ((0x4<<24)|SYS_IPRST1_UART0RST_Pos)     /*!< UART0 reset is one of the SYS_ResetModule parameter */
N#define UART1_RST   ((0x4<<24)|SYS_IPRST1_UART1RST_Pos)     /*!< UART1 reset is one of the SYS_ResetModule parameter */
N#define UART2_RST   ((0x4<<24)|SYS_IPRST1_UART2RST_Pos)     /*!< UART2 reset is one of the SYS_ResetModule parameter */
N#define PWM0_RST    ((0x4<<24)|SYS_IPRST1_PWM0RST_Pos)      /*!< PWM0 reset is one of the SYS_ResetModule parameter */
N#define PWM1_RST    ((0x4<<24)|SYS_IPRST1_PWM1RST_Pos)      /*!< PWM1 reset is one of the SYS_ResetModule parameter */
N#define ACMP01_RST  ((0x4<<24)|SYS_IPRST1_ACMP01RST_Pos)    /*!< ACMP01 reset is one of the SYS_ResetModule parameter */
N#define USBD_RST    ((0x4<<24)|SYS_IPRST1_USBDRST_Pos)      /*!< USBD reset is one of the SYS_ResetModule parameter */
N#define ADC_RST     ((0x4<<24)|SYS_IPRST1_ADCRST_Pos)       /*!< ADC reset is one of the SYS_ResetModule parameter */
N
N#define SC0_RST     ((0x8<<24)|SYS_IPRST2_SC0RST_Pos)       /*!< SC0 reset is one of the SYS_ResetModule parameter */
N#define SC1_RST     ((0x8<<24)|SYS_IPRST2_SC1RST_Pos)       /*!< SC1 reset is one of the SYS_ResetModule parameter */
N#define USCI0_RST   ((0x8<<24)|SYS_IPRST2_USCI0RST_Pos)     /*!< USCI0 reset is one of the SYS_ResetModule parameter */
N#define USCI1_RST   ((0x8<<24)|SYS_IPRST2_USCI1RST_Pos)     /*!< USCI1 reset is one of the SYS_ResetModule parameter */
N#define USCI2_RST   ((0x8<<24)|SYS_IPRST2_USCI2RST_Pos)     /*!< USCI2 reset is one of the SYS_ResetModule parameter */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Brown Out Detector Threshold Voltage Selection constant definitions.                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYS_BODCTL_BOD_RST_EN           (1UL<<SYS_BODCTL_BODRSTEN_Pos)    /*!< Brown-out Reset Enable */
N#define SYS_BODCTL_BOD_INTERRUPT_EN     (0UL<<SYS_BODCTL_BODRSTEN_Pos)    /*!< Brown-out Interrupt Enable */
N#define SYS_BODCTL_BODVL_4_5V           (3UL<<SYS_BODCTL_BODVL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 4.5V */
N#define SYS_BODCTL_BODVL_3_7V           (2UL<<SYS_BODCTL_BODVL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 3.7V */
N#define SYS_BODCTL_BODVL_2_7V           (1UL<<SYS_BODCTL_BODVL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 2.7V */
N#define SYS_BODCTL_BODVL_2_2V           (0UL<<SYS_BODCTL_BODVL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 2.2V */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  VREFCTL constant definitions. (Write-Protection Register)                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYS_VREFCTL_VREF_PIN        (0x0UL<<SYS_VREFCTL_VREFCTL_Pos)    /*!< Vref = Vref pin */
N#define SYS_VREFCTL_VREF_2_56V      (0x3UL<<SYS_VREFCTL_VREFCTL_Pos)    /*!< Vref = 2.56V */
N#define SYS_VREFCTL_VREF_2_048V     (0x7UL<<SYS_VREFCTL_VREFCTL_Pos)    /*!< Vref = 2.048V */
N#define SYS_VREFCTL_VREF_3_072V     (0xBUL<<SYS_VREFCTL_VREFCTL_Pos)    /*!< Vref = 3.072V */
N#define SYS_VREFCTL_VREF_4_096V     (0xFUL<<SYS_VREFCTL_VREFCTL_Pos)    /*!< Vref = 4.096V */
N#define SYS_VREFCTL_VREF_AVDD       (0x10UL<<SYS_VREFCTL_VREFCTL_Pos)   /*!< Vref = AVDD */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Multi-Function constant definitions.                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/* How to use below #define?
N
NExample: If user want to set PA.2 as UART0_TXD and PA.3 as UART0_RXD in initial function,
N         user can issue following command to achieve it.
N
N         SYS->GPA_MFPL = (SYS->GPA_MFPL & (~SYS_GPA_MFPL_PA2MFP_Msk)) | SYS_GPA_MFPL_PA2MFP_UART0_TXD;
N         SYS->GPA_MFPL = (SYS->GPA_MFPL & (~SYS_GPA_MFPL_PA3MFP_Msk)) | SYS_GPA_MFPL_PA3MFP_UART0_RXD;
N*/
N
N//PA.0 MFP
N#define SYS_GPA_MFPL_PA0MFP_GPIO            (0x0UL<<SYS_GPA_MFPL_PA0MFP_Pos)    /*!< GPA_MFPL PA0 setting for GPIO           */
N#define SYS_GPA_MFPL_PA0MFP_UART1_nCTS      (0x1UL<<SYS_GPA_MFPL_PA0MFP_Pos)    /*!< GPA_MFPL PA0 setting for UART1_nCTS     */
N#define SYS_GPA_MFPL_PA0MFP_UART1_TXD       (0x3UL<<SYS_GPA_MFPL_PA0MFP_Pos)    /*!< GPA_MFPL PA0 setting for UART1_TXD      */
N#define SYS_GPA_MFPL_PA0MFP_USCI1_CTL0      (0x4UL<<SYS_GPA_MFPL_PA0MFP_Pos)    /*!< GPA_MFPL PA0 setting for USCI1_CTL0     */
N#define SYS_GPA_MFPL_PA0MFP_SC0_CLK         (0x5UL<<SYS_GPA_MFPL_PA0MFP_Pos)    /*!< GPA_MFPL PA0 setting for SC0_CLK        */
N#define SYS_GPA_MFPL_PA0MFP_PWM1_CH5        (0x6UL<<SYS_GPA_MFPL_PA0MFP_Pos)    /*!< GPA_MFPL PA0 setting for PWM1_CH5       */
N#define SYS_GPA_MFPL_PA0MFP_EBI_AD0         (0x7UL<<SYS_GPA_MFPL_PA0MFP_Pos)    /*!< GPA_MFPL PA0 setting for EBI_AD0        */
N#define SYS_GPA_MFPL_PA0MFP_INT0            (0x8UL<<SYS_GPA_MFPL_PA0MFP_Pos)    /*!< GPA_MFPL PA0 setting for INT0           */
N
N//PA.1 MFP
N#define SYS_GPA_MFPL_PA1MFP_GPIO            (0x0UL<<SYS_GPA_MFPL_PA1MFP_Pos)    /*!< GPA_MFPL PA1 setting for GPIO           */
N#define SYS_GPA_MFPL_PA1MFP_UART1_nRTS      (0x1UL<<SYS_GPA_MFPL_PA1MFP_Pos)    /*!< GPA_MFPL PA1 setting for UART1_nRTS     */
N#define SYS_GPA_MFPL_PA1MFP_UART1_RXD       (0x3UL<<SYS_GPA_MFPL_PA1MFP_Pos)    /*!< GPA_MFPL PA1 setting for UART1_RXD      */
N#define SYS_GPA_MFPL_PA1MFP_USCI1_CTL1      (0x4UL<<SYS_GPA_MFPL_PA1MFP_Pos)    /*!< GPA_MFPL PA1 setting for USCI1_CTL1     */
N#define SYS_GPA_MFPL_PA1MFP_SC0_DAT         (0x5UL<<SYS_GPA_MFPL_PA1MFP_Pos)    /*!< GPA_MFPL PA1 setting for SC0_DAT        */
N#define SYS_GPA_MFPL_PA1MFP_PWM1_CH4        (0x6UL<<SYS_GPA_MFPL_PA1MFP_Pos)    /*!< GPA_MFPL PA1 setting for PWM1_CH4       */
N#define SYS_GPA_MFPL_PA1MFP_EBI_AD1         (0x7UL<<SYS_GPA_MFPL_PA1MFP_Pos)    /*!< GPA_MFPL PA1 setting for EBI_AD1        */
N
N//PA.2 MFP
N#define SYS_GPA_MFPL_PA2MFP_GPIO            (0x0UL<<SYS_GPA_MFPL_PA2MFP_Pos)    /*!< GPA_MFPL PA2 setting for GPIO           */
N#define SYS_GPA_MFPL_PA2MFP_UART0_TXD       (0x2UL<<SYS_GPA_MFPL_PA2MFP_Pos)    /*!< GPA_MFPL PA2 setting for UART0_TXD      */
N#define SYS_GPA_MFPL_PA2MFP_UART0_nCTS      (0x3UL<<SYS_GPA_MFPL_PA2MFP_Pos)    /*!< GPA_MFPL PA2 setting for UART0_nCTS     */
N#define SYS_GPA_MFPL_PA2MFP_I2C0_SDA        (0x4UL<<SYS_GPA_MFPL_PA2MFP_Pos)    /*!< GPA_MFPL PA2 setting for I2C0_SDA       */
N#define SYS_GPA_MFPL_PA2MFP_SC0_RST         (0x5UL<<SYS_GPA_MFPL_PA2MFP_Pos)    /*!< GPA_MFPL PA2 setting for SC0_RST        */
N#define SYS_GPA_MFPL_PA2MFP_PWM1_CH3        (0x6UL<<SYS_GPA_MFPL_PA2MFP_Pos)    /*!< GPA_MFPL PA2 setting for PWM1_CH3       */
N#define SYS_GPA_MFPL_PA2MFP_EBI_AD2         (0x7UL<<SYS_GPA_MFPL_PA2MFP_Pos)    /*!< GPA_MFPL PA2 setting for EBI_AD2        */
N#define SYS_GPA_MFPL_PA2MFP_USCI1_CTL0      (0x8UL<<SYS_GPA_MFPL_PA2MFP_Pos)    /*!< GPA_MFPL PA2 setting for USCI1_CTL0     */
N
N//PA.3 MFP
N#define SYS_GPA_MFPL_PA3MFP_GPIO            (0x0UL<<SYS_GPA_MFPL_PA3MFP_Pos)    /*!< GPA_MFPL PA3 setting for GPIO           */
N#define SYS_GPA_MFPL_PA3MFP_UART0_RXD       (0x2UL<<SYS_GPA_MFPL_PA3MFP_Pos)    /*!< GPA_MFPL PA3 setting for UART0_RXD      */
N#define SYS_GPA_MFPL_PA3MFP_UART0_nRTS      (0x3UL<<SYS_GPA_MFPL_PA3MFP_Pos)    /*!< GPA_MFPL PA3 setting for UART0_nRTS     */
N#define SYS_GPA_MFPL_PA3MFP_I2C0_SCL        (0x4UL<<SYS_GPA_MFPL_PA3MFP_Pos)    /*!< GPA_MFPL PA3 setting for I2C0_SCL       */
N#define SYS_GPA_MFPL_PA3MFP_SC0_PWR         (0x5UL<<SYS_GPA_MFPL_PA3MFP_Pos)    /*!< GPA_MFPL PA3 setting for SC0_PWR        */
N#define SYS_GPA_MFPL_PA3MFP_PWM1_CH2        (0x6UL<<SYS_GPA_MFPL_PA3MFP_Pos)    /*!< GPA_MFPL PA3 setting for PWM1_CH2       */
N#define SYS_GPA_MFPL_PA3MFP_EBI_AD3         (0x7UL<<SYS_GPA_MFPL_PA3MFP_Pos)    /*!< GPA_MFPL PA3 setting for EBI_AD3        */
N#define SYS_GPA_MFPL_PA3MFP_USCI1_CLK       (0x8UL<<SYS_GPA_MFPL_PA3MFP_Pos)    /*!< GPA_MFPL PA3 setting for USCI1_CLK      */
N
N//PA.4 MFP
N#define SYS_GPA_MFPL_PA4MFP_GPIO            (0x0UL<<SYS_GPA_MFPL_PA4MFP_Pos)    /*!< GPA_MFPL PA4 setting for GPIO           */
N#define SYS_GPA_MFPL_PA4MFP_SPI1_SS         (0x2UL<<SYS_GPA_MFPL_PA4MFP_Pos)    /*!< GPA_MFPL PA4 setting for SPI1_SS        */
N#define SYS_GPA_MFPL_PA4MFP_TM3_EXT         (0x3UL<<SYS_GPA_MFPL_PA4MFP_Pos)    /*!< GPA_MFPL PA4 setting for TM3_EXT        */
N#define SYS_GPA_MFPL_PA4MFP_EBI_AD4         (0x7UL<<SYS_GPA_MFPL_PA4MFP_Pos)    /*!< GPA_MFPL PA4 setting for EBI_AD4        */
N
N//PA.5 MFP
N#define SYS_GPA_MFPL_PA5MFP_GPIO            (0x0UL<<SYS_GPA_MFPL_PA5MFP_Pos)    /*!< GPA_MFPL PA5 setting for GPIO           */
N#define SYS_GPA_MFPL_PA5MFP_SPI1_MOSI       (0x2UL<<SYS_GPA_MFPL_PA5MFP_Pos)    /*!< GPA_MFPL PA5 setting for SPI1_MOSI      */
N#define SYS_GPA_MFPL_PA5MFP_TM2_EXT         (0x3UL<<SYS_GPA_MFPL_PA5MFP_Pos)    /*!< GPA_MFPL PA5 setting for TM2_EXT        */
N#define SYS_GPA_MFPL_PA5MFP_TM_BRAKE3       (0x6UL<<SYS_GPA_MFPL_PA5MFP_Pos)    /*!< GPA_MFPL PA5 setting for TM_BRAKE3      */
N#define SYS_GPA_MFPL_PA5MFP_EBI_AD5         (0x7UL<<SYS_GPA_MFPL_PA5MFP_Pos)    /*!< GPA_MFPL PA5 setting for EBI_AD5        */
N
N//PA.6 MFP
N#define SYS_GPA_MFPL_PA6MFP_GPIO            (0x0UL<<SYS_GPA_MFPL_PA6MFP_Pos)    /*!< GPA_MFPL PA6 setting for GPIO           */
N#define SYS_GPA_MFPL_PA6MFP_SPI1_MISO       (0x2UL<<SYS_GPA_MFPL_PA6MFP_Pos)    /*!< GPA_MFPL PA6 setting for SPI1_MISO      */
N#define SYS_GPA_MFPL_PA6MFP_TM1_EXT         (0x3UL<<SYS_GPA_MFPL_PA6MFP_Pos)    /*!< GPA_MFPL PA6 setting for TM1_EXT        */
N#define SYS_GPA_MFPL_PA6MFP_TM_BRAKE2       (0x6UL<<SYS_GPA_MFPL_PA6MFP_Pos)    /*!< GPA_MFPL PA6 setting for TM_BRAKE2      */
N#define SYS_GPA_MFPL_PA6MFP_EBI_AD6         (0x7UL<<SYS_GPA_MFPL_PA6MFP_Pos)    /*!< GPA_MFPL PA6 setting for EBI_AD6        */
N
N//PA.7 MFP
N#define SYS_GPA_MFPL_PA7MFP_GPIO            (0x0UL<<SYS_GPA_MFPL_PA7MFP_Pos)    /*!< GPA_MFPL PA7 setting for GPIO           */
N#define SYS_GPA_MFPL_PA7MFP_SPI1_CLK        (0x2UL<<SYS_GPA_MFPL_PA7MFP_Pos)    /*!< GPA_MFPL PA7 setting for SPI1_CLK       */
N#define SYS_GPA_MFPL_PA7MFP_TM0_EXT         (0x3UL<<SYS_GPA_MFPL_PA7MFP_Pos)    /*!< GPA_MFPL PA7 setting for TM0_EXT        */
N#define SYS_GPA_MFPL_PA7MFP_TM_BRAKE1       (0x6UL<<SYS_GPA_MFPL_PA7MFP_Pos)    /*!< GPA_MFPL PA7 setting for TM_BRAKE1      */
N#define SYS_GPA_MFPL_PA7MFP_EBI_AD7         (0x7UL<<SYS_GPA_MFPL_PA7MFP_Pos)    /*!< GPA_MFPL PA7 setting for EBI_AD7        */
N
N//PA.8 MFP
N#define SYS_GPA_MFPH_PA8MFP_GPIO            (0x0UL<<SYS_GPA_MFPH_PA8MFP_Pos)    /*!< GPA_MFPH PA8 setting for GPIO           */
N#define SYS_GPA_MFPH_PA8MFP_CLKO            (0x1UL<<SYS_GPA_MFPH_PA8MFP_Pos)    /*!< GPA_MFPH PA8 setting for CLKO           */
N#define SYS_GPA_MFPH_PA8MFP_I2C1_SCL        (0x2UL<<SYS_GPA_MFPH_PA8MFP_Pos)    /*!< GPA_MFPH PA8 setting for I2C1_SCL       */
N#define SYS_GPA_MFPH_PA8MFP_UART1_TXD       (0x3UL<<SYS_GPA_MFPH_PA8MFP_Pos)    /*!< GPA_MFPH PA8 setting for UART1_TXD      */
N#define SYS_GPA_MFPH_PA8MFP_SC0_PWR         (0x4UL<<SYS_GPA_MFPH_PA8MFP_Pos)    /*!< GPA_MFPH PA8 setting for SC0_PWR        */
N#define SYS_GPA_MFPH_PA8MFP_SC1_RST         (0x5UL<<SYS_GPA_MFPH_PA8MFP_Pos)    /*!< GPA_MFPH PA8 setting for SC1_RST        */
N#define SYS_GPA_MFPH_PA8MFP_TM_BRAKE0       (0x6UL<<SYS_GPA_MFPH_PA8MFP_Pos)    /*!< GPA_MFPH PA8 setting for TM_BRAKE0      */
N#define SYS_GPA_MFPH_PA8MFP_PWM0_BRAKE0     (0x7UL<<SYS_GPA_MFPH_PA8MFP_Pos)    /*!< GPA_MFPH PA8 setting for PWM0_BRAKE0    */
N#define SYS_GPA_MFPH_PA8MFP_TM1             (0x8UL<<SYS_GPA_MFPH_PA8MFP_Pos)    /*!< GPA_MFPH PA8 setting for TM1            */
N
N//PA.9 MFP
N#define SYS_GPA_MFPH_PA9MFP_GPIO            (0x0UL<<SYS_GPA_MFPH_PA9MFP_Pos)    /*!< GPA_MFPH PA9 setting for GPIO           */
N#define SYS_GPA_MFPH_PA9MFP_SPI1_I2SMCLK    (0x1UL<<SYS_GPA_MFPH_PA9MFP_Pos)    /*!< GPA_MFPH PA9 setting for SPI1_I2SMCLK   */
N#define SYS_GPA_MFPH_PA9MFP_I2C1_SDA        (0x2UL<<SYS_GPA_MFPH_PA9MFP_Pos)    /*!< GPA_MFPH PA9 setting for I2C1_SDA       */
N#define SYS_GPA_MFPH_PA9MFP_UART1_RXD       (0x3UL<<SYS_GPA_MFPH_PA9MFP_Pos)    /*!< GPA_MFPH PA9 setting for UART1_RXD      */
N#define SYS_GPA_MFPH_PA9MFP_SC0_RST         (0x4UL<<SYS_GPA_MFPH_PA9MFP_Pos)    /*!< GPA_MFPH PA9 setting for SC0_RST        */
N#define SYS_GPA_MFPH_PA9MFP_SC1_PWR         (0x5UL<<SYS_GPA_MFPH_PA9MFP_Pos)    /*!< GPA_MFPH PA9 setting for SC1_PWR        */
N#define SYS_GPA_MFPH_PA9MFP_TM_BRAKE1       (0x6UL<<SYS_GPA_MFPH_PA9MFP_Pos)    /*!< GPA_MFPH PA9 setting for TM_BRAKE1      */
N#define SYS_GPA_MFPH_PA9MFP_PWM1_BRAKE1     (0x7UL<<SYS_GPA_MFPH_PA9MFP_Pos)    /*!< GPA_MFPH PA9 setting for PWM1_BRAKE1    */
N#define SYS_GPA_MFPH_PA9MFP_TM2             (0x8UL<<SYS_GPA_MFPH_PA9MFP_Pos)    /*!< GPA_MFPH PA9 setting for TM2            */
N
N//PA.10 MFP
N#define SYS_GPA_MFPH_PA10MFP_GPIO           (0x0UL<<SYS_GPA_MFPH_PA10MFP_Pos)   /*!< GPA_MFPH PA10 setting for GPIO          */
N#define SYS_GPA_MFPH_PA10MFP_UART1_nCTS     (0x3UL<<SYS_GPA_MFPH_PA10MFP_Pos)   /*!< GPA_MFPH PA10 setting for UART1_nCTS    */
N#define SYS_GPA_MFPH_PA10MFP_SC1_DAT        (0x5UL<<SYS_GPA_MFPH_PA10MFP_Pos)   /*!< GPA_MFPH PA10 setting for SC1_DAT       */
N
N//PA.11 MFP
N#define SYS_GPA_MFPH_PA11MFP_GPIO           (0x0UL<<SYS_GPA_MFPH_PA11MFP_Pos)   /*!< GPA_MFPH PA11 setting for GPIO          */
N#define SYS_GPA_MFPH_PA11MFP_UART1_nRTS     (0x3UL<<SYS_GPA_MFPH_PA11MFP_Pos)   /*!< GPA_MFPH PA11 setting for UART1_nRTS    */
N#define SYS_GPA_MFPH_PA11MFP_SC1_CLK        (0x5UL<<SYS_GPA_MFPH_PA11MFP_Pos)   /*!< GPA_MFPH PA11 setting for SC1_CLK       */
N
N//PA.12 MFP
N#define SYS_GPA_MFPH_PA12MFP_GPIO           (0x0UL<<SYS_GPA_MFPH_PA12MFP_Pos)   /*!< GPA_MFPH PA12 setting for GPIO          */
N#define SYS_GPA_MFPH_PA12MFP_SPI1_I2SMCLK   (0x2UL<<SYS_GPA_MFPH_PA12MFP_Pos)   /*!< GPA_MFPH PA12 setting for SPI1_I2SMCLK  */
N#define SYS_GPA_MFPH_PA12MFP_UART2_RXD      (0x3UL<<SYS_GPA_MFPH_PA12MFP_Pos)   /*!< GPA_MFPH PA12 setting for UART2_RXD     */
N#define SYS_GPA_MFPH_PA12MFP_UART1_RXD      (0x4UL<<SYS_GPA_MFPH_PA12MFP_Pos)   /*!< GPA_MFPH PA12 setting for UART1_RXD     */
N#define SYS_GPA_MFPH_PA12MFP_TM_BRAKE2      (0x6UL<<SYS_GPA_MFPH_PA12MFP_Pos)   /*!< GPA_MFPH PA12 setting for TM_BRAKE2     */
N
N//PA.13 MFP
N#define SYS_GPA_MFPH_PA13MFP_GPIO           (0x0UL<<SYS_GPA_MFPH_PA13MFP_Pos)   /*!< GPA_MFPH PA13 setting for GPIO          */
N#define SYS_GPA_MFPH_PA13MFP_UART2_TXD      (0x3UL<<SYS_GPA_MFPH_PA13MFP_Pos)   /*!< GPA_MFPH PA13 setting for UART2_TXD     */
N#define SYS_GPA_MFPH_PA13MFP_UART1_TXD      (0x4UL<<SYS_GPA_MFPH_PA13MFP_Pos)   /*!< GPA_MFPH PA13 setting for UART1_TXD     */
N#define SYS_GPA_MFPH_PA13MFP_TM_BRAKE3      (0x6UL<<SYS_GPA_MFPH_PA13MFP_Pos)   /*!< GPA_MFPH PA12 setting for TM_BRAKE3     */
N
N//PA.14 MFP
N#define SYS_GPA_MFPH_PA14MFP_GPIO           (0x0UL<<SYS_GPA_MFPH_PA14MFP_Pos)   /*!< GPA_MFPH PA14 setting for GPIO          */
N#define SYS_GPA_MFPH_PA14MFP_UART2_nCTS     (0x3UL<<SYS_GPA_MFPH_PA14MFP_Pos)   /*!< GPA_MFPH PA14 setting for UART2_nCTS    */
N#define SYS_GPA_MFPH_PA14MFP_USCI1_CTL1     (0x4UL<<SYS_GPA_MFPH_PA14MFP_Pos)   /*!< GPA_MFPH PA14 setting for USCI1_CTL1    */
N#define SYS_GPA_MFPH_PA14MFP_TM2            (0x6UL<<SYS_GPA_MFPH_PA14MFP_Pos)   /*!< GPA_MFPH PA14 setting for TM2           */
N
N//PA.15 MFP
N#define SYS_GPA_MFPH_PA15MFP_GPIO           (0x0UL<<SYS_GPA_MFPH_PA15MFP_Pos)   /*!< GPA_MFPH PA15 setting for GPIO          */
N#define SYS_GPA_MFPH_PA15MFP_UART2_nRTS     (0x3UL<<SYS_GPA_MFPH_PA15MFP_Pos)   /*!< GPA_MFPH PA15 setting for UART2_nRTS    */
N#define SYS_GPA_MFPH_PA15MFP_USCI1_CLK      (0x4UL<<SYS_GPA_MFPH_PA15MFP_Pos)   /*!< GPA_MFPH PA15 setting for USCI1_CLK     */
N#define SYS_GPA_MFPH_PA15MFP_TM3            (0x6UL<<SYS_GPA_MFPH_PA15MFP_Pos)   /*!< GPA_MFPH PA15 setting for TM3   */
N
N//PB.0 MFP
N#define SYS_GPB_MFPL_PB0MFP_GPIO            (0x0UL<<SYS_GPB_MFPL_PB0MFP_Pos)    /*!< GPB_MFPL PB0 setting for GPIO           */
N#define SYS_GPB_MFPL_PB0MFP_ADC0_CH0        (0x1UL<<SYS_GPB_MFPL_PB0MFP_Pos)    /*!< GPB_MFPL PB0 setting for ADC0_CH0       */
N#define SYS_GPB_MFPL_PB0MFP_VDET_P0         (0x2UL<<SYS_GPB_MFPL_PB0MFP_Pos)    /*!< GPB_MFPL PB0 setting for VDET_P0        */
N#define SYS_GPB_MFPL_PB0MFP_UART2_RXD       (0x3UL<<SYS_GPB_MFPL_PB0MFP_Pos)    /*!< GPB_MFPL PB0 setting for UART2_RXD      */
N#define SYS_GPB_MFPL_PB0MFP_TM2             (0x4UL<<SYS_GPB_MFPL_PB0MFP_Pos)    /*!< GPB_MFPL PB0 setting for TM2            */
N#define SYS_GPB_MFPL_PB0MFP_USCI1_DAT0      (0x6UL<<SYS_GPB_MFPL_PB0MFP_Pos)    /*!< GPB_MFPL PB0 setting for USCI1_DAT0     */
N#define SYS_GPB_MFPL_PB0MFP_EBI_nWRL        (0x7UL<<SYS_GPB_MFPL_PB0MFP_Pos)    /*!< GPB_MFPL PB0 setting for EBI_nWRL       */
N#define SYS_GPB_MFPL_PB0MFP_INT1            (0x8UL<<SYS_GPB_MFPL_PB0MFP_Pos)    /*!< GPB_MFPL PB0 setting for INT1           */
N#define SYS_GPB_MFPL_PB0MFP_TM1_EXT         (0xAUL<<SYS_GPB_MFPL_PB0MFP_Pos)    /*!< GPB_MFPL PB0 setting for TM1_EXT        */
N
N//PB.1 MFP
N#define SYS_GPB_MFPL_PB1MFP_GPIO            (0x0UL<<SYS_GPB_MFPL_PB1MFP_Pos)    /*!< GPB_MFPL PB1 setting for GPIO           */
N#define SYS_GPB_MFPL_PB1MFP_ADC0_CH1        (0x1UL<<SYS_GPB_MFPL_PB1MFP_Pos)    /*!< GPB_MFPL PB1 setting for ADC0_CH1       */
N#define SYS_GPB_MFPL_PB1MFP_VDET_P1         (0x2UL<<SYS_GPB_MFPL_PB1MFP_Pos)    /*!< GPB_MFPL PB1 setting for VDET_P1        */
N#define SYS_GPB_MFPL_PB1MFP_UART2_TXD       (0x3UL<<SYS_GPB_MFPL_PB1MFP_Pos)    /*!< GPB_MFPL PB1 setting for UART2_TXD      */
N#define SYS_GPB_MFPL_PB1MFP_TM3             (0x4UL<<SYS_GPB_MFPL_PB1MFP_Pos)    /*!< GPB_MFPL PB1 setting for TM3            */
N#define SYS_GPB_MFPL_PB1MFP_SC0_RST         (0x5UL<<SYS_GPB_MFPL_PB1MFP_Pos)    /*!< GPB_MFPL PB1 setting for SC0_RST        */
N#define SYS_GPB_MFPL_PB1MFP_PWM0_SYNC_OUT   (0x6UL<<SYS_GPB_MFPL_PB1MFP_Pos)    /*!< GPB_MFPL PB1 setting for PWM0_SYNC_OUT  */
N#define SYS_GPB_MFPL_PB1MFP_EBI_nWRH        (0x7UL<<SYS_GPB_MFPL_PB1MFP_Pos)    /*!< GPB_MFPL PB1 setting for EBI_nWRH       */
N#define SYS_GPB_MFPL_PB1MFP_USCI1_DAT1      (0x8UL<<SYS_GPB_MFPL_PB1MFP_Pos)    /*!< GPB_MFPL PB1 setting for USCI1_DAT1     */
N
N//PB.2 MFP
N#define SYS_GPB_MFPL_PB2MFP_GPIO            (0x0UL<<SYS_GPB_MFPL_PB2MFP_Pos)    /*!< GPB_MFPL PB2 setting for GPIO           */
N#define SYS_GPB_MFPL_PB2MFP_ADC0_CH2        (0x1UL<<SYS_GPB_MFPL_PB2MFP_Pos)    /*!< GPB_MFPL PB2 setting for ADC0_CH2       */
N#define SYS_GPB_MFPL_PB2MFP_SPI0_CLK        (0x2UL<<SYS_GPB_MFPL_PB2MFP_Pos)    /*!< GPB_MFPL PB2 setting for SPI0_CLK       */
N#define SYS_GPB_MFPL_PB2MFP_SPI1_CLK        (0x3UL<<SYS_GPB_MFPL_PB2MFP_Pos)    /*!< GPB_MFPL PB2 setting for SPI1_CLK       */
N#define SYS_GPB_MFPL_PB2MFP_UART1_RXD       (0x4UL<<SYS_GPB_MFPL_PB2MFP_Pos)    /*!< GPB_MFPL PB2 setting for UART1_RXD      */
N#define SYS_GPB_MFPL_PB2MFP_SC0_nCD         (0x5UL<<SYS_GPB_MFPL_PB2MFP_Pos)    /*!< GPB_MFPL PB2 setting for SC0_nCD        */
N#define SYS_GPB_MFPL_PB2MFP_TM_BRAKE0       (0x6UL<<SYS_GPB_MFPL_PB2MFP_Pos)    /*!< GPB_MFPL PB2 setting for TM_BRAKE0      */
N#define SYS_GPB_MFPL_PB2MFP_EBI_nCS0        (0x7UL<<SYS_GPB_MFPL_PB2MFP_Pos)    /*!< GPB_MFPL PB2 setting for EBI_nCS0       */
N#define SYS_GPB_MFPL_PB2MFP_USCI0_DAT0      (0x8UL<<SYS_GPB_MFPL_PB2MFP_Pos)    /*!< GPB_MFPL PB2 setting for USCI0_DAT0     */
N#define SYS_GPB_MFPL_PB2MFP_TM2_EXT         (0xAUL<<SYS_GPB_MFPL_PB2MFP_Pos)    /*!< GPB_MFPL PB2 setting for TM2_EXT        */
N
N//PB.3 MFP
N#define SYS_GPB_MFPL_PB3MFP_GPIO            (0x0UL<<SYS_GPB_MFPL_PB3MFP_Pos)    /*!< GPB_MFPL PB3 setting for GPIO           */
N#define SYS_GPB_MFPL_PB3MFP_ADC0_CH3        (0x1UL<<SYS_GPB_MFPL_PB3MFP_Pos)    /*!< GPB_MFPL PB3 setting for ADC0_CH3       */
N#define SYS_GPB_MFPL_PB3MFP_SPI0_MISO       (0x2UL<<SYS_GPB_MFPL_PB3MFP_Pos)    /*!< GPB_MFPL PB3 setting for SPI0_MISO      */
N#define SYS_GPB_MFPL_PB3MFP_SPI1_MISO       (0x3UL<<SYS_GPB_MFPL_PB3MFP_Pos)    /*!< GPB_MFPL PB3 setting for SPI1_MISO      */
N#define SYS_GPB_MFPL_PB3MFP_UART1_TXD       (0x4UL<<SYS_GPB_MFPL_PB3MFP_Pos)    /*!< GPB_MFPL PB3 setting for UART1_TXD      */
N#define SYS_GPB_MFPL_PB3MFP_TM_BRAKE1       (0x6UL<<SYS_GPB_MFPL_PB3MFP_Pos)    /*!< GPB_MFPL PB3 setting for TM_BRAKE1      */
N#define SYS_GPB_MFPL_PB3MFP_EBI_ALE         (0x7UL<<SYS_GPB_MFPL_PB3MFP_Pos)    /*!< GPB_MFPL PB3 setting for EBI_ALE        */
N#define SYS_GPB_MFPL_PB3MFP_USCI0_DAT1      (0x8UL<<SYS_GPB_MFPL_PB3MFP_Pos)    /*!< GPB_MFPL PB3 setting for USCI0_DAT1     */
N#define SYS_GPB_MFPL_PB3MFP_TM0_EXT        (0xAUL<<SYS_GPB_MFPL_PB3MFP_Pos)    /*!< GPB_MFPL PB3 setting for TM0_EXT         */
N
N//PB.4 MFP
N#define SYS_GPB_MFPL_PB4MFP_GPIO            (0x0UL<<SYS_GPB_MFPL_PB4MFP_Pos)    /*!< GPB_MFPL PB4 setting for GPIO           */
N#define SYS_GPB_MFPL_PB4MFP_ADC0_CH4        (0x1UL<<SYS_GPB_MFPL_PB4MFP_Pos)    /*!< GPB_MFPL PB4 setting for ADC0_CH4       */
N#define SYS_GPB_MFPL_PB4MFP_SPI0_SS         (0x2UL<<SYS_GPB_MFPL_PB4MFP_Pos)    /*!< GPB_MFPL PB4 setting for SPI0_SS        */
N#define SYS_GPB_MFPL_PB4MFP_SPI1_SS         (0x3UL<<SYS_GPB_MFPL_PB4MFP_Pos)    /*!< GPB_MFPL PB4 setting for SPI1_SS        */
N#define SYS_GPB_MFPL_PB4MFP_UART1_nCTS      (0x4UL<<SYS_GPB_MFPL_PB4MFP_Pos)    /*!< GPB_MFPL PB4 setting for UART1_nCTS     */
N#define SYS_GPB_MFPL_PB4MFP_ACMP0_N         (0x5UL<<SYS_GPB_MFPL_PB4MFP_Pos)    /*!< GPB_MFPL PB4 setting for ACMP0_N        */
N#define SYS_GPB_MFPL_PB4MFP_SC1_nCD         (0x6UL<<SYS_GPB_MFPL_PB4MFP_Pos)    /*!< GPB_MFPL PB4 setting for SC1_nCD        */
N#define SYS_GPB_MFPL_PB4MFP_EBI_AD7         (0x7UL<<SYS_GPB_MFPL_PB4MFP_Pos)    /*!< GPB_MFPL PB4 setting for EBI_AD7        */
N#define SYS_GPB_MFPL_PB4MFP_USCI0_CTL1      (0x8UL<<SYS_GPB_MFPL_PB4MFP_Pos)    /*!< GPB_MFPL PB4 setting for USCI0_CTL1     */
N#define SYS_GPB_MFPL_PB4MFP_UART2_RXD       (0x9UL<<SYS_GPB_MFPL_PB4MFP_Pos)    /*!< GPB_MFPL PB4 setting for UART2_RXD      */
N#define SYS_GPB_MFPL_PB4MFP_TM1_EXT         (0xAUL<<SYS_GPB_MFPL_PB4MFP_Pos)    /*!< GPB_MFPL PB4 setting for TM1_EXT        */
N
N//PB.5 MFP
N#define SYS_GPB_MFPL_PB5MFP_GPIO            (0x0UL<<SYS_GPB_MFPL_PB5MFP_Pos)    /*!< GPB_MFPL PB5 setting for GPIO           */
N#define SYS_GPB_MFPL_PB5MFP_ADC0_CH13       (0x1UL<<SYS_GPB_MFPL_PB5MFP_Pos)    /*!< GPB_MFPL PB5 setting for ADC0_CH13      */
N#define SYS_GPB_MFPL_PB5MFP_SPI0_MOSI       (0x2UL<<SYS_GPB_MFPL_PB5MFP_Pos)    /*!< GPB_MFPL PB5 setting for SPI0_MOSI      */
N#define SYS_GPB_MFPL_PB5MFP_SPI1_MOSI       (0x3UL<<SYS_GPB_MFPL_PB5MFP_Pos)    /*!< GPB_MFPL PB5 setting for SPI1_MOSI      */
N#define SYS_GPB_MFPL_PB5MFP_ACMP0_P2        (0x5UL<<SYS_GPB_MFPL_PB5MFP_Pos)    /*!< GPB_MFPL PB5 setting for ACMP0_P2       */
N#define SYS_GPB_MFPL_PB5MFP_SC1_RST         (0x6UL<<SYS_GPB_MFPL_PB5MFP_Pos)    /*!< GPB_MFPL PB5 setting for SC1_RST        */
N#define SYS_GPB_MFPL_PB5MFP_EBI_AD6         (0x7UL<<SYS_GPB_MFPL_PB5MFP_Pos)    /*!< GPB_MFPL PB5 setting for EBI_AD6        */
N#define SYS_GPB_MFPL_PB5MFP_UART2_RXD       (0x9UL<<SYS_GPB_MFPL_PB5MFP_Pos)    /*!< GPB_MFPL PB5 setting for UART2_RXD      */
N
N//PB.6 MFP
N#define SYS_GPB_MFPL_PB6MFP_GPIO            (0x0UL<<SYS_GPB_MFPL_PB6MFP_Pos)    /*!< GPB_MFPL PB6 setting for GPIO           */
N#define SYS_GPB_MFPL_PB6MFP_ADC0_CH14       (0x1UL<<SYS_GPB_MFPL_PB6MFP_Pos)    /*!< GPB_MFPL PB6 setting for ADC0_CH14      */
N#define SYS_GPB_MFPL_PB6MFP_SPI0_MISO       (0x2UL<<SYS_GPB_MFPL_PB6MFP_Pos)    /*!< GPB_MFPL PB6 setting for SPI0_MISO      */
N#define SYS_GPB_MFPL_PB6MFP_SPI1_MISO       (0x3UL<<SYS_GPB_MFPL_PB6MFP_Pos)    /*!< GPB_MFPL PB6 setting for SPI1_MISO      */
N#define SYS_GPB_MFPL_PB6MFP_ACMP0_P1        (0x5UL<<SYS_GPB_MFPL_PB6MFP_Pos)    /*!< GPB_MFPL PB6 setting for ACMP0_P1       */
N#define SYS_GPB_MFPL_PB6MFP_SC1_PWR         (0x6UL<<SYS_GPB_MFPL_PB6MFP_Pos)    /*!< GPB_MFPL PB6 setting for SC1_PWR        */
N#define SYS_GPB_MFPL_PB6MFP_EBI_AD5         (0x7UL<<SYS_GPB_MFPL_PB6MFP_Pos)    /*!< GPB_MFPL PB6 setting for EBI_AD5        */
N
N//PB.7 MFP
N#define SYS_GPB_MFPL_PB7MFP_GPIO            (0x0UL<<SYS_GPB_MFPL_PB7MFP_Pos)    /*!< GPB_MFPL PB7 setting for GPIO           */
N#define SYS_GPB_MFPL_PB7MFP_ADC0_CH15       (0x1UL<<SYS_GPB_MFPL_PB7MFP_Pos)    /*!< GPB_MFPL PB7 setting for ADC0_CH15      */
N#define SYS_GPB_MFPL_PB7MFP_SPI0_CLK        (0x2UL<<SYS_GPB_MFPL_PB7MFP_Pos)    /*!< GPB_MFPL PB7 setting for SPI0_CLK       */
N#define SYS_GPB_MFPL_PB7MFP_SPI1_CLK        (0x3UL<<SYS_GPB_MFPL_PB7MFP_Pos)    /*!< GPB_MFPL PB7 setting for SPI1_CLK       */
N#define SYS_GPB_MFPL_PB7MFP_USCI2_CTL1      (0x4UL<<SYS_GPB_MFPL_PB7MFP_Pos)    /*!< GPB_MFPL PB7 setting for USCI2_CTL1     */
N#define SYS_GPB_MFPL_PB7MFP_ACMP0_P0        (0x5UL<<SYS_GPB_MFPL_PB7MFP_Pos)    /*!< GPB_MFPL PB7 setting for ACMP0_P0       */
N#define SYS_GPB_MFPL_PB7MFP_SC1_DAT         (0x6UL<<SYS_GPB_MFPL_PB7MFP_Pos)    /*!< GPB_MFPL PB7 setting for SC1_DAT        */
N#define SYS_GPB_MFPL_PB7MFP_EBI_AD4         (0x7UL<<SYS_GPB_MFPL_PB7MFP_Pos)    /*!< GPB_MFPL PB7 setting for EBI_AD4        */
N
N//PB.8 MFP
N#define SYS_GPB_MFPH_PB8MFP_GPIO            (0x0UL<<SYS_GPB_MFPH_PB8MFP_Pos)    /*!< GPB_MFPH PB8 setting for GPIO           */
N#define SYS_GPB_MFPH_PB8MFP_ADC0_CH5        (0x1UL<<SYS_GPB_MFPH_PB8MFP_Pos)    /*!< GPB_MFPH PB8 setting for ADC0_CH5       */
N#define SYS_GPB_MFPH_PB8MFP_UART1_nRTS      (0x4UL<<SYS_GPB_MFPH_PB8MFP_Pos)    /*!< GPB_MFPH PB8 setting for UART1_nRTS     */
N#define SYS_GPB_MFPH_PB8MFP_TM_BRAKE2       (0x5UL<<SYS_GPB_MFPH_PB8MFP_Pos)    /*!< GPB_MFPH PB8 setting for TM_BRAKE2      */
N#define SYS_GPB_MFPH_PB8MFP_PWM0_CH2        (0x6UL<<SYS_GPB_MFPH_PB8MFP_Pos)    /*!< GPB_MFPH PB8 setting for PWM0_CH2       */
N#define SYS_GPB_MFPH_PB8MFP_USCI0_CTL0      (0x8UL<<SYS_GPB_MFPH_PB8MFP_Pos)    /*!< GPB_MFPH PB8 setting for USCI0_CTL0     */
N
N//PB.9 MFP
N#define SYS_GPB_MFPH_PB9MFP_GPIO            (0x0UL<<SYS_GPB_MFPH_PB9MFP_Pos)    /*!< GPB_MFPH PB9 setting for GPIO           */
N#define SYS_GPB_MFPH_PB9MFP_ADC0_CH6        (0x1UL<<SYS_GPB_MFPH_PB9MFP_Pos)    /*!< GPB_MFPH PB9 setting for ADC0_CH6       */
N#define SYS_GPB_MFPH_PB9MFP_USCI0_CLK       (0x8UL<<SYS_GPB_MFPH_PB9MFP_Pos)    /*!< GPB_MFPH PB9 setting for USCI0_CLK      */
N
N//PB.10 MFP
N#define SYS_GPB_MFPH_PB10MFP_GPIO           (0x0UL<<SYS_GPB_MFPH_PB10MFP_Pos)   /*!< GPB_MFPH PB10 setting for GPIO          */
N#define SYS_GPB_MFPH_PB10MFP_ADC0_CH7       (0x1UL<<SYS_GPB_MFPH_PB10MFP_Pos)   /*!< GPB_MFPH PB10 setting for ADC0_CH7      */
N
N//PB.11 MFP
N#define SYS_GPB_MFPH_PB11MFP_GPIO           (0x0UL<<SYS_GPB_MFPH_PB11MFP_Pos)   /*!< GPB_MFPH PB11 setting for GPIO          */
N#define SYS_GPB_MFPH_PB11MFP_ADC0_CH8       (0x1UL<<SYS_GPB_MFPH_PB11MFP_Pos)   /*!< GPB_MFPH PB11 setting for ADC0_CH8      */
N
N//PB.12 MFP
N#define SYS_GPB_MFPH_PB12MFP_GPIO           (0x0UL<<SYS_GPB_MFPH_PB12MFP_Pos)   /*!< GPB_MFPH PB12 setting for GPIO          */
N#define SYS_GPB_MFPH_PB12MFP_PWM1_CH1       (0x6UL<<SYS_GPB_MFPH_PB12MFP_Pos)   /*!< GPB_MFPH PB12 setting for PWM1_CH1      */
N
N//PB.13MFP
N#define SYS_GPB_MFPH_PB13MFP_GPIO           (0x0UL<<SYS_GPB_MFPH_PB13MFP_Pos)   /*!< GPB_MFPH PB13 setting for GPIO          */
N#define SYS_GPB_MFPH_PB13MFP_ADC0_CH10      (0x1UL<<SYS_GPB_MFPH_PB13MFP_Pos)   /*!< GPB_MFPH PB13 setting for ADC0_CH10     */
N
N//PB.14 MFP
N#define SYS_GPB_MFPH_PB14MFP_GPIO           (0x0UL<<SYS_GPB_MFPH_PB14MFP_Pos)   /*!< GPB_MFPH PB14 setting for GPIO          */
N#define SYS_GPB_MFPH_PB14MFP_ADC0_CH11      (0x1UL<<SYS_GPB_MFPH_PB14MFP_Pos)   /*!< GPB_MFPH PB14 setting for ADC0_CH11     */
N
N//PB.15 MFP
N#define SYS_GPB_MFPH_PB15MFP_GPIO           (0x0UL<<SYS_GPB_MFPH_PB15MFP_Pos)   /*!< GPB_MFPH PB15 setting for GPIO          */
N#define SYS_GPB_MFPH_PB15MFP_ADC0_CH12      (0x1UL<<SYS_GPB_MFPH_PB15MFP_Pos)   /*!< GPB_MFPH PB15 setting for ADC0_CH12     */
N#define SYS_GPB_MFPH_PB15MFP_ACMP0_P3       (0x5UL<<SYS_GPB_MFPH_PB15MFP_Pos)   /*!< GPB_MFPH PB15 setting for ACMP0_P3      */
N#define SYS_GPB_MFPH_PB15MFP_EBI_nCS1       (0x7UL<<SYS_GPB_MFPH_PB15MFP_Pos)   /*!< GPB_MFPH PB15 setting for EBI_nCS1      */
N
N//PC.0 MFP
N#define SYS_GPC_MFPL_PC0MFP_GPIO            (0x0UL<<SYS_GPC_MFPL_PC0MFP_Pos)    /*!< GPC_MFPL PC0 setting for GPIO           */
N#define SYS_GPC_MFPL_PC0MFP_SC0_DAT         (0x1UL<<SYS_GPC_MFPL_PC0MFP_Pos)    /*!< GPC_MFPL PC0 setting for SC0_DAT        */
N#define SYS_GPC_MFPL_PC0MFP_SPI0_CLK        (0x2UL<<SYS_GPC_MFPL_PC0MFP_Pos)    /*!< GPC_MFPL PC0 setting for SPI0_CLK       */
N#define SYS_GPC_MFPL_PC0MFP_UART2_nCTS      (0x3UL<<SYS_GPC_MFPL_PC0MFP_Pos)    /*!< GPC_MFPL PC0 setting for UART2_nCTS     */
N#define SYS_GPC_MFPL_PC0MFP_USCI0_DAT0      (0x4UL<<SYS_GPC_MFPL_PC0MFP_Pos)    /*!< GPC_MFPL PC0 setting for USCI0_DAT0     */
N#define SYS_GPC_MFPL_PC0MFP_ACMP0_WLAT      (0x5UL<<SYS_GPC_MFPL_PC0MFP_Pos)    /*!< GPC_MFPL PC0 setting for ACMP0_WLAT     */
N#define SYS_GPC_MFPL_PC0MFP_PWM0_CH0        (0x6UL<<SYS_GPC_MFPL_PC0MFP_Pos)    /*!< GPC_MFPL PC0 setting for PWM0_CH0       */
N#define SYS_GPC_MFPL_PC0MFP_EBI_AD8         (0x7UL<<SYS_GPC_MFPL_PC0MFP_Pos)    /*!< GPC_MFPL PC0 setting for EBI_AD8        */
N#define SYS_GPC_MFPL_PC0MFP_INT2            (0x8UL<<SYS_GPC_MFPL_PC0MFP_Pos)    /*!< GPC_MFPL PC0 setting for INT2           */
N
N//PC.1 MFP
N#define SYS_GPC_MFPL_PC1MFP_GPIO            (0x0UL<<SYS_GPC_MFPL_PC1MFP_Pos)    /*!< GPC_MFPL PC1 setting for GPIO           */
N#define SYS_GPC_MFPL_PC1MFP_CLKO            (0x1UL<<SYS_GPC_MFPL_PC1MFP_Pos)    /*!< GPC_MFPL PC1 setting for CLKO           */
N#define SYS_GPC_MFPL_PC1MFP_SC0_CLK         (0x2UL<<SYS_GPC_MFPL_PC1MFP_Pos)    /*!< GPC_MFPL PC1 setting for SC0_CLK        */
N#define SYS_GPC_MFPL_PC1MFP_UART2_nRTS      (0x3UL<<SYS_GPC_MFPL_PC1MFP_Pos)    /*!< GPC_MFPL PC1 setting for UART2_nRTS     */
N#define SYS_GPC_MFPL_PC1MFP_USCI0_DAT1      (0x4UL<<SYS_GPC_MFPL_PC1MFP_Pos)    /*!< GPC_MFPL PC1 setting for USCI0_DAT1     */
N#define SYS_GPC_MFPL_PC1MFP_ACMP1_WLAT      (0x5UL<<SYS_GPC_MFPL_PC1MFP_Pos)    /*!< GPC_MFPL PC1 setting for ACMP1_WLAT     */
N#define SYS_GPC_MFPL_PC1MFP_PWM0_CH1        (0x6UL<<SYS_GPC_MFPL_PC1MFP_Pos)    /*!< GPC_MFPL PC1 setting for PWM0_CH1       */
N#define SYS_GPC_MFPL_PC1MFP_EBI_AD9         (0x7UL<<SYS_GPC_MFPL_PC1MFP_Pos)    /*!< GPC_MFPL PC1 setting for EBI_AD9        */
N
N//PC.2 MFP
N#define SYS_GPC_MFPL_PC2MFP_GPIO            (0x0UL<<SYS_GPC_MFPL_PC2MFP_Pos)    /*!< GPC_MFPL PC2 setting for GPIO           */
N#define SYS_GPC_MFPL_PC2MFP_SC0_RST         (0x1UL<<SYS_GPC_MFPL_PC2MFP_Pos)    /*!< GPC_MFPL PC2 setting for SC0_RST        */
N#define SYS_GPC_MFPL_PC2MFP_SPI0_SS         (0x2UL<<SYS_GPC_MFPL_PC2MFP_Pos)    /*!< GPC_MFPL PC2 setting for SPI0_SS        */
N#define SYS_GPC_MFPL_PC2MFP_UART2_TXD       (0x3UL<<SYS_GPC_MFPL_PC2MFP_Pos)    /*!< GPC_MFPL PC2 setting for UART2_TXD      */
N#define SYS_GPC_MFPL_PC2MFP_USCI0_CTL1      (0x4UL<<SYS_GPC_MFPL_PC2MFP_Pos)    /*!< GPC_MFPL PC2 setting for USCI0_CTL1     */
N#define SYS_GPC_MFPL_PC2MFP_ACMP1_O         (0x5UL<<SYS_GPC_MFPL_PC2MFP_Pos)    /*!< GPC_MFPL PC2 setting for ACMP1_O        */
N#define SYS_GPC_MFPL_PC2MFP_PWM0_CH2        (0x6UL<<SYS_GPC_MFPL_PC2MFP_Pos)    /*!< GPC_MFPL PC2 setting for PWM0_CH2       */
N#define SYS_GPC_MFPL_PC2MFP_EBI_AD10        (0x7UL<<SYS_GPC_MFPL_PC2MFP_Pos)    /*!< GPC_MFPL PC2 setting for EBI_AD10       */
N
N//PC.3 MFP
N#define SYS_GPC_MFPL_PC3MFP_GPIO            (0x0UL<<SYS_GPC_MFPL_PC3MFP_Pos)    /*!< GPC_MFPL PC3 setting for GPIO           */
N#define SYS_GPC_MFPL_PC3MFP_SC0_PWR         (0x1UL<<SYS_GPC_MFPL_PC3MFP_Pos)    /*!< GPC_MFPL PC3 setting for SC0_PWR        */
N#define SYS_GPC_MFPL_PC3MFP_SPI0_MOSI       (0x2UL<<SYS_GPC_MFPL_PC3MFP_Pos)    /*!< GPC_MFPL PC3 setting for SPI0_MOSI      */
N#define SYS_GPC_MFPL_PC3MFP_UART2_RXD       (0x3UL<<SYS_GPC_MFPL_PC3MFP_Pos)    /*!< GPC_MFPL PC3 setting for UART2_RXD      */
N#define SYS_GPC_MFPL_PC3MFP_USCI0_CTL0      (0x5UL<<SYS_GPC_MFPL_PC3MFP_Pos)    /*!< GPC_MFPL PC3 setting for USCI0_CTL0     */
N#define SYS_GPC_MFPL_PC3MFP_PWM0_CH3        (0x6UL<<SYS_GPC_MFPL_PC3MFP_Pos)    /*!< GPC_MFPL PC3 setting for PWM0_CH3       */
N#define SYS_GPC_MFPL_PC3MFP_EBI_AD11        (0x7UL<<SYS_GPC_MFPL_PC3MFP_Pos)    /*!< GPC_MFPL PC3 setting for EBI_AD11       */
N
N//PC.4 MFP
N#define SYS_GPC_MFPL_PC4MFP_GPIO            (0x0UL<<SYS_GPC_MFPL_PC4MFP_Pos)    /*!< GPC_MFPL PC4 setting for GPIO           */
N#define SYS_GPC_MFPL_PC4MFP_SC0_nCD         (0x1UL<<SYS_GPC_MFPL_PC4MFP_Pos)    /*!< GPC_MFPL PC4 setting for SC0_nCD        */
N#define SYS_GPC_MFPL_PC4MFP_SPI0_MISO       (0x2UL<<SYS_GPC_MFPL_PC4MFP_Pos)    /*!< GPC_MFPL PC4 setting for SPI0_MISO      */
N#define SYS_GPC_MFPL_PC4MFP_I2C1_SCL        (0x3UL<<SYS_GPC_MFPL_PC4MFP_Pos)    /*!< GPC_MFPL PC4 setting for I2C1_SCL       */
N#define SYS_GPC_MFPL_PC4MFP_USCI0_CLK       (0x5UL<<SYS_GPC_MFPL_PC4MFP_Pos)    /*!< GPC_MFPL PC4 setting for USCI0_CLK      */
N#define SYS_GPC_MFPL_PC4MFP_PWM0_CH4        (0x6UL<<SYS_GPC_MFPL_PC4MFP_Pos)    /*!< GPC_MFPL PC4 setting for PWM0_CH4       */
N#define SYS_GPC_MFPL_PC4MFP_EBI_AD12        (0x7UL<<SYS_GPC_MFPL_PC4MFP_Pos)    /*!< GPC_MFPL PC4 setting for EBI_AD12       */
N
N//PC.5 MFP
N#define SYS_GPC_MFPL_PC5MFP_GPIO            (0x0UL<<SYS_GPC_MFPL_PC5MFP_Pos)    /*!< GPC_MFPL PC5 setting for GPIO           */
N#define SYS_GPC_MFPL_PC5MFP_SPI0_I2SMCLK    (0x2UL<<SYS_GPC_MFPL_PC5MFP_Pos)    /*!< GPC_MFPL PC5 setting for SPI0_I2SMCLK   */
N#define SYS_GPC_MFPL_PC5MFP_I2C1_SDA        (0x3UL<<SYS_GPC_MFPL_PC5MFP_Pos)    /*!< GPC_MFPL PC5 setting for I2C1_SDA       */
N#define SYS_GPC_MFPL_PC5MFP_USCI0_DAT0      (0x4UL<<SYS_GPC_MFPL_PC5MFP_Pos)    /*!< GPC_MFPL PC5 setting for USCI0_DAT0     */
N#define SYS_GPC_MFPL_PC5MFP_PWM0_CH5        (0x6UL<<SYS_GPC_MFPL_PC5MFP_Pos)    /*!< GPC_MFPL PC5 setting for PWM0_CH5       */
N#define SYS_GPC_MFPL_PC5MFP_EBI_AD13        (0x7UL<<SYS_GPC_MFPL_PC5MFP_Pos)    /*!< GPC_MFPL PC5 setting for EBI_AD13       */
N
N//PC.6 MFP
N#define SYS_GPC_MFPL_PC6MFP_GPIO            (0x0UL<<SYS_GPC_MFPL_PC6MFP_Pos)    /*!< GPC_MFPL PC6 setting for GPIO           */
N#define SYS_GPC_MFPL_PC6MFP_USCI0_DAT1      (0x4UL<<SYS_GPC_MFPL_PC6MFP_Pos)    /*!< GPC_MFPL PC6 setting for USCI0_DAT1     */
N#define SYS_GPC_MFPL_PC6MFP_ACMP1_O         (0x5UL<<SYS_GPC_MFPL_PC6MFP_Pos)    /*!< GPC_MFPL PC6 setting for ACMP1_O        */
N#define SYS_GPC_MFPL_PC6MFP_PWM1_CH0        (0x6UL<<SYS_GPC_MFPL_PC6MFP_Pos)    /*!< GPC_MFPL PC6 setting for PWM1_CH0       */
N#define SYS_GPC_MFPL_PC6MFP_EBI_AD14        (0x7UL<<SYS_GPC_MFPL_PC6MFP_Pos)    /*!< GPC_MFPL PC6 setting for EBI_AD14       */
N
N//PC.7 MFP
N#define SYS_GPC_MFPL_PC7MFP_GPIO            (0x0UL<<SYS_GPC_MFPL_PC7MFP_Pos)    /*!< GPC_MFPL PC7 setting for GPIO           */
N#define SYS_GPC_MFPL_PC7MFP_USCI0_CTL1      (0x4UL<<SYS_GPC_MFPL_PC7MFP_Pos)    /*!< GPC_MFPL PC7 setting for USCI0_CTL1     */
N#define SYS_GPC_MFPL_PC7MFP_PWM1_CH1        (0x6UL<<SYS_GPC_MFPL_PC7MFP_Pos)    /*!< GPC_MFPL PC7 setting for PWM1_CH1       */
N#define SYS_GPC_MFPL_PC7MFP_EBI_AD15        (0x7UL<<SYS_GPC_MFPL_PC7MFP_Pos)    /*!< GPC_MFPL PC7 setting for EBI_AD15       */
N
N//PC.8 MFP
N#define SYS_GPC_MFPH_PC8MFP_GPIO            (0x0UL<<SYS_GPC_MFPH_PC8MFP_Pos)    /*!< GPC_MFPH PC8 setting for GPIO           */
N#define SYS_GPC_MFPH_PC8MFP_ADC0_CH16       (0x1UL<<SYS_GPC_MFPH_PC8MFP_Pos)    /*!< GPC_MFPH PC8 setting for ADC0_CH16      */
N#define SYS_GPC_MFPH_PC8MFP_UART0_nRTS      (0x3UL<<SYS_GPC_MFPH_PC8MFP_Pos)    /*!< GPC_MFPH PC8 setting for UART0_nRTS     */
N
N//PC.9 MFP
N#define SYS_GPC_MFPH_PC9MFP_GPIO            (0x0UL<<SYS_GPC_MFPH_PC9MFP_Pos)    /*!< GPC_MFPH PC9 setting for GPIO           */
N#define SYS_GPC_MFPH_PC9MFP_SPI0_I2SMCLK    (0x2UL<<SYS_GPC_MFPH_PC9MFP_Pos)    /*!< GPC_MFPH PC9 setting for SPI0_I2SMCLK   */
N#define SYS_GPC_MFPH_PC9MFP_I2C1_SCL        (0x3UL<<SYS_GPC_MFPH_PC9MFP_Pos)    /*!< GPC_MFPH PC9 setting for I2C1_SCL       */
N#define SYS_GPC_MFPH_PC9MFP_USCI2_CTL1      (0x4UL<<SYS_GPC_MFPH_PC9MFP_Pos)    /*!< GPC_MFPH PC9 setting for USCI2_CTL1     */
N#define SYS_GPC_MFPH_PC9MFP_PWM1_CH0        (0x6UL<<SYS_GPC_MFPH_PC9MFP_Pos)    /*!< GPC_MFPH PC9 setting for PWM1_CH0       */
N
N//PC.10 MFP
N#define SYS_GPC_MFPH_PC10MFP_GPIO           (0x0UL<<SYS_GPC_MFPH_PC10MFP_Pos)   /*!< GPC_MFPH PC10 setting for GPIO          */
N#define SYS_GPC_MFPH_PC10MFP_SPI0_MOSI      (0x2UL<<SYS_GPC_MFPH_PC10MFP_Pos)   /*!< GPC_MFPH PC10 setting for SPI0_MOSI     */
N#define SYS_GPC_MFPH_PC10MFP_I2C1_SDA       (0x3UL<<SYS_GPC_MFPH_PC10MFP_Pos)   /*!< GPC_MFPH PC10 setting for I2C1_SDA      */
N#define SYS_GPC_MFPH_PC10MFP_USCI2_DAT1     (0x4UL<<SYS_GPC_MFPH_PC10MFP_Pos)   /*!< GPC_MFPH PC10 setting for USCI2_DAT1    */
N#define SYS_GPC_MFPH_PC10MFP_PWM1_CH1       (0x6UL<<SYS_GPC_MFPH_PC10MFP_Pos)   /*!< GPC_MFPH PC10 setting for PWM1_CH1      */
N
N//PC.11 MFP
N#define SYS_GPC_MFPH_PC11MFP_GPIO           (0x0UL<<SYS_GPC_MFPH_PC11MFP_Pos)   /*!< GPC_MFPH PC11 setting for GPIO          */
N#define SYS_GPC_MFPH_PC11MFP_SPI0_MISO      (0x2UL<<SYS_GPC_MFPH_PC11MFP_Pos)   /*!< GPC_MFPH PC11 setting for SPI0_MISO     */
N#define SYS_GPC_MFPH_PC11MFP_USCI2_CLK      (0x4UL<<SYS_GPC_MFPH_PC11MFP_Pos)   /*!< GPC_MFPH PC11 setting for USCI2_CLK     */
N#define SYS_GPC_MFPH_PC11MFP_PWM1_CH2       (0x6UL<<SYS_GPC_MFPH_PC11MFP_Pos)   /*!< GPC_MFPH PC11 setting for PWM1_CH2      */
N
N//PC.12 MFP
N#define SYS_GPC_MFPH_PC12MFP_GPIO           (0x0UL<<SYS_GPC_MFPH_PC12MFP_Pos)   /*!< GPC_MFPH PC12 setting for GPIO          */
N#define SYS_GPC_MFPH_PC12MFP_SPI0_CLK       (0x2UL<<SYS_GPC_MFPH_PC12MFP_Pos)   /*!< GPC_MFPH PC12 setting for SPI0_CLK      */
N#define SYS_GPC_MFPH_PC12MFP_USCI2_CTL0     (0x4UL<<SYS_GPC_MFPH_PC12MFP_Pos)   /*!< GPC_MFPH PC12 setting for USCI2_CTL0    */
N#define SYS_GPC_MFPH_PC12MFP_PWM1_CH3       (0x6UL<<SYS_GPC_MFPH_PC12MFP_Pos)   /*!< GPC_MFPH PC12 setting for PWM1_CH3      */
N
N//PC.13 MFP
N#define SYS_GPC_MFPH_PC13MFP_GPIO           (0x0UL<<SYS_GPC_MFPH_PC13MFP_Pos)   /*!< GPC_MFPH PC13 setting for GPIO          */
N#define SYS_GPC_MFPH_PC13MFP_SPI0_SS        (0x2UL<<SYS_GPC_MFPH_PC13MFP_Pos)   /*!< GPC_MFPH PC13 setting for SPI0_SS       */
N#define SYS_GPC_MFPH_PC13MFP_USCI2_DAT0     (0x4UL<<SYS_GPC_MFPH_PC13MFP_Pos)   /*!< GPC_MFPH PC13 setting for USCI2_DAT0    */
N#define SYS_GPC_MFPH_PC13MFP_PWM1_CH4       (0x6UL<<SYS_GPC_MFPH_PC13MFP_Pos)   /*!< GPC_MFPH PC13 setting for PWM1_CH4      */
N
N//PC.14 MFP
N#define SYS_GPC_MFPH_PC14MFP_GPIO           (0x0UL<<SYS_GPC_MFPH_PC14MFP_Pos)   /*!< GPC_MFPH PC14 setting for GPIO          */
N#define SYS_GPC_MFPH_PC14MFP_PWM1_CH5       (0x6UL<<SYS_GPC_MFPH_PC14MFP_Pos)   /*!< GPC_MFPH PC14 setting for PWM1_CH5      */
N
N//PC.15 MFP
N#define SYS_GPC_MFPH_PC15MFP_GPIO           (0x0UL<<SYS_GPC_MFPH_PC15MFP_Pos)   /*!< GPC_MFPH PC15 setting for GPIO          */
N#define SYS_GPC_MFPH_PC15MFP_PWM1_CH0       (0x6UL<<SYS_GPC_MFPH_PC15MFP_Pos)   /*!< GPC_MFPH PC15 setting for PWM1_CH0      */
N
N//PD.0 MFP
N#define SYS_GPD_MFPL_PD0MFP_GPIO            (0x0UL<<SYS_GPD_MFPL_PD0MFP_Pos)    /*!< GPD_MFPL PD0 setting for GPIO           */
N#define SYS_GPD_MFPL_PD0MFP_SPI0_I2SMCLK    (0x1UL<<SYS_GPD_MFPL_PD0MFP_Pos)    /*!< GPD_MFPL PD0 setting for SPI0_I2SMCLK   */
N#define SYS_GPD_MFPL_PD0MFP_SPI1_I2SMCLK    (0x2UL<<SYS_GPD_MFPL_PD0MFP_Pos)    /*!< GPD_MFPL PD0 setting for SPI1_I2SMCLK   */
N#define SYS_GPD_MFPL_PD0MFP_UART0_RXD       (0x3UL<<SYS_GPD_MFPL_PD0MFP_Pos)    /*!< GPD_MFPL PD0 setting for UART0_RXD      */
N#define SYS_GPD_MFPL_PD0MFP_USCI2_CTL0      (0x4UL<<SYS_GPD_MFPL_PD0MFP_Pos)    /*!< GPD_MFPL PD0 setting for USCI2_CTL0     */
N#define SYS_GPD_MFPL_PD0MFP_ACMP1_N         (0x5UL<<SYS_GPD_MFPL_PD0MFP_Pos)    /*!< GPD_MFPL PD0 setting for ACMP1_N        */
N#define SYS_GPD_MFPL_PD0MFP_SC1_CLK         (0x6UL<<SYS_GPD_MFPL_PD0MFP_Pos)    /*!< GPD_MFPL PD0 setting for SC1_CLK        */
N#define SYS_GPD_MFPL_PD0MFP_INT3            (0x8UL<<SYS_GPD_MFPL_PD0MFP_Pos)    /*!< GPD_MFPL PD0 setting for INT3           */
N
N//PD.1 MFP
N#define SYS_GPD_MFPL_PD1MFP_GPIO            (0x0UL<<SYS_GPD_MFPL_PD1MFP_Pos)    /*!< GPD_MFPL PD1 setting for GPIO           */
N#define SYS_GPD_MFPL_PD1MFP_ADC0_CH19       (0x1UL<<SYS_GPD_MFPL_PD1MFP_Pos)    /*!< GPD_MFPL PD1 setting for ADC0_CH19      */
N#define SYS_GPD_MFPL_PD1MFP_PWM0_SYNC_IN    (0x2UL<<SYS_GPD_MFPL_PD1MFP_Pos)    /*!< GPD_MFPL PD1 setting for PWM0_SYNC_IN   */
N#define SYS_GPD_MFPL_PD1MFP_UART0_TXD       (0x3UL<<SYS_GPD_MFPL_PD1MFP_Pos)    /*!< GPD_MFPL PD1 setting for UART0_TXD      */
N#define SYS_GPD_MFPL_PD1MFP_USCI2_CLK       (0x4UL<<SYS_GPD_MFPL_PD1MFP_Pos)    /*!< GPD_MFPL PD1 setting for USCI2_CLK      */
N#define SYS_GPD_MFPL_PD1MFP_ACMP1_P2        (0x5UL<<SYS_GPD_MFPL_PD1MFP_Pos)    /*!< GPD_MFPL PD1 setting for ACMP1_P2       */
N#define SYS_GPD_MFPL_PD1MFP_TM0             (0x6UL<<SYS_GPD_MFPL_PD1MFP_Pos)    /*!< GPD_MFPL PD1 setting for TM0            */
N#define SYS_GPD_MFPL_PD1MFP_EBI_nRD         (0x7UL<<SYS_GPD_MFPL_PD1MFP_Pos)    /*!< GPD_MFPL PD1 setting for EBI_nRD        */
N
N//PD.2 MFP
N#define SYS_GPD_MFPL_PD2MFP_GPIO            (0x0UL<<SYS_GPD_MFPL_PD2MFP_Pos)    /*!< GPD_MFPL PD2 setting for GPIO           */
N#define SYS_GPD_MFPL_PD2MFP_ADC0_ST         (0x1UL<<SYS_GPD_MFPL_PD2MFP_Pos)    /*!< GPD_MFPL PD2 setting for ADC0_ST        */
N#define SYS_GPD_MFPL_PD2MFP_TM0_EXT         (0x3UL<<SYS_GPD_MFPL_PD2MFP_Pos)    /*!< GPD_MFPL PD2 setting for TM0_EXT        */
N#define SYS_GPD_MFPL_PD2MFP_USCI2_DAT0      (0x4UL<<SYS_GPD_MFPL_PD2MFP_Pos)    /*!< GPD_MFPL PD2 setting for USCI2_DAT0     */
N#define SYS_GPD_MFPL_PD2MFP_ACMP1_P1        (0x5UL<<SYS_GPD_MFPL_PD2MFP_Pos)    /*!< GPD_MFPL PD2 setting for ACMP1_P1       */
N#define SYS_GPD_MFPL_PD2MFP_PWM0_BRAKE0     (0x6UL<<SYS_GPD_MFPL_PD2MFP_Pos)    /*!< GPD_MFPL PD2 setting for PWM0_BRAKE0    */
N#define SYS_GPD_MFPL_PD2MFP_EBI_nWR         (0x7UL<<SYS_GPD_MFPL_PD2MFP_Pos)    /*!< GPD_MFPL PD2 setting for EBI_nWR        */
N#define SYS_GPD_MFPL_PD2MFP_INT0            (0x8UL<<SYS_GPD_MFPL_PD2MFP_Pos)    /*!< GPD_MFPL PD2 setting for INT0           */
N
N//PD.3 MFP
N#define SYS_GPD_MFPL_PD3MFP_GPIO            (0x0UL<<SYS_GPD_MFPL_PD3MFP_Pos)    /*!< GPD_MFPL PD3 setting for GPIO           */
N#define SYS_GPD_MFPL_PD3MFP_TM2             (0x1UL<<SYS_GPD_MFPL_PD3MFP_Pos)    /*!< GPD_MFPL PD3 setting for TM2            */
N#define SYS_GPD_MFPL_PD3MFP_SPI0_I2SMCLK    (0x2UL<<SYS_GPD_MFPL_PD3MFP_Pos)    /*!< GPD_MFPL PD3 setting for SPI0_I2SMCLK   */
N#define SYS_GPD_MFPL_PD3MFP_TM1_EXT         (0x3UL<<SYS_GPD_MFPL_PD3MFP_Pos)    /*!< GPD_MFPL PD3 setting for TM1_EXT        */
N#define SYS_GPD_MFPL_PD3MFP_USCI2_DAT1      (0x4UL<<SYS_GPD_MFPL_PD3MFP_Pos)    /*!< GPD_MFPL PD3 setting for USCI2_DAT1     */
N#define SYS_GPD_MFPL_PD3MFP_ACMP1_P0        (0x5UL<<SYS_GPD_MFPL_PD3MFP_Pos)    /*!< GPD_MFPL PD3 setting for ACMP1_P0       */
N#define SYS_GPD_MFPL_PD3MFP_PWM0_BRAKE1     (0x6UL<<SYS_GPD_MFPL_PD3MFP_Pos)    /*!< GPD_MFPL PD3 setting for PWM0_BRAKE1    */
N#define SYS_GPD_MFPL_PD3MFP_EBI_MCLK        (0x7UL<<SYS_GPD_MFPL_PD3MFP_Pos)    /*!< GPD_MFPL PD3 setting for EBI_MCLK       */
N#define SYS_GPD_MFPL_PD3MFP_INT1            (0x8UL<<SYS_GPD_MFPL_PD3MFP_Pos)    /*!< GPD_MFPL PD3 setting for INT1           */
N
N//PD.4 MFP
N#define SYS_GPD_MFPL_PD4MFP_GPIO            (0x0UL<<SYS_GPD_MFPL_PD4MFP_Pos)    /*!< GPD_MFPL PD4 setting for GPIO           */
N#define SYS_GPD_MFPL_PD4MFP_SPI1_CLK        (0x2UL<<SYS_GPD_MFPL_PD4MFP_Pos)    /*!< GPD_MFPL PD4 setting for SPI1_CLK       */
N#define SYS_GPD_MFPL_PD4MFP_I2C0_SDA        (0x3UL<<SYS_GPD_MFPL_PD4MFP_Pos)    /*!< GPD_MFPL PD4 setting for I2C0_SDA       */
N#define SYS_GPD_MFPL_PD4MFP_UART2_nRTS      (0x4UL<<SYS_GPD_MFPL_PD4MFP_Pos)    /*!< GPD_MFPL PD4 setting for UART2_nRTS     */
N#define SYS_GPD_MFPL_PD4MFP_PWM0_BRAKE0     (0x5UL<<SYS_GPD_MFPL_PD4MFP_Pos)    /*!< GPD_MFPL PD4 setting for PWM0_BRAKE0    */
N#define SYS_GPD_MFPL_PD4MFP_TM0             (0x6UL<<SYS_GPD_MFPL_PD4MFP_Pos)    /*!< GPD_MFPL PD4 setting for TM0            */
N
N//PD.5 MFP
N#define SYS_GPD_MFPL_PD5MFP_GPIO            (0x0UL<<SYS_GPD_MFPL_PD5MFP_Pos)    /*!< GPD_MFPL PD5 setting for GPIO           */
N#define SYS_GPD_MFPL_PD5MFP_CLKO            (0x1UL<<SYS_GPD_MFPL_PD5MFP_Pos)    /*!< GPD_MFPL PD5 setting for CLKO           */
N#define SYS_GPD_MFPL_PD5MFP_SPI1_MISO       (0x2UL<<SYS_GPD_MFPL_PD5MFP_Pos)    /*!< GPD_MFPL PD5 setting for SPI1_MISO      */
N#define SYS_GPD_MFPL_PD5MFP_I2C0_SCL        (0x3UL<<SYS_GPD_MFPL_PD5MFP_Pos)    /*!< GPD_MFPL PD5 setting for I2C0_SCL       */
N#define SYS_GPD_MFPL_PD5MFP_UART2_nCTS      (0x4UL<<SYS_GPD_MFPL_PD5MFP_Pos)    /*!< GPD_MFPL PD5 setting for UART2_nCTS     */
N#define SYS_GPD_MFPL_PD5MFP_PWM0_BRAKE1     (0x5UL<<SYS_GPD_MFPL_PD5MFP_Pos)    /*!< GPD_MFPL PD5 setting for PWM0_BRAKE1    */
N#define SYS_GPD_MFPL_PD5MFP_TM1             (0x6UL<<SYS_GPD_MFPL_PD5MFP_Pos)    /*!< GPD_MFPL PD5 setting for TM1            */
N
N//PD.6 MFP
N#define SYS_GPD_MFPL_PD6MFP_GPIO            (0x0UL<<SYS_GPD_MFPL_PD6MFP_Pos)    /*!< GPD_MFPL PD6 setting for GPIO           */
N#define SYS_GPD_MFPL_PD6MFP_CLKO            (0x1UL<<SYS_GPD_MFPL_PD6MFP_Pos)    /*!< GPD_MFPL PD6 setting for CLKO           */
N#define SYS_GPD_MFPL_PD6MFP_SPI1_SS         (0x2UL<<SYS_GPD_MFPL_PD6MFP_Pos)    /*!< GPD_MFPL PD6 setting for SPI1_SS        */
N#define SYS_GPD_MFPL_PD6MFP_UART0_RXD       (0x3UL<<SYS_GPD_MFPL_PD6MFP_Pos)    /*!< GPD_MFPL PD6 setting for UART0_RXD      */
N#define SYS_GPD_MFPL_PD6MFP_UART2_TXD       (0x4UL<<SYS_GPD_MFPL_PD6MFP_Pos)    /*!< GPD_MFPL PD6 setting for UART2_TXD      */
N#define SYS_GPD_MFPL_PD6MFP_ACMP0_O         (0x5UL<<SYS_GPD_MFPL_PD6MFP_Pos)    /*!< GPD_MFPL PD6 setting for ACMP0_O        */
N#define SYS_GPD_MFPL_PD6MFP_PWM0_CH5        (0x6UL<<SYS_GPD_MFPL_PD6MFP_Pos)    /*!< GPD_MFPL PD6 setting for PWM0_CH5       */
N#define SYS_GPD_MFPL_PD6MFP_EBI_nWR         (0x7UL<<SYS_GPD_MFPL_PD6MFP_Pos)    /*!< GPD_MFPL PD6 setting for EBI_nWR        */
N
N//PD.7 MFP
N#define SYS_GPD_MFPL_PD7MFP_GPIO            (0x0UL<<SYS_GPD_MFPL_PD7MFP_Pos)    /*!< GPD_MFPL PD7 setting for GPIO           */
N#define SYS_GPD_MFPL_PD7MFP_USCI1_CTL1      (0x1UL<<SYS_GPD_MFPL_PD7MFP_Pos)    /*!< GPD_MFPL PD7 setting for USCI1_CTL1     */
N#define SYS_GPD_MFPL_PD7MFP_SPI0_I2SMCLK    (0x2UL<<SYS_GPD_MFPL_PD7MFP_Pos)    /*!< GPD_MFPL PD7 setting for SPI0_I2SMCLK   */
N#define SYS_GPD_MFPL_PD7MFP_PWM0_SYNC_IN    (0x3UL<<SYS_GPD_MFPL_PD7MFP_Pos)    /*!< GPD_MFPL PD7 setting for PWM0_SYNC_IN   */
N#define SYS_GPD_MFPL_PD7MFP_TM1             (0x4UL<<SYS_GPD_MFPL_PD7MFP_Pos)    /*!< GPD_MFPL PD7 setting for TM1            */
N#define SYS_GPD_MFPL_PD7MFP_ACMP0_O         (0x5UL<<SYS_GPD_MFPL_PD7MFP_Pos)    /*!< GPD_MFPL PD7 setting for ACMP0_O        */
N#define SYS_GPD_MFPL_PD7MFP_PWM0_CH5        (0x6UL<<SYS_GPD_MFPL_PD7MFP_Pos)    /*!< GPD_MFPL PD7 setting for PWM0_CH5       */
N#define SYS_GPD_MFPL_PD7MFP_EBI_nRD         (0x7UL<<SYS_GPD_MFPL_PD7MFP_Pos)    /*!< GPD_MFPL PD7 setting for EBI_nRD        */
N
N//PD.8 MFP
N#define SYS_GPD_MFPH_PD8MFP_GPIO            (0x0UL<<SYS_GPD_MFPH_PD8MFP_Pos)    /*!< GPD_MFPH PD8 setting for GPIO           */
N#define SYS_GPD_MFPH_PD8MFP_ADC0_CH17       (0x1UL<<SYS_GPD_MFPH_PD8MFP_Pos)    /*!< GPD_MFPH PD8 setting for ADC0_CH17      */
N#define SYS_GPD_MFPH_PD8MFP_UART0_nCTS      (0x3UL<<SYS_GPD_MFPH_PD8MFP_Pos)    /*!< GPD_MFPH PD8 setting for UART0_nCTS     */
N#define SYS_GPD_MFPH_PD8MFP_USCI2_CTL1      (0x4UL<<SYS_GPD_MFPH_PD8MFP_Pos)    /*!< GPD_MFPH PD8 setting for USCI2_CTL1     */
N#define SYS_GPD_MFPH_PD8MFP_TM2             (0x6UL<<SYS_GPD_MFPH_PD8MFP_Pos)    /*!< GPD_MFPH PD8 setting for TM2            */
N#define SYS_GPD_MFPH_PD8MFP_EBI_nCS0        (0x7UL<<SYS_GPD_MFPH_PD8MFP_Pos)    /*!< GPD_MFPH PD8 setting for EBI_nCS0       */
N
N//PD.9 MFP
N#define SYS_GPD_MFPH_PD9MFP_GPIO            (0x0UL<<SYS_GPD_MFPH_PD9MFP_Pos)    /*!< GPD_MFPH PD9 setting for GPIO           */
N#define SYS_GPD_MFPH_PD9MFP_ADC0_CH18       (0x1UL<<SYS_GPD_MFPH_PD9MFP_Pos)    /*!< GPD_MFPH PD9 setting for ADC0_CH18      */
N#define SYS_GPD_MFPH_PD9MFP_UART0_RXD       (0x3UL<<SYS_GPD_MFPH_PD9MFP_Pos)    /*!< GPD_MFPH PD9 setting for UART0_RXD      */
N#define SYS_GPD_MFPH_PD9MFP_USCI2_CTL0      (0x4UL<<SYS_GPD_MFPH_PD9MFP_Pos)    /*!< GPD_MFPH PD9 setting for USCI2_CTL0     */
N#define SYS_GPD_MFPH_PD9MFP_ACMP1_P3        (0x5UL<<SYS_GPD_MFPH_PD9MFP_Pos)    /*!< GPD_MFPH PD9 setting for ACMP1_P3       */
N#define SYS_GPD_MFPH_PD9MFP_TM3             (0x6UL<<SYS_GPD_MFPH_PD9MFP_Pos)    /*!< GPD_MFPH PD9 setting for TM3            */
N#define SYS_GPD_MFPH_PD9MFP_EBI_ALE         (0x7UL<<SYS_GPD_MFPH_PD9MFP_Pos)    /*!< GPD_MFPH PD9 setting for EBI_ALE        */
N
N//PD.10 MFP
N#define SYS_GPD_MFPH_PD10MFP_GPIO           (0x0UL<<SYS_GPD_MFPH_PD10MFP_Pos)   /*!< GPD_MFPH PD10 setting for GPIO          */
N#define SYS_GPD_MFPH_PD10MFP_TM2            (0x4UL<<SYS_GPD_MFPH_PD10MFP_Pos)   /*!< GPD_MFPH PD10 setting for TM2           */
N#define SYS_GPD_MFPH_PD10MFP_USCI2_DAT0     (0x5UL<<SYS_GPD_MFPH_PD10MFP_Pos)   /*!< GPD_MFPH PD10 setting for USCI2_DAT0    */
N
N//PD.11 MFP
N#define SYS_GPD_MFPH_PD11MFP_GPIO           (0x0UL<<SYS_GPD_MFPH_PD11MFP_Pos)   /*!< GPD_MFPH PD11 setting for GPIO          */
N#define SYS_GPD_MFPH_PD11MFP_TM3            (0x4UL<<SYS_GPD_MFPH_PD11MFP_Pos)   /*!< GPD_MFPH PD11 setting for TM3           */
N#define SYS_GPD_MFPH_PD11MFP_USCI2_DAT1     (0x5UL<<SYS_GPD_MFPH_PD11MFP_Pos)   /*!< GPD_MFPH PD11 setting for USCI2_DAT1    */
N
N//PD.12 MFP
N#define SYS_GPD_MFPH_PD12MFP_GPIO           (0x0UL<<SYS_GPD_MFPH_PD12MFP_Pos)   /*!< GPD_MFPH PD12 setting for GPIO          */
N#define SYS_GPD_MFPH_PD12MFP_USCI1_CTL0     (0x1UL<<SYS_GPD_MFPH_PD12MFP_Pos)   /*!< GPD_MFPH PD12 setting for USCI1_CTL0    */
N#define SYS_GPD_MFPH_PD12MFP_SPI1_SS        (0x2UL<<SYS_GPD_MFPH_PD12MFP_Pos)   /*!< GPD_MFPH PD12 setting for SPI1_SS       */
N#define SYS_GPD_MFPH_PD12MFP_UART0_TXD      (0x3UL<<SYS_GPD_MFPH_PD12MFP_Pos)   /*!< GPD_MFPH PD12 setting for UART0_TXD     */
N#define SYS_GPD_MFPH_PD12MFP_PWM1_CH0       (0x6UL<<SYS_GPD_MFPH_PD12MFP_Pos)   /*!< GPD_MFPH PD12 setting for PWM1_CH0      */
N#define SYS_GPD_MFPH_PD12MFP_EBI_ADR16      (0x7UL<<SYS_GPD_MFPH_PD12MFP_Pos)   /*!< GPD_MFPH PD12 setting for EBI_ADR16     */
N
N//PD.13 MFP
N#define SYS_GPD_MFPH_PD13MFP_GPIO           (0x0UL<<SYS_GPD_MFPH_PD13MFP_Pos)   /*!< GPD_MFPH PD13 setting for GPIO          */
N#define SYS_GPD_MFPH_PD13MFP_USCI1_DAT1     (0x1UL<<SYS_GPD_MFPH_PD13MFP_Pos)   /*!< GPD_MFPH PD13 setting for USCI1_DAT1    */
N#define SYS_GPD_MFPH_PD13MFP_SPI1_MOSI      (0x2UL<<SYS_GPD_MFPH_PD13MFP_Pos)   /*!< GPD_MFPH PD13 setting for SPI1_MOSI     */
N#define SYS_GPD_MFPH_PD13MFP_UART0_RXD      (0x3UL<<SYS_GPD_MFPH_PD13MFP_Pos)   /*!< GPD_MFPH PD13 setting for UART0_RXD     */
N#define SYS_GPD_MFPH_PD13MFP_PWM1_CH1       (0x6UL<<SYS_GPD_MFPH_PD13MFP_Pos)   /*!< GPD_MFPH PD13 setting for PWM1_CH1      */
N#define SYS_GPD_MFPH_PD13MFP_EBI_ADR17      (0x7UL<<SYS_GPD_MFPH_PD13MFP_Pos)   /*!< GPD_MFPH PD13 setting for EBI_ADR17     */
N
N//PD.14 MFP
N#define SYS_GPD_MFPH_PD14MFP_GPIO           (0x0UL<<SYS_GPD_MFPH_PD14MFP_Pos)   /*!< GPD_MFPH PD14 setting for GPIO          */
N#define SYS_GPD_MFPH_PD14MFP_USCI1_DAT0     (0x1UL<<SYS_GPD_MFPH_PD14MFP_Pos)   /*!< GPD_MFPH PD14 setting for USCI1_DAT0    */
N#define SYS_GPD_MFPH_PD14MFP_SPI1_MISO      (0x2UL<<SYS_GPD_MFPH_PD14MFP_Pos)   /*!< GPD_MFPH PD14 setting for SPI1_MISO     */
N#define SYS_GPD_MFPH_PD14MFP_UART0_nCTS     (0x3UL<<SYS_GPD_MFPH_PD14MFP_Pos)   /*!< GPD_MFPH PD14 setting for UART0_nCTS    */
N#define SYS_GPD_MFPH_PD14MFP_PWM1_CH2       (0x6UL<<SYS_GPD_MFPH_PD14MFP_Pos)   /*!< GPD_MFPH PD14 setting for PWM1_CH2      */
N#define SYS_GPD_MFPH_PD14MFP_EBI_ADR18      (0x7UL<<SYS_GPD_MFPH_PD14MFP_Pos)   /*!< GPD_MFPH PD14 setting for EBI_ADR18     */
N
N//PD.15 MFP
N#define SYS_GPD_MFPH_PD15MFP_GPIO           (0x0UL<<SYS_GPD_MFPH_PD15MFP_Pos)   /*!< GPD_MFPH PD15 setting for GPIO          */
N#define SYS_GPD_MFPH_PD15MFP_USCI1_CLK      (0x1UL<<SYS_GPD_MFPH_PD15MFP_Pos)   /*!< GPD_MFPH PD15 setting for USCI1_CLK     */
N#define SYS_GPD_MFPH_PD15MFP_SPI1_CLK       (0x2UL<<SYS_GPD_MFPH_PD15MFP_Pos)   /*!< GPD_MFPH PD15 setting for SPI1_CLK      */
N#define SYS_GPD_MFPH_PD15MFP_UART0_nRTS     (0x3UL<<SYS_GPD_MFPH_PD15MFP_Pos)   /*!< GPD_MFPH PD15 setting for UART0_nRTS    */
N#define SYS_GPD_MFPH_PD15MFP_PWM1_CH3       (0x6UL<<SYS_GPD_MFPH_PD15MFP_Pos)   /*!< GPD_MFPH PD15 setting for PWM1_CH3      */
N#define SYS_GPD_MFPH_PD15MFP_EBI_ADR19      (0x7UL<<SYS_GPD_MFPH_PD15MFP_Pos)   /*!< GPD_MFPH PD15 setting for EBI_ADR19     */
N
N//PE.0 MFP
N#define SYS_GPE_MFPL_PE0MFP_GPIO            (0x0UL<<SYS_GPE_MFPL_PE0MFP_Pos)    /*!< GPE_MFPL PE0 setting for GPIO           */
N#define SYS_GPE_MFPL_PE0MFP_SPI0_CLK        (0x2UL<<SYS_GPE_MFPL_PE0MFP_Pos)    /*!< GPE_MFPL PE0 setting for SPI0_CLK       */
N#define SYS_GPE_MFPL_PE0MFP_I2C1_SDA        (0x3UL<<SYS_GPE_MFPL_PE0MFP_Pos)    /*!< GPE_MFPL PE0 setting for I2C1_SDA       */
N#define SYS_GPE_MFPL_PE0MFP_TM2_EXT         (0x4UL<<SYS_GPE_MFPL_PE0MFP_Pos)    /*!< GPE_MFPL PE0 setting for TM2_EXT        */
N#define SYS_GPE_MFPL_PE0MFP_SC0_nCD         (0x5UL<<SYS_GPE_MFPL_PE0MFP_Pos)    /*!< GPE_MFPL PE0 setting for SC0_nCD        */
N#define SYS_GPE_MFPL_PE0MFP_PWM0_CH0        (0x6UL<<SYS_GPE_MFPL_PE0MFP_Pos)    /*!< GPE_MFPL PE0 setting for PWM0_CH0       */
N#define SYS_GPE_MFPL_PE0MFP_EBI_nCS1        (0x7UL<<SYS_GPE_MFPL_PE0MFP_Pos)    /*!< GPE_MFPL PE0 setting for EBI_nCS1       */
N#define SYS_GPE_MFPL_PE0MFP_INT4            (0x8UL<<SYS_GPE_MFPL_PE0MFP_Pos)    /*!< GPE_MFPL PE0 setting for INT4           */
N
N//PE.1 MFP
N#define SYS_GPE_MFPL_PE1MFP_GPIO            (0x0UL<<SYS_GPE_MFPL_PE1MFP_Pos)    /*!< GPE_MFPL PE1 setting for GPIO           */
N#define SYS_GPE_MFPL_PE1MFP_TM3_EXT         (0x3UL<<SYS_GPE_MFPL_PE1MFP_Pos)    /*!< GPE_MFPL PE1 setting for TM3_EXT        */
N#define SYS_GPE_MFPL_PE1MFP_SC0_nCD         (0x5UL<<SYS_GPE_MFPL_PE1MFP_Pos)    /*!< GPE_MFPL PE1 setting for SC0_nCD        */
N#define SYS_GPE_MFPL_PE1MFP_PWM0_CH1        (0x6UL<<SYS_GPE_MFPL_PE1MFP_Pos)    /*!< GPE_MFPL PE1 setting for PWM0_CH1       */
N
N//PE.2 MFP
N#define SYS_GPE_MFPL_PE2MFP_GPIO            (0x0UL<<SYS_GPE_MFPL_PE2MFP_Pos)    /*!< GPE_MFPL PE2 setting for GPIO           */
N#define SYS_GPE_MFPL_PE2MFP_ADC0_CH9        (0x1UL<<SYS_GPE_MFPL_PE2MFP_Pos)    /*!< GPE_MFPL PE2 setting for ADC0_CH9       */
N#define SYS_GPE_MFPL_PE2MFP_UART1_nRTS      (0x4UL<<SYS_GPE_MFPL_PE2MFP_Pos)    /*!< GPE_MFPL PE2 setting for UART1_nRTS     */
N#define SYS_GPE_MFPL_PE2MFP_TM_BRAKE3       (0x5UL<<SYS_GPE_MFPL_PE2MFP_Pos)    /*!< GPE_MFPL PE2 setting for TM_BRAKE3      */
N#define SYS_GPE_MFPL_PE2MFP_PWM0_CH2        (0x6UL<<SYS_GPE_MFPL_PE2MFP_Pos)    /*!< GPE_MFPL PE2 setting for PWM0_CH2       */
N#define SYS_GPE_MFPL_PE2MFP_USCI0_CTL0      (0x8UL<<SYS_GPE_MFPL_PE2MFP_Pos)    /*!< GPE_MFPL PE2 setting for USCI0_CTL0     */
N
N//PE.3 MFP
N#define SYS_GPE_MFPL_PE3MFP_GPIO            (0x0UL<<SYS_GPE_MFPL_PE3MFP_Pos)    /*!< GPE_MFPL PE3 setting for GPIO           */
N#define SYS_GPE_MFPL_PE3MFP_SPI1_MOSI       (0x2UL<<SYS_GPE_MFPL_PE3MFP_Pos)    /*!< GPE_MFPL PE3 setting for SPI1_MOSI      */
N#define SYS_GPE_MFPL_PE3MFP_UART2_RXD       (0x4UL<<SYS_GPE_MFPL_PE3MFP_Pos)    /*!< GPE_MFPL PE3 setting for UART2_RXD      */
N#define SYS_GPE_MFPL_PE3MFP_PWM0_CH3        (0x6UL<<SYS_GPE_MFPL_PE3MFP_Pos)    /*!< GPE_MFPL PE3 setting for PWM0_CH3       */
N
N//PE.4 MFP
N#define SYS_GPE_MFPL_PE4MFP_GPIO            (0x0UL<<SYS_GPE_MFPL_PE4MFP_Pos)    /*!< GPE_MFPL PE4 setting for GPIO           */
N#define SYS_GPE_MFPL_PE4MFP_I2C0_SCL        (0x2UL<<SYS_GPE_MFPL_PE4MFP_Pos)    /*!< GPE_MFPL PE4 setting for I2C0_SCL       */
N#define SYS_GPE_MFPL_PE4MFP_I2C1_SCL        (0x3UL<<SYS_GPE_MFPL_PE4MFP_Pos)    /*!< GPE_MFPL PE4 setting for I2C1_SCL       */
N#define SYS_GPE_MFPL_PE4MFP_USCI0_CTL0      (0x4UL<<SYS_GPE_MFPL_PE4MFP_Pos)    /*!< GPE_MFPL PE4 setting for USCI0_CTL0     */
N#define SYS_GPE_MFPL_PE4MFP_SC0_PWR         (0x5UL<<SYS_GPE_MFPL_PE4MFP_Pos)    /*!< GPE_MFPL PE4 setting for SC0_PWR        */
N#define SYS_GPE_MFPL_PE4MFP_PWM1_BRAKE0     (0x6UL<<SYS_GPE_MFPL_PE4MFP_Pos)    /*!< GPE_MFPL PE4 setting for PWM1_BRAKE0    */
N#define SYS_GPE_MFPL_PE4MFP_EBI_nCS0        (0x7UL<<SYS_GPE_MFPL_PE4MFP_Pos)    /*!< GPE_MFPL PE4 setting for EBI_nCS0       */
N#define SYS_GPE_MFPL_PE4MFP_INT0            (0x8UL<<SYS_GPE_MFPL_PE4MFP_Pos)    /*!< GPE_MFPL PE4 setting for INT0           */
N
N//PE.5 MFP
N#define SYS_GPE_MFPL_PE5MFP_GPIO            (0x0UL<<SYS_GPE_MFPL_PE5MFP_Pos)    /*!< GPE_MFPL PE5 setting for GPIO           */
N#define SYS_GPE_MFPL_PE5MFP_I2C0_SDA        (0x2UL<<SYS_GPE_MFPL_PE5MFP_Pos)    /*!< GPE_MFPL PE5 setting for I2C0_SDA       */
N#define SYS_GPE_MFPL_PE5MFP_I2C1_SDA        (0x3UL<<SYS_GPE_MFPL_PE5MFP_Pos)    /*!< GPE_MFPL PE5 setting for I2C1_SDA       */
N#define SYS_GPE_MFPL_PE5MFP_USCI0_CLK       (0x4UL<<SYS_GPE_MFPL_PE5MFP_Pos)    /*!< GPE_MFPL PE5 setting for USCI0_CLK      */
N#define SYS_GPE_MFPL_PE5MFP_SC0_RST         (0x5UL<<SYS_GPE_MFPL_PE5MFP_Pos)    /*!< GPE_MFPL PE5 setting for SC0_RST        */
N#define SYS_GPE_MFPL_PE5MFP_PWM1_BRAKE1     (0x6UL<<SYS_GPE_MFPL_PE5MFP_Pos)    /*!< GPE_MFPL PE5 setting for PWM1_BRAKE1    */
N#define SYS_GPE_MFPL_PE5MFP_EBI_ALE         (0x7UL<<SYS_GPE_MFPL_PE5MFP_Pos)    /*!< GPE_MFPL PE5 setting for EBI_ALE        */
N#define SYS_GPE_MFPL_PE5MFP_INT1            (0x8UL<<SYS_GPE_MFPL_PE5MFP_Pos)    /*!< GPE_MFPL PE5 setting for INT1           */
N
N//PE.6 MFP
N#define SYS_GPE_MFPL_PE6MFP_GPIO            (0x0UL<<SYS_GPE_MFPL_PE6MFP_Pos)    /*!< GPE_MFPL PE6 setting for GPIO           */
N#define SYS_GPE_MFPL_PE6MFP_ICE_CLK         (0x1UL<<SYS_GPE_MFPL_PE6MFP_Pos)    /*!< GPE_MFPL PE6 setting for ICE_CLK        */
N#define SYS_GPE_MFPL_PE6MFP_I2C0_SCL        (0x2UL<<SYS_GPE_MFPL_PE6MFP_Pos)    /*!< GPE_MFPL PE6 setting for I2C0_SCL       */
N#define SYS_GPE_MFPL_PE6MFP_UART0_RXD       (0x3UL<<SYS_GPE_MFPL_PE6MFP_Pos)    /*!< GPE_MFPL PE6 setting for UART0_RXD      */
N
N//PE.7 MFP
N#define SYS_GPE_MFPL_PE7MFP_GPIO            (0x0UL<<SYS_GPE_MFPL_PE7MFP_Pos)    /*!< GPE_MFPL PE7 setting for GPIO           */
N#define SYS_GPE_MFPL_PE7MFP_ICE_DAT         (0x1UL<<SYS_GPE_MFPL_PE7MFP_Pos)    /*!< GPE_MFPL PE7 setting for ICE_DAT        */
N#define SYS_GPE_MFPL_PE7MFP_I2C0_SDA        (0x2UL<<SYS_GPE_MFPL_PE7MFP_Pos)    /*!< GPE_MFPL PE7 setting for I2C0_SDA       */
N#define SYS_GPE_MFPL_PE7MFP_UART0_TXD       (0x3UL<<SYS_GPE_MFPL_PE7MFP_Pos)    /*!< GPE_MFPL PE7 setting for UART0_TXD      */
N
N//PE.8 MFP
N#define SYS_GPE_MFPH_PE8MFP_GPIO            (0x0UL<<SYS_GPE_MFPH_PE8MFP_Pos)    /*!< GPE_MFPH PE8 setting for GPIO           */
N#define SYS_GPE_MFPH_PE8MFP_UART1_TXD       (0x1UL<<SYS_GPE_MFPH_PE8MFP_Pos)    /*!< GPE_MFPH PE8 setting for UART1_TXD      */
N#define SYS_GPE_MFPH_PE8MFP_TM0             (0x3UL<<SYS_GPE_MFPH_PE8MFP_Pos)    /*!< GPE_MFPH PE8 setting for TM0            */
N#define SYS_GPE_MFPH_PE8MFP_I2C1_SCL        (0x4UL<<SYS_GPE_MFPH_PE8MFP_Pos)    /*!< GPE_MFPH PE8 setting for I2C1_SCL       */
N#define SYS_GPE_MFPH_PE8MFP_SC0_PWR         (0x5UL<<SYS_GPE_MFPH_PE8MFP_Pos)    /*!< GPE_MFPH PE8 setting for SC0_PWR        */
N
N//PE.9 MFP
N#define SYS_GPE_MFPH_PE9MFP_GPIO            (0x0UL<<SYS_GPE_MFPH_PE9MFP_Pos)    /*!< GPE_MFPH PE9 setting for GPIO           */
N#define SYS_GPE_MFPH_PE9MFP_UART1_RXD       (0x1UL<<SYS_GPE_MFPH_PE9MFP_Pos)    /*!< GPE_MFPH PE9 setting for UART1_RXD      */
N#define SYS_GPE_MFPH_PE9MFP_TM1             (0x3UL<<SYS_GPE_MFPH_PE9MFP_Pos)    /*!< GPE_MFPH PE9 setting for TM1            */
N#define SYS_GPE_MFPH_PE9MFP_I2C1_SDA        (0x4UL<<SYS_GPE_MFPH_PE9MFP_Pos)    /*!< GPE_MFPH PE9 setting for I2C1_SDA       */
N#define SYS_GPE_MFPH_PE9MFP_SC0_RST         (0x5UL<<SYS_GPE_MFPH_PE9MFP_Pos)    /*!< GPE_MFPH PE9 setting for SC0_RST        */
N
N//PE.10 MFP
N#define SYS_GPE_MFPH_PE10MFP_GPIO           (0x0UL<<SYS_GPE_MFPH_PE10MFP_Pos)   /*!< GPE_MFPH PE10 setting for GPIO          */
N#define SYS_GPE_MFPH_PE10MFP_SPI1_MISO      (0x1UL<<SYS_GPE_MFPH_PE10MFP_Pos)   /*!< GPE_MFPH PE10 setting for SPI1_MISO     */
N#define SYS_GPE_MFPH_PE10MFP_SPI0_MISO      (0x2UL<<SYS_GPE_MFPH_PE10MFP_Pos)   /*!< GPE_MFPH PE10 setting for SPI0_MISO     */
N#define SYS_GPE_MFPH_PE10MFP_UART1_nCTS     (0x3UL<<SYS_GPE_MFPH_PE10MFP_Pos)   /*!< GPE_MFPH PE10 setting for UART1_nCTS    */
N#define SYS_GPE_MFPH_PE10MFP_SC0_DAT        (0x5UL<<SYS_GPE_MFPH_PE10MFP_Pos)   /*!< GPE_MFPH PE10 setting for SC0_DAT       */
N#define SYS_GPE_MFPH_PE10MFP_SPI1_CLK       (0x6UL<<SYS_GPE_MFPH_PE10MFP_Pos)   /*!< GPE_MFPH PE10 setting for SPI1_CLK      */
N#define SYS_GPE_MFPH_PE10MFP_EBI_AD7        (0x7UL<<SYS_GPE_MFPH_PE10MFP_Pos)   /*!< GPE_MFPH PE10 setting for EBI_AD7       */
N#define SYS_GPE_MFPH_PE10MFP_TM0_EXT        (0x8UL<<SYS_GPE_MFPH_PE10MFP_Pos)   /*!< GPE_MFPH PE10 setting for TM0_EXT       */
N
N//PE.11 MFP
N#define SYS_GPE_MFPH_PE11MFP_GPIO           (0x0UL<<SYS_GPE_MFPH_PE11MFP_Pos)   /*!< GPE_MFPH PE11 setting for GPIO          */
N#define SYS_GPE_MFPH_PE11MFP_SPI1_MOSI      (0x1UL<<SYS_GPE_MFPH_PE11MFP_Pos)   /*!< GPE_MFPH PE11 setting for SPI1_MOSI     */
N#define SYS_GPE_MFPH_PE11MFP_SPI0_MOSI      (0x2UL<<SYS_GPE_MFPH_PE11MFP_Pos)   /*!< GPE_MFPH PE11 setting for SPI0_MOSI     */
N#define SYS_GPE_MFPH_PE11MFP_UART1_nRTS     (0x3UL<<SYS_GPE_MFPH_PE11MFP_Pos)   /*!< GPE_MFPH PE11 setting for UART1_nRTS    */
N#define SYS_GPE_MFPH_PE11MFP_SC0_CLK        (0x5UL<<SYS_GPE_MFPH_PE11MFP_Pos)   /*!< GPE_MFPH PE11 setting for SC0_CLK       */
N#define SYS_GPE_MFPH_PE11MFP_SPI1_MISO      (0x6UL<<SYS_GPE_MFPH_PE11MFP_Pos)   /*!< GPE_MFPH PE11 setting for SPI1_MISO     */
N#define SYS_GPE_MFPH_PE11MFP_EBI_AD6        (0x7UL<<SYS_GPE_MFPH_PE11MFP_Pos)   /*!< GPE_MFPH PE11 setting for EBI_AD6       */
N#define SYS_GPE_MFPH_PE11MFP_TM1_EXT        (0x8UL<<SYS_GPE_MFPH_PE11MFP_Pos)   /*!< GPE_MFPH PE11 setting for TM1_EXT       */
N
N//PE.12 MFP
N#define SYS_GPE_MFPH_PE12MFP_GPIO           (0x0UL<<SYS_GPE_MFPH_PE12MFP_Pos)   /*!< GPE_MFPH PE12 setting for GPIO          */
N#define SYS_GPE_MFPH_PE12MFP_SPI1_SS        (0x1UL<<SYS_GPE_MFPH_PE12MFP_Pos)   /*!< GPE_MFPH PE12 setting for SPI1_SS       */
N#define SYS_GPE_MFPH_PE12MFP_SPI0_SS        (0x2UL<<SYS_GPE_MFPH_PE12MFP_Pos)   /*!< GPE_MFPH PE12 setting for SPI0_SS       */
N#define SYS_GPE_MFPH_PE12MFP_UART1_TXD      (0x3UL<<SYS_GPE_MFPH_PE12MFP_Pos)   /*!< GPE_MFPH PE12 setting for UART1_TXD     */
N#define SYS_GPE_MFPH_PE12MFP_I2C0_SCL       (0x4UL<<SYS_GPE_MFPH_PE12MFP_Pos)   /*!< GPE_MFPH PE12 setting for I2C0_SCL      */
N#define SYS_GPE_MFPH_PE12MFP_SPI1_MOSI      (0x6UL<<SYS_GPE_MFPH_PE12MFP_Pos)   /*!< GPE_MFPH PE12 setting for SPI1_MOSI     */
N#define SYS_GPE_MFPH_PE12MFP_EBI_AD5        (0x7UL<<SYS_GPE_MFPH_PE12MFP_Pos)   /*!< GPE_MFPH PE12 setting for EBI_AD5       */
N#define SYS_GPE_MFPH_PE12MFP_TM2_EXT        (0x8UL<<SYS_GPE_MFPH_PE12MFP_Pos)   /*!< GPE_MFPH PE12 setting for TM2_EXT       */
N
N//PE.13 MFP
N#define SYS_GPE_MFPH_PE13MFP_GPIO           (0x0UL<<SYS_GPE_MFPH_PE13MFP_Pos)   /*!< GPE_MFPH PE13 setting for GPIO          */
N#define SYS_GPE_MFPH_PE13MFP_SPI1_CLK       (0x1UL<<SYS_GPE_MFPH_PE13MFP_Pos)   /*!< GPE_MFPH PE13 setting for SPI1_CLK      */
N#define SYS_GPE_MFPH_PE13MFP_SPI0_CLK       (0x2UL<<SYS_GPE_MFPH_PE13MFP_Pos)   /*!< GPE_MFPH PE13 setting for SPI0_CLK      */
N#define SYS_GPE_MFPH_PE13MFP_UART1_RXD      (0x3UL<<SYS_GPE_MFPH_PE13MFP_Pos)   /*!< GPE_MFPH PE13 setting for UART1_RXD     */
N#define SYS_GPE_MFPH_PE13MFP_I2C0_SDA       (0x4UL<<SYS_GPE_MFPH_PE13MFP_Pos)   /*!< GPE_MFPH PE13 setting for I2C0_SDA      */
N#define SYS_GPE_MFPH_PE13MFP_SPI1_SS        (0x6UL<<SYS_GPE_MFPH_PE13MFP_Pos)   /*!< GPE_MFPH PE13 setting for SPI1_SS       */
N#define SYS_GPE_MFPH_PE13MFP_EBI_AD4        (0x7UL<<SYS_GPE_MFPH_PE13MFP_Pos)   /*!< GPE_MFPH PE13 setting for EBI_AD4       */
N#define SYS_GPE_MFPH_PE13MFP_TM3_EXT        (0x8UL<<SYS_GPE_MFPH_PE13MFP_Pos)   /*!< GPE_MFPH PE13 setting for TM3_EXT       */
N
N//PF.0 MFP
N#define SYS_GPF_MFPL_PF0MFP_GPIO            (0x0UL<<SYS_GPF_MFPL_PF0MFP_Pos)    /*!< GPF_MFPL PF0 setting for GPIO           */
N#define SYS_GPF_MFPL_PF0MFP_X32_OUT         (0x1UL<<SYS_GPF_MFPL_PF0MFP_Pos)    /*!< GPF_MFPL PF0 setting for X32_OUT        */
N#define SYS_GPF_MFPL_PF0MFP_USCI2_CTL1      (0x5UL<<SYS_GPF_MFPL_PF0MFP_Pos)    /*!< GPF_MFPL PF0 setting for USCI2_CTL1     */
N#define SYS_GPF_MFPL_PF0MFP_INT5            (0x8UL<<SYS_GPF_MFPL_PF0MFP_Pos)    /*!< GPF_MFPL PF0 setting for INT5           */
N
N//PF.1 MFP
N#define SYS_GPF_MFPL_PF1MFP_GPIO            (0x0UL<<SYS_GPF_MFPL_PF1MFP_Pos)    /*!< GPF_MFPL PF1 setting for GPIO           */
N#define SYS_GPF_MFPL_PF1MFP_X32_IN          (0x1UL<<SYS_GPF_MFPL_PF1MFP_Pos)    /*!< GPF_MFPL PF1 setting for X32_IN         */
N#define SYS_GPF_MFPL_PF1MFP_USCI2_CTL0      (0x5UL<<SYS_GPF_MFPL_PF1MFP_Pos)    /*!< GPF_MFPL PF1 setting for USCI2_CTL0     */
N#define SYS_GPF_MFPL_PF1MFP_PWM1_BRAKE0     (0x6UL<<SYS_GPF_MFPL_PF1MFP_Pos)    /*!< GPF_MFPL PF1 setting for PWM1_BRAKE0    */
N
N//PF.2 MFP
N#define SYS_GPF_MFPL_PF2MFP_GPIO            (0x0UL<<SYS_GPF_MFPL_PF2MFP_Pos)    /*!< GPF_MFPL PF2 setting for GPIO           */
N#define SYS_GPF_MFPL_PF2MFP_USCI2_CLK       (0x5UL<<SYS_GPF_MFPL_PF2MFP_Pos)    /*!< GPF_MFPL PF2 setting for USCI2_CLK      */
N#define SYS_GPF_MFPL_PF2MFP_PWM1_BRAKE1     (0x6UL<<SYS_GPF_MFPL_PF2MFP_Pos)    /*!< GPF_MFPL PF2 setting for PWM1_BRAKE1    */
N
N//PF.3 MFP
N#define SYS_GPF_MFPL_PF3MFP_GPIO            (0x0UL<<SYS_GPF_MFPL_PF3MFP_Pos)    /*!< GPF_MFPL PF3 setting for GPIO           */
N#define SYS_GPF_MFPL_PF3MFP_XT1_OUT         (0x1UL<<SYS_GPF_MFPL_PF3MFP_Pos)    /*!< GPF_MFPL PF3 setting for XT1_OUT        */
N#define SYS_GPF_MFPL_PF3MFP_I2C1_SCL        (0x3UL<<SYS_GPF_MFPL_PF3MFP_Pos)    /*!< GPF_MFPL PF3 setting for I2C1_SCL       */
N
N//PF.4 MFP
N#define SYS_GPF_MFPL_PF4MFP_GPIO            (0x0UL<<SYS_GPF_MFPL_PF4MFP_Pos)    /*!< GPF_MFPL PF4 setting for GPIO           */
N#define SYS_GPF_MFPL_PF4MFP_XT1_IN          (0x1UL<<SYS_GPF_MFPL_PF4MFP_Pos)    /*!< GPF_MFPL PF4 setting for XT1_IN         */
N#define SYS_GPF_MFPL_PF4MFP_I2C1_SDA        (0x3UL<<SYS_GPF_MFPL_PF4MFP_Pos)    /*!< GPF_MFPL PF4 setting for I2C1_SDA       */
N
N//PF.5 MFP
N#define SYS_GPF_MFPL_PF5MFP_GPIO            (0x0UL<<SYS_GPF_MFPL_PF5MFP_Pos)    /*!< GPF_MFPL PF5 setting for GPIO           */
N#define SYS_GPF_MFPL_PF5MFP_TM3_EXT         (0x3UL<<SYS_GPF_MFPL_PF5MFP_Pos)    /*!< GPF_MFPL PF5 setting for TM3_EXT        */
N#define SYS_GPF_MFPL_PF5MFP_SC1_nCD         (0x5UL<<SYS_GPF_MFPL_PF5MFP_Pos)    /*!< GPF_MFPL PF5 setting for SC1_nCD        */
N#define SYS_GPF_MFPL_PF5MFP_TM_BRAKE0       (0x6UL<<SYS_GPF_MFPL_PF5MFP_Pos)    /*!< GPF_MFPL PF5 setting for TM_BRAKE0      */
N
N//PF.6 MFP
N#define SYS_GPF_MFPL_PF6MFP_GPIO            (0x0UL<<SYS_GPF_MFPL_PF6MFP_Pos)    /*!< GPF_MFPL PF6 setting for GPIO           */
N
N//PF.7 MFP
N#define SYS_GPF_MFPL_PF7MFP_GPIO            (0x0UL<<SYS_GPF_MFPL_PF7MFP_Pos)    /*!< GPF_MFPL PF7 setting for GPIO           */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Multi-Function constant definitions.                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ACMP0_N_PB4              SYS_GPB_MFPL_PB4MFP_ACMP0_N          /*!< GPB_MFPL PB4 setting for ACMP0_N        */
N#define ACMP0_O_PD6              SYS_GPD_MFPL_PD6MFP_ACMP0_O          /*!< GPD_MFPL PD6 setting for ACMP0_O        */
N#define ACMP0_O_PD7              SYS_GPD_MFPL_PD7MFP_ACMP0_O          /*!< GPD_MFPL PD7 setting for ACMP0_O        */
N#define ACMP0_P0_PB7             SYS_GPB_MFPL_PB7MFP_ACMP0_P0         /*!< GPB_MFPL PB7 setting for ACMP0_P0       */
N#define ACMP0_P1_PB6             SYS_GPB_MFPL_PB6MFP_ACMP0_P1         /*!< GPB_MFPL PB6 setting for ACMP0_P1       */
N#define ACMP0_P2_PB5             SYS_GPB_MFPL_PB5MFP_ACMP0_P2         /*!< GPB_MFPL PB5 setting for ACMP0_P2       */
N#define ACMP0_P3_PB15            SYS_GPB_MFPH_PB15MFP_ACMP0_P3        /*!< GPB_MFPH PB15 setting for ACMP0_P3      */
N#define ACMP0_WLAT_PC0           SYS_GPC_MFPL_PC0MFP_ACMP0_WLAT       /*!< GPC_MFPL PC0 setting for ACMP0_WLAT     */
N#define ACMP1_N_PD0              SYS_GPD_MFPL_PD0MFP_ACMP1_N          /*!< GPD_MFPL PD0 setting for ACMP1_N        */
N#define ACMP1_O_PC6              SYS_GPC_MFPL_PC6MFP_ACMP1_O          /*!< GPC_MFPL PC6 setting for ACMP1_O        */
N#define ACMP1_O_PC2              SYS_GPC_MFPL_PC2MFP_ACMP1_O          /*!< GPC_MFPL PC2 setting for ACMP1_O        */
N#define ACMP1_P0_PD3             SYS_GPD_MFPL_PD3MFP_ACMP1_P0         /*!< GPD_MFPL PD3 setting for ACMP1_P0       */
N#define ACMP1_P1_PD2             SYS_GPD_MFPL_PD2MFP_ACMP1_P1         /*!< GPD_MFPL PD2 setting for ACMP1_P1       */
N#define ACMP1_P2_PD1             SYS_GPD_MFPL_PD1MFP_ACMP1_P2         /*!< GPD_MFPL PD1 setting for ACMP1_P2       */
N#define ACMP1_P3_PD9             SYS_GPD_MFPH_PD9MFP_ACMP1_P3         /*!< GPD_MFPH PD9 setting for ACMP1_P3       */
N#define ACMP1_WLAT_PC1           SYS_GPC_MFPL_PC1MFP_ACMP1_WLAT       /*!< GPC_MFPL PC1 setting for ACMP1_WLAT     */
N#define ADC0_CH0_PB0             SYS_GPB_MFPL_PB0MFP_ADC0_CH0         /*!< GPB_MFPL PB0 setting for ADC0_CH0       */
N#define ADC0_CH1_PB1             SYS_GPB_MFPL_PB1MFP_ADC0_CH1         /*!< GPB_MFPL PB1 setting for ADC0_CH1       */
N#define ADC0_CH10_PB13           SYS_GPB_MFPH_PB13MFP_ADC0_CH10       /*!< GPB_MFPH PB13 setting for ADC0_CH10     */
N#define ADC0_CH11_PB14           SYS_GPB_MFPH_PB14MFP_ADC0_CH11       /*!< GPB_MFPH PB14 setting for ADC0_CH11     */
N#define ADC0_CH12_PB15           SYS_GPB_MFPH_PB15MFP_ADC0_CH12       /*!< GPB_MFPH PB15 setting for ADC0_CH12     */
N#define ADC0_CH13_PB5            SYS_GPB_MFPL_PB5MFP_ADC0_CH13        /*!< GPB_MFPL PB5 setting for ADC0_CH13      */
N#define ADC0_CH14_PB6            SYS_GPB_MFPL_PB6MFP_ADC0_CH14        /*!< GPB_MFPL PB6 setting for ADC0_CH14      */
N#define ADC0_CH15_PB7            SYS_GPB_MFPL_PB7MFP_ADC0_CH15        /*!< GPB_MFPL PB7 setting for ADC0_CH15      */
N#define ADC0_CH16_PC8            SYS_GPC_MFPH_PC8MFP_ADC0_CH16        /*!< GPC_MFPH PC8 setting for ADC0_CH16      */
N#define ADC0_CH17_PD8            SYS_GPD_MFPH_PD8MFP_ADC0_CH17        /*!< GPD_MFPH PD8 setting for ADC0_CH17      */
N#define ADC0_CH18_PD9            SYS_GPD_MFPH_PD9MFP_ADC0_CH18        /*!< GPD_MFPH PD9 setting for ADC0_CH18      */
N#define ADC0_CH19_PD1            SYS_GPD_MFPL_PD1MFP_ADC0_CH19        /*!< GPD_MFPL PD1 setting for ADC0_CH19      */
N#define ADC0_CH2_PB2             SYS_GPB_MFPL_PB2MFP_ADC0_CH2         /*!< GPB_MFPL PB2 setting for ADC0_CH2       */
N#define ADC0_CH3_PB3             SYS_GPB_MFPL_PB3MFP_ADC0_CH3         /*!< GPB_MFPL PB3 setting for ADC0_CH3       */
N#define ADC0_CH4_PB4             SYS_GPB_MFPL_PB4MFP_ADC0_CH4         /*!< GPB_MFPL PB4 setting for ADC0_CH4       */
N#define ADC0_CH5_PB8             SYS_GPB_MFPH_PB8MFP_ADC0_CH5         /*!< GPB_MFPH PB8 setting for ADC0_CH5       */
N#define ADC0_CH6_PB9             SYS_GPB_MFPH_PB9MFP_ADC0_CH6         /*!< GPB_MFPH PB9 setting for ADC0_CH6       */
N#define ADC0_CH7_PB10            SYS_GPB_MFPH_PB10MFP_ADC0_CH7        /*!< GPB_MFPH PB10 setting for ADC0_CH7      */
N#define ADC0_CH8_PB11            SYS_GPB_MFPH_PB11MFP_ADC0_CH8        /*!< GPB_MFPH PB11 setting for ADC0_CH8      */
N#define ADC0_CH9_PE2             SYS_GPE_MFPL_PE2MFP_ADC0_CH9         /*!< GPE_MFPL PE2 setting for ADC0_CH9       */
N#define ADC0_ST_PD2              SYS_GPD_MFPL_PD2MFP_ADC0_ST          /*!< GPD_MFPL PD2 setting for ADC0_ST        */
N#define CLKO_PD5                 SYS_GPD_MFPL_PD5MFP_CLKO             /*!< GPD_MFPL PD5 setting for CLKO           */
N#define CLKO_PD6                 SYS_GPD_MFPL_PD6MFP_CLKO             /*!< GPD_MFPL PD6 setting for CLKO           */
N#define CLKO_PA8                 SYS_GPA_MFPH_PA8MFP_CLKO             /*!< GPA_MFPH PA8 setting for CLKO           */
N#define CLKO_PC1                 SYS_GPC_MFPL_PC1MFP_CLKO             /*!< GPC_MFPL PC1 setting for CLKO           */
N#define EBI_AD0_PA0              SYS_GPA_MFPL_PA0MFP_EBI_AD0          /*!< GPA_MFPL PA0 setting for EBI_AD0        */
N#define EBI_AD1_PA1              SYS_GPA_MFPL_PA1MFP_EBI_AD1          /*!< GPA_MFPL PA1 setting for EBI_AD1        */
N#define EBI_AD10_PC2             SYS_GPC_MFPL_PC2MFP_EBI_AD10         /*!< GPC_MFPL PC2 setting for EBI_AD10       */
N#define EBI_AD11_PC3             SYS_GPC_MFPL_PC3MFP_EBI_AD11         /*!< GPC_MFPL PC3 setting for EBI_AD11       */
N#define EBI_AD12_PC4             SYS_GPC_MFPL_PC4MFP_EBI_AD12         /*!< GPC_MFPL PC4 setting for EBI_AD12       */
N#define EBI_AD13_PC5             SYS_GPC_MFPL_PC5MFP_EBI_AD13         /*!< GPC_MFPL PC5 setting for EBI_AD13       */
N#define EBI_AD14_PC6             SYS_GPC_MFPL_PC6MFP_EBI_AD14         /*!< GPC_MFPL PC6 setting for EBI_AD14       */
N#define EBI_AD15_PC7             SYS_GPC_MFPL_PC7MFP_EBI_AD15         /*!< GPC_MFPL PC7 setting for EBI_AD15       */
N#define EBI_AD2_PA2              SYS_GPA_MFPL_PA2MFP_EBI_AD2          /*!< GPA_MFPL PA2 setting for EBI_AD2        */
N#define EBI_AD3_PA3              SYS_GPA_MFPL_PA3MFP_EBI_AD3          /*!< GPA_MFPL PA3 setting for EBI_AD3        */
N#define EBI_AD4_PA4              SYS_GPA_MFPL_PA4MFP_EBI_AD4          /*!< GPA_MFPL PA4 setting for EBI_AD4        */
N#define EBI_AD4_PB7              SYS_GPB_MFPL_PB7MFP_EBI_AD4          /*!< GPB_MFPL PB7 setting for EBI_AD4        */
N#define EBI_AD4_PE13             SYS_GPE_MFPH_PE13MFP_EBI_AD4         /*!< GPE_MFPH PE13 setting for EBI_AD4       */
N#define EBI_AD5_PA5              SYS_GPA_MFPL_PA5MFP_EBI_AD5          /*!< GPA_MFPL PA5 setting for EBI_AD5        */
N#define EBI_AD5_PE12             SYS_GPE_MFPH_PE12MFP_EBI_AD5         /*!< GPE_MFPH PE12 setting for EBI_AD5       */
N#define EBI_AD5_PB6              SYS_GPB_MFPL_PB6MFP_EBI_AD5          /*!< GPB_MFPL PB6 setting for EBI_AD5        */
N#define EBI_AD6_PE11             SYS_GPE_MFPH_PE11MFP_EBI_AD6         /*!< GPE_MFPH PE11 setting for EBI_AD6       */
N#define EBI_AD6_PA6              SYS_GPA_MFPL_PA6MFP_EBI_AD6          /*!< GPA_MFPL PA6 setting for EBI_AD6        */
N#define EBI_AD6_PB5              SYS_GPB_MFPL_PB5MFP_EBI_AD6          /*!< GPB_MFPL PB5 setting for EBI_AD6        */
N#define EBI_AD7_PB4              SYS_GPB_MFPL_PB4MFP_EBI_AD7          /*!< GPB_MFPL PB4 setting for EBI_AD7        */
N#define EBI_AD7_PA7              SYS_GPA_MFPL_PA7MFP_EBI_AD7          /*!< GPA_MFPL PA7 setting for EBI_AD7        */
N#define EBI_AD7_PE10             SYS_GPE_MFPH_PE10MFP_EBI_AD7         /*!< GPE_MFPH PE10 setting for EBI_AD7       */
N#define EBI_AD8_PC0              SYS_GPC_MFPL_PC0MFP_EBI_AD8          /*!< GPC_MFPL PC0 setting for EBI_AD8        */
N#define EBI_AD9_PC1              SYS_GPC_MFPL_PC1MFP_EBI_AD9          /*!< GPC_MFPL PC1 setting for EBI_AD9        */
N#define EBI_ADR16_PD12           SYS_GPD_MFPH_PD12MFP_EBI_ADR16       /*!< GPD_MFPH PD12 setting for EBI_ADR16     */
N#define EBI_ADR17_PD13           SYS_GPD_MFPH_PD13MFP_EBI_ADR17       /*!< GPD_MFPH PD13 setting for EBI_ADR17     */
N#define EBI_ADR18_PD14           SYS_GPD_MFPH_PD14MFP_EBI_ADR18       /*!< GPD_MFPH PD14 setting for EBI_ADR18     */
N#define EBI_ADR19_PD15           SYS_GPD_MFPH_PD15MFP_EBI_ADR19       /*!< GPD_MFPH PD15 setting for EBI_ADR19     */
N#define EBI_ALE_PB3              SYS_GPB_MFPL_PB3MFP_EBI_ALE          /*!< GPB_MFPL PB3 setting for EBI_ALE        */
N#define EBI_ALE_PE5              SYS_GPE_MFPL_PE5MFP_EBI_ALE          /*!< GPE_MFPL PE5 setting for EBI_ALE        */
N#define EBI_ALE_PD9              SYS_GPD_MFPH_PD9MFP_EBI_ALE          /*!< GPD_MFPH PD9 setting for EBI_ALE        */
N#define EBI_MCLK_PD3             SYS_GPD_MFPL_PD3MFP_EBI_MCLK         /*!< GPD_MFPL PD3 setting for EBI_MCLK       */
N#define EBI_nCS0_PE4             SYS_GPE_MFPL_PE4MFP_EBI_nCS0         /*!< GPE_MFPL PE4 setting for EBI_nCS0       */
N#define EBI_nCS0_PB2             SYS_GPB_MFPL_PB2MFP_EBI_nCS0         /*!< GPB_MFPL PB2 setting for EBI_nCS0       */
N#define EBI_nCS0_PD8             SYS_GPD_MFPH_PD8MFP_EBI_nCS0         /*!< GPD_MFPH PD8 setting for EBI_nCS0       */
N#define EBI_nCS1_PE0             SYS_GPE_MFPL_PE0MFP_EBI_nCS1         /*!< GPE_MFPL PE0 setting for EBI_nCS1       */
N#define EBI_nCS1_PB15            SYS_GPB_MFPH_PB15MFP_EBI_nCS1        /*!< GPB_MFPH PB15 setting for EBI_nCS1      */
N#define EBI_nRD_PD7              SYS_GPD_MFPL_PD7MFP_EBI_nRD          /*!< GPD_MFPL PD7 setting for EBI_nRD        */
N#define EBI_nRD_PD1              SYS_GPD_MFPL_PD1MFP_EBI_nRD          /*!< GPD_MFPL PD1 setting for EBI_nRD        */
N#define EBI_nWR_PD6              SYS_GPD_MFPL_PD6MFP_EBI_nWR          /*!< GPD_MFPL PD6 setting for EBI_nWR        */
N#define EBI_nWR_PD2              SYS_GPD_MFPL_PD2MFP_EBI_nWR          /*!< GPD_MFPL PD2 setting for EBI_nWR        */
N#define EBI_nWRH_PB1             SYS_GPB_MFPL_PB1MFP_EBI_nWRH         /*!< GPB_MFPL PB1 setting for EBI_nWRH       */
N#define EBI_nWRL_PB0             SYS_GPB_MFPL_PB0MFP_EBI_nWRL         /*!< GPB_MFPL PB0 setting for EBI_nWRL       */
N#define I2C0_SCL_PE4             SYS_GPE_MFPL_PE4MFP_I2C0_SCL         /*!< GPE_MFPL PE4 setting for I2C0_SCL       */
N#define I2C0_SCL_PA3             SYS_GPA_MFPL_PA3MFP_I2C0_SCL         /*!< GPA_MFPL PA3 setting for I2C0_SCL       */
N#define I2C0_SCL_PE12            SYS_GPE_MFPH_PE12MFP_I2C0_SCL        /*!< GPE_MFPH PE12 setting for I2C0_SCL      */
N#define I2C0_SCL_PD5             SYS_GPD_MFPL_PD5MFP_I2C0_SCL         /*!< GPD_MFPL PD5 setting for I2C0_SCL       */
N#define I2C0_SCL_PE6             SYS_GPE_MFPL_PE6MFP_I2C0_SCL         /*!< GPE_MFPL PE6 setting for I2C0_SCL       */
N#define I2C0_SDA_PA2             SYS_GPA_MFPL_PA2MFP_I2C0_SDA         /*!< GPA_MFPL PA2 setting for I2C0_SDA       */
N#define I2C0_SDA_PD4             SYS_GPD_MFPL_PD4MFP_I2C0_SDA         /*!< GPD_MFPL PD4 setting for I2C0_SDA       */
N#define I2C0_SDA_PE7             SYS_GPE_MFPL_PE7MFP_I2C0_SDA         /*!< GPE_MFPL PE7 setting for I2C0_SDA       */
N#define I2C0_SDA_PE13            SYS_GPE_MFPH_PE13MFP_I2C0_SDA        /*!< GPE_MFPH PE13 setting for I2C0_SDA      */
N#define I2C0_SDA_PE5             SYS_GPE_MFPL_PE5MFP_I2C0_SDA         /*!< GPE_MFPL PE5 setting for I2C0_SDA       */
N#define I2C1_SCL_PC4             SYS_GPC_MFPL_PC4MFP_I2C1_SCL         /*!< GPC_MFPL PC4 setting for I2C1_SCL       */
N#define I2C1_SCL_PE4             SYS_GPE_MFPL_PE4MFP_I2C1_SCL         /*!< GPE_MFPL PE4 setting for I2C1_SCL       */
N#define I2C1_SCL_PC9             SYS_GPC_MFPH_PC9MFP_I2C1_SCL         /*!< GPC_MFPH PC9 setting for I2C1_SCL       */
N#define I2C1_SCL_PE8             SYS_GPE_MFPH_PE8MFP_I2C1_SCL         /*!< GPE_MFPH PE8 setting for I2C1_SCL       */
N#define I2C1_SCL_PA8             SYS_GPA_MFPH_PA8MFP_I2C1_SCL         /*!< GPA_MFPH PA8 setting for I2C1_SCL       */
N#define I2C1_SCL_PF3             SYS_GPF_MFPL_PF3MFP_I2C1_SCL         /*!< GPF_MFPL PF3 setting for I2C1_SCL       */
N#define I2C1_SDA_PC5             SYS_GPC_MFPL_PC5MFP_I2C1_SDA         /*!< GPC_MFPL PC5 setting for I2C1_SDA       */
N#define I2C1_SDA_PE0             SYS_GPE_MFPL_PE0MFP_I2C1_SDA         /*!< GPE_MFPL PE0 setting for I2C1_SDA       */
N#define I2C1_SDA_PC10            SYS_GPC_MFPH_PC10MFP_I2C1_SDA        /*!< GPC_MFPH PC10 setting for I2C1_SDA      */
N#define I2C1_SDA_PA9             SYS_GPA_MFPH_PA9MFP_I2C1_SDA         /*!< GPA_MFPH PA9 setting for I2C1_SDA       */
N#define I2C1_SDA_PE9             SYS_GPE_MFPH_PE9MFP_I2C1_SDA         /*!< GPE_MFPH PE9 setting for I2C1_SDA       */
N#define I2C1_SDA_PE5             SYS_GPE_MFPL_PE5MFP_I2C1_SDA         /*!< GPE_MFPL PE5 setting for I2C1_SDA       */
N#define I2C1_SDA_PF4             SYS_GPF_MFPL_PF4MFP_I2C1_SDA         /*!< GPF_MFPL PF4 setting for I2C1_SDA       */
N#define ICE_CLK_PE6              SYS_GPE_MFPL_PE6MFP_ICE_CLK          /*!< GPE_MFPL PE6 setting for ICE_CLK        */
N#define ICE_DAT_PE7              SYS_GPE_MFPL_PE7MFP_ICE_DAT          /*!< GPE_MFPL PE7 setting for ICE_DAT        */
N#define INT0_PE4                 SYS_GPE_MFPL_PE4MFP_INT0             /*!< GPE_MFPL PE4 setting for INT0           */
N#define INT0_PD2                 SYS_GPD_MFPL_PD2MFP_INT0             /*!< GPD_MFPL PD2 setting for INT0           */
N#define INT0_PA0                 SYS_GPA_MFPL_PA0MFP_INT0             /*!< GPA_MFPL PA0 setting for INT0           */
N#define INT1_PE5                 SYS_GPE_MFPL_PE5MFP_INT1             /*!< GPE_MFPL PE5 setting for INT1           */
N#define INT1_PD3                 SYS_GPD_MFPL_PD3MFP_INT1             /*!< GPD_MFPL PD3 setting for INT1           */
N#define INT1_PB0                 SYS_GPB_MFPL_PB0MFP_INT1             /*!< GPB_MFPL PB0 setting for INT1           */
N#define INT2_PC0                 SYS_GPC_MFPL_PC0MFP_INT2             /*!< GPC_MFPL PC0 setting for INT2           */
N#define INT3_PD0                 SYS_GPD_MFPL_PD0MFP_INT3             /*!< GPD_MFPL PD0 setting for INT3           */
N#define INT4_PE0                 SYS_GPE_MFPL_PE0MFP_INT4             /*!< GPE_MFPL PE0 setting for INT4           */
N#define INT5_PF0                 SYS_GPF_MFPL_PF0MFP_INT5             /*!< GPF_MFPL PF0 setting for INT5           */
N#define PWM0_BRAKE0_PD2          SYS_GPD_MFPL_PD2MFP_PWM0_BRAKE0      /*!< GPD_MFPL PD2 setting for PWM0_BRAKE0    */
N#define PWM0_BRAKE0_PD4          SYS_GPD_MFPL_PD4MFP_PWM0_BRAKE0      /*!< GPD_MFPL PD4 setting for PWM0_BRAKE0    */
N#define PWM0_BRAKE0_PA8          SYS_GPA_MFPH_PA8MFP_PWM0_BRAKE0      /*!< GPA_MFPH PA8 setting for PWM0_BRAKE0    */
N#define PWM0_BRAKE1_PD5          SYS_GPD_MFPL_PD5MFP_PWM0_BRAKE1      /*!< GPD_MFPL PD5 setting for PWM0_BRAKE1    */
N#define PWM0_BRAKE1_PD3          SYS_GPD_MFPL_PD3MFP_PWM0_BRAKE1      /*!< GPD_MFPL PD3 setting for PWM0_BRAKE1    */
N#define PWM0_CH0_PC0             SYS_GPC_MFPL_PC0MFP_PWM0_CH0         /*!< GPC_MFPL PC0 setting for PWM0_CH0       */
N#define PWM0_CH0_PE0             SYS_GPE_MFPL_PE0MFP_PWM0_CH0         /*!< GPE_MFPL PE0 setting for PWM0_CH0       */
N#define PWM0_CH1_PC1             SYS_GPC_MFPL_PC1MFP_PWM0_CH1         /*!< GPC_MFPL PC1 setting for PWM0_CH1       */
N#define PWM0_CH1_PE1             SYS_GPE_MFPL_PE1MFP_PWM0_CH1         /*!< GPE_MFPL PE1 setting for PWM0_CH1       */
N#define PWM0_CH2_PE2             SYS_GPE_MFPL_PE2MFP_PWM0_CH2         /*!< GPE_MFPL PE2 setting for PWM0_CH2       */
N#define PWM0_CH2_PC2             SYS_GPC_MFPL_PC2MFP_PWM0_CH2         /*!< GPC_MFPL PC2 setting for PWM0_CH2       */
N#define PWM0_CH2_PB8             SYS_GPB_MFPH_PB8MFP_PWM0_CH2         /*!< GPB_MFPH PB8 setting for PWM0_CH2       */
N#define PWM0_CH3_PE3             SYS_GPE_MFPL_PE3MFP_PWM0_CH3         /*!< GPE_MFPL PE3 setting for PWM0_CH3       */
N#define PWM0_CH3_PC3             SYS_GPC_MFPL_PC3MFP_PWM0_CH3         /*!< GPC_MFPL PC3 setting for PWM0_CH3       */
N#define PWM0_CH4_PC4             SYS_GPC_MFPL_PC4MFP_PWM0_CH4         /*!< GPC_MFPL PC4 setting for PWM0_CH4       */
N#define PWM0_CH5_PD7             SYS_GPD_MFPL_PD7MFP_PWM0_CH5         /*!< GPD_MFPL PD7 setting for PWM0_CH5       */
N#define PWM0_CH5_PC5             SYS_GPC_MFPL_PC5MFP_PWM0_CH5         /*!< GPC_MFPL PC5 setting for PWM0_CH5       */
N#define PWM0_CH5_PD6             SYS_GPD_MFPL_PD6MFP_PWM0_CH5         /*!< GPD_MFPL PD6 setting for PWM0_CH5       */
N#define PWM0_SYNC_IN_PD7         SYS_GPD_MFPL_PD7MFP_PWM0_SYNC_IN     /*!< GPD_MFPL PD7 setting for PWM0_SYNC_IN   */
N#define PWM0_SYNC_IN_PD1         SYS_GPD_MFPL_PD1MFP_PWM0_SYNC_IN     /*!< GPD_MFPL PD1 setting for PWM0_SYNC_IN   */
N#define PWM0_SYNC_OUT_PB1        SYS_GPB_MFPL_PB1MFP_PWM0_SYNC_OUT    /*!< GPB_MFPL PB1 setting for PWM0_SYNC_OUT  */
N#define PWM1_BRAKE0_PE4          SYS_GPE_MFPL_PE4MFP_PWM1_BRAKE0      /*!< GPE_MFPL PE4 setting for PWM1_BRAKE0    */
N#define PWM1_BRAKE0_PF1          SYS_GPF_MFPL_PF1MFP_PWM1_BRAKE0      /*!< GPF_MFPL PF1 setting for PWM1_BRAKE0    */
N#define PWM1_BRAKE1_PF2          SYS_GPF_MFPL_PF2MFP_PWM1_BRAKE1      /*!< GPF_MFPL PF2 setting for PWM1_BRAKE1    */
N#define PWM1_BRAKE1_PA9          SYS_GPA_MFPH_PA9MFP_PWM1_BRAKE1      /*!< GPA_MFPH PA9 setting for PWM1_BRAKE1    */
N#define PWM1_BRAKE1_PE5          SYS_GPE_MFPL_PE5MFP_PWM1_BRAKE1      /*!< GPE_MFPL PE5 setting for PWM1_BRAKE1    */
N#define PWM1_CH0_PD12            SYS_GPD_MFPH_PD12MFP_PWM1_CH0        /*!< GPD_MFPH PD12 setting for PWM1_CH0      */
N#define PWM1_CH0_PC9             SYS_GPC_MFPH_PC9MFP_PWM1_CH0         /*!< GPC_MFPH PC9 setting for PWM1_CH0       */
N#define PWM1_CH0_PC6             SYS_GPC_MFPL_PC6MFP_PWM1_CH0         /*!< GPC_MFPL PC6 setting for PWM1_CH0       */
N#define PWM1_CH0_PC15            SYS_GPC_MFPH_PC15MFP_PWM1_CH0        /*!< GPC_MFPH PC15 setting for PWM1_CH0      */
N#define PWM1_CH1_PC10            SYS_GPC_MFPH_PC10MFP_PWM1_CH1        /*!< GPC_MFPH PC10 setting for PWM1_CH1      */
N#define PWM1_CH1_PD13            SYS_GPD_MFPH_PD13MFP_PWM1_CH1        /*!< GPD_MFPH PD13 setting for PWM1_CH1      */
N#define PWM1_CH1_PC7             SYS_GPC_MFPL_PC7MFP_PWM1_CH1         /*!< GPC_MFPL PC7 setting for PWM1_CH1       */
N#define PWM1_CH1_PB12            SYS_GPB_MFPH_PB12MFP_PWM1_CH1        /*!< GPB_MFPH PB12 setting for PWM1_CH1      */
N#define PWM1_CH2_PC11            SYS_GPC_MFPH_PC11MFP_PWM1_CH2        /*!< GPC_MFPH PC11 setting for PWM1_CH2      */
N#define PWM1_CH2_PD14            SYS_GPD_MFPH_PD14MFP_PWM1_CH2        /*!< GPD_MFPH PD14 setting for PWM1_CH2      */
N#define PWM1_CH2_PA3             SYS_GPA_MFPL_PA3MFP_PWM1_CH2         /*!< GPA_MFPL PA3 setting for PWM1_CH2       */
N#define PWM1_CH3_PA2             SYS_GPA_MFPL_PA2MFP_PWM1_CH3         /*!< GPA_MFPL PA2 setting for PWM1_CH3       */
N#define PWM1_CH3_PC12            SYS_GPC_MFPH_PC12MFP_PWM1_CH3        /*!< GPC_MFPH PC12 setting for PWM1_CH3      */
N#define PWM1_CH3_PD15            SYS_GPD_MFPH_PD15MFP_PWM1_CH3        /*!< GPD_MFPH PD15 setting for PWM1_CH3      */
N#define PWM1_CH4_PC13            SYS_GPC_MFPH_PC13MFP_PWM1_CH4        /*!< GPC_MFPH PC13 setting for PWM1_CH4      */
N#define PWM1_CH4_PA1             SYS_GPA_MFPL_PA1MFP_PWM1_CH4         /*!< GPA_MFPL PA1 setting for PWM1_CH4       */
N#define PWM1_CH5_PC14            SYS_GPC_MFPH_PC14MFP_PWM1_CH5        /*!< GPC_MFPH PC14 setting for PWM1_CH5      */
N#define PWM1_CH5_PA0             SYS_GPA_MFPL_PA0MFP_PWM1_CH5         /*!< GPA_MFPL PA0 setting for PWM1_CH5       */
N#define SC0_CLK_PA0              SYS_GPA_MFPL_PA0MFP_SC0_CLK          /*!< GPA_MFPL PA0 setting for SC0_CLK        */
N#define SC0_CLK_PE11             SYS_GPE_MFPH_PE11MFP_SC0_CLK         /*!< GPE_MFPH PE11 setting for SC0_CLK       */
N#define SC0_CLK_PC1              SYS_GPC_MFPL_PC1MFP_SC0_CLK          /*!< GPC_MFPL PC1 setting for SC0_CLK        */
N#define SC0_DAT_PA1              SYS_GPA_MFPL_PA1MFP_SC0_DAT          /*!< GPA_MFPL PA1 setting for SC0_DAT        */
N#define SC0_DAT_PC0              SYS_GPC_MFPL_PC0MFP_SC0_DAT          /*!< GPC_MFPL PC0 setting for SC0_DAT        */
N#define SC0_DAT_PE10             SYS_GPE_MFPH_PE10MFP_SC0_DAT         /*!< GPE_MFPH PE10 setting for SC0_DAT       */
N#define SC0_PWR_PE8              SYS_GPE_MFPH_PE8MFP_SC0_PWR          /*!< GPE_MFPH PE8 setting for SC0_PWR        */
N#define SC0_PWR_PA8              SYS_GPA_MFPH_PA8MFP_SC0_PWR          /*!< GPA_MFPH PA8 setting for SC0_PWR        */
N#define SC0_PWR_PA3              SYS_GPA_MFPL_PA3MFP_SC0_PWR          /*!< GPA_MFPL PA3 setting for SC0_PWR        */
N#define SC0_PWR_PE4              SYS_GPE_MFPL_PE4MFP_SC0_PWR          /*!< GPE_MFPL PE4 setting for SC0_PWR        */
N#define SC0_PWR_PC3              SYS_GPC_MFPL_PC3MFP_SC0_PWR          /*!< GPC_MFPL PC3 setting for SC0_PWR        */
N#define SC0_RST_PA2              SYS_GPA_MFPL_PA2MFP_SC0_RST          /*!< GPA_MFPL PA2 setting for SC0_RST        */
N#define SC0_RST_PB1              SYS_GPB_MFPL_PB1MFP_SC0_RST          /*!< GPB_MFPL PB1 setting for SC0_RST        */
N#define SC0_RST_PC2              SYS_GPC_MFPL_PC2MFP_SC0_RST          /*!< GPC_MFPL PC2 setting for SC0_RST        */
N#define SC0_RST_PE5              SYS_GPE_MFPL_PE5MFP_SC0_RST          /*!< GPE_MFPL PE5 setting for SC0_RST        */
N#define SC0_RST_PE9              SYS_GPE_MFPH_PE9MFP_SC0_RST          /*!< GPE_MFPH PE9 setting for SC0_RST        */
N#define SC0_RST_PA9              SYS_GPA_MFPH_PA9MFP_SC0_RST          /*!< GPA_MFPH PA9 setting for SC0_RST        */
N#define SC0_nCD_PB2              SYS_GPB_MFPL_PB2MFP_SC0_nCD          /*!< GPB_MFPL PB2 setting for SC0_nCD        */
N#define SC0_nCD_PE0              SYS_GPE_MFPL_PE0MFP_SC0_nCD          /*!< GPE_MFPL PE0 setting for SC0_nCD        */
N#define SC0_nCD_PE1              SYS_GPE_MFPL_PE1MFP_SC0_nCD          /*!< GPE_MFPL PE1 setting for SC0_nCD        */
N#define SC0_nCD_PC4              SYS_GPC_MFPL_PC4MFP_SC0_nCD          /*!< GPC_MFPL PC4 setting for SC0_nCD        */
N#define SC1_CLK_PD0              SYS_GPD_MFPL_PD0MFP_SC1_CLK          /*!< GPD_MFPL PD0 setting for SC1_CLK        */
N#define SC1_CLK_PA11             SYS_GPA_MFPH_PA11MFP_SC1_CLK         /*!< GPA_MFPH PA11 setting for SC1_CLK       */
N#define SC1_DAT_PA10             SYS_GPA_MFPH_PA10MFP_SC1_DAT         /*!< GPA_MFPH PA10 setting for SC1_DAT       */
N#define SC1_DAT_PB7              SYS_GPB_MFPL_PB7MFP_SC1_DAT          /*!< GPB_MFPL PB7 setting for SC1_DAT        */
N#define SC1_PWR_PA9              SYS_GPA_MFPH_PA9MFP_SC1_PWR          /*!< GPA_MFPH PA9 setting for SC1_PWR        */
N#define SC1_PWR_PB6              SYS_GPB_MFPL_PB6MFP_SC1_PWR          /*!< GPB_MFPL PB6 setting for SC1_PWR        */
N#define SC1_RST_PA8              SYS_GPA_MFPH_PA8MFP_SC1_RST          /*!< GPA_MFPH PA8 setting for SC1_RST        */
N#define SC1_RST_PB5              SYS_GPB_MFPL_PB5MFP_SC1_RST          /*!< GPB_MFPL PB5 setting for SC1_RST        */
N#define SC1_nCD_PB4              SYS_GPB_MFPL_PB4MFP_SC1_nCD          /*!< GPB_MFPL PB4 setting for SC1_nCD        */
N#define SC1_nCD_PF5              SYS_GPF_MFPL_PF5MFP_SC1_nCD          /*!< GPF_MFPL PF5 setting for SC1_nCD        */
N#define SPI0_CLK_PC0             SYS_GPC_MFPL_PC0MFP_SPI0_CLK         /*!< GPC_MFPL PC0 setting for SPI0_CLK       */
N#define SPI0_CLK_PE0             SYS_GPE_MFPL_PE0MFP_SPI0_CLK         /*!< GPE_MFPL PE0 setting for SPI0_CLK       */
N#define SPI0_CLK_PB7             SYS_GPB_MFPL_PB7MFP_SPI0_CLK         /*!< GPB_MFPL PB7 setting for SPI0_CLK       */
N#define SPI0_CLK_PE13            SYS_GPE_MFPH_PE13MFP_SPI0_CLK        /*!< GPE_MFPH PE13 setting for SPI0_CLK      */
N#define SPI0_CLK_PC12            SYS_GPC_MFPH_PC12MFP_SPI0_CLK        /*!< GPC_MFPH PC12 setting for SPI0_CLK      */
N#define SPI0_CLK_PB2             SYS_GPB_MFPL_PB2MFP_SPI0_CLK         /*!< GPB_MFPL PB2 setting for SPI0_CLK       */
N#define SPI0_I2SMCLK_PC5         SYS_GPC_MFPL_PC5MFP_SPI0_I2SMCLK     /*!< GPC_MFPL PC5 setting for SPI0_I2SMCLK   */
N#define SPI0_I2SMCLK_PD7         SYS_GPD_MFPL_PD7MFP_SPI0_I2SMCLK     /*!< GPD_MFPL PD7 setting for SPI0_I2SMCLK   */
N#define SPI0_I2SMCLK_PC9         SYS_GPC_MFPH_PC9MFP_SPI0_I2SMCLK     /*!< GPC_MFPH PC9 setting for SPI0_I2SMCLK   */
N#define SPI0_I2SMCLK_PD0         SYS_GPD_MFPL_PD0MFP_SPI0_I2SMCLK     /*!< GPD_MFPL PD0 setting for SPI0_I2SMCLK   */
N#define SPI0_I2SMCLK_PD3         SYS_GPD_MFPL_PD3MFP_SPI0_I2SMCLK     /*!< GPD_MFPL PD3 setting for SPI0_I2SMCLK   */
N#define SPI0_MISO_PC4            SYS_GPC_MFPL_PC4MFP_SPI0_MISO        /*!< GPC_MFPL PC4 setting for SPI0_MISO      */
N#define SPI0_MISO_PC11           SYS_GPC_MFPH_PC11MFP_SPI0_MISO       /*!< GPC_MFPH PC11 setting for SPI0_MISO     */
N#define SPI0_MISO_PB3            SYS_GPB_MFPL_PB3MFP_SPI0_MISO        /*!< GPB_MFPL PB3 setting for SPI0_MISO      */
N#define SPI0_MISO_PB6            SYS_GPB_MFPL_PB6MFP_SPI0_MISO        /*!< GPB_MFPL PB6 setting for SPI0_MISO      */
N#define SPI0_MISO_PE10           SYS_GPE_MFPH_PE10MFP_SPI0_MISO       /*!< GPE_MFPH PE10 setting for SPI0_MISO     */
N#define SPI0_MOSI_PC10           SYS_GPC_MFPH_PC10MFP_SPI0_MOSI       /*!< GPC_MFPH PC10 setting for SPI0_MOSI     */
N#define SPI0_MOSI_PB5            SYS_GPB_MFPL_PB5MFP_SPI0_MOSI        /*!< GPB_MFPL PB5 setting for SPI0_MOSI      */
N#define SPI0_MOSI_PE11           SYS_GPE_MFPH_PE11MFP_SPI0_MOSI       /*!< GPE_MFPH PE11 setting for SPI0_MOSI     */
N#define SPI0_MOSI_PC3            SYS_GPC_MFPL_PC3MFP_SPI0_MOSI        /*!< GPC_MFPL PC3 setting for SPI0_MOSI      */
N#define SPI0_SS_PE12             SYS_GPE_MFPH_PE12MFP_SPI0_SS         /*!< GPE_MFPH PE12 setting for SPI0_SS       */
N#define SPI0_SS_PC2              SYS_GPC_MFPL_PC2MFP_SPI0_SS          /*!< GPC_MFPL PC2 setting for SPI0_SS        */
N#define SPI0_SS_PC13             SYS_GPC_MFPH_PC13MFP_SPI0_SS         /*!< GPC_MFPH PC13 setting for SPI0_SS       */
N#define SPI0_SS_PB4              SYS_GPB_MFPL_PB4MFP_SPI0_SS          /*!< GPB_MFPL PB4 setting for SPI0_SS        */
N#define SPI1_CLK_PA7             SYS_GPA_MFPL_PA7MFP_SPI1_CLK         /*!< GPA_MFPL PA7 setting for SPI1_CLK       */
N#define SPI1_CLK_PD15            SYS_GPD_MFPH_PD15MFP_SPI1_CLK        /*!< GPD_MFPH PD15 setting for SPI1_CLK      */
N#define SPI1_CLK_PE10            SYS_GPE_MFPH_PE10MFP_SPI1_CLK        /*!< GPE_MFPH PE10 setting for SPI1_CLK      */
N#define SPI1_CLK_PB2             SYS_GPB_MFPL_PB2MFP_SPI1_CLK         /*!< GPB_MFPL PB2 setting for SPI1_CLK       */
N#define SPI1_CLK_PE13            SYS_GPE_MFPH_PE13MFP_SPI1_CLK        /*!< GPE_MFPH PE13 setting for SPI1_CLK      */
N#define SPI1_CLK_PB7             SYS_GPB_MFPL_PB7MFP_SPI1_CLK         /*!< GPB_MFPL PB7 setting for SPI1_CLK       */
N#define SPI1_CLK_PD4             SYS_GPD_MFPL_PD4MFP_SPI1_CLK         /*!< GPD_MFPL PD4 setting for SPI1_CLK       */
N#define SPI1_I2SMCLK_PA9         SYS_GPA_MFPH_PA9MFP_SPI1_I2SMCLK     /*!< GPA_MFPH PA9 setting for SPI1_I2SMCLK   */
N#define SPI1_I2SMCLK_PD0         SYS_GPD_MFPL_PD0MFP_SPI1_I2SMCLK     /*!< GPD_MFPL PD0 setting for SPI1_I2SMCLK   */
N#define SPI1_I2SMCLK_PA12        SYS_GPA_MFPH_PA12MFP_SPI1_I2SMCLK    /*!< GPA_MFPH PA12 setting for SPI1_I2SMCLK  */
N#define SPI1_MISO_PB3            SYS_GPB_MFPL_PB3MFP_SPI1_MISO        /*!< GPB_MFPL PB3 setting for SPI1_MISO      */
N#define SPI1_MISO_PA6            SYS_GPA_MFPL_PA6MFP_SPI1_MISO        /*!< GPA_MFPL PA6 setting for SPI1_MISO      */
N#define SPI1_MISO_PD5            SYS_GPD_MFPL_PD5MFP_SPI1_MISO        /*!< GPD_MFPL PD5 setting for SPI1_MISO      */
N#define SPI1_MISO_PD14           SYS_GPD_MFPH_PD14MFP_SPI1_MISO       /*!< GPD_MFPH PD14 setting for SPI1_MISO     */
N#define SPI1_MISO_PB6            SYS_GPB_MFPL_PB6MFP_SPI1_MISO        /*!< GPB_MFPL PB6 setting for SPI1_MISO      */
N#define SPI1_MISO_PE10           SYS_GPE_MFPH_PE10MFP_SPI1_MISO       /*!< GPE_MFPH PE10 setting for SPI1_MISO     */
N#define SPI1_MISO_PE11           SYS_GPE_MFPH_PE11MFP_SPI1_MISO       /*!< GPE_MFPH PE11 setting for SPI1_MISO     */
N#define SPI1_MOSI_PE12           SYS_GPE_MFPH_PE12MFP_SPI1_MOSI       /*!< GPE_MFPH PE12 setting for SPI1_MOSI     */
N#define SPI1_MOSI_PE3            SYS_GPE_MFPL_PE3MFP_SPI1_MOSI        /*!< GPE_MFPL PE3 setting for SPI1_MOSI      */
N#define SPI1_MOSI_PB5            SYS_GPB_MFPL_PB5MFP_SPI1_MOSI        /*!< GPB_MFPL PB5 setting for SPI1_MOSI      */
N#define SPI1_MOSI_PA5            SYS_GPA_MFPL_PA5MFP_SPI1_MOSI        /*!< GPA_MFPL PA5 setting for SPI1_MOSI      */
N#define SPI1_MOSI_PE11           SYS_GPE_MFPH_PE11MFP_SPI1_MOSI       /*!< GPE_MFPH PE11 setting for SPI1_MOSI     */
N#define SPI1_MOSI_PD13           SYS_GPD_MFPH_PD13MFP_SPI1_MOSI       /*!< GPD_MFPH PD13 setting for SPI1_MOSI     */
N#define SPI1_SS_PB4              SYS_GPB_MFPL_PB4MFP_SPI1_SS          /*!< GPB_MFPL PB4 setting for SPI1_SS        */
N#define SPI1_SS_PE12             SYS_GPE_MFPH_PE12MFP_SPI1_SS         /*!< GPE_MFPH PE12 setting for SPI1_SS       */
N#define SPI1_SS_PD6              SYS_GPD_MFPL_PD6MFP_SPI1_SS          /*!< GPD_MFPL PD6 setting for SPI1_SS        */
N#define SPI1_SS_PA4              SYS_GPA_MFPL_PA4MFP_SPI1_SS          /*!< GPA_MFPL PA4 setting for SPI1_SS        */
N#define SPI1_SS_PE13             SYS_GPE_MFPH_PE13MFP_SPI1_SS         /*!< GPE_MFPH PE13 setting for SPI1_SS       */
N#define SPI1_SS_PD12             SYS_GPD_MFPH_PD12MFP_SPI1_SS         /*!< GPD_MFPH PD12 setting for SPI1_SS       */
N#define TM0_PD4                  SYS_GPD_MFPL_PD4MFP_TM0              /*!< GPD_MFPL PD4 setting for TM0            */
N#define TM0_PD1                  SYS_GPD_MFPL_PD1MFP_TM0              /*!< GPD_MFPL PD1 setting for TM0            */
N#define TM0_PE8                  SYS_GPE_MFPH_PE8MFP_TM0              /*!< GPE_MFPH PE8 setting for TM0            */
N#define TM0_EXT_PD2              SYS_GPD_MFPL_PD2MFP_TM0_EXT          /*!< GPD_MFPL PD2 setting for TM0_EXT        */
N#define TM0_EXT_PB3              SYS_GPB_MFPL_PB3MFP_TM0_EXT          /*!< GPB_MFPL PB3 setting for TM0_EXT        */
N#define TM0_EXT_PE10             SYS_GPE_MFPH_PE10MFP_TM0_EXT         /*!< GPE_MFPH PE10 setting for TM0_EXT       */
N#define TM0_EXT_PA7              SYS_GPA_MFPL_PA7MFP_TM0_EXT          /*!< GPA_MFPL PA7 setting for TM0_EXT        */
N#define TM1_PA8                  SYS_GPA_MFPH_PA8MFP_TM1              /*!< GPA_MFPH PA8 setting for TM1            */
N#define TM1_PD7                  SYS_GPD_MFPL_PD7MFP_TM1              /*!< GPD_MFPL PD7 setting for TM1            */
N#define TM1_PE9                  SYS_GPE_MFPH_PE9MFP_TM1              /*!< GPE_MFPH PE9 setting for TM1            */
N#define TM1_PD5                  SYS_GPD_MFPL_PD5MFP_TM1              /*!< GPD_MFPL PD5 setting for TM1            */
N#define TM1_EXT_PD3              SYS_GPD_MFPL_PD3MFP_TM1_EXT          /*!< GPD_MFPL PD3 setting for TM1_EXT        */
N#define TM1_EXT_PB4              SYS_GPB_MFPL_PB4MFP_TM1_EXT          /*!< GPB_MFPL PB4 setting for TM1_EXT        */
N#define TM1_EXT_PA6              SYS_GPA_MFPL_PA6MFP_TM1_EXT          /*!< GPA_MFPL PA6 setting for TM1_EXT         */
N#define TM1_EXT_PE11             SYS_GPE_MFPH_PE11MFP_TM1_EXT         /*!< GPE_MFPH PE11 setting for TM1_EXT       */
N#define TM1_EXT_PB0              SYS_GPB_MFPL_PB0MFP_TM1_EXT          /*!< GPB_MFPL PB0 setting for TM1_EXT        */
N#define TM2_PA9                  SYS_GPA_MFPH_PA9MFP_TM2              /*!< GPA_MFPH PA9 setting for TM2            */
N#define TM2_PB0                  SYS_GPB_MFPL_PB0MFP_TM2              /*!< GPB_MFPL PB0 setting for TM2            */
N#define TM2_PA14                 SYS_GPA_MFPH_PA14MFP_TM2             /*!< GPA_MFPH PA14 setting for TM2   */
N#define TM2_PD10                 SYS_GPD_MFPH_PD10MFP_TM2             /*!< GPD_MFPH PD10 setting for TM2           */
N#define TM2_PD8                  SYS_GPD_MFPH_PD8MFP_TM2              /*!< GPD_MFPH PD8 setting for TM2            */
N#define TM2_PD3                  SYS_GPD_MFPL_PD3MFP_TM2              /*!< GPD_MFPL PD3 setting for TM2            */
N#define TM2_EXT_PE12             SYS_GPE_MFPH_PE12MFP_TM2_EXT         /*!< GPE_MFPH PE12 setting for TM2_EXT       */
N#define TM2_EXT_PB2              SYS_GPB_MFPL_PB2MFP_TM2_EXT          /*!< GPB_MFPL PB2 setting for TM2_EXT        */
N#define TM2_EXT_PE0              SYS_GPE_MFPL_PE0MFP_TM2_EXT          /*!< GPE_MFPL PE0 setting for TM2_EXT        */
N#define TM2_EXT_PA5              SYS_GPA_MFPL_PA5MFP_TM2_EXT          /*!< GPA_MFPL PA5 setting for TM2_EXT        */
N#define TM3_PD9                  SYS_GPD_MFPH_PD9MFP_TM3              /*!< GPD_MFPH PD9 setting for TM3            */
N#define TM3_PB1                  SYS_GPB_MFPL_PB1MFP_TM3              /*!< GPB_MFPL PB1 setting for TM3            */
N#define TM3_PA15                 SYS_GPA_MFPH_PA15MFP_TM3             /*!< GPA_MFPH PA15 setting for TM3   */
N#define TM3_PD11                 SYS_GPD_MFPH_PD11MFP_TM3             /*!< GPD_MFPH PD11 setting for TM3           */
N#define TM3_EXT_PE1              SYS_GPE_MFPL_PE1MFP_TM3_EXT          /*!< GPE_MFPL PE1 setting for TM3_EXT        */
N#define TM3_EXT_PA4              SYS_GPA_MFPL_PA4MFP_TM3_EXT          /*!< GPA_MFPL PA4 setting for TM3_EXT        */
N#define TM3_EXT_PF5              SYS_GPF_MFPL_PF5MFP_TM3_EXT          /*!< GPF_MFPL PF5 setting for TM3_EXT        */
N#define TM3_EXT_PE13             SYS_GPE_MFPH_PE13MFP_TM3_EXT         /*!< GPE_MFPH PE13 setting for TM3_EXT       */
N#define TM_BRAKE0_PB2            SYS_GPB_MFPL_PB2MFP_TM_BRAKE0        /*!< GPB_MFPL PB2 setting for TM_BRAKE0      */
N#define TM_BRAKE0_PA8            SYS_GPA_MFPH_PA8MFP_TM_BRAKE0        /*!< GPA_MFPH PA8 setting for TM_BRAKE0      */
N#define TM_BRAKE0_PF5            SYS_GPF_MFPL_PF5MFP_TM_BRAKE0        /*!< GPF_MFPL PF5 setting for TM_BRAKE0      */
N#define TM_BRAKE1_PA9            SYS_GPA_MFPH_PA9MFP_TM_BRAKE1        /*!< GPA_MFPH PA9 setting for TM_BRAKE1      */
N#define TM_BRAKE1_PA7            SYS_GPA_MFPL_PA7MFP_TM_BRAKE1        /*!< GPA_MFPL PA7 setting for TM_BRAKE1      */
N#define TM_BRAKE1_PB3            SYS_GPB_MFPL_PB3MFP_TM_BRAKE1        /*!< GPB_MFPL PB3 setting for TM_BRAKE1      */
N#define TM_BRAKE2_PB8            SYS_GPB_MFPH_PB8MFP_TM_BRAKE2        /*!< GPB_MFPH PB8 setting for TM_BRAKE2      */
N#define TM_BRAKE2_PA12           SYS_GPA_MFPH_PA12MFP_TM_BRAKE2       /*!< GPA_MFPH PA12 setting for TM_BRAKE2     */
N#define TM_BRAKE2_PA6            SYS_GPA_MFPL_PA6MFP_TM_BRAKE2        /*!< GPA_MFPL PA6 setting for TM_BRAKE2      */
N#define TM_BRAKE3_PA5            SYS_GPA_MFPL_PA5MFP_TM_BRAKE3        /*!< GPA_MFPL PA5 setting for TM_BRAKE3      */
N#define TM_BRAKE3_PA13           SYS_GPA_MFPH_PA13MFP_TM_BRAKE3       /*!< GPA_MFPH PA12 setting for TM_BRAKE3     */
N#define TM_BRAKE3_PE2            SYS_GPE_MFPL_PE2MFP_TM_BRAKE3        /*!< GPE_MFPL PE2 setting for TM_BRAKE3      */
N#define UART0_RXD_PA3            SYS_GPA_MFPL_PA3MFP_UART0_RXD        /*!< GPA_MFPL PA3 setting for UART0_RXD      */
N#define UART0_RXD_PE6            SYS_GPE_MFPL_PE6MFP_UART0_RXD        /*!< GPE_MFPL PE6 setting for UART0_RXD      */
N#define UART0_RXD_PD9            SYS_GPD_MFPH_PD9MFP_UART0_RXD        /*!< GPD_MFPH PD9 setting for UART0_RXD      */
N#define UART0_RXD_PD0            SYS_GPD_MFPL_PD0MFP_UART0_RXD        /*!< GPD_MFPL PD0 setting for UART0_RXD      */
N#define UART0_RXD_PD13           SYS_GPD_MFPH_PD13MFP_UART0_RXD       /*!< GPD_MFPH PD13 setting for UART0_RXD     */
N#define UART0_RXD_PD6            SYS_GPD_MFPL_PD6MFP_UART0_RXD        /*!< GPD_MFPL PD6 setting for UART0_RXD      */
N#define UART0_TXD_PD1            SYS_GPD_MFPL_PD1MFP_UART0_TXD        /*!< GPD_MFPL PD1 setting for UART0_TXD      */
N#define UART0_TXD_PE7            SYS_GPE_MFPL_PE7MFP_UART0_TXD        /*!< GPE_MFPL PE7 setting for UART0_TXD      */
N#define UART0_TXD_PD12           SYS_GPD_MFPH_PD12MFP_UART0_TXD       /*!< GPD_MFPH PD12 setting for UART0_TXD     */
N#define UART0_TXD_PA2            SYS_GPA_MFPL_PA2MFP_UART0_TXD        /*!< GPA_MFPL PA2 setting for UART0_TXD      */
N#define UART0_nCTS_PD8           SYS_GPD_MFPH_PD8MFP_UART0_nCTS       /*!< GPD_MFPH PD8 setting for UART0_nCTS     */
N#define UART0_nCTS_PD14          SYS_GPD_MFPH_PD14MFP_UART0_nCTS      /*!< GPD_MFPH PD14 setting for UART0_nCTS    */
N#define UART0_nCTS_PA2           SYS_GPA_MFPL_PA2MFP_UART0_nCTS       /*!< GPA_MFPL PA2 setting for UART0_nCTS     */
N#define UART0_nRTS_PC8           SYS_GPC_MFPH_PC8MFP_UART0_nRTS       /*!< GPC_MFPH PC8 setting for UART0_nRTS     */
N#define UART0_nRTS_PD15          SYS_GPD_MFPH_PD15MFP_UART0_nRTS      /*!< GPD_MFPH PD15 setting for UART0_nRTS    */
N#define UART0_nRTS_PA3           SYS_GPA_MFPL_PA3MFP_UART0_nRTS       /*!< GPA_MFPL PA3 setting for UART0_nRTS     */
N#define UART1_RXD_PA1            SYS_GPA_MFPL_PA1MFP_UART1_RXD        /*!< GPA_MFPL PA1 setting for UART1_RXD      */
N#define UART1_RXD_PE9            SYS_GPE_MFPH_PE9MFP_UART1_RXD        /*!< GPE_MFPH PE9 setting for UART1_RXD      */
N#define UART1_RXD_PA9            SYS_GPA_MFPH_PA9MFP_UART1_RXD        /*!< GPA_MFPH PA9 setting for UART1_RXD      */
N#define UART1_RXD_PB2            SYS_GPB_MFPL_PB2MFP_UART1_RXD        /*!< GPB_MFPL PB2 setting for UART1_RXD      */
N#define UART1_RXD_PA12           SYS_GPA_MFPH_PA12MFP_UART1_RXD       /*!< GPA_MFPH PA12 setting for UART1_RXD     */
N#define UART1_RXD_PE13           SYS_GPE_MFPH_PE13MFP_UART1_RXD       /*!< GPE_MFPH PE13 setting for UART1_RXD     */
N#define UART1_TXD_PA13           SYS_GPA_MFPH_PA13MFP_UART1_TXD       /*!< GPA_MFPH PA13 setting for UART1_TXD     */
N#define UART1_TXD_PB3            SYS_GPB_MFPL_PB3MFP_UART1_TXD        /*!< GPB_MFPL PB3 setting for UART1_TXD      */
N#define UART1_TXD_PE8            SYS_GPE_MFPH_PE8MFP_UART1_TXD        /*!< GPE_MFPH PE8 setting for UART1_TXD      */
N#define UART1_TXD_PA0            SYS_GPA_MFPL_PA0MFP_UART1_TXD        /*!< GPA_MFPL PA0 setting for UART1_TXD      */
N#define UART1_TXD_PE12           SYS_GPE_MFPH_PE12MFP_UART1_TXD       /*!< GPE_MFPH PE12 setting for UART1_TXD     */
N#define UART1_TXD_PA8            SYS_GPA_MFPH_PA8MFP_UART1_TXD        /*!< GPA_MFPH PA8 setting for UART1_TXD      */
N#define UART1_nCTS_PB4           SYS_GPB_MFPL_PB4MFP_UART1_nCTS       /*!< GPB_MFPL PB4 setting for UART1_nCTS     */
N#define UART1_nCTS_PA10          SYS_GPA_MFPH_PA10MFP_UART1_nCTS      /*!< GPA_MFPH PA10 setting for UART1_nCTS    */
N#define UART1_nCTS_PA0           SYS_GPA_MFPL_PA0MFP_UART1_nCTS       /*!< GPA_MFPL PA0 setting for UART1_nCTS     */
N#define UART1_nCTS_PE10          SYS_GPE_MFPH_PE10MFP_UART1_nCTS      /*!< GPE_MFPH PE10 setting for UART1_nCTS    */
N#define UART1_nRTS_PA11          SYS_GPA_MFPH_PA11MFP_UART1_nRTS      /*!< GPA_MFPH PA11 setting for UART1_nRTS    */
N#define UART1_nRTS_PB8           SYS_GPB_MFPH_PB8MFP_UART1_nRTS       /*!< GPB_MFPH PB8 setting for UART1_nRTS     */
N#define UART1_nRTS_PA1           SYS_GPA_MFPL_PA1MFP_UART1_nRTS       /*!< GPA_MFPL PA1 setting for UART1_nRTS     */
N#define UART1_nRTS_PE11          SYS_GPE_MFPH_PE11MFP_UART1_nRTS      /*!< GPE_MFPH PE11 setting for UART1_nRTS    */
N#define UART1_nRTS_PE2           SYS_GPE_MFPL_PE2MFP_UART1_nRTS       /*!< GPE_MFPL PE2 setting for UART1_nRTS     */
N#define UART2_RXD_PB0            SYS_GPB_MFPL_PB0MFP_UART2_RXD        /*!< GPB_MFPL PB0 setting for UART2_RXD      */
N#define UART2_RXD_PC3            SYS_GPC_MFPL_PC3MFP_UART2_RXD        /*!< GPC_MFPL PC3 setting for UART2_RXD      */
N#define UART2_RXD_PE3            SYS_GPE_MFPL_PE3MFP_UART2_RXD        /*!< GPE_MFPL PE3 setting for UART2_RXD      */
N#define UART2_RXD_PB5            SYS_GPB_MFPL_PB5MFP_UART2_RXD        /*!< GPB_MFPL PB5 setting for UART2_RXD      */
N#define UART2_RXD_PA12           SYS_GPA_MFPH_PA12MFP_UART2_RXD       /*!< GPA_MFPH PA12 setting for UART2_RXD     */
N#define UART2_RXD_PB4            SYS_GPB_MFPL_PB4MFP_UART2_RXD        /*!< GPB_MFPL PB4 setting for UART2_RXD      */
N#define UART2_TXD_PD6            SYS_GPD_MFPL_PD6MFP_UART2_TXD        /*!< GPD_MFPL PD6 setting for UART2_TXD      */
N#define UART2_TXD_PB1            SYS_GPB_MFPL_PB1MFP_UART2_TXD        /*!< GPB_MFPL PB1 setting for UART2_TXD      */
N#define UART2_TXD_PA13           SYS_GPA_MFPH_PA13MFP_UART2_TXD       /*!< GPA_MFPH PA13 setting for UART2_TXD     */
N#define UART2_TXD_PC2            SYS_GPC_MFPL_PC2MFP_UART2_TXD        /*!< GPC_MFPL PC2 setting for UART2_TXD      */
N#define UART2_nCTS_PC0           SYS_GPC_MFPL_PC0MFP_UART2_nCTS       /*!< GPC_MFPL PC0 setting for UART2_nCTS     */
N#define UART2_nCTS_PD5           SYS_GPD_MFPL_PD5MFP_UART2_nCTS       /*!< GPD_MFPL PD5 setting for UART2_nCTS     */
N#define UART2_nCTS_PA14          SYS_GPA_MFPH_PA14MFP_UART2_nCTS      /*!< GPA_MFPH PA14 setting for UART2_nCTS    */
N#define UART2_nRTS_PA15          SYS_GPA_MFPH_PA15MFP_UART2_nRTS      /*!< GPA_MFPH PA15 setting for UART2_nRTS    */
N#define UART2_nRTS_PD4           SYS_GPD_MFPL_PD4MFP_UART2_nRTS       /*!< GPD_MFPL PD4 setting for UART2_nRTS     */
N#define UART2_nRTS_PC1           SYS_GPC_MFPL_PC1MFP_UART2_nRTS       /*!< GPC_MFPL PC1 setting for UART2_nRTS     */
N#define USCI0_CLK_PB9            SYS_GPB_MFPH_PB9MFP_USCI0_CLK        /*!< GPB_MFPH PB9 setting for USCI0_CLK      */
N#define USCI0_CLK_PC4            SYS_GPC_MFPL_PC4MFP_USCI0_CLK        /*!< GPC_MFPL PC4 setting for USCI0_CLK      */
N#define USCI0_CLK_PE5            SYS_GPE_MFPL_PE5MFP_USCI0_CLK        /*!< GPE_MFPL PE5 setting for USCI0_CLK      */
N#define USCI0_CTL0_PC3           SYS_GPC_MFPL_PC3MFP_USCI0_CTL0       /*!< GPC_MFPL PC3 setting for USCI0_CTL0     */
N#define USCI0_CTL0_PB8           SYS_GPB_MFPH_PB8MFP_USCI0_CTL0       /*!< GPB_MFPH PB8 setting for USCI0_CTL0     */
N#define USCI0_CTL0_PE4           SYS_GPE_MFPL_PE4MFP_USCI0_CTL0       /*!< GPE_MFPL PE4 setting for USCI0_CTL0     */
N#define USCI0_CTL0_PE2           SYS_GPE_MFPL_PE2MFP_USCI0_CTL0       /*!< GPE_MFPL PE2 setting for USCI0_CTL0     */
N#define USCI0_CTL1_PC7           SYS_GPC_MFPL_PC7MFP_USCI0_CTL1       /*!< GPC_MFPL PC7 setting for USCI0_CTL1     */
N#define USCI0_CTL1_PB4           SYS_GPB_MFPL_PB4MFP_USCI0_CTL1       /*!< GPB_MFPL PB4 setting for USCI0_CTL1     */
N#define USCI0_CTL1_PC2           SYS_GPC_MFPL_PC2MFP_USCI0_CTL1       /*!< GPC_MFPL PC2 setting for USCI0_CTL1     */
N#define USCI0_DAT0_PC5           SYS_GPC_MFPL_PC5MFP_USCI0_DAT0       /*!< GPC_MFPL PC5 setting for USCI0_DAT0     */
N#define USCI0_DAT0_PC0           SYS_GPC_MFPL_PC0MFP_USCI0_DAT0       /*!< GPC_MFPL PC0 setting for USCI0_DAT0     */
N#define USCI0_DAT0_PB2           SYS_GPB_MFPL_PB2MFP_USCI0_DAT0       /*!< GPB_MFPL PB2 setting for USCI0_DAT0     */
N#define USCI0_DAT1_PC1           SYS_GPC_MFPL_PC1MFP_USCI0_DAT1       /*!< GPC_MFPL PC1 setting for USCI0_DAT1     */
N#define USCI0_DAT1_PB3           SYS_GPB_MFPL_PB3MFP_USCI0_DAT1       /*!< GPB_MFPL PB3 setting for USCI0_DAT1     */
N#define USCI0_DAT1_PC6           SYS_GPC_MFPL_PC6MFP_USCI0_DAT1       /*!< GPC_MFPL PC6 setting for USCI0_DAT1     */
N#define USCI1_CLK_PD15           SYS_GPD_MFPH_PD15MFP_USCI1_CLK       /*!< GPD_MFPH PD15 setting for USCI1_CLK     */
N#define USCI1_CLK_PA3            SYS_GPA_MFPL_PA3MFP_USCI1_CLK        /*!< GPA_MFPL PA3 setting for USCI1_CLK      */
N#define USCI1_CLK_PA15           SYS_GPA_MFPH_PA15MFP_USCI1_CLK       /*!< GPA_MFPH PA15 setting for USCI1_CLK     */
N#define USCI1_CTL0_PA2           SYS_GPA_MFPL_PA2MFP_USCI1_CTL0       /*!< GPA_MFPL PA2 setting for USCI1_CTL0     */
N#define USCI1_CTL0_PA0           SYS_GPA_MFPL_PA0MFP_USCI1_CTL0       /*!< GPA_MFPL PA0 setting for USCI1_CTL0     */
N#define USCI1_CTL0_PD12          SYS_GPD_MFPH_PD12MFP_USCI1_CTL0      /*!< GPD_MFPH PD12 setting for USCI1_CTL0    */
N#define USCI1_CTL1_PA1           SYS_GPA_MFPL_PA1MFP_USCI1_CTL1       /*!< GPA_MFPL PA1 setting for USCI1_CTL1     */
N#define USCI1_CTL1_PA14          SYS_GPA_MFPH_PA14MFP_USCI1_CTL1      /*!< GPA_MFPH PA14 setting for USCI1_CTL1    */
N#define USCI1_CTL1_PD7           SYS_GPD_MFPL_PD7MFP_USCI1_CTL1       /*!< GPD_MFPL PD7 setting for USCI1_CTL1     */
N#define USCI1_DAT0_PD14          SYS_GPD_MFPH_PD14MFP_USCI1_DAT0      /*!< GPD_MFPH PD14 setting for USCI1_DAT0    */
N#define USCI1_DAT0_PB0           SYS_GPB_MFPL_PB0MFP_USCI1_DAT0       /*!< GPB_MFPL PB0 setting for USCI1_DAT0     */
N#define USCI1_DAT1_PB1           SYS_GPB_MFPL_PB1MFP_USCI1_DAT1       /*!< GPB_MFPL PB1 setting for USCI1_DAT1     */
N#define USCI1_DAT1_PD13          SYS_GPD_MFPH_PD13MFP_USCI1_DAT1      /*!< GPD_MFPH PD13 setting for USCI1_DAT1    */
N#define USCI2_CLK_PC11           SYS_GPC_MFPH_PC11MFP_USCI2_CLK       /*!< GPC_MFPH PC11 setting for USCI2_CLK     */
N#define USCI2_CLK_PD1            SYS_GPD_MFPL_PD1MFP_USCI2_CLK        /*!< GPD_MFPL PD1 setting for USCI2_CLK      */
N#define USCI2_CLK_PF2            SYS_GPF_MFPL_PF2MFP_USCI2_CLK        /*!< GPF_MFPL PF2 setting for USCI2_CLK      */
N#define USCI2_CTL0_PD0           SYS_GPD_MFPL_PD0MFP_USCI2_CTL0       /*!< GPD_MFPL PD0 setting for USCI2_CTL0     */
N#define USCI2_CTL0_PD9           SYS_GPD_MFPH_PD9MFP_USCI2_CTL0       /*!< GPD_MFPH PD9 setting for USCI2_CTL0     */
N#define USCI2_CTL0_PC12          SYS_GPC_MFPH_PC12MFP_USCI2_CTL0      /*!< GPC_MFPH PC12 setting for USCI2_CTL0    */
N#define USCI2_CTL0_PF1           SYS_GPF_MFPL_PF1MFP_USCI2_CTL0       /*!< GPF_MFPL PF1 setting for USCI2_CTL0     */
N#define USCI2_CTL1_PC9           SYS_GPC_MFPH_PC9MFP_USCI2_CTL1       /*!< GPC_MFPH PC9 setting for USCI2_CTL1     */
N#define USCI2_CTL1_PF0           SYS_GPF_MFPL_PF0MFP_USCI2_CTL1       /*!< GPF_MFPL PF0 setting for USCI2_CTL1     */
N#define USCI2_CTL1_PD8           SYS_GPD_MFPH_PD8MFP_USCI2_CTL1       /*!< GPD_MFPH PD8 setting for USCI2_CTL1     */
N#define USCI2_CTL1_PB7           SYS_GPB_MFPL_PB7MFP_USCI2_CTL1       /*!< GPB_MFPL PB7 setting for USCI2_CTL1     */
N#define USCI2_DAT0_PD2           SYS_GPD_MFPL_PD2MFP_USCI2_DAT0       /*!< GPD_MFPL PD2 setting for USCI2_DAT0     */
N#define USCI2_DAT0_PD10          SYS_GPD_MFPH_PD10MFP_USCI2_DAT0      /*!< GPD_MFPH PD10 setting for USCI2_DAT0    */
N#define USCI2_DAT0_PC13          SYS_GPC_MFPH_PC13MFP_USCI2_DAT0      /*!< GPC_MFPH PC13 setting for USCI2_DAT0    */
N#define USCI2_DAT1_PD3           SYS_GPD_MFPL_PD3MFP_USCI2_DAT1       /*!< GPD_MFPL PD3 setting for USCI2_DAT1     */
N#define USCI2_DAT1_PC10          SYS_GPC_MFPH_PC10MFP_USCI2_DAT1      /*!< GPC_MFPH PC10 setting for USCI2_DAT1    */
N#define USCI2_DAT1_PD11          SYS_GPD_MFPH_PD11MFP_USCI2_DAT1      /*!< GPD_MFPH PD11 setting for USCI2_DAT1    */
N#define VDET_P0_PB0              SYS_GPB_MFPL_PB0MFP_VDET_P0          /*!< GPB_MFPL PB0 setting for VDET_P0        */
N#define VDET_P1_PB1              SYS_GPB_MFPL_PB1MFP_VDET_P1          /*!< GPB_MFPL PB1 setting for VDET_P1        */
N#define X32_IN_PF1               SYS_GPF_MFPL_PF1MFP_X32_IN           /*!< GPF_MFPL PF1 setting for X32_IN         */
N#define X32_OUT_PF0              SYS_GPF_MFPL_PF0MFP_X32_OUT          /*!< GPF_MFPL PF0 setting for X32_OUT        */
N#define XT1_IN_PF4               SYS_GPF_MFPL_PF4MFP_XT1_IN           /*!< GPF_MFPL PF4 setting for XT1_IN         */
N#define XT1_OUT_PF3              SYS_GPF_MFPL_PF3MFP_XT1_OUT          /*!< GPF_MFPL PF3 setting for XT1_OUT        */
N
N
N#define ACMP0_N_PB4_Msk          SYS_GPB_MFPL_PB4MFP_Msk              /*<! ACMP0_N         PB4      MFP Mask */
N#define ACMP0_O_PD6_Msk          SYS_GPD_MFPL_PD6MFP_Msk              /*<! ACMP0_O         PD6      MFP Mask */
N#define ACMP0_O_PD7_Msk          SYS_GPD_MFPL_PD7MFP_Msk              /*<! ACMP0_O         PD7      MFP Mask */
N#define ACMP0_P0_PB7_Msk         SYS_GPB_MFPL_PB7MFP_Msk              /*<! ACMP0_P0        PB7      MFP Mask */
N#define ACMP0_P1_PB6_Msk         SYS_GPB_MFPL_PB6MFP_Msk              /*<! ACMP0_P1        PB6      MFP Mask */
N#define ACMP0_P2_PB5_Msk         SYS_GPB_MFPL_PB5MFP_Msk              /*<! ACMP0_P2        PB5      MFP Mask */
N#define ACMP0_P3_PB15_Msk        SYS_GPB_MFPH_PB15MFP_Msk             /*<! ACMP0_P3        PB15     MFP Mask */
N#define ACMP0_WLAT_PC0_Msk       SYS_GPC_MFPL_PC0MFP_Msk              /*<! ACMP0_WLAT      PC0      MFP Mask */
N#define ACMP1_N_PD0_Msk          SYS_GPD_MFPL_PD0MFP_Msk              /*<! ACMP1_N         PD0      MFP Mask */
N#define ACMP1_O_PC6_Msk          SYS_GPC_MFPL_PC6MFP_Msk              /*<! ACMP1_O         PC6      MFP Mask */
N#define ACMP1_O_PC2_Msk          SYS_GPC_MFPL_PC2MFP_Msk              /*<! ACMP1_O         PC2      MFP Mask */
N#define ACMP1_P0_PD3_Msk         SYS_GPD_MFPL_PD3MFP_Msk              /*<! ACMP1_P0        PD3      MFP Mask */
N#define ACMP1_P1_PD2_Msk         SYS_GPD_MFPL_PD2MFP_Msk              /*<! ACMP1_P1        PD2      MFP Mask */
N#define ACMP1_P2_PD1_Msk         SYS_GPD_MFPL_PD1MFP_Msk              /*<! ACMP1_P2        PD1      MFP Mask */
N#define ACMP1_P3_PD9_Msk         SYS_GPD_MFPH_PD9MFP_Msk              /*<! ACMP1_P3        PD9      MFP Mask */
N#define ACMP1_WLAT_PC1_Msk       SYS_GPC_MFPL_PC1MFP_Msk              /*<! ACMP1_WLAT      PC1      MFP Mask */
N#define ADC0_CH0_PB0_Msk         SYS_GPB_MFPL_PB0MFP_Msk              /*<! ADC0_CH0        PB0      MFP Mask */
N#define ADC0_CH1_PB1_Msk         SYS_GPB_MFPL_PB1MFP_Msk              /*<! ADC0_CH1        PB1      MFP Mask */
N#define ADC0_CH10_PB13_Msk       SYS_GPB_MFPH_PB13MFP_Msk             /*<! ADC0_CH10       PB13     MFP Mask */
N#define ADC0_CH11_PB14_Msk       SYS_GPB_MFPH_PB14MFP_Msk             /*<! ADC0_CH11       PB14     MFP Mask */
N#define ADC0_CH12_PB15_Msk       SYS_GPB_MFPH_PB15MFP_Msk             /*<! ADC0_CH12       PB15     MFP Mask */
N#define ADC0_CH13_PB5_Msk        SYS_GPB_MFPL_PB5MFP_Msk              /*<! ADC0_CH13       PB5      MFP Mask */
N#define ADC0_CH14_PB6_Msk        SYS_GPB_MFPL_PB6MFP_Msk              /*<! ADC0_CH14       PB6      MFP Mask */
N#define ADC0_CH15_PB7_Msk        SYS_GPB_MFPL_PB7MFP_Msk              /*<! ADC0_CH15       PB7      MFP Mask */
N#define ADC0_CH16_PC8_Msk        SYS_GPC_MFPH_PC8MFP_Msk              /*<! ADC0_CH16       PC8      MFP Mask */
N#define ADC0_CH17_PD8_Msk        SYS_GPD_MFPH_PD8MFP_Msk              /*<! ADC0_CH17       PD8      MFP Mask */
N#define ADC0_CH18_PD9_Msk        SYS_GPD_MFPH_PD9MFP_Msk              /*<! ADC0_CH18       PD9      MFP Mask */
N#define ADC0_CH19_PD1_Msk        SYS_GPD_MFPL_PD1MFP_Msk              /*<! ADC0_CH19       PD1      MFP Mask */
N#define ADC0_CH2_PB2_Msk         SYS_GPB_MFPL_PB2MFP_Msk              /*<! ADC0_CH2        PB2      MFP Mask */
N#define ADC0_CH3_PB3_Msk         SYS_GPB_MFPL_PB3MFP_Msk              /*<! ADC0_CH3        PB3      MFP Mask */
N#define ADC0_CH4_PB4_Msk         SYS_GPB_MFPL_PB4MFP_Msk              /*<! ADC0_CH4        PB4      MFP Mask */
N#define ADC0_CH5_PB8_Msk         SYS_GPB_MFPH_PB8MFP_Msk              /*<! ADC0_CH5        PB8      MFP Mask */
N#define ADC0_CH6_PB9_Msk         SYS_GPB_MFPH_PB9MFP_Msk              /*<! ADC0_CH6        PB9      MFP Mask */
N#define ADC0_CH7_PB10_Msk        SYS_GPB_MFPH_PB10MFP_Msk             /*<! ADC0_CH7        PB10     MFP Mask */
N#define ADC0_CH8_PB11_Msk        SYS_GPB_MFPH_PB11MFP_Msk             /*<! ADC0_CH8        PB11     MFP Mask */
N#define ADC0_CH9_PE2_Msk         SYS_GPE_MFPL_PE2MFP_Msk              /*<! ADC0_CH9        PE2      MFP Mask */
N#define ADC0_ST_PD2_Msk          SYS_GPD_MFPL_PD2MFP_Msk              /*<! ADC0_ST         PD2      MFP Mask */
N#define CLKO_PD5_Msk             SYS_GPD_MFPL_PD5MFP_Msk              /*<! CLKO            PD5      MFP Mask */
N#define CLKO_PD6_Msk             SYS_GPD_MFPL_PD6MFP_Msk              /*<! CLKO            PD6      MFP Mask */
N#define CLKO_PA8_Msk             SYS_GPA_MFPH_PA8MFP_Msk              /*<! CLKO            PA8      MFP Mask */
N#define CLKO_PC1_Msk             SYS_GPC_MFPL_PC1MFP_Msk              /*<! CLKO            PC1      MFP Mask */
N#define EBI_AD0_PA0_Msk          SYS_GPA_MFPL_PA0MFP_Msk              /*<! EBI_AD0         PA0      MFP Mask */
N#define EBI_AD1_PA1_Msk          SYS_GPA_MFPL_PA1MFP_Msk              /*<! EBI_AD1         PA1      MFP Mask */
N#define EBI_AD10_PC2_Msk         SYS_GPC_MFPL_PC2MFP_Msk              /*<! EBI_AD10        PC2      MFP Mask */
N#define EBI_AD11_PC3_Msk         SYS_GPC_MFPL_PC3MFP_Msk              /*<! EBI_AD11        PC3      MFP Mask */
N#define EBI_AD12_PC4_Msk         SYS_GPC_MFPL_PC4MFP_Msk              /*<! EBI_AD12        PC4      MFP Mask */
N#define EBI_AD13_PC5_Msk         SYS_GPC_MFPL_PC5MFP_Msk              /*<! EBI_AD13        PC5      MFP Mask */
N#define EBI_AD14_PC6_Msk         SYS_GPC_MFPL_PC6MFP_Msk              /*<! EBI_AD14        PC6      MFP Mask */
N#define EBI_AD15_PC7_Msk         SYS_GPC_MFPL_PC7MFP_Msk              /*<! EBI_AD15        PC7      MFP Mask */
N#define EBI_AD2_PA2_Msk          SYS_GPA_MFPL_PA2MFP_Msk              /*<! EBI_AD2         PA2      MFP Mask */
N#define EBI_AD3_PA3_Msk          SYS_GPA_MFPL_PA3MFP_Msk              /*<! EBI_AD3         PA3      MFP Mask */
N#define EBI_AD4_PA4_Msk          SYS_GPA_MFPL_PA4MFP_Msk              /*<! EBI_AD4         PA4      MFP Mask */
N#define EBI_AD4_PB7_Msk          SYS_GPB_MFPL_PB7MFP_Msk              /*<! EBI_AD4         PB7      MFP Mask */
N#define EBI_AD4_PE13_Msk         SYS_GPE_MFPH_PE13MFP_Msk             /*<! EBI_AD4         PE13     MFP Mask */
N#define EBI_AD5_PA5_Msk          SYS_GPA_MFPL_PA5MFP_Msk              /*<! EBI_AD5         PA5      MFP Mask */
N#define EBI_AD5_PE12_Msk         SYS_GPE_MFPH_PE12MFP_Msk             /*<! EBI_AD5         PE12     MFP Mask */
N#define EBI_AD5_PB6_Msk          SYS_GPB_MFPL_PB6MFP_Msk              /*<! EBI_AD5         PB6      MFP Mask */
N#define EBI_AD6_PE11_Msk         SYS_GPE_MFPH_PE11MFP_Msk             /*<! EBI_AD6         PE11     MFP Mask */
N#define EBI_AD6_PA6_Msk          SYS_GPA_MFPL_PA6MFP_Msk              /*<! EBI_AD6         PA6      MFP Mask */
N#define EBI_AD6_PB5_Msk          SYS_GPB_MFPL_PB5MFP_Msk              /*<! EBI_AD6         PB5      MFP Mask */
N#define EBI_AD7_PB4_Msk          SYS_GPB_MFPL_PB4MFP_Msk              /*<! EBI_AD7         PB4      MFP Mask */
N#define EBI_AD7_PA7_Msk          SYS_GPA_MFPL_PA7MFP_Msk              /*<! EBI_AD7         PA7      MFP Mask */
N#define EBI_AD7_PE10_Msk         SYS_GPE_MFPH_PE10MFP_Msk             /*<! EBI_AD7         PE10     MFP Mask */
N#define EBI_AD8_PC0_Msk          SYS_GPC_MFPL_PC0MFP_Msk              /*<! EBI_AD8         PC0      MFP Mask */
N#define EBI_AD9_PC1_Msk          SYS_GPC_MFPL_PC1MFP_Msk              /*<! EBI_AD9         PC1      MFP Mask */
N#define EBI_ADR16_PD12_Msk       SYS_GPD_MFPH_PD12MFP_Msk             /*<! EBI_ADR16       PD12     MFP Mask */
N#define EBI_ADR17_PD13_Msk       SYS_GPD_MFPH_PD13MFP_Msk             /*<! EBI_ADR17       PD13     MFP Mask */
N#define EBI_ADR18_PD14_Msk       SYS_GPD_MFPH_PD14MFP_Msk             /*<! EBI_ADR18       PD14     MFP Mask */
N#define EBI_ADR19_PD15_Msk       SYS_GPD_MFPH_PD15MFP_Msk             /*<! EBI_ADR19       PD15     MFP Mask */
N#define EBI_ALE_PB3_Msk          SYS_GPB_MFPL_PB3MFP_Msk              /*<! EBI_ALE         PB3      MFP Mask */
N#define EBI_ALE_PE5_Msk          SYS_GPE_MFPL_PE5MFP_Msk              /*<! EBI_ALE         PE5      MFP Mask */
N#define EBI_ALE_PD9_Msk          SYS_GPD_MFPH_PD9MFP_Msk              /*<! EBI_ALE         PD9      MFP Mask */
N#define EBI_MCLK_PD3_Msk         SYS_GPD_MFPL_PD3MFP_Msk              /*<! EBI_MCLK        PD3      MFP Mask */
N#define EBI_nCS0_PE4_Msk         SYS_GPE_MFPL_PE4MFP_Msk              /*<! EBI_nCS0        PE4      MFP Mask */
N#define EBI_nCS0_PB2_Msk         SYS_GPB_MFPL_PB2MFP_Msk              /*<! EBI_nCS0        PB2      MFP Mask */
N#define EBI_nCS0_PD8_Msk         SYS_GPD_MFPH_PD8MFP_Msk              /*<! EBI_nCS0        PD8      MFP Mask */
N#define EBI_nCS1_PE0_Msk         SYS_GPE_MFPL_PE0MFP_Msk              /*<! EBI_nCS1        PE0      MFP Mask */
N#define EBI_nCS1_PB15_Msk        SYS_GPB_MFPH_PB15MFP_Msk             /*<! EBI_nCS1        PB15     MFP Mask */
N#define EBI_nRD_PD7_Msk          SYS_GPD_MFPL_PD7MFP_Msk              /*<! EBI_nRD         PD7      MFP Mask */
N#define EBI_nRD_PD1_Msk          SYS_GPD_MFPL_PD1MFP_Msk              /*<! EBI_nRD         PD1      MFP Mask */
N#define EBI_nWR_PD6_Msk          SYS_GPD_MFPL_PD6MFP_Msk              /*<! EBI_nWR         PD6      MFP Mask */
N#define EBI_nWR_PD2_Msk          SYS_GPD_MFPL_PD2MFP_Msk              /*<! EBI_nWR         PD2      MFP Mask */
N#define EBI_nWRH_PB1_Msk         SYS_GPB_MFPL_PB1MFP_Msk              /*<! EBI_nWRH        PB1      MFP Mask */
N#define EBI_nWRL_PB0_Msk         SYS_GPB_MFPL_PB0MFP_Msk              /*<! EBI_nWRL        PB0      MFP Mask */
N#define I2C0_SCL_PE4_Msk         SYS_GPE_MFPL_PE4MFP_Msk              /*<! I2C0_SCL        PE4      MFP Mask */
N#define I2C0_SCL_PA3_Msk         SYS_GPA_MFPL_PA3MFP_Msk              /*<! I2C0_SCL        PA3      MFP Mask */
N#define I2C0_SCL_PE12_Msk        SYS_GPE_MFPH_PE12MFP_Msk             /*<! I2C0_SCL        PE12     MFP Mask */
N#define I2C0_SCL_PD5_Msk         SYS_GPD_MFPL_PD5MFP_Msk              /*<! I2C0_SCL        PD5      MFP Mask */
N#define I2C0_SCL_PE6_Msk         SYS_GPE_MFPL_PE6MFP_Msk              /*<! I2C0_SCL        PE6      MFP Mask */
N#define I2C0_SDA_PA2_Msk         SYS_GPA_MFPL_PA2MFP_Msk              /*<! I2C0_SDA        PA2      MFP Mask */
N#define I2C0_SDA_PD4_Msk         SYS_GPD_MFPL_PD4MFP_Msk              /*<! I2C0_SDA        PD4      MFP Mask */
N#define I2C0_SDA_PE7_Msk         SYS_GPE_MFPL_PE7MFP_Msk              /*<! I2C0_SDA        PE7      MFP Mask */
N#define I2C0_SDA_PE13_Msk        SYS_GPE_MFPH_PE13MFP_Msk             /*<! I2C0_SDA        PE13     MFP Mask */
N#define I2C0_SDA_PE5_Msk         SYS_GPE_MFPL_PE5MFP_Msk              /*<! I2C0_SDA        PE5      MFP Mask */
N#define I2C1_SCL_PC4_Msk         SYS_GPC_MFPL_PC4MFP_Msk              /*<! I2C1_SCL        PC4      MFP Mask */
N#define I2C1_SCL_PE4_Msk         SYS_GPE_MFPL_PE4MFP_Msk              /*<! I2C1_SCL        PE4      MFP Mask */
N#define I2C1_SCL_PC9_Msk         SYS_GPC_MFPH_PC9MFP_Msk              /*<! I2C1_SCL        PC9      MFP Mask */
N#define I2C1_SCL_PE8_Msk         SYS_GPE_MFPH_PE8MFP_Msk              /*<! I2C1_SCL        PE8      MFP Mask */
N#define I2C1_SCL_PA8_Msk         SYS_GPA_MFPH_PA8MFP_Msk              /*<! I2C1_SCL        PA8      MFP Mask */
N#define I2C1_SCL_PF3_Msk         SYS_GPF_MFPL_PF3MFP_Msk              /*<! I2C1_SCL        PF3      MFP Mask */
N#define I2C1_SDA_PC5_Msk         SYS_GPC_MFPL_PC5MFP_Msk              /*<! I2C1_SDA        PC5      MFP Mask */
N#define I2C1_SDA_PE0_Msk         SYS_GPE_MFPL_PE0MFP_Msk              /*<! I2C1_SDA        PE0      MFP Mask */
N#define I2C1_SDA_PC10_Msk        SYS_GPC_MFPH_PC10MFP_Msk             /*<! I2C1_SDA        PC10     MFP Mask */
N#define I2C1_SDA_PA9_Msk         SYS_GPA_MFPH_PA9MFP_Msk              /*<! I2C1_SDA        PA9      MFP Mask */
N#define I2C1_SDA_PE9_Msk         SYS_GPE_MFPH_PE9MFP_Msk              /*<! I2C1_SDA        PE9      MFP Mask */
N#define I2C1_SDA_PE5_Msk         SYS_GPE_MFPL_PE5MFP_Msk              /*<! I2C1_SDA        PE5      MFP Mask */
N#define I2C1_SDA_PF4_Msk         SYS_GPF_MFPL_PF4MFP_Msk              /*<! I2C1_SDA        PF4      MFP Mask */
N#define ICE_CLK_PE6_Msk          SYS_GPE_MFPL_PE6MFP_Msk              /*<! ICE_CLK         PE6      MFP Mask */
N#define ICE_DAT_PE7_Msk          SYS_GPE_MFPL_PE7MFP_Msk              /*<! ICE_DAT         PE7      MFP Mask */
N#define INT0_PE4_Msk             SYS_GPE_MFPL_PE4MFP_Msk              /*<! INT0            PE4      MFP Mask */
N#define INT0_PD2_Msk             SYS_GPD_MFPL_PD2MFP_Msk              /*<! INT0            PD2      MFP Mask */
N#define INT0_PA0_Msk             SYS_GPA_MFPL_PA0MFP_Msk              /*<! INT0            PA0      MFP Mask */
N#define INT1_PE5_Msk             SYS_GPE_MFPL_PE5MFP_Msk              /*<! INT1            PE5      MFP Mask */
N#define INT1_PD3_Msk             SYS_GPD_MFPL_PD3MFP_Msk              /*<! INT1            PD3      MFP Mask */
N#define INT1_PB0_Msk             SYS_GPB_MFPL_PB0MFP_Msk              /*<! INT1            PB0      MFP Mask */
N#define INT2_PC0_Msk             SYS_GPC_MFPL_PC0MFP_Msk              /*<! INT2            PC0      MFP Mask */
N#define INT3_PD0_Msk             SYS_GPD_MFPL_PD0MFP_Msk              /*<! INT3            PD0      MFP Mask */
N#define INT4_PE0_Msk             SYS_GPE_MFPL_PE0MFP_Msk              /*<! INT4            PE0      MFP Mask */
N#define INT5_PF0_Msk             SYS_GPF_MFPL_PF0MFP_Msk              /*<! INT5            PF0      MFP Mask */
N#define PWM0_BRAKE0_PD2_Msk      SYS_GPD_MFPL_PD2MFP_Msk              /*<! PWM0_BRAKE0     PD2      MFP Mask */
N#define PWM0_BRAKE0_PD4_Msk      SYS_GPD_MFPL_PD4MFP_Msk              /*<! PWM0_BRAKE0     PD4      MFP Mask */
N#define PWM0_BRAKE0_PA8_Msk      SYS_GPA_MFPH_PA8MFP_Msk              /*<! PWM0_BRAKE0     PA8      MFP Mask */
N#define PWM0_BRAKE1_PD5_Msk      SYS_GPD_MFPL_PD5MFP_Msk              /*<! PWM0_BRAKE1     PD5      MFP Mask */
N#define PWM0_BRAKE1_PD3_Msk      SYS_GPD_MFPL_PD3MFP_Msk              /*<! PWM0_BRAKE1     PD3      MFP Mask */
N#define PWM0_CH0_PC0_Msk         SYS_GPC_MFPL_PC0MFP_Msk              /*<! PWM0_CH0        PC0      MFP Mask */
N#define PWM0_CH0_PE0_Msk         SYS_GPE_MFPL_PE0MFP_Msk              /*<! PWM0_CH0        PE0      MFP Mask */
N#define PWM0_CH1_PC1_Msk         SYS_GPC_MFPL_PC1MFP_Msk              /*<! PWM0_CH1        PC1      MFP Mask */
N#define PWM0_CH1_PE1_Msk         SYS_GPE_MFPL_PE1MFP_Msk              /*<! PWM0_CH1        PE1      MFP Mask */
N#define PWM0_CH2_PE2_Msk         SYS_GPE_MFPL_PE2MFP_Msk              /*<! PWM0_CH2        PE2      MFP Mask */
N#define PWM0_CH2_PC2_Msk         SYS_GPC_MFPL_PC2MFP_Msk              /*<! PWM0_CH2        PC2      MFP Mask */
N#define PWM0_CH2_PB8_Msk         SYS_GPB_MFPH_PB8MFP_Msk              /*<! PWM0_CH2        PB8      MFP Mask */
N#define PWM0_CH3_PE3_Msk         SYS_GPE_MFPL_PE3MFP_Msk              /*<! PWM0_CH3        PE3      MFP Mask */
N#define PWM0_CH3_PC3_Msk         SYS_GPC_MFPL_PC3MFP_Msk              /*<! PWM0_CH3        PC3      MFP Mask */
N#define PWM0_CH4_PC4_Msk         SYS_GPC_MFPL_PC4MFP_Msk              /*<! PWM0_CH4        PC4      MFP Mask */
N#define PWM0_CH5_PD7_Msk         SYS_GPD_MFPL_PD7MFP_Msk              /*<! PWM0_CH5        PD7      MFP Mask */
N#define PWM0_CH5_PC5_Msk         SYS_GPC_MFPL_PC5MFP_Msk              /*<! PWM0_CH5        PC5      MFP Mask */
N#define PWM0_CH5_PD6_Msk         SYS_GPD_MFPL_PD6MFP_Msk              /*<! PWM0_CH5        PD6      MFP Mask */
N#define PWM0_SYNC_IN_PD7_Msk     SYS_GPD_MFPL_PD7MFP_Msk              /*<! PWM0_SYNC_IN    PD7      MFP Mask */
N#define PWM0_SYNC_IN_PD1_Msk     SYS_GPD_MFPL_PD1MFP_Msk              /*<! PWM0_SYNC_IN    PD1      MFP Mask */
N#define PWM0_SYNC_OUT_PB1_Msk    SYS_GPB_MFPL_PB1MFP_Msk              /*<! PWM0_SYNC_OUT   PB1      MFP Mask */
N#define PWM1_BRAKE0_PE4_Msk      SYS_GPE_MFPL_PE4MFP_Msk              /*<! PWM1_BRAKE0     PE4      MFP Mask */
N#define PWM1_BRAKE0_PF1_Msk      SYS_GPF_MFPL_PF1MFP_Msk              /*<! PWM1_BRAKE0     PF1      MFP Mask */
N#define PWM1_BRAKE1_PF2_Msk      SYS_GPF_MFPL_PF2MFP_Msk              /*<! PWM1_BRAKE1     PF2      MFP Mask */
N#define PWM1_BRAKE1_PA9_Msk      SYS_GPA_MFPH_PA9MFP_Msk              /*<! PWM1_BRAKE1     PA9      MFP Mask */
N#define PWM1_BRAKE1_PE5_Msk      SYS_GPE_MFPL_PE5MFP_Msk              /*<! PWM1_BRAKE1     PE5      MFP Mask */
N#define PWM1_CH0_PD12_Msk        SYS_GPD_MFPH_PD12MFP_Msk             /*<! PWM1_CH0        PD12     MFP Mask */
N#define PWM1_CH0_PC9_Msk         SYS_GPC_MFPH_PC9MFP_Msk              /*<! PWM1_CH0        PC9      MFP Mask */
N#define PWM1_CH0_PC6_Msk         SYS_GPC_MFPL_PC6MFP_Msk              /*<! PWM1_CH0        PC6      MFP Mask */
N#define PWM1_CH0_PC15_Msk        SYS_GPC_MFPH_PC15MFP_Msk             /*<! PWM1_CH0        PC15     MFP Mask */
N#define PWM1_CH1_PC10_Msk        SYS_GPC_MFPH_PC10MFP_Msk             /*<! PWM1_CH1        PC10     MFP Mask */
N#define PWM1_CH1_PD13_Msk        SYS_GPD_MFPH_PD13MFP_Msk             /*<! PWM1_CH1        PD13     MFP Mask */
N#define PWM1_CH1_PC7_Msk         SYS_GPC_MFPL_PC7MFP_Msk              /*<! PWM1_CH1        PC7      MFP Mask */
N#define PWM1_CH1_PB12_Msk        SYS_GPB_MFPH_PB12MFP_Msk             /*<! PWM1_CH1        PB12     MFP Mask */
N#define PWM1_CH2_PC11_Msk        SYS_GPC_MFPH_PC11MFP_Msk             /*<! PWM1_CH2        PC11     MFP Mask */
N#define PWM1_CH2_PD14_Msk        SYS_GPD_MFPH_PD14MFP_Msk             /*<! PWM1_CH2        PD14     MFP Mask */
N#define PWM1_CH2_PA3_Msk         SYS_GPA_MFPL_PA3MFP_Msk              /*<! PWM1_CH2        PA3      MFP Mask */
N#define PWM1_CH3_PA2_Msk         SYS_GPA_MFPL_PA2MFP_Msk              /*<! PWM1_CH3        PA2      MFP Mask */
N#define PWM1_CH3_PC12_Msk        SYS_GPC_MFPH_PC12MFP_Msk             /*<! PWM1_CH3        PC12     MFP Mask */
N#define PWM1_CH3_PD15_Msk        SYS_GPD_MFPH_PD15MFP_Msk             /*<! PWM1_CH3        PD15     MFP Mask */
N#define PWM1_CH4_PC13_Msk        SYS_GPC_MFPH_PC13MFP_Msk             /*<! PWM1_CH4        PC13     MFP Mask */
N#define PWM1_CH4_PA1_Msk         SYS_GPA_MFPL_PA1MFP_Msk              /*<! PWM1_CH4        PA1      MFP Mask */
N#define PWM1_CH5_PC14_Msk        SYS_GPC_MFPH_PC14MFP_Msk             /*<! PWM1_CH5        PC14     MFP Mask */
N#define PWM1_CH5_PA0_Msk         SYS_GPA_MFPL_PA0MFP_Msk              /*<! PWM1_CH5        PA0      MFP Mask */
N#define SC0_CLK_PA0_Msk          SYS_GPA_MFPL_PA0MFP_Msk              /*<! SC0_CLK         PA0      MFP Mask */
N#define SC0_CLK_PE11_Msk         SYS_GPE_MFPH_PE11MFP_Msk             /*<! SC0_CLK         PE11     MFP Mask */
N#define SC0_CLK_PC1_Msk          SYS_GPC_MFPL_PC1MFP_Msk              /*<! SC0_CLK         PC1      MFP Mask */
N#define SC0_DAT_PA1_Msk          SYS_GPA_MFPL_PA1MFP_Msk              /*<! SC0_DAT         PA1      MFP Mask */
N#define SC0_DAT_PC0_Msk          SYS_GPC_MFPL_PC0MFP_Msk              /*<! SC0_DAT         PC0      MFP Mask */
N#define SC0_DAT_PE10_Msk         SYS_GPE_MFPH_PE10MFP_Msk             /*<! SC0_DAT         PE10     MFP Mask */
N#define SC0_PWR_PE8_Msk          SYS_GPE_MFPH_PE8MFP_Msk              /*<! SC0_PWR         PE8      MFP Mask */
N#define SC0_PWR_PA8_Msk          SYS_GPA_MFPH_PA8MFP_Msk              /*<! SC0_PWR         PA8      MFP Mask */
N#define SC0_PWR_PA3_Msk          SYS_GPA_MFPL_PA3MFP_Msk              /*<! SC0_PWR         PA3      MFP Mask */
N#define SC0_PWR_PE4_Msk          SYS_GPE_MFPL_PE4MFP_Msk              /*<! SC0_PWR         PE4      MFP Mask */
N#define SC0_PWR_PC3_Msk          SYS_GPC_MFPL_PC3MFP_Msk              /*<! SC0_PWR         PC3      MFP Mask */
N#define SC0_RST_PA2_Msk          SYS_GPA_MFPL_PA2MFP_Msk              /*<! SC0_RST         PA2      MFP Mask */
N#define SC0_RST_PB1_Msk          SYS_GPB_MFPL_PB1MFP_Msk              /*<! SC0_RST         PB1      MFP Mask */
N#define SC0_RST_PC2_Msk          SYS_GPC_MFPL_PC2MFP_Msk              /*<! SC0_RST         PC2      MFP Mask */
N#define SC0_RST_PE5_Msk          SYS_GPE_MFPL_PE5MFP_Msk              /*<! SC0_RST         PE5      MFP Mask */
N#define SC0_RST_PE9_Msk          SYS_GPE_MFPH_PE9MFP_Msk              /*<! SC0_RST         PE9      MFP Mask */
N#define SC0_RST_PA9_Msk          SYS_GPA_MFPH_PA9MFP_Msk              /*<! SC0_RST         PA9      MFP Mask */
N#define SC0_nCD_PB2_Msk          SYS_GPB_MFPL_PB2MFP_Msk              /*<! SC0_nCD         PB2      MFP Mask */
N#define SC0_nCD_PE0_Msk          SYS_GPE_MFPL_PE0MFP_Msk              /*<! SC0_nCD         PE0      MFP Mask */
N#define SC0_nCD_PE1_Msk          SYS_GPE_MFPL_PE1MFP_Msk              /*<! SC0_nCD         PE1      MFP Mask */
N#define SC0_nCD_PC4_Msk          SYS_GPC_MFPL_PC4MFP_Msk              /*<! SC0_nCD         PC4      MFP Mask */
N#define SC1_CLK_PD0_Msk          SYS_GPD_MFPL_PD0MFP_Msk              /*<! SC1_CLK         PD0      MFP Mask */
N#define SC1_CLK_PA11_Msk         SYS_GPA_MFPH_PA11MFP_Msk             /*<! SC1_CLK         PA11     MFP Mask */
N#define SC1_DAT_PA10_Msk         SYS_GPA_MFPH_PA10MFP_Msk             /*<! SC1_DAT         PA10     MFP Mask */
N#define SC1_DAT_PB7_Msk          SYS_GPB_MFPL_PB7MFP_Msk              /*<! SC1_DAT         PB7      MFP Mask */
N#define SC1_PWR_PA9_Msk          SYS_GPA_MFPH_PA9MFP_Msk              /*<! SC1_PWR         PA9      MFP Mask */
N#define SC1_PWR_PB6_Msk          SYS_GPB_MFPL_PB6MFP_Msk              /*<! SC1_PWR         PB6      MFP Mask */
N#define SC1_RST_PA8_Msk          SYS_GPA_MFPH_PA8MFP_Msk              /*<! SC1_RST         PA8      MFP Mask */
N#define SC1_RST_PB5_Msk          SYS_GPB_MFPL_PB5MFP_Msk              /*<! SC1_RST         PB5      MFP Mask */
N#define SC1_nCD_PB4_Msk          SYS_GPB_MFPL_PB4MFP_Msk              /*<! SC1_nCD         PB4      MFP Mask */
N#define SC1_nCD_PF5_Msk          SYS_GPF_MFPL_PF5MFP_Msk              /*<! SC1_nCD         PF5      MFP Mask */
N#define SPI0_CLK_PC0_Msk         SYS_GPC_MFPL_PC0MFP_Msk              /*<! SPI0_CLK        PC0      MFP Mask */
N#define SPI0_CLK_PE0_Msk         SYS_GPE_MFPL_PE0MFP_Msk              /*<! SPI0_CLK        PE0      MFP Mask */
N#define SPI0_CLK_PB7_Msk         SYS_GPB_MFPL_PB7MFP_Msk              /*<! SPI0_CLK        PB7      MFP Mask */
N#define SPI0_CLK_PE13_Msk        SYS_GPE_MFPH_PE13MFP_Msk             /*<! SPI0_CLK        PE13     MFP Mask */
N#define SPI0_CLK_PC12_Msk        SYS_GPC_MFPH_PC12MFP_Msk             /*<! SPI0_CLK        PC12     MFP Mask */
N#define SPI0_CLK_PB2_Msk         SYS_GPB_MFPL_PB2MFP_Msk              /*<! SPI0_CLK        PB2      MFP Mask */
N#define SPI0_I2SMCLK_PC5_Msk     SYS_GPC_MFPL_PC5MFP_Msk              /*<! SPI0_I2SMCLK    PC5      MFP Mask */
N#define SPI0_I2SMCLK_PD7_Msk     SYS_GPD_MFPL_PD7MFP_Msk              /*<! SPI0_I2SMCLK    PD7      MFP Mask */
N#define SPI0_I2SMCLK_PC9_Msk     SYS_GPC_MFPH_PC9MFP_Msk              /*<! SPI0_I2SMCLK    PC9      MFP Mask */
N#define SPI0_I2SMCLK_PD0_Msk     SYS_GPD_MFPL_PD0MFP_Msk              /*<! SPI0_I2SMCLK    PD0      MFP Mask */
N#define SPI0_I2SMCLK_PD3_Msk     SYS_GPD_MFPL_PD3MFP_Msk              /*<! SPI0_I2SMCLK    PD3      MFP Mask */
N#define SPI0_MISO_PC4_Msk        SYS_GPC_MFPL_PC4MFP_Msk              /*<! SPI0_MISO       PC4      MFP Mask */
N#define SPI0_MISO_PC11_Msk       SYS_GPC_MFPH_PC11MFP_Msk             /*<! SPI0_MISO       PC11     MFP Mask */
N#define SPI0_MISO_PB3_Msk        SYS_GPB_MFPL_PB3MFP_Msk              /*<! SPI0_MISO       PB3      MFP Mask */
N#define SPI0_MISO_PB6_Msk        SYS_GPB_MFPL_PB6MFP_Msk              /*<! SPI0_MISO       PB6      MFP Mask */
N#define SPI0_MISO_PE10_Msk       SYS_GPE_MFPH_PE10MFP_Msk             /*<! SPI0_MISO       PE10     MFP Mask */
N#define SPI0_MOSI_PC10_Msk       SYS_GPC_MFPH_PC10MFP_Msk             /*<! SPI0_MOSI       PC10     MFP Mask */
N#define SPI0_MOSI_PB5_Msk        SYS_GPB_MFPL_PB5MFP_Msk              /*<! SPI0_MOSI       PB5      MFP Mask */
N#define SPI0_MOSI_PE11_Msk       SYS_GPE_MFPH_PE11MFP_Msk             /*<! SPI0_MOSI       PE11     MFP Mask */
N#define SPI0_MOSI_PC3_Msk        SYS_GPC_MFPL_PC3MFP_Msk              /*<! SPI0_MOSI       PC3      MFP Mask */
N#define SPI0_SS_PE12_Msk         SYS_GPE_MFPH_PE12MFP_Msk             /*<! SPI0_SS         PE12     MFP Mask */
N#define SPI0_SS_PC2_Msk          SYS_GPC_MFPL_PC2MFP_Msk              /*<! SPI0_SS         PC2      MFP Mask */
N#define SPI0_SS_PC13_Msk         SYS_GPC_MFPH_PC13MFP_Msk             /*<! SPI0_SS         PC13     MFP Mask */
N#define SPI0_SS_PB4_Msk          SYS_GPB_MFPL_PB4MFP_Msk              /*<! SPI0_SS         PB4      MFP Mask */
N#define SPI1_CLK_PA7_Msk         SYS_GPA_MFPL_PA7MFP_Msk              /*<! SPI1_CLK        PA7      MFP Mask */
N#define SPI1_CLK_PD15_Msk        SYS_GPD_MFPH_PD15MFP_Msk             /*<! SPI1_CLK        PD15     MFP Mask */
N#define SPI1_CLK_PE10_Msk        SYS_GPE_MFPH_PE10MFP_Msk             /*<! SPI1_CLK        PE10     MFP Mask */
N#define SPI1_CLK_PB2_Msk         SYS_GPB_MFPL_PB2MFP_Msk              /*<! SPI1_CLK        PB2      MFP Mask */
N#define SPI1_CLK_PE13_Msk        SYS_GPE_MFPH_PE13MFP_Msk             /*<! SPI1_CLK        PE13     MFP Mask */
N#define SPI1_CLK_PB7_Msk         SYS_GPB_MFPL_PB7MFP_Msk              /*<! SPI1_CLK        PB7      MFP Mask */
N#define SPI1_CLK_PD4_Msk         SYS_GPD_MFPL_PD4MFP_Msk              /*<! SPI1_CLK        PD4      MFP Mask */
N#define SPI1_I2SMCLK_PA9_Msk     SYS_GPA_MFPH_PA9MFP_Msk              /*<! SPI1_I2SMCLK    PA9      MFP Mask */
N#define SPI1_I2SMCLK_PD0_Msk     SYS_GPD_MFPL_PD0MFP_Msk              /*<! SPI1_I2SMCLK    PD0      MFP Mask */
N#define SPI1_I2SMCLK_PA12_Msk    SYS_GPA_MFPH_PA12MFP_Msk             /*<! SPI1_I2SMCLK    PA12     MFP Mask */
N#define SPI1_MISO_PB3_Msk        SYS_GPB_MFPL_PB3MFP_Msk              /*<! SPI1_MISO       PB3      MFP Mask */
N#define SPI1_MISO_PA6_Msk        SYS_GPA_MFPL_PA6MFP_Msk              /*<! SPI1_MISO       PA6      MFP Mask */
N#define SPI1_MISO_PD5_Msk        SYS_GPD_MFPL_PD5MFP_Msk              /*<! SPI1_MISO       PD5      MFP Mask */
N#define SPI1_MISO_PD14_Msk       SYS_GPD_MFPH_PD14MFP_Msk             /*<! SPI1_MISO       PD14     MFP Mask */
N#define SPI1_MISO_PB6_Msk        SYS_GPB_MFPL_PB6MFP_Msk              /*<! SPI1_MISO       PB6      MFP Mask */
N#define SPI1_MISO_PE10_Msk       SYS_GPE_MFPH_PE10MFP_Msk             /*<! SPI1_MISO       PE10     MFP Mask */
N#define SPI1_MISO_PE11_Msk       SYS_GPE_MFPH_PE11MFP_Msk             /*<! SPI1_MISO       PE11     MFP Mask */
N#define SPI1_MOSI_PE12_Msk       SYS_GPE_MFPH_PE12MFP_Msk             /*<! SPI1_MOSI       PE12     MFP Mask */
N#define SPI1_MOSI_PE3_Msk        SYS_GPE_MFPL_PE3MFP_Msk              /*<! SPI1_MOSI       PE3      MFP Mask */
N#define SPI1_MOSI_PB5_Msk        SYS_GPB_MFPL_PB5MFP_Msk              /*<! SPI1_MOSI       PB5      MFP Mask */
N#define SPI1_MOSI_PA5_Msk        SYS_GPA_MFPL_PA5MFP_Msk              /*<! SPI1_MOSI       PA5      MFP Mask */
N#define SPI1_MOSI_PE11_Msk       SYS_GPE_MFPH_PE11MFP_Msk             /*<! SPI1_MOSI       PE11     MFP Mask */
N#define SPI1_MOSI_PD13_Msk       SYS_GPD_MFPH_PD13MFP_Msk             /*<! SPI1_MOSI       PD13     MFP Mask */
N#define SPI1_SS_PB4_Msk          SYS_GPB_MFPL_PB4MFP_Msk              /*<! SPI1_SS         PB4      MFP Mask */
N#define SPI1_SS_PE12_Msk         SYS_GPE_MFPH_PE12MFP_Msk             /*<! SPI1_SS         PE12     MFP Mask */
N#define SPI1_SS_PD6_Msk          SYS_GPD_MFPL_PD6MFP_Msk              /*<! SPI1_SS         PD6      MFP Mask */
N#define SPI1_SS_PA4_Msk          SYS_GPA_MFPL_PA4MFP_Msk              /*<! SPI1_SS         PA4      MFP Mask */
N#define SPI1_SS_PE13_Msk         SYS_GPE_MFPH_PE13MFP_Msk             /*<! SPI1_SS         PE13     MFP Mask */
N#define SPI1_SS_PD12_Msk         SYS_GPD_MFPH_PD12MFP_Msk             /*<! SPI1_SS         PD12     MFP Mask */
N#define TM0_PD4_Msk              SYS_GPD_MFPL_PD4MFP_Msk              /*<! TM0             PD4      MFP Mask */
N#define TM0_PD1_Msk              SYS_GPD_MFPL_PD1MFP_Msk              /*<! TM0             PD1      MFP Mask */
N#define TM0_PE8_Msk              SYS_GPE_MFPH_PE8MFP_Msk              /*<! TM0             PE8      MFP Mask */
N#define TM0_EXT_PD2_Msk          SYS_GPD_MFPL_PD2MFP_Msk              /*<! TM0_EXT         PD2      MFP Mask */
N#define TM0_EXT_PB3_Msk          SYS_GPB_MFPL_PB3MFP_Msk              /*<! TM0_EXT         PB3      MFP Mask */
N#define TM0_EXT_PE10_Msk         SYS_GPE_MFPH_PE10MFP_Msk             /*<! TM0_EXT         PE10     MFP Mask */
N#define TM0_EXT_PA7_Msk          SYS_GPA_MFPL_PA7MFP_Msk              /*<! TM0_EXT         PA7      MFP Mask */
N#define TM1_PA8_Msk              SYS_GPA_MFPH_PA8MFP_Msk              /*<! TM1             PA8      MFP Mask */
N#define TM1_PD7_Msk              SYS_GPD_MFPL_PD7MFP_Msk              /*<! TM1             PD7      MFP Mask */
N#define TM1_PE9_Msk              SYS_GPE_MFPH_PE9MFP_Msk              /*<! TM1             PE9      MFP Mask */
N#define TM1_PD5_Msk              SYS_GPD_MFPL_PD5MFP_Msk              /*<! TM1             PD5      MFP Mask */
N#define TM1_EXT_PD3_Msk          SYS_GPD_MFPL_PD3MFP_Msk              /*<! TM1_EXT         PD3      MFP Mask */
N#define TM1_EXT_PB4_Msk          SYS_GPB_MFPL_PB4MFP_Msk              /*<! TM1_EXT         PB4      MFP Mask */
N#define TM1_EXT_PA6_Msk          SYS_GPA_MFPL_PA6MFP_Msk              /*<! TM1_EXT         PA6      MFP Mask */
N#define TM1_EXT_PE11_Msk         SYS_GPE_MFPH_PE11MFP_Msk             /*<! TM1_EXT         PE11     MFP Mask */
N#define TM1_EXT_PB0_Msk          SYS_GPB_MFPL_PB0MFP_Msk              /*<! TM1_EXT         PB0      MFP Mask */
N#define TM2_PA9_Msk              SYS_GPA_MFPH_PA9MFP_Msk              /*<! TM2             PA9      MFP Mask */
N#define TM2_PB0_Msk              SYS_GPB_MFPL_PB0MFP_Msk              /*<! TM2             PB0      MFP Mask */
N#define TM2_PA14_Msk             SYS_GPA_MFPH_PA14MFP_Msk             /*<! TM2             PA14     MFP Mask */
N#define TM2_PD10_Msk             SYS_GPD_MFPH_PD10MFP_Msk             /*<! TM2             PD10     MFP Mask */
N#define TM2_PD8_Msk              SYS_GPD_MFPH_PD8MFP_Msk              /*<! TM2             PD8      MFP Mask */
N#define TM2_PD3_Msk              SYS_GPD_MFPL_PD3MFP_Msk              /*<! TM2             PD3      MFP Mask */
N#define TM2_EXT_PE12_Msk         SYS_GPE_MFPH_PE12MFP_Msk             /*<! TM2_EXT         PE12     MFP Mask */
N#define TM2_EXT_PB2_Msk          SYS_GPB_MFPL_PB2MFP_Msk              /*<! TM2_EXT         PB2      MFP Mask */
N#define TM2_EXT_PE0_Msk          SYS_GPE_MFPL_PE0MFP_Msk              /*<! TM2_EXT         PE0      MFP Mask */
N#define TM2_EXT_PA5_Msk          SYS_GPA_MFPL_PA5MFP_Msk              /*<! TM2_EXT         PA5      MFP Mask */
N#define TM3_PD9_Msk              SYS_GPD_MFPH_PD9MFP_Msk              /*<! TM3             PD9      MFP Mask */
N#define TM3_PB1_Msk              SYS_GPB_MFPL_PB1MFP_Msk              /*<! TM3             PB1      MFP Mask */
N#define TM3_PA15_Msk             SYS_GPA_MFPH_PA15MFP_Msk             /*<! TM3             PA15     MFP Mask */
N#define TM3_PD11_Msk             SYS_GPD_MFPH_PD11MFP_Msk             /*<! TM3             PD11     MFP Mask */
N#define TM3_EXT_PE1_Msk          SYS_GPE_MFPL_PE1MFP_Msk              /*<! TM3_EXT         PE1      MFP Mask */
N#define TM3_EXT_PA4_Msk          SYS_GPA_MFPL_PA4MFP_Msk              /*<! TM3_EXT         PA4      MFP Mask */
N#define TM3_EXT_PF5_Msk          SYS_GPF_MFPL_PF5MFP_Msk              /*<! TM3_EXT         PF5      MFP Mask */
N#define TM3_EXT_PE13_Msk         SYS_GPE_MFPH_PE13MFP_Msk             /*<! TM3_EXT         PE13     MFP Mask */
N#define TM_BRAKE0_PB2_Msk        SYS_GPB_MFPL_PB2MFP_Msk              /*<! TM_BRAKE0       PB2      MFP Mask */
N#define TM_BRAKE0_PA8_Msk        SYS_GPA_MFPH_PA8MFP_Msk              /*<! TM_BRAKE0       PA8      MFP Mask */
N#define TM_BRAKE0_PF5_Msk        SYS_GPF_MFPL_PF5MFP_Msk              /*<! TM_BRAKE0       PF5      MFP Mask */
N#define TM_BRAKE1_PA9_Msk        SYS_GPA_MFPH_PA9MFP_Msk              /*<! TM_BRAKE1       PA9      MFP Mask */
N#define TM_BRAKE1_PA7_Msk        SYS_GPA_MFPL_PA7MFP_Msk              /*<! TM_BRAKE1       PA7      MFP Mask */
N#define TM_BRAKE1_PB3_Msk        SYS_GPB_MFPL_PB3MFP_Msk              /*<! TM_BRAKE1       PB3      MFP Mask */
N#define TM_BRAKE2_PB8_Msk        SYS_GPB_MFPH_PB8MFP_Msk              /*<! TM_BRAKE2       PB8      MFP Mask */
N#define TM_BRAKE2_PA12_Msk       SYS_GPA_MFPH_PA12MFP_Msk             /*<! TM_BRAKE2       PA12     MFP Mask */
N#define TM_BRAKE2_PA6_Msk        SYS_GPA_MFPL_PA6MFP_Msk              /*<! TM_BRAKE2       PA6      MFP Mask */
N#define TM_BRAKE3_PA5_Msk        SYS_GPA_MFPL_PA5MFP_Msk              /*<! TM_BRAKE3       PA5      MFP Mask */
N#define TM_BRAKE3_PA13_Msk       SYS_GPA_MFPH_PA13MFP_Msk             /*<! TM_BRAKE3       PA13     MFP Mask */
N#define TM_BRAKE3_PE2_Msk        SYS_GPE_MFPL_PE2MFP_Msk              /*<! TM_BRAKE3       PE2      MFP Mask */
N#define UART0_RXD_PA3_Msk        SYS_GPA_MFPL_PA3MFP_Msk              /*<! UART0_RXD       PA3      MFP Mask */
N#define UART0_RXD_PE6_Msk        SYS_GPE_MFPL_PE6MFP_Msk              /*<! UART0_RXD       PE6      MFP Mask */
N#define UART0_RXD_PD9_Msk        SYS_GPD_MFPH_PD9MFP_Msk              /*<! UART0_RXD       PD9      MFP Mask */
N#define UART0_RXD_PD0_Msk        SYS_GPD_MFPL_PD0MFP_Msk              /*<! UART0_RXD       PD0      MFP Mask */
N#define UART0_RXD_PD13_Msk       SYS_GPD_MFPH_PD13MFP_Msk             /*<! UART0_RXD       PD13     MFP Mask */
N#define UART0_RXD_PD6_Msk        SYS_GPD_MFPL_PD6MFP_Msk              /*<! UART0_RXD       PD6      MFP Mask */
N#define UART0_TXD_PD1_Msk        SYS_GPD_MFPL_PD1MFP_Msk              /*<! UART0_TXD       PD1      MFP Mask */
N#define UART0_TXD_PE7_Msk        SYS_GPE_MFPL_PE7MFP_Msk              /*<! UART0_TXD       PE7      MFP Mask */
N#define UART0_TXD_PD12_Msk       SYS_GPD_MFPH_PD12MFP_Msk             /*<! UART0_TXD       PD12     MFP Mask */
N#define UART0_TXD_PA2_Msk        SYS_GPA_MFPL_PA2MFP_Msk              /*<! UART0_TXD       PA2      MFP Mask */
N#define UART0_nCTS_PD8_Msk       SYS_GPD_MFPH_PD8MFP_Msk              /*<! UART0_nCTS      PD8      MFP Mask */
N#define UART0_nCTS_PD14_Msk      SYS_GPD_MFPH_PD14MFP_Msk             /*<! UART0_nCTS      PD14     MFP Mask */
N#define UART0_nCTS_PA2_Msk       SYS_GPA_MFPL_PA2MFP_Msk              /*<! UART0_nCTS      PA2      MFP Mask */
N#define UART0_nRTS_PC8_Msk       SYS_GPC_MFPH_PC8MFP_Msk              /*<! UART0_nRTS      PC8      MFP Mask */
N#define UART0_nRTS_PD15_Msk      SYS_GPD_MFPH_PD15MFP_Msk             /*<! UART0_nRTS      PD15     MFP Mask */
N#define UART0_nRTS_PA3_Msk       SYS_GPA_MFPL_PA3MFP_Msk              /*<! UART0_nRTS      PA3      MFP Mask */
N#define UART1_RXD_PA1_Msk        SYS_GPA_MFPL_PA1MFP_Msk              /*<! UART1_RXD       PA1      MFP Mask */
N#define UART1_RXD_PE9_Msk        SYS_GPE_MFPH_PE9MFP_Msk              /*<! UART1_RXD       PE9      MFP Mask */
N#define UART1_RXD_PA9_Msk        SYS_GPA_MFPH_PA9MFP_Msk              /*<! UART1_RXD       PA9      MFP Mask */
N#define UART1_RXD_PB2_Msk        SYS_GPB_MFPL_PB2MFP_Msk              /*<! UART1_RXD       PB2      MFP Mask */
N#define UART1_RXD_PA12_Msk       SYS_GPA_MFPH_PA12MFP_Msk             /*<! UART1_RXD       PA12     MFP Mask */
N#define UART1_RXD_PE13_Msk       SYS_GPE_MFPH_PE13MFP_Msk             /*<! UART1_RXD       PE13     MFP Mask */
N#define UART1_TXD_PA13_Msk       SYS_GPA_MFPH_PA13MFP_Msk             /*<! UART1_TXD       PA13     MFP Mask */
N#define UART1_TXD_PB3_Msk        SYS_GPB_MFPL_PB3MFP_Msk              /*<! UART1_TXD       PB3      MFP Mask */
N#define UART1_TXD_PE8_Msk        SYS_GPE_MFPH_PE8MFP_Msk              /*<! UART1_TXD       PE8      MFP Mask */
N#define UART1_TXD_PA0_Msk        SYS_GPA_MFPL_PA0MFP_Msk              /*<! UART1_TXD       PA0      MFP Mask */
N#define UART1_TXD_PE12_Msk       SYS_GPE_MFPH_PE12MFP_Msk             /*<! UART1_TXD       PE12     MFP Mask */
N#define UART1_TXD_PA8_Msk        SYS_GPA_MFPH_PA8MFP_Msk              /*<! UART1_TXD       PA8      MFP Mask */
N#define UART1_nCTS_PB4_Msk       SYS_GPB_MFPL_PB4MFP_Msk              /*<! UART1_nCTS      PB4      MFP Mask */
N#define UART1_nCTS_PA10_Msk      SYS_GPA_MFPH_PA10MFP_Msk             /*<! UART1_nCTS      PA10     MFP Mask */
N#define UART1_nCTS_PA0_Msk       SYS_GPA_MFPL_PA0MFP_Msk              /*<! UART1_nCTS      PA0      MFP Mask */
N#define UART1_nCTS_PE10_Msk      SYS_GPE_MFPH_PE10MFP_Msk             /*<! UART1_nCTS      PE10     MFP Mask */
N#define UART1_nRTS_PA11_Msk      SYS_GPA_MFPH_PA11MFP_Msk             /*<! UART1_nRTS      PA11     MFP Mask */
N#define UART1_nRTS_PB8_Msk       SYS_GPB_MFPH_PB8MFP_Msk              /*<! UART1_nRTS      PB8      MFP Mask */
N#define UART1_nRTS_PA1_Msk       SYS_GPA_MFPL_PA1MFP_Msk              /*<! UART1_nRTS      PA1      MFP Mask */
N#define UART1_nRTS_PE11_Msk      SYS_GPE_MFPH_PE11MFP_Msk             /*<! UART1_nRTS      PE11     MFP Mask */
N#define UART1_nRTS_PE2_Msk       SYS_GPE_MFPL_PE2MFP_Msk              /*<! UART1_nRTS      PE2      MFP Mask */
N#define UART2_RXD_PB0_Msk        SYS_GPB_MFPL_PB0MFP_Msk              /*<! UART2_RXD       PB0      MFP Mask */
N#define UART2_RXD_PC3_Msk        SYS_GPC_MFPL_PC3MFP_Msk              /*<! UART2_RXD       PC3      MFP Mask */
N#define UART2_RXD_PE3_Msk        SYS_GPE_MFPL_PE3MFP_Msk              /*<! UART2_RXD       PE3      MFP Mask */
N#define UART2_RXD_PB5_Msk        SYS_GPB_MFPL_PB5MFP_Msk              /*<! UART2_RXD       PB5      MFP Mask */
N#define UART2_RXD_PA12_Msk       SYS_GPA_MFPH_PA12MFP_Msk             /*<! UART2_RXD       PA12     MFP Mask */
N#define UART2_RXD_PB4_Msk        SYS_GPB_MFPL_PB4MFP_Msk              /*<! UART2_RXD       PB4      MFP Mask */
N#define UART2_TXD_PD6_Msk        SYS_GPD_MFPL_PD6MFP_Msk              /*<! UART2_TXD       PD6      MFP Mask */
N#define UART2_TXD_PB1_Msk        SYS_GPB_MFPL_PB1MFP_Msk              /*<! UART2_TXD       PB1      MFP Mask */
N#define UART2_TXD_PA13_Msk       SYS_GPA_MFPH_PA13MFP_Msk             /*<! UART2_TXD       PA13     MFP Mask */
N#define UART2_TXD_PC2_Msk        SYS_GPC_MFPL_PC2MFP_Msk              /*<! UART2_TXD       PC2      MFP Mask */
N#define UART2_nCTS_PC0_Msk       SYS_GPC_MFPL_PC0MFP_Msk              /*<! UART2_nCTS      PC0      MFP Mask */
N#define UART2_nCTS_PD5_Msk       SYS_GPD_MFPL_PD5MFP_Msk              /*<! UART2_nCTS      PD5      MFP Mask */
N#define UART2_nCTS_PA14_Msk      SYS_GPA_MFPH_PA14MFP_Msk             /*<! UART2_nCTS      PA14     MFP Mask */
N#define UART2_nRTS_PA15_Msk      SYS_GPA_MFPH_PA15MFP_Msk             /*<! UART2_nRTS      PA15     MFP Mask */
N#define UART2_nRTS_PD4_Msk       SYS_GPD_MFPL_PD4MFP_Msk              /*<! UART2_nRTS      PD4      MFP Mask */
N#define UART2_nRTS_PC1_Msk       SYS_GPC_MFPL_PC1MFP_Msk              /*<! UART2_nRTS      PC1      MFP Mask */
N#define USCI0_CLK_PB9_Msk        SYS_GPB_MFPH_PB9MFP_Msk              /*<! USCI0_CLK       PB9      MFP Mask */
N#define USCI0_CLK_PC4_Msk        SYS_GPC_MFPL_PC4MFP_Msk              /*<! USCI0_CLK       PC4      MFP Mask */
N#define USCI0_CLK_PE5_Msk        SYS_GPE_MFPL_PE5MFP_Msk              /*<! USCI0_CLK       PE5      MFP Mask */
N#define USCI0_CTL0_PC3_Msk       SYS_GPC_MFPL_PC3MFP_Msk              /*<! USCI0_CTL0      PC3      MFP Mask */
N#define USCI0_CTL0_PB8_Msk       SYS_GPB_MFPH_PB8MFP_Msk              /*<! USCI0_CTL0      PB8      MFP Mask */
N#define USCI0_CTL0_PE4_Msk       SYS_GPE_MFPL_PE4MFP_Msk              /*<! USCI0_CTL0      PE4      MFP Mask */
N#define USCI0_CTL0_PE2_Msk       SYS_GPE_MFPL_PE2MFP_Msk              /*<! USCI0_CTL0      PE2      MFP Mask */
N#define USCI0_CTL1_PC7_Msk       SYS_GPC_MFPL_PC7MFP_Msk              /*<! USCI0_CTL1      PC7      MFP Mask */
N#define USCI0_CTL1_PB4_Msk       SYS_GPB_MFPL_PB4MFP_Msk              /*<! USCI0_CTL1      PB4      MFP Mask */
N#define USCI0_CTL1_PC2_Msk       SYS_GPC_MFPL_PC2MFP_Msk              /*<! USCI0_CTL1      PC2      MFP Mask */
N#define USCI0_DAT0_PC5_Msk       SYS_GPC_MFPL_PC5MFP_Msk              /*<! USCI0_DAT0      PC5      MFP Mask */
N#define USCI0_DAT0_PC0_Msk       SYS_GPC_MFPL_PC0MFP_Msk              /*<! USCI0_DAT0      PC0      MFP Mask */
N#define USCI0_DAT0_PB2_Msk       SYS_GPB_MFPL_PB2MFP_Msk              /*<! USCI0_DAT0      PB2      MFP Mask */
N#define USCI0_DAT1_PC1_Msk       SYS_GPC_MFPL_PC1MFP_Msk              /*<! USCI0_DAT1      PC1      MFP Mask */
N#define USCI0_DAT1_PB3_Msk       SYS_GPB_MFPL_PB3MFP_Msk              /*<! USCI0_DAT1      PB3      MFP Mask */
N#define USCI0_DAT1_PC6_Msk       SYS_GPC_MFPL_PC6MFP_Msk              /*<! USCI0_DAT1      PC6      MFP Mask */
N#define USCI1_CLK_PD15_Msk       SYS_GPD_MFPH_PD15MFP_Msk             /*<! USCI1_CLK       PD15     MFP Mask */
N#define USCI1_CLK_PA3_Msk        SYS_GPA_MFPL_PA3MFP_Msk              /*<! USCI1_CLK       PA3      MFP Mask */
N#define USCI1_CLK_PA15_Msk       SYS_GPA_MFPH_PA15MFP_Msk             /*<! USCI1_CLK       PA15     MFP Mask */
N#define USCI1_CTL0_PA2_Msk       SYS_GPA_MFPL_PA2MFP_Msk              /*<! USCI1_CTL0      PA2      MFP Mask */
N#define USCI1_CTL0_PA0_Msk       SYS_GPA_MFPL_PA0MFP_Msk              /*<! USCI1_CTL0      PA0      MFP Mask */
N#define USCI1_CTL0_PD12_Msk      SYS_GPD_MFPH_PD12MFP_Msk             /*<! USCI1_CTL0      PD12     MFP Mask */
N#define USCI1_CTL1_PA1_Msk       SYS_GPA_MFPL_PA1MFP_Msk              /*<! USCI1_CTL1      PA1      MFP Mask */
N#define USCI1_CTL1_PA14_Msk      SYS_GPA_MFPH_PA14MFP_Msk             /*<! USCI1_CTL1      PA14     MFP Mask */
N#define USCI1_CTL1_PD7_Msk       SYS_GPD_MFPL_PD7MFP_Msk              /*<! USCI1_CTL1      PD7      MFP Mask */
N#define USCI1_DAT0_PD14_Msk      SYS_GPD_MFPH_PD14MFP_Msk             /*<! USCI1_DAT0      PD14     MFP Mask */
N#define USCI1_DAT0_PB0_Msk       SYS_GPB_MFPL_PB0MFP_Msk              /*<! USCI1_DAT0      PB0      MFP Mask */
N#define USCI1_DAT1_PB1_Msk       SYS_GPB_MFPL_PB1MFP_Msk              /*<! USCI1_DAT1      PB1      MFP Mask */
N#define USCI1_DAT1_PD13_Msk      SYS_GPD_MFPH_PD13MFP_Msk             /*<! USCI1_DAT1      PD13     MFP Mask */
N#define USCI2_CLK_PC11_Msk       SYS_GPC_MFPH_PC11MFP_Msk             /*<! USCI2_CLK       PC11     MFP Mask */
N#define USCI2_CLK_PD1_Msk        SYS_GPD_MFPL_PD1MFP_Msk              /*<! USCI2_CLK       PD1      MFP Mask */
N#define USCI2_CLK_PF2_Msk        SYS_GPF_MFPL_PF2MFP_Msk              /*<! USCI2_CLK       PF2      MFP Mask */
N#define USCI2_CTL0_PD0_Msk       SYS_GPD_MFPL_PD0MFP_Msk              /*<! USCI2_CTL0      PD0      MFP Mask */
N#define USCI2_CTL0_PD9_Msk       SYS_GPD_MFPH_PD9MFP_Msk              /*<! USCI2_CTL0      PD9      MFP Mask */
N#define USCI2_CTL0_PC12_Msk      SYS_GPC_MFPH_PC12MFP_Msk             /*<! USCI2_CTL0      PC12     MFP Mask */
N#define USCI2_CTL0_PF1_Msk       SYS_GPF_MFPL_PF1MFP_Msk              /*<! USCI2_CTL0      PF1      MFP Mask */
N#define USCI2_CTL1_PC9_Msk       SYS_GPC_MFPH_PC9MFP_Msk              /*<! USCI2_CTL1      PC9      MFP Mask */
N#define USCI2_CTL1_PF0_Msk       SYS_GPF_MFPL_PF0MFP_Msk              /*<! USCI2_CTL1      PF0      MFP Mask */
N#define USCI2_CTL1_PD8_Msk       SYS_GPD_MFPH_PD8MFP_Msk              /*<! USCI2_CTL1      PD8      MFP Mask */
N#define USCI2_CTL1_PB7_Msk       SYS_GPB_MFPL_PB7MFP_Msk              /*<! USCI2_CTL1      PB7      MFP Mask */
N#define USCI2_DAT0_PD2_Msk       SYS_GPD_MFPL_PD2MFP_Msk              /*<! USCI2_DAT0      PD2      MFP Mask */
N#define USCI2_DAT0_PD10_Msk      SYS_GPD_MFPH_PD10MFP_Msk             /*<! USCI2_DAT0      PD10     MFP Mask */
N#define USCI2_DAT0_PC13_Msk      SYS_GPC_MFPH_PC13MFP_Msk             /*<! USCI2_DAT0      PC13     MFP Mask */
N#define USCI2_DAT1_PD3_Msk       SYS_GPD_MFPL_PD3MFP_Msk              /*<! USCI2_DAT1      PD3      MFP Mask */
N#define USCI2_DAT1_PC10_Msk      SYS_GPC_MFPH_PC10MFP_Msk             /*<! USCI2_DAT1      PC10     MFP Mask */
N#define USCI2_DAT1_PD11_Msk      SYS_GPD_MFPH_PD11MFP_Msk             /*<! USCI2_DAT1      PD11     MFP Mask */
N#define VDET_P0_PB0_Msk          SYS_GPB_MFPL_PB0MFP_Msk              /*<! VDET_P0         PB0      MFP Mask */
N#define VDET_P1_PB1_Msk          SYS_GPB_MFPL_PB1MFP_Msk              /*<! VDET_P1         PB1      MFP Mask */
N#define X32_IN_PF1_Msk           SYS_GPF_MFPL_PF1MFP_Msk              /*<! X32_IN          PF1      MFP Mask */
N#define X32_OUT_PF0_Msk          SYS_GPF_MFPL_PF0MFP_Msk              /*<! X32_OUT         PF0      MFP Mask */
N#define XT1_IN_PF4_Msk           SYS_GPF_MFPL_PF4MFP_Msk              /*<! XT1_IN          PF4      MFP Mask */
N#define XT1_OUT_PF3_Msk          SYS_GPF_MFPL_PF3MFP_Msk              /*<! XT1_OUT         PF3      MFP Mask */
N
N
N/*@}*/ /* end of group SYS_EXPORTED_CONSTANTS */
N
N/** @addtogroup SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N
N
N/**
N  * @brief      Clear Brown-out detector interrupt flag
N  * @param      None
N  * @return     None
N  * @details    This macro clear Brown-out detector interrupt flag.
N  */
N#define SYS_CLEAR_BOD_INT_FLAG()        (SYS->BODCTL |= SYS_BODCTL_BODIF_Msk)
N
N/**
N  * @brief      Set Brown-out detector function to normal mode
N  * @param      None
N  * @return     None
N  * @details    This macro set Brown-out detector to normal mode.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_CLEAR_BOD_LPM()             (SYS->BODCTL &= ~SYS_BODCTL_BODLPM_Msk)
N
N/**
N  * @brief      Disable Brown-out detector function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Brown-out detector function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_DISABLE_BOD()               (SYS->BODCTL &= ~SYS_BODCTL_BODEN_Msk)
N
N/**
N  * @brief      Enable Brown-out detector function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detector function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_ENABLE_BOD()                (SYS->BODCTL |= SYS_BODCTL_BODEN_Msk)
N
N/**
N  * @brief      Get Brown-out detector interrupt flag
N  * @param      None
N  * @retval     0   Brown-out detect interrupt flag is not set.
N  * @retval     >=1 Brown-out detect interrupt flag is set.
N  * @details    This macro get Brown-out detector interrupt flag.
N  */
N#define SYS_GET_BOD_INT_FLAG()          (SYS->BODCTL & SYS_BODCTL_BODIF_Msk)
N
N/**
N  * @brief      Get Brown-out detector status
N  * @param      None
N  * @retval     0   System voltage is higher than BOD threshold voltage setting or BOD function is disabled.
N  * @retval     >=1 System voltage is lower than BOD threshold voltage setting.
N  * @details    This macro get Brown-out detector output status.
N  *             If the BOD function is disabled, this function always return 0.
N  */
N#define SYS_GET_BOD_OUTPUT()            (SYS->BODCTL & SYS_BODCTL_BODOUT_Msk)
N
N/**
N  * @brief      Enable Brown-out detector interrupt function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detector interrupt function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_DISABLE_BOD_RST()           (SYS->BODCTL &= ~SYS_BODCTL_BODRSTEN_Msk)
N
N/**
N  * @brief      Enable Brown-out detector reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detect reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_ENABLE_BOD_RST()            (SYS->BODCTL |= SYS_BODCTL_BODRSTEN_Msk)
N
N/**
N  * @brief      Set Brown-out detector function low power mode
N  * @param      None
N  * @return     None
N  * @details    This macro set Brown-out detector to low power mode.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_SET_BOD_LPM()               (SYS->BODCTL |= SYS_BODCTL_BODLPM_Msk)
N
N/**
N  * @brief      Set Brown-out detector voltage level
N  * @param[in]  u32Level is Brown-out voltage level. Including :
N  *             - \ref SYS_BODCTL_BODVL_4_5V
N  *             - \ref SYS_BODCTL_BODVL_3_7V
N  *             - \ref SYS_BODCTL_BODVL_2_7V
N  *             - \ref SYS_BODCTL_BODVL_2_2V
N  * @return     None
N  * @details    This macro set Brown-out detector voltage level.
N  *             The write-protection function should be disabled before using this macro.
N  */
N#define SYS_SET_BOD_LEVEL(u32Level)     (SYS->BODCTL = (SYS->BODCTL & ~SYS_BODCTL_BODVL_Msk) | (u32Level))
N
N/**
N  * @brief      Get reset source is from Brown-out detector reset
N  * @param      None
N  * @retval     0   Previous reset source is not from Brown-out detector reset
N  * @retval     >=1 Previous reset source is from Brown-out detector reset
N  * @details    This macro get previous reset source is from Brown-out detect reset or not.
N  */
N#define SYS_IS_BOD_RST()                (SYS->RSTSTS & SYS_RSTSTS_BODRF_Msk)
N
N/**
N  * @brief      Get reset source is from CPU reset
N  * @param      None
N  * @retval     0   Previous reset source is not from CPU reset
N  * @retval     >=1 Previous reset source is from CPU reset
N  * @details    This macro get previous reset source is from CPU reset.
N  */
N#define SYS_IS_CPU_RST()                (SYS->RSTSTS & SYS_RSTSTS_CPURF_Msk)
N
N/**
N  * @brief      Get reset source is from LVR Reset
N  * @param      None
N  * @retval     0   Previous reset source is not from Low-Voltage-Reset
N  * @retval     >=1 Previous reset source is from Low-Voltage-Reset
N  * @details    This macro get previous reset source is from Low-Voltage-Reset.
N  */
N#define SYS_IS_LVR_RST()                (SYS->RSTSTS & SYS_RSTSTS_LVRF_Msk)
N
N/**
N  * @brief      Get reset source is from Power-on Reset
N  * @param      None
N  * @retval     0   Previous reset source is not from Power-on Reset
N  * @retval     >=1 Previous reset source is from Power-on Reset
N  * @details    This macro get previous reset source is from Power-on Reset.
N  */
N#define SYS_IS_POR_RST()                (SYS->RSTSTS & SYS_RSTSTS_PORF_Msk)
N
N/**
N  * @brief      Get reset source is from reset pin reset
N  * @param      None
N  * @retval     0   Previous reset source is not from reset pin reset
N  * @retval     >=1 Previous reset source is from reset pin reset
N  * @details    This macro get previous reset source is from reset pin reset.
N  */
N#define SYS_IS_RSTPIN_RST()             (SYS->RSTSTS & SYS_RSTSTS_PINRF_Msk)
N
N/**
N  * @brief      Get reset source is from system reset
N  * @param      None
N  * @retval     0   Previous reset source is not from system reset
N  * @retval     >=1 Previous reset source is from system reset
N  * @details    This macro get previous reset source is from system reset.
N  */
N#define SYS_IS_SYSTEM_RST()             (SYS->RSTSTS & SYS_RSTSTS_MCURF_Msk)
N
N/**
N  * @brief      Get reset source is from window watch dog reset
N  * @param      None
N  * @retval     0   Previous reset source is not from window watch dog reset
N  * @retval     >=1 Previous reset source is from window watch dog reset
N  * @details    This macro get previous reset source is from window watch dog reset.
N  */
N#define SYS_IS_WDT_RST()                (SYS->RSTSTS & SYS_RSTSTS_WDTRF_Msk)
N
N/**
N  * @brief      Disable Low-Voltage-Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Low-Voltage-Reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_DISABLE_LVR()               (SYS->BODCTL &= ~SYS_BODCTL_LVREN_Msk)
N
N/**
N  * @brief      Enable Low-Voltage-Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Low-Voltage-Reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_ENABLE_LVR()                (SYS->BODCTL |= SYS_BODCTL_LVREN_Msk)
N
N/**
N  * @brief      Disable Power-on Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Power-on Reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_DISABLE_POR()               (SYS->PORCTL = 0x5AA5)
N
N/**
N  * @brief      Enable Power-on Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Power-on Reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_ENABLE_POR()                (SYS->PORCTL = 0)
N
N/**
N  * @brief      Clear reset source flag
N  * @param[in]  u32RstSrc is reset source. Including :
N  *             - \ref SYS_RSTSTS_PORF_Msk
N  *             - \ref SYS_RSTSTS_PINRF_Msk
N  *             - \ref SYS_RSTSTS_WDTRF_Msk
N  *             - \ref SYS_RSTSTS_LVRF_Msk
N  *             - \ref SYS_RSTSTS_BODRF_Msk
N  *             - \ref SYS_RSTSTS_MCURF_Msk
N  *             - \ref SYS_RSTSTS_CPURF_Msk
N  *             - \ref SYS_RSTSTS_CPULKRF_Msk
N  * @return     None
N  * @details    This macro clear reset source flag.
N  */
N#define SYS_CLEAR_RST_SOURCE(u32RstSrc) ((SYS->RSTSTS) = (u32RstSrc) )
N
N
N
N
N/**
N  * @brief      Disable register write-protection function
N  * @param      None
N  * @return     None
N  * @details    This function disable register write-protection function.
N  *             To unlock the protected register to allow write access.
N  */
N__STATIC_INLINE void SYS_UnlockReg(void)
Xstatic __inline void SYS_UnlockReg(void)
N{
N    do
N    {
N        SYS->REGLCTL = 0x59;
X        ((SYS_T *) ((( uint32_t)0x50000000) + 0x00000))->REGLCTL = 0x59;
N        SYS->REGLCTL = 0x16;
X        ((SYS_T *) ((( uint32_t)0x50000000) + 0x00000))->REGLCTL = 0x16;
N        SYS->REGLCTL = 0x88;
X        ((SYS_T *) ((( uint32_t)0x50000000) + 0x00000))->REGLCTL = 0x88;
N    }
N    while(SYS->REGLCTL == 0);
X    while(((SYS_T *) ((( uint32_t)0x50000000) + 0x00000))->REGLCTL == 0);
N}
N
N/**
N  * @brief      Enable register write-protection function
N  * @param      None
N  * @return     None
N  * @details    This function is used to enable register write-protection function.
N  *             To lock the protected register to forbid write access.
N  */
N__STATIC_INLINE void SYS_LockReg(void)
Xstatic __inline void SYS_LockReg(void)
N{
N    SYS->REGLCTL = 0;
X    ((SYS_T *) ((( uint32_t)0x50000000) + 0x00000))->REGLCTL = 0;
N}
N
N
Nvoid SYS_ClearResetSrc(uint32_t u32Src);
Nuint32_t SYS_GetBODStatus(void);
Nuint32_t SYS_GetResetSrc(void);
Nuint32_t SYS_IsRegLocked(void);
Nuint32_t SYS_ReadPDID(void);
Nvoid SYS_ResetChip(void);
Nvoid SYS_ResetCPU(void);
Nvoid SYS_ResetModule(uint32_t u32ModuleIndex);
Nvoid SYS_EnableBOD(int32_t i32Mode, uint32_t u32BODLevel);
Nvoid SYS_DisableBOD(void);
N
N
N/*@}*/ /* end of group SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group SYS_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SYS_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17555 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "clk.h"
L 1 "..\lib\StdDriver\inc\clk.h" 1
N/**************************************************************************//**
N * @file     clk.h
N * @version  V3.0
N * $Revision: 12 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE series Clock Controller (CLK) driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __CLK_H__
N#define __CLK_H__
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup CLK_Driver CLK Driver
N  @{
N*/
N
N/** @addtogroup CLK_EXPORTED_CONSTANTS CLK Exported Constants
N  @{
N*/
N
N#define FREQ_25MHZ         25000000
N#define FREQ_50MHZ         50000000
N#define FREQ_72MHZ         72000000
N#define FREQ_100MHZ        100000000
N#define FREQ_200MHZ        200000000
N
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL0 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL0_HCLKSEL_HXT        (0x00UL<<CLK_CLKSEL0_HCLKSEL_Pos) /*!< Setting HCLK clock source as HXT */
N#define CLK_CLKSEL0_HCLKSEL_LXT        (0x01UL<<CLK_CLKSEL0_HCLKSEL_Pos) /*!< Setting HCLK clock source as LXT */
N#define CLK_CLKSEL0_HCLKSEL_PLL        (0x02UL<<CLK_CLKSEL0_HCLKSEL_Pos) /*!< Setting HCLK clock source as PLL */
N#define CLK_CLKSEL0_HCLKSEL_LIRC       (0x03UL<<CLK_CLKSEL0_HCLKSEL_Pos) /*!< Setting HCLK clock source as LIRC */
N#define CLK_CLKSEL0_HCLKSEL_HIRC48     (0x04UL<<CLK_CLKSEL0_HCLKSEL_Pos) /*!< Setting HCLK clock source as HIRC48 */
N#define CLK_CLKSEL0_HCLKSEL_HIRC       (0x07UL<<CLK_CLKSEL0_HCLKSEL_Pos) /*!< Setting HCLK clock source as HIRC */
N
N#define CLK_CLKSEL0_STCLKSEL_HXT       (0x00UL<<CLK_CLKSEL0_STCLKSEL_Pos) /*!< Setting SysTick clock source as HXT */
N#define CLK_CLKSEL0_STCLKSEL_LXT       (0x01UL<<CLK_CLKSEL0_STCLKSEL_Pos) /*!< Setting SysTick clock source as LXT */
N#define CLK_CLKSEL0_STCLKSEL_HXT_DIV2  (0x02UL<<CLK_CLKSEL0_STCLKSEL_Pos) /*!< Setting SysTick clock source as HXT */
N#define CLK_CLKSEL0_STCLKSEL_HCLK_DIV2 (0x03UL<<CLK_CLKSEL0_STCLKSEL_Pos) /*!< Setting SysTick clock source as HCLK/2 */
N#define CLK_CLKSEL0_STCLKSEL_HIRC_DIV2 (0x07UL<<CLK_CLKSEL0_STCLKSEL_Pos) /*!< Setting SysTick clock source as HIRC/2 */
N#define CLK_CLKSEL0_STCLKSEL_HCLK      (0x01UL<<SysTick_CTRL_CLKSOURCE_Pos) /*!< Setting SysTick clock source as HCLK */
N
N#define CLK_CLKSEL0_PCLK0SEL_HCLK      (0x00UL<<CLK_CLKSEL0_PCLK0SEL_Pos) /*!< Setting PCLK0 clock source as HCLK */
N#define CLK_CLKSEL0_PCLK0SEL_HCLK_DIV2 (0x01UL<<CLK_CLKSEL0_PCLK0SEL_Pos) /*!< Setting PCLK0 clock source as HCLK/2 */
N
N#define CLK_CLKSEL0_PCLK1SEL_HCLK      (0x00UL<<CLK_CLKSEL0_PCLK1SEL_Pos) /*!< Setting PCLK1 clock source as HCLK */
N#define CLK_CLKSEL0_PCLK1SEL_HCLK_DIV2 (0x01UL<<CLK_CLKSEL0_PCLK1SEL_Pos) /*!< Setting PCLK1 clock source as HCLK/2 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL1 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL1_WDTSEL_LXT           (0x1UL<<CLK_CLKSEL1_WDTSEL_Pos)  /*!< Setting WDT clock source as LXT */
N#define CLK_CLKSEL1_WDTSEL_HCLK_DIV2048  (0x2UL<<CLK_CLKSEL1_WDTSEL_Pos)  /*!< Setting WDT clock source as HCLK/2048 */
N#define CLK_CLKSEL1_WDTSEL_LIRC          (0x3UL<<CLK_CLKSEL1_WDTSEL_Pos)  /*!< Setting WDT clock source as LIRC */
N
N#define CLK_CLKSEL1_ADCSEL_HXT           (0x0UL<<CLK_CLKSEL1_ADCSEL_Pos)  /*!< Setting ADC clock source as HXT */
N#define CLK_CLKSEL1_ADCSEL_PLL           (0x1UL<<CLK_CLKSEL1_ADCSEL_Pos)  /*!< Setting ADC clock source as PLL */
N#define CLK_CLKSEL1_ADCSEL_PCLK0         (0x2UL<<CLK_CLKSEL1_ADCSEL_Pos)  /*!< Setting ADC clock source as PCLK0 */
N#define CLK_CLKSEL1_ADCSEL_HIRC          (0x3UL<<CLK_CLKSEL1_ADCSEL_Pos)  /*!< Setting ADC clock source as HIRC */
N
N#define CLK_CLKSEL1_TMR0SEL_HXT          (0x0UL<<CLK_CLKSEL1_TMR0SEL_Pos) /*!< Setting Timer 0 clock source as HXT */
N#define CLK_CLKSEL1_TMR0SEL_LXT          (0x1UL<<CLK_CLKSEL1_TMR0SEL_Pos) /*!< Setting Timer 0 clock source as LXT */
N#define CLK_CLKSEL1_TMR0SEL_PCLK0        (0x2UL<<CLK_CLKSEL1_TMR0SEL_Pos) /*!< Setting Timer 0 clock source as PCLK0 */
N#define CLK_CLKSEL1_TMR0SEL_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR0SEL_Pos) /*!< Setting Timer 0 clock source as external trigger */
N#define CLK_CLKSEL1_TMR0SEL_LIRC         (0x5UL<<CLK_CLKSEL1_TMR0SEL_Pos) /*!< Setting Timer 0 clock source as LIRC */
N#define CLK_CLKSEL1_TMR0SEL_HIRC         (0x7UL<<CLK_CLKSEL1_TMR0SEL_Pos) /*!< Setting Timer 0 clock source as HIRC */
N
N#define CLK_CLKSEL1_TMR1SEL_HXT          (0x0UL<<CLK_CLKSEL1_TMR1SEL_Pos) /*!< Setting Timer 1 clock source as HXT */
N#define CLK_CLKSEL1_TMR1SEL_LXT          (0x1UL<<CLK_CLKSEL1_TMR1SEL_Pos) /*!< Setting Timer 1 clock source as LXT */
N#define CLK_CLKSEL1_TMR1SEL_PCLK0        (0x2UL<<CLK_CLKSEL1_TMR1SEL_Pos) /*!< Setting Timer 1 clock source as PCLK0 */
N#define CLK_CLKSEL1_TMR1SEL_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR1SEL_Pos) /*!< Setting Timer 1 clock source as external trigger */
N#define CLK_CLKSEL1_TMR1SEL_LIRC         (0x5UL<<CLK_CLKSEL1_TMR1SEL_Pos) /*!< Setting Timer 1 clock source as LIRC */
N#define CLK_CLKSEL1_TMR1SEL_HIRC         (0x7UL<<CLK_CLKSEL1_TMR1SEL_Pos) /*!< Setting Timer 1 clock source as HIRC */
N
N#define CLK_CLKSEL1_TMR2SEL_HXT          (0x0UL<<CLK_CLKSEL1_TMR2SEL_Pos) /*!< Setting Timer 2 clock source as HXT */
N#define CLK_CLKSEL1_TMR2SEL_LXT          (0x1UL<<CLK_CLKSEL1_TMR2SEL_Pos) /*!< Setting Timer 2 clock source as LXT */
N#define CLK_CLKSEL1_TMR2SEL_PCLK1        (0x2UL<<CLK_CLKSEL1_TMR2SEL_Pos) /*!< Setting Timer 2 clock source as PCLK1 */
N#define CLK_CLKSEL1_TMR2SEL_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR2SEL_Pos) /*!< Setting Timer 2 clock source as external trigger */
N#define CLK_CLKSEL1_TMR2SEL_LIRC         (0x5UL<<CLK_CLKSEL1_TMR2SEL_Pos) /*!< Setting Timer 2 clock source as LIRC */
N#define CLK_CLKSEL1_TMR2SEL_HIRC         (0x7UL<<CLK_CLKSEL1_TMR2SEL_Pos) /*!< Setting Timer 2 clock source as HIRC */
N
N#define CLK_CLKSEL1_TMR3SEL_HXT          (0x0UL<<CLK_CLKSEL1_TMR3SEL_Pos) /*!< Setting Timer 3 clock source as HXT */
N#define CLK_CLKSEL1_TMR3SEL_LXT          (0x1UL<<CLK_CLKSEL1_TMR3SEL_Pos) /*!< Setting Timer 3 clock source as LXT */
N#define CLK_CLKSEL1_TMR3SEL_PCLK1        (0x2UL<<CLK_CLKSEL1_TMR3SEL_Pos) /*!< Setting Timer 3 clock source as PCLK1 */
N#define CLK_CLKSEL1_TMR3SEL_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR3SEL_Pos) /*!< Setting Timer 3 clock source as external trigger */
N#define CLK_CLKSEL1_TMR3SEL_LIRC         (0x5UL<<CLK_CLKSEL1_TMR3SEL_Pos) /*!< Setting Timer 3 clock source as LIRC */
N#define CLK_CLKSEL1_TMR3SEL_HIRC         (0x7UL<<CLK_CLKSEL1_TMR3SEL_Pos) /*!< Setting Timer 3 clock source as HIRC */
N
N#define CLK_CLKSEL1_UARTSEL_HXT          (0x0UL<<CLK_CLKSEL1_UARTSEL_Pos) /*!< Setting UART clock source as HXT */
N#define CLK_CLKSEL1_UARTSEL_PLL          (0x1UL<<CLK_CLKSEL1_UARTSEL_Pos) /*!< Setting UART clock source as PLL */
N#define CLK_CLKSEL1_UARTSEL_LXT          (0x2UL<<CLK_CLKSEL1_UARTSEL_Pos) /*!< Setting UART clock source as LXT */
N#define CLK_CLKSEL1_UARTSEL_HIRC         (0x3UL<<CLK_CLKSEL1_UARTSEL_Pos) /*!< Setting UART clock source as HIRC */
N
N#define CLK_CLKSEL1_PWM0SEL_PLL          (0x0UL<<CLK_CLKSEL1_PWM0SEL_Pos) /*!< Setting PWM0 clock source as PLL */
N#define CLK_CLKSEL1_PWM0SEL_PCLK0        (0x1UL<<CLK_CLKSEL1_PWM0SEL_Pos) /*!< Setting PWM0 clock source as PCLK0 */
N
N#define CLK_CLKSEL1_PWM1SEL_PLL          (0x0UL<<CLK_CLKSEL1_PWM1SEL_Pos) /*!< Setting PWM1 clock source as PLL */
N#define CLK_CLKSEL1_PWM1SEL_PCLK1        (0x1UL<<CLK_CLKSEL1_PWM1SEL_Pos) /*!< Setting PWM1 clock source as PCLK1 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL2 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL2_CLKOSEL_HXT             (0x0UL<<CLK_CLKSEL2_CLKOSEL_Pos) /*!< Setting CLKO clock source as HXT */
N#define CLK_CLKSEL2_CLKOSEL_LXT             (0x1UL<<CLK_CLKSEL2_CLKOSEL_Pos) /*!< Setting CLKO clock source as LXT */
N#define CLK_CLKSEL2_CLKOSEL_HCLK            (0x2UL<<CLK_CLKSEL2_CLKOSEL_Pos) /*!< Setting CLKO clock source as HCLK */
N#define CLK_CLKSEL2_CLKOSEL_HIRC            (0x3UL<<CLK_CLKSEL2_CLKOSEL_Pos) /*!< Setting CLKO clock source as HIRC */
N#define CLK_CLKSEL2_CLKOSEL_SOF             (0x4UL<<CLK_CLKSEL2_CLKOSEL_Pos) /*!< Setting CLKO clock source as SOF */
N#define CLK_CLKSEL2_CLKOSEL_HIRC48          (0x5UL<<CLK_CLKSEL2_CLKOSEL_Pos) /*!< Setting CLKO clock source as HIRC48 */
N
N#define CLK_CLKSEL2_WWDTSEL_HCLK_DIV2048    (0x2UL<<CLK_CLKSEL2_WWDTSEL_Pos) /*!< Setting WWDT clock source as HCLK/2048 */
N#define CLK_CLKSEL2_WWDTSEL_LIRC            (0x3UL<<CLK_CLKSEL2_WWDTSEL_Pos) /*!< Setting WWDT clock source as LIRC */
N
N#define CLK_CLKSEL2_RTCSEL_LXT              (0x0UL<<CLK_CLKSEL2_RTCSEL_Pos)  /*!< Setting RTC clock source as LXT */
N#define CLK_CLKSEL2_RTCSEL_LIRC             (0x1UL<<CLK_CLKSEL2_RTCSEL_Pos)  /*!< Setting RTC clock source as LIRC */
N
N#define CLK_CLKSEL2_SPI0SEL_HXT             (0x0UL<<CLK_CLKSEL2_SPI0SEL_Pos) /*!< Setting SPI0 clock source as HXT */
N#define CLK_CLKSEL2_SPI0SEL_PLL             (0x1UL<<CLK_CLKSEL2_SPI0SEL_Pos) /*!< Setting SPI0 clock source as PLL */
N#define CLK_CLKSEL2_SPI0SEL_PCLK0           (0x2UL<<CLK_CLKSEL2_SPI0SEL_Pos) /*!< Setting SPI0 clock source as PCLK0 */
N#define CLK_CLKSEL2_SPI0SEL_HIRC48          (0x3UL<<CLK_CLKSEL2_SPI0SEL_Pos) /*!< Setting SPI0 clock source as HIRC48 */
N
N#define CLK_CLKSEL2_SPI1SEL_HXT             (0x0UL<<CLK_CLKSEL2_SPI1SEL_Pos) /*!< Setting SPI1 clock source as HXT */
N#define CLK_CLKSEL2_SPI1SEL_PLL             (0x1UL<<CLK_CLKSEL2_SPI1SEL_Pos) /*!< Setting SPI1 clock source as PLL */
N#define CLK_CLKSEL2_SPI1SEL_PCLK0           (0x2UL<<CLK_CLKSEL2_SPI1SEL_Pos) /*!< Setting SPI1 clock source as PCLK0 */
N#define CLK_CLKSEL2_SPI1SEL_HIRC48          (0x3UL<<CLK_CLKSEL2_SPI1SEL_Pos) /*!< Setting SPI1 clock source as HIRC48 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL3 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL3_SC0SEL_HXT          (0x0UL<<CLK_CLKSEL3_SC0SEL_Pos) /*!< Setting SC0 clock source as HXT */
N#define CLK_CLKSEL3_SC0SEL_PLL          (0x1UL<<CLK_CLKSEL3_SC0SEL_Pos) /*!< Setting SC0 clock source as PLL */
N#define CLK_CLKSEL3_SC0SEL_PCLK1        (0x2UL<<CLK_CLKSEL3_SC0SEL_Pos) /*!< Setting SC0 clock source as PCLK1 */
N#define CLK_CLKSEL3_SC0SEL_HIRC         (0x3UL<<CLK_CLKSEL3_SC0SEL_Pos) /*!< Setting SC0 clock source as HIRC */
N
N#define CLK_CLKSEL3_SC1SEL_HXT          (0x0UL<<CLK_CLKSEL3_SC1SEL_Pos) /*!< Setting SC1 clock source as HXT */
N#define CLK_CLKSEL3_SC1SEL_PLL          (0x1UL<<CLK_CLKSEL3_SC1SEL_Pos) /*!< Setting SC1 clock source as PLL */
N#define CLK_CLKSEL3_SC1SEL_PCLK1        (0x2UL<<CLK_CLKSEL3_SC1SEL_Pos) /*!< Setting SC1 clock source as PCLK1 */
N#define CLK_CLKSEL3_SC1SEL_HIRC         (0x3UL<<CLK_CLKSEL3_SC1SEL_Pos) /*!< Setting SC1 clock source as HIRC */
N
N#define CLK_CLKSEL3_USBDSEL_HIRC48      (0x0UL<<CLK_CLKSEL3_USBDSEL_Pos) /*!< Setting USBD clock source as HIRC48 */
N#define CLK_CLKSEL3_USBDSEL_PLL         (0x1UL<<CLK_CLKSEL3_USBDSEL_Pos) /*!< Setting USBD clock source as PLL */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKDIV0 constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKDIV0_HCLK(x)     (((x)-1) << CLK_CLKDIV0_HCLKDIV_Pos) /*!< CLKDIV0 Setting for HCLK clock divider. It could be 1~16 */
N#define CLK_CLKDIV0_USB(x)      (((x)-1) << CLK_CLKDIV0_USBDIV_Pos)  /*!< CLKDIV0 Setting for USB clock divider. It could be 1~16 */
N#define CLK_CLKDIV0_UART(x)     (((x)-1) << CLK_CLKDIV0_UARTDIV_Pos) /*!< CLKDIV0 Setting for UART clock divider. It could be 1~16 */
N#define CLK_CLKDIV0_ADC(x)      (((x)-1) << CLK_CLKDIV0_ADCDIV_Pos)  /*!< CLKDIV0 Setting for ADC clock divider. It could be 1~256 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKDIV1 constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKDIV1_SC0(x)      (((x)-1) << CLK_CLKDIV1_SC0DIV_Pos)  /*!< CLKDIV1 Setting for SC0 clock divider. It could be 1~16 */
N#define CLK_CLKDIV1_SC1(x)      (((x)-1) << CLK_CLKDIV1_SC1DIV_Pos)  /*!< CLKDIV1 Setting for SC1 clock divider. It could be 1~16 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PLLCTL constant definitions. PLL = FIN * NF / NR / NO                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_PLLCTL_PLLSRC_HXT   0x00000000UL    /*!< For PLL clock source is HXT.  3.2MHz < FIN < 150MHz */
N#define CLK_PLLCTL_PLLSRC_HIRC  0x00080000UL    /*!< For PLL clock source is HIRC. 3.2MHz < FIN < 150MHz */
N
N#define CLK_PLLCTL_NF(x)        ((x)-2)         /*!< x must be constant and 2 <= x <= 513. 200MHz < FIN*NF/NR < 500MHz. (FIN*NF/NR > 250MHz is preferred.) */
N#define CLK_PLLCTL_NR(x)        (((x)-2)<<9)    /*!< x must be constant and 2 <= x <= 33.  1.6MHz < FIN/NR < 16MHz */
N
N#define CLK_PLLCTL_NO_1         0x0000UL        /*!< For output divider is 1 */
N#define CLK_PLLCTL_NO_2         0x4000UL        /*!< For output divider is 2 */
N#define CLK_PLLCTL_NO_4         0xC000UL        /*!< For output divider is 4 */
N
N#define CLK_PLLCTL_72MHz_HXT    (CLK_PLLCTL_PLLSRC_HXT  | CLK_PLLCTL_NR(4) | CLK_PLLCTL_NF( 48) | CLK_PLLCTL_NO_2) /*!< Predefined PLLCTL setting for 72MHz PLL output with HXT(12MHz X'tal) */
N#define CLK_PLLCTL_144MHz_HXT   (CLK_PLLCTL_PLLSRC_HXT  | CLK_PLLCTL_NR(4) | CLK_PLLCTL_NF( 48) | CLK_PLLCTL_NO_1) /*!< Predefined PLLCTL setting for 144MHz PLL output with HXT(12MHz X'tal) */
N#define CLK_PLLCTL_72MHz_HIRC   (CLK_PLLCTL_PLLSRC_HIRC | CLK_PLLCTL_NR(8) | CLK_PLLCTL_NF( 52) | CLK_PLLCTL_NO_2) /*!< Predefined PLLCTL setting for 71.8848MHz PLL output with HIRC(22.1184MHz IRC) */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  MODULE constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N/* APBCLK(31:30)|CLKSEL(29:28)|CLKSEL_Msk(27:25) |CLKSEL_Pos(24:20)|CLKDIV(19:18)|CLKDIV_Msk(17:10)|CLKDIV_Pos(9:5)|IP_EN_Pos(4:0) */
N
N#define MODULE_APBCLK(x)        (((x) >>30) & 0x3)    /*!< Calculate AHBCLK/APBCLK offset on MODULE index, 0x0:AHBCLK, 0x1:APBCLK0, 0x2:APBCLK1 */
N#define MODULE_CLKSEL(x)        (((x) >>28) & 0x3)    /*!< Calculate CLKSEL offset on MODULE index, 0x0:CLKSEL0, 0x1:CLKSEL1, 0x2:CLKSEL2, 0x3:CLKSEL3 */
N#define MODULE_CLKSEL_Msk(x)    (((x) >>25) & 0x7)    /*!< Calculate CLKSEL mask offset on MODULE index */
N#define MODULE_CLKSEL_Pos(x)    (((x) >>20) & 0x1f)   /*!< Calculate CLKSEL position offset on MODULE index */
N#define MODULE_CLKDIV(x)        (((x) >>18) & 0x3)    /*!< Calculate APBCLK CLKDIV on MODULE index, 0x0:CLKDIV, 0x1:CLKDIV1 */
N#define MODULE_CLKDIV_Msk(x)    (((x) >>10) & 0xff)   /*!< Calculate CLKDIV mask offset on MODULE index */
N#define MODULE_CLKDIV_Pos(x)    (((x) >>5 ) & 0x1f)   /*!< Calculate CLKDIV position offset on MODULE index */
N#define MODULE_IP_EN_Pos(x)     (((x) >>0 ) & 0x1f)   /*!< Calculate APBCLK offset on MODULE index */
N#define MODULE_NoMsk            0x0                   /*!< Not mask on MODULE index */
N#define NA                      MODULE_NoMsk          /*!< Not Available */
N
N#define MODULE_APBCLK_ENC(x)        (((x) & 0x03) << 30)   /*!< MODULE index, 0x0:AHBCLK, 0x1:APBCLK0, 0x2:APBCLK1 */
N#define MODULE_CLKSEL_ENC(x)        (((x) & 0x03) << 28)   /*!< CLKSEL offset on MODULE index, 0x0:CLKSEL0, 0x1:CLKSEL1, 0x2:CLKSEL2, 0x3:CLKSEL3 */
N#define MODULE_CLKSEL_Msk_ENC(x)    (((x) & 0x07) << 25)   /*!< CLKSEL mask offset on MODULE index */
N#define MODULE_CLKSEL_Pos_ENC(x)    (((x) & 0x1f) << 20)   /*!< CLKSEL position offset on MODULE index */
N#define MODULE_CLKDIV_ENC(x)        (((x) & 0x03) << 18)   /*!< APBCLK CLKDIV on MODULE index, 0x0:CLKDIV, 0x1:CLKDIV1 */
N#define MODULE_CLKDIV_Msk_ENC(x)    (((x) & 0xff) << 10)   /*!< CLKDIV mask offset on MODULE index */
N#define MODULE_CLKDIV_Pos_ENC(x)    (((x) & 0x1f) <<  5)   /*!< CLKDIV position offset on MODULE index */
N#define MODULE_IP_EN_Pos_ENC(x)     (((x) & 0x1f) <<  0)   /*!< AHBCLK/APBCLK offset on MODULE index */
N
N
N//AHBCLK
N#define PDMA_MODULE    (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_PDMACKEN_Pos)|\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PDMA Module */
X#define PDMA_MODULE    (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_PDMACKEN_Pos)|                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define ISP_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_ISPCKEN_Pos)|\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< ISP Module */
X#define ISP_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_ISPCKEN_Pos)|                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define EBI_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_EBICKEN_Pos)|\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< EBI Module */
X#define EBI_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_EBICKEN_Pos)|                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define HDIV_MODULE    (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_HDIVCKEN_Pos)|\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< HDIV Module */
X#define HDIV_MODULE    (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_HDIVCKEN_Pos)|                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define CRC_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_CRCCKEN_Pos)|\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< CRC Module */
X#define CRC_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_CRCCKEN_Pos)|                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define GPIOA_MODULE   (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_GPIOACKEN_Pos)|\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< GPIOA Module */
X#define GPIOA_MODULE   (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_GPIOACKEN_Pos)|                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define GPIOB_MODULE   (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_GPIOBCKEN_Pos)|\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< GPIOB Module */
X#define GPIOB_MODULE   (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_GPIOBCKEN_Pos)|                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define GPIOC_MODULE   (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_GPIOCCKEN_Pos)|\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< GPIOC Module */
X#define GPIOC_MODULE   (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_GPIOCCKEN_Pos)|                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define GPIOD_MODULE   (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_GPIODCKEN_Pos)|\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< GPIOD Module */
X#define GPIOD_MODULE   (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_GPIODCKEN_Pos)|                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define GPIOE_MODULE   (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_GPIOECKEN_Pos)|\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< GPIOE Module */
X#define GPIOE_MODULE   (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_GPIOECKEN_Pos)|                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define GPIOF_MODULE   (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_GPIOFCKEN_Pos)|\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< GPIOF Module */
X#define GPIOF_MODULE   (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_GPIOFCKEN_Pos)|                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N//APBCLK0
N#define WDT_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_WDTCKEN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< WDT Module */
X#define WDT_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_WDTCKEN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define WWDT_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_WDTCKEN_Pos)|\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(16)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< WWDT Module */
X#define WWDT_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_WDTCKEN_Pos)|                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(16)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define RTC_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_RTCCKEN_Pos)|\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC(18)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< RTC Module */
X#define RTC_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_RTCCKEN_Pos)|                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC(18)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define TMR0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_TMR0CKEN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC( 8)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR0 Module */
X#define TMR0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_TMR0CKEN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC( 8)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define TMR1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_TMR1CKEN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(12)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR1 Module */
X#define TMR1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_TMR1CKEN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(12)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define TMR2_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_TMR2CKEN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(16)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR2 Module */
X#define TMR2_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_TMR2CKEN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(16)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define TMR3_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_TMR3CKEN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(20)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR3 Module */
X#define TMR3_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_TMR3CKEN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(20)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define CLKO_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_CLKOCKEN_Pos) |\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(2)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< CLKO Module */
X#define CLKO_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_CLKOCKEN_Pos) |                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(2)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define I2C0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_I2C0CKEN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< I2C0 Module */
X#define I2C0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_I2C0CKEN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define I2C1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_I2C1CKEN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< I2C1 Module */
X#define I2C1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_I2C1CKEN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define SPI0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_SPI0CKEN_Pos) |\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< SPI0 Module */
X#define SPI0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_SPI0CKEN_Pos) |                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define SPI1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_SPI1CKEN_Pos) |\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(26)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< SPI1 Module */
X#define SPI1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_SPI1CKEN_Pos) |                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(26)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define UART0_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_UART0CKEN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< UART0 Module */
X#define UART0_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_UART0CKEN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))     
N
N#define UART1_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_UART1CKEN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< UART1 Module */
X#define UART1_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_UART1CKEN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))     
N
N#define UART2_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_UART2CKEN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< UART2 Module */
X#define UART2_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_UART2CKEN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))     
N
N#define PWM0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_PWM0CKEN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC(28)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PWM0 Module */
X#define PWM0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_PWM0CKEN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC(28)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define PWM1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_PWM1CKEN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC(29)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PWM1 Module */
X#define PWM1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_PWM1CKEN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC(29)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define USBD_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_USBDCKEN_Pos)|\
N                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 8)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC(4))     /*!< USBD Module */
X#define USBD_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_USBDCKEN_Pos)|                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 8)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC(4))      
N
N#define ADC_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_ADCCKEN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(2)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC(16))    /*!< ADC Module */
X#define ADC_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_ADCCKEN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(2)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC(16))     
N
N#define ACMP01_MODULE  (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_ACMP01CKEN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< ACMP01 Module */
X#define ACMP01_MODULE  (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_ACMP01CKEN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N//APBCLK1
N#define SC0_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_SC0CKEN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|\
N                        MODULE_CLKDIV_ENC( 1)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC( 0))    /*!< SC0 Module */
X#define SC0_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_SC0CKEN_Pos)  |                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|                        MODULE_CLKDIV_ENC( 1)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC( 0))     
N
N#define SC1_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_SC1CKEN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 2)|\
N                        MODULE_CLKDIV_ENC( 1)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< SC1 Module */
X#define SC1_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_SC1CKEN_Pos)  |                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 2)|                        MODULE_CLKDIV_ENC( 1)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC( 8))     
N
N#define USCI0_MODULE   (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_USCI0CKEN_Pos)|\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< USCI0 Module */
X#define USCI0_MODULE   (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_USCI0CKEN_Pos)|                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define USCI1_MODULE   (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_USCI1CKEN_Pos)|\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< USCI1 Module */
X#define USCI1_MODULE   (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_USCI1CKEN_Pos)|                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define USCI2_MODULE   (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_USCI2CKEN_Pos)|\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< USCI2 Module */
X#define USCI2_MODULE   (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_USCI2CKEN_Pos)|                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N/*@}*/ /* end of group CLK_EXPORTED_CONSTANTS */
N
N/** @addtogroup CLK_EXPORTED_FUNCTIONS CLK Exported Functions
N  @{
N*/
N
N
N/**
N  * @brief      Get PLL clock frequency
N  * @param      None
N  * @return     PLL frequency
N  * @details    This function get PLL frequency. The frequency unit is Hz.
N  */
N__STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
Xstatic __inline uint32_t CLK_GetPLLClockFreq(void)
N{
N    uint32_t u32PllFreq = 0, u32PllReg;
N    uint32_t u32FIN, u32NF, u32NR, u32NO;
N    uint8_t au8NoTbl[4] = {1, 2, 2, 4};
N
N    u32PllReg = CLK->PLLCTL;
X    u32PllReg = ((CLK_T *) ((( uint32_t)0x50000000) + 0x00200))->PLLCTL;
N
N    if(u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
X    if(u32PllReg & ((0x1ul << (16)) | (0x1ul << (18))))
N        return 0;           /* PLL is in power down mode or fix low */
N
N    if(u32PllReg & CLK_PLLCTL_PLLSRC_HIRC)
X    if(u32PllReg & 0x00080000UL)
N        u32FIN = __HIRC;    /* PLL source clock from HIRC */
X        u32FIN = (22118400UL);     
N    else
N        u32FIN = __HXT;     /* PLL source clock from HXT */
X        u32FIN = (12000000UL);      
N
N    if(u32PllReg & CLK_PLLCTL_BP_Msk)
X    if(u32PllReg & (0x1ul << (17)))
N        return u32FIN;      /* PLL is in bypass mode */
N
N    /* PLL is output enabled in normal work mode */
N    u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
X    u32NO = au8NoTbl[((u32PllReg & (0x3ul << (14))) >> (14))];
N    u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
X    u32NF = ((u32PllReg & (0x1fful << (0))) >> (0)) + 2;
N    u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
X    u32NR = ((u32PllReg & (0x1ful << (9))) >> (9)) + 2;
N
N    /* u32FIN is shifted 2 bits to avoid overflow */
N    u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
N
N    return u32PllFreq;
N}
N
N/**
N  * @brief      This function execute delay function.
N  * @param[in]  us  Delay time. The Max value is 2^24 / CPU Clock(MHz). Ex:
N  *                             72MHz => 233016us, 50MHz => 335544us,
N                                48MHz => 349525us, 28MHz => 699050us ...
N  * @return     None
N  * @details    Use the SysTick to generate the delay time and the UNIT is in us.
N  *             The SysTick clock source is from HCLK, i.e the same as system core clock.
N  *             User can use SystemCoreClockUpdate() to calculate CyclesPerUs automatically before using this function.
N  */
N__STATIC_INLINE void CLK_SysTickDelay(uint32_t us)
Xstatic __inline void CLK_SysTickDelay(uint32_t us)
N{
N    SysTick->LOAD = us * CyclesPerUs;
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD = us * CyclesPerUs;
N    SysTick->VAL  = (0x00);
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL  = (0x00);
N    SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2U) | (1UL );
N
N    /* Waiting for down-count to zero */
N    while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0);
X    while((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL & (1UL << 16U)) == 0);
N
N    /* Disable SysTick counter */
N    SysTick->CTRL = 0;
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = 0;
N}
N
N/**
N  * @brief      This function execute long delay function.
N  * @param[in]  us  Delay time.
N  * @return     None
N  * @details    Use the SysTick to generate the long delay time and the UNIT is in us.
N  *             The SysTick clock source is from HCLK, i.e the same as system core clock.
N  *             User can use SystemCoreClockUpdate() to calculate CyclesPerUs automatically before using this function.
N  */
N__STATIC_INLINE void CLK_SysTickLongDelay(uint32_t us)
Xstatic __inline void CLK_SysTickLongDelay(uint32_t us)
N{
N    uint32_t delay;
N
N    /* It should <= 233016us for each delay loop */
N    delay = 233016UL;
N
N    do
N    {
N        if(us > delay)
N        {
N            us -= delay;
N        }
N        else
N        {
N            delay = us;
N            us = 0UL;
N        }
N
N        SysTick->LOAD = delay * CyclesPerUs;
X        ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD = delay * CyclesPerUs;
N        SysTick->VAL  = (0x0UL);
X        ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL  = (0x0UL);
N        SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
X        ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2U) | (1UL );
N
N        /* Waiting for down-count to zero */
N        while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0UL);
X        while((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL & (1UL << 16U)) == 0UL);
N
N        /* Disable SysTick counter */
N        SysTick->CTRL = 0UL;
X        ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = 0UL;
N
N    }
N    while(us > 0UL);
N
N}
N
N
Nvoid CLK_DisableCKO(void);
Nvoid CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En);
Nvoid CLK_PowerDown(void);
Nvoid CLK_Idle(void);
Nuint32_t CLK_GetHXTFreq(void);
Nuint32_t CLK_GetLXTFreq(void);
Nuint32_t CLK_GetHCLKFreq(void);
Nuint32_t CLK_GetPCLK0Freq(void);
Nuint32_t CLK_GetPCLK1Freq(void);
Nuint32_t CLK_GetCPUFreq(void);
Nuint32_t CLK_SetCoreClock(uint32_t u32Hclk);
Nvoid CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetSysTickClockSrc(uint32_t u32ClkSrc);
Nvoid CLK_EnableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_DisableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_EnableModuleClock(uint32_t u32ModuleIdx);
Nvoid CLK_DisableModuleClock(uint32_t u32ModuleIdx);
Nuint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq);
Nvoid CLK_DisablePLL(void);
Nuint32_t CLK_WaitClockReady(uint32_t u32ClkMask);
Nvoid CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count);
Nvoid CLK_DisableSysTick(void);
N
N
N
N
N/*@}*/ /* end of group CLK_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group CLK_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif //__CLK_H__
N
N
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17556 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "adc.h"
L 1 "..\lib\StdDriver\inc\adc.h" 1
N/**************************************************************************//**
N * @file     adc.h
N * @brief    NUC029xGE series ADC driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __ADC_H__
N#define __ADC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup ADC_Driver ADC Driver
N  @{
N*/
N
N/** @addtogroup ADC_EXPORTED_CONSTANTS ADC Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ADCR Constant Definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCR_ADEN_CONVERTER_DISABLE   (0UL<<ADC_ADCR_ADEN_Pos)   /*!< ADC converter disable          */
N#define ADC_ADCR_ADEN_CONVERTER_ENABLE    (1UL<<ADC_ADCR_ADEN_Pos)   /*!< ADC converter enable           */
N
N#define ADC_ADCR_ADMD_SINGLE            (0UL<<ADC_ADCR_ADMD_Pos)     /*!< Single mode                */
N#define ADC_ADCR_ADMD_BURST             (1UL<<ADC_ADCR_ADMD_Pos)     /*!< Burst mode                 */
N#define ADC_ADCR_ADMD_SINGLE_CYCLE      (2UL<<ADC_ADCR_ADMD_Pos)     /*!< Single cycle scan mode     */
N#define ADC_ADCR_ADMD_CONTINUOUS        (3UL<<ADC_ADCR_ADMD_Pos)     /*!< Continuous scan mode       */
N
N#define ADC_ADCR_DIFFEN_SINGLE_END      (0UL<<ADC_ADCR_DIFFEN_Pos)   /*!< Single end input mode      */
N#define ADC_ADCR_DIFFEN_DIFFERENTIAL    (1UL<<ADC_ADCR_DIFFEN_Pos)   /*!< Differential input type    */
N
N#define ADC_ADCR_DMOF_UNSIGNED_OUTPUT   (0UL<<ADC_ADCR_DMOF_Pos)     /*!< Select the straight binary format as the output format of the conversion result   */
N#define ADC_ADCR_DMOF_TWOS_COMPLEMENT   (1UL<<ADC_ADCR_DMOF_Pos)     /*!< Select the 2's complement format as the output format of the conversion result    */
N
N#define ADC_ADCR_TRGEN_DISABLE          (0UL<<ADC_ADCR_TRGEN_Pos)    /*!< Disable triggering of A/D conversion by external STADC pin or PWM   */
N#define ADC_ADCR_TRGEN_ENABLE           (1UL<<ADC_ADCR_TRGEN_Pos)    /*!< Enable triggering of A/D conversion by external STADC pin or PWM  */
N
N#define ADC_ADCR_TRGS_STADC             (0UL<<ADC_ADCR_TRGS_Pos)     /*!< A/D conversion is started by external STADC pin */
N#define ADC_ADCR_TRGS_TIMER             (1UL<<ADC_ADCR_TRGS_Pos)     /*!< A/D conversion is started by Timer */
N#define ADC_ADCR_TRGS_PWM               (3UL<<ADC_ADCR_TRGS_Pos)     /*!< A/D conversion is started by PWM */
N
N#define ADC_ADCR_TRGCOND_LOW_LEVEL      (0UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Low level active     */
N#define ADC_ADCR_TRGCOND_HIGH_LEVEL     (1UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC High level active    */
N#define ADC_ADCR_TRGCOND_FALLING_EDGE   (2UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Falling edge active  */
N#define ADC_ADCR_TRGCOND_RISING_EDGE    (3UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Rising edge active   */
N
N#define ADC_ADCR_SMPTSEL_1_CLOCK        (0UL<<ADC_ADCR_SMPTSEL_Pos)  /*!< A/D conversion sampling time is 1 ADC peripheral clock cycle */
N#define ADC_ADCR_SMPTSEL_2_CLOCK        (1UL<<ADC_ADCR_SMPTSEL_Pos)  /*!< A/D conversion sampling time is 2 ADC peripheral clock cycles */
N#define ADC_ADCR_SMPTSEL_3_CLOCK        (2UL<<ADC_ADCR_SMPTSEL_Pos)  /*!< A/D conversion sampling time is 3 ADC peripheral clock cycles */
N#define ADC_ADCR_SMPTSEL_4_CLOCK        (3UL<<ADC_ADCR_SMPTSEL_Pos)  /*!< A/D conversion sampling time is 4 ADC peripheral clock cycles */
N#define ADC_ADCR_SMPTSEL_5_CLOCK        (4UL<<ADC_ADCR_SMPTSEL_Pos)  /*!< A/D conversion sampling time is 5 ADC peripheral clock cycles */
N#define ADC_ADCR_SMPTSEL_6_CLOCK        (5UL<<ADC_ADCR_SMPTSEL_Pos)  /*!< A/D conversion sampling time is 6 ADC peripheral clock cycles */
N#define ADC_ADCR_SMPTSEL_7_CLOCK        (6UL<<ADC_ADCR_SMPTSEL_Pos)  /*!< A/D conversion sampling time is 7 ADC peripheral clock cycles */
N#define ADC_ADCR_SMPTSEL_8_CLOCK        (7UL<<ADC_ADCR_SMPTSEL_Pos)  /*!< A/D conversion sampling time is 8 ADC peripheral clock cycles */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADCMPR Constant Definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCMPR_CMPD(x)                    ((x) << ADC_ADCMPR_CMPD_Pos)          /*!< Compare value for compare function            */
N#define ADC_ADCMPR_CMPMATCNT(x)               (((x)-1) << ADC_ADCMPR_CMPMATCNT_Pos) /*!< Match count for compare function              */
N#define ADC_ADCMPR_CMPCH(x)                   ((x) << ADC_ADCMPR_CMPCH_Pos)         /*!< Compare channel for compare function          */
N#define ADC_ADCMPR_CMPCOND_LESS_THAN          (0<<ADC_ADCMPR_CMPCOND_Pos)           /*!< The compare condition is "less than"          */
N#define ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL   (1<<ADC_ADCMPR_CMPCOND_Pos)           /*!< The compare condition is "greater than or equal to" */
N#define ADC_ADCMPR_CMPIE_INTERRUPT_ENABLE     (ADC_ADCMPR_CMPIE_Msk)                /*!< The compare function interrupt enable */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Interrupt Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADF_INT         (ADC_ADSR0_ADF_Msk)          /*!< ADC convert complete interrupt */
N#define ADC_CMP0_INT        (ADC_ADSR0_CMPF0_Msk)        /*!< ADC comparator 0 interrupt */
N#define ADC_CMP1_INT        (ADC_ADSR0_CMPF1_Msk)        /*!< ADC comparator 1 interrupt */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Operation Mode Constant Definitions                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_SINGLE_MODE         0   /*!< ADC single mode            */
N#define ADC_BURST_MODE          1   /*!< ADC burst mode             */
N#define ADC_SINGLE_CYCLE_MODE   2   /*!< ADC single-cycle scan mode */
N#define ADC_CONTINUOUS_MODE     3   /*!< ADC continuous scan mode   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Trigger Condition Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_LOW_LEVEL      0   /*!< ADC external trigger condition is low level trigger    */
N#define ADC_HIGH_LEVEL     1   /*!< ADC external trigger condition is high level trigger   */
N#define ADC_FALLING_EDGE   2   /*!< ADC external trigger condition is falling edge trigger */
N#define ADC_RISING_EDGE    3   /*!< ADC external trigger condition is rising edge trigger  */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Compare Condition Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_LESS_THAN          0   /*!< ADC compare condition is "less than the compare value"                */
N#define ADC_GREATER_OR_EQUAL   1   /*!< ADC compare condition is "greater than or equal to the compare value" */
N
N
N
N/*@}*/ /* end of group ADC_EXPORTED_CONSTANTS */
N
N/** @addtogroup ADC_EXPORTED_FUNCTIONS ADC Exported Functions
N  @{
N*/
N
N
N/**
N  * @brief Get conversion data of specified channel.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum ADC Channel, valid value are from 0 to 19 and 29 to 31.
N  * @return  16-bit data.
N  * @details Read RSLT bit field to get conversion data.
N  */
N#define ADC_GET_CONVERSION_DATA(adc, u32ChNum) ((adc)->ADDR[(u32ChNum)] & ADC_ADDR_RSLT_Msk)
N
N/**
N  * @brief Return the user-specified interrupt flags.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Mask The combination of following interrupt status bits. Each bit corresponds to a interrupt status.
N  *                    Valid values are:
N  *                     - \ref ADC_ADF_INT          :Convert complete interrupt flag.
N  *                     - \ref ADC_CMP0_INT         :Comparator 0 interrupt flag.
N  *                     - \ref ADC_CMP1_INT         :Comparator 1 interrupt flag.
N  * @return  User specified interrupt flags.
N  * @details Get the status of the ADC interrupt flag.
N  */
N#define ADC_GET_INT_FLAG(adc, u32Mask) ((adc)->ADSR0 & (u32Mask))
N
N/**
N  * @brief This macro clear the selected interrupt status bits.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Mask The combination of following interrupt status bits. Each bit corresponds to a interrupt status.
N  *                    Valid values are:
N  *                     - \ref ADC_ADF_INT          :Convert complete interrupt flag.
N  *                     - \ref ADC_CMP0_INT         :Comparator 0 interrupt flag.
N  *                     - \ref ADC_CMP1_INT         :Comparator 1 interrupt flag.
N  * @return  None
N  * @details ADF (ADSR[0])/CMPF0 (ADSR[1])/CMPF2 (ADSR[2]) can be cleared by writing 1 to itself.
N  */
N#define ADC_CLR_INT_FLAG(adc, u32Mask) ((adc)->ADSR0 = (u32Mask))
N
N/**
N  * @brief Get the busy state of ADC.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @retval 0 ADC is not busy.
N  * @retval 1 ADC is busy.
N  * @details ADSR0[7] (BUSY) is a mirror of ADCR[11] (ADST).
N  */
N#define ADC_IS_BUSY(adc) ((adc)->ADSR0 & ADC_ADSR0_BUSY_Msk ? 1 : 0)
N
N/**
N  * @brief Check if the ADC conversion data is over written or not.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum ADC Channel, valid value are from 0 to 19 and 29 to 31.
N  * @retval 0 ADC data is not overrun.
N  * @retval 1 ADC data is overrun.
N  * @details ADSR2[31:0] (OVERRUN) is the mirror of ADDR0~31[16] OVERRUN bits.
N  */
N#define ADC_IS_DATA_OVERRUN(adc, u32ChNum) (((adc)->ADSR2 & (1<<(u32ChNum))) ? 1 : 0)
N
N/**
N  * @brief Check if the ADC conversion data is valid or not.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum ADC Channel, valid value are from 0 to 7 and 29 to 31.
N  * @retval 0 ADC data is not valid.
N  * @retval 1 ADC data is valid.
N  * @details VALID (ADDR0~31[17]) is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.
N  */
N#define ADC_IS_DATA_VALID(adc, u32ChNum) ((adc)->ADSR1 & (0x1<<(u32ChNum)) ? 1 : 0)
N
N/**
N  * @brief Power down ADC module.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Disable A/D converter analog circuit for saving power consumption.
N  */
N#define ADC_POWER_DOWN(adc) ((adc)->ADCR &= ~ADC_ADCR_ADEN_Msk)
N
N/**
N  * @brief Power on ADC module.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Before starting A/D conversion function, ADEN bit (ADCR[0]) should be set to 1.
N  */
N#define ADC_POWER_ON(adc) ((adc)->ADCR |= ADC_ADCR_ADEN_Msk)
N
N/**
N  * @brief Configure the comparator 0 and enable it.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum  Specifies the source channel, valid value are from 0 to 7 and 29 to 31.
N  * @param[in] u32Condition Specifies the compare condition. Valid values are:
N  *                          - \ref ADC_ADCMPR_CMPCOND_LESS_THAN            :The compare condition is "less than the compare value".
N  *                          - \ref ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL     :The compare condition is "greater than or equal to the compare value".
N  * @param[in] u32Data Specifies the compare value, valid value are between 0 ~ 0xFFF.
N  * @param[in] u32MatchCount Specifies the match count setting, valid values are between 1~16.
N  * @return None
N  * @details For example, ADC_ENABLE_CMP0(ADC, 5, ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL, 0x800, 10);
N  *          Means ADC will assert comparator 0 flag if channel 5 conversion result is greater than or
N  *          equal to 0x800 for 10 times continuously.
N  */
N#define ADC_ENABLE_CMP0(adc, \
N                        u32ChNum, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) ((adc)->ADCMPR[0] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) | \
N                                                           (u32Condition) | \
N                                                           ((u32Data) << ADC_ADCMPR_CMPD_Pos) | \
N                                                           (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |\
N                                                           ADC_ADCMPR_CMPEN_Msk)
X#define ADC_ENABLE_CMP0(adc,                         u32ChNum,                         u32Condition,                         u32Data,                         u32MatchCount) ((adc)->ADCMPR[0] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) |                                                            (u32Condition) |                                                            ((u32Data) << ADC_ADCMPR_CMPD_Pos) |                                                            (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |                                                           ADC_ADCMPR_CMPEN_Msk)
N
N/**
N  * @brief Disable comparator 0
N  * @param[in] adc The pointer of the specified ADC module
N  * @return None
N  * @details Set CMPEN (ADCMPR0[0]) to 0 and reset comparator 0 configurations to disable ADC compare function.
N  */
N#define ADC_DISABLE_CMP0(adc) ((adc)->ADCMPR[0] = 0)
N
N/**
N  * @brief Configure the comparator 1 and enable it.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum  Specifies the source channel, valid value are from 0 to 7 and 29 to 31.
N  * @param[in] u32Condition Specifies the compare condition. Valid values are:
N  *                          - \ref ADC_ADCMPR_CMPCOND_LESS_THAN            :The compare condition is "less than the compare value".
N  *                          - \ref ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL     :The compare condition is "greater than or equal to the compare value".
N  * @param[in] u32Data Specifies the compare value, valid value are between 0 ~ 0xFFF.
N  * @param[in] u32MatchCount Specifies the match count setting, valid values are between 1~16.
N  * @return None
N  * @details For example, ADC_ENABLE_CMP1(ADC, 5, ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL, 0x800, 10);
N  *          Means ADC will assert comparator 1 flag if channel 5 conversion result is greater than or
N  *          equal to 0x800 for 10 times continuously.
N  */
N#define ADC_ENABLE_CMP1(adc, \
N                        u32ChNum, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) ((adc)->ADCMPR[1] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) | \
N                                                           (u32Condition) | \
N                                                           ((u32Data) << ADC_ADCMPR_CMPD_Pos) | \
N                                                           (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |\
N                                                           ADC_ADCMPR_CMPEN_Msk)
X#define ADC_ENABLE_CMP1(adc,                         u32ChNum,                         u32Condition,                         u32Data,                         u32MatchCount) ((adc)->ADCMPR[1] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) |                                                            (u32Condition) |                                                            ((u32Data) << ADC_ADCMPR_CMPD_Pos) |                                                            (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |                                                           ADC_ADCMPR_CMPEN_Msk)
N
N/**
N  * @brief Disable comparator 1.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Set CMPEN (ADCMPR1[0]) to 0 and reset comparator 1 configurations to disable ADC compare function.
N  */
N#define ADC_DISABLE_CMP1(adc) ((adc)->ADCMPR[1] = 0)
N
N/**
N  * @brief Set ADC input channel.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Mask  Channel enable bit. Each bit corresponds to a input channel. Bit 0 is channel 0, bit 1 is channel 1..., bit 7 is channel 7.
N  * @return None
N  * @details Enabled channel will be converted while ADC starts.
N  * @note In single mode, ADC can only convert 1 channel. If more than 1 channel are enabled, only the channel with smallest number will be converted.
N  */
N#define ADC_SET_INPUT_CHANNEL(adc, u32Mask) ((adc)->ADCHER = ((adc)->ADCHER & ~ADC_ADCHER_CHEN_Msk) | (u32Mask))
N
N/**
N  * @brief Set the output format mode.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Format Decides the output format. Valid values are:
N  *                      - \ref ADC_ADCR_DMOF_UNSIGNED_OUTPUT      : Select the straight binary format as the output format of the conversion result.
N  *                      - \ref ADC_ADCR_DMOF_TWOS_COMPLEMENT      : Select the 2's complement format as the output format of the conversion result.
N  * @return None
N  * @details  The macro is used to set the output format of ADC differential input mode.
N  * @note ADC compare function can not support 2's complement output format, u32Format should be set to 0.
N  */
N#define ADC_SET_DMOF(adc, u32Format) ((adc)->ADCR = ((adc)->ADCR & ~ADC_ADCR_DMOF_Msk) | (u32Format))
N
N/**
N  * @brief Start the A/D conversion.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Set ADST bit to 1 to start the A/D conversion.
N  */
N#define ADC_START_CONV(adc) ((adc)->ADCR |= ADC_ADCR_ADST_Msk)
N
N/**
N  * @brief Stop the A/D conversion.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details ADST (ADCR[11]) will be cleared to 0 by hardware automatically at the ends of single mode and single-cycle scan mode.
N  *          In continuous scan mode and burst mode, A/D conversion is continuously performed until software writes 0 to this bit.
N  * @note When the ADST bit is cleared to 0, the ADST bit must be kept at 0 at least one ADC peripheral clock period
N  *       before setting it to 1 again, otherwise the A/D converter may not work.
N  *       If ADST bit is cleared to 0 when ADC is in converting, the BUSY bit will be cleared to 0 immediately,
N  *       ADC will terminate the current conversion and enter idle state directly.
N  */
N#define ADC_STOP_CONV(adc) ((adc)->ADCR &= ~ADC_ADCR_ADST_Msk)
N
N/**
N  * @brief Enable PDMA transfer.
N  * @param[in] adc The pointer of the specified ADC module
N  * @return None
N  * @details Enable PDMA to transfer the conversion data.
N  * @note While enable PDMA transfer, software must set ADIE = 0 to disable interrupt.
N  */
N#define ADC_ENABLE_PDMA(adc) (ADC->ADCR |= ADC_ADCR_PTEN_Msk)
N
N/**
N  * @brief Disable PDMA transfer.
N  * @param[in] adc The pointer of the specified ADC module
N  * @return None
N  * @details Disable PDMA to transfer the conversion data.
N  */
N#define ADC_DISABLE_PDMA(adc) (ADC->ADCR &= ~ADC_ADCR_PTEN_Msk)
N
N/**
N  * @brief Get PDMA current transfer data
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return  PDMA current transfer data
N  * \hideinitializer
N  */
N#define ADC_GET_PDMA_DATA(adc) (ADC->ADPDMA & ADC_ADPDMA_CURDAT_Msk)
N
N
Nvoid ADC_Open(ADC_T *adc,
N              uint32_t u32InputMode,
N              uint32_t u32OpMode,
N              uint32_t u32ChMask);
Nvoid ADC_Close(ADC_T *adc);
Nvoid ADC_EnableHWTrigger(ADC_T *adc,
N                         uint32_t u32Source,
N                         uint32_t u32Param);
Nvoid ADC_DisableHWTrigger(ADC_T *adc);
Nvoid ADC_EnableInt(ADC_T *adc, uint32_t u32Mask);
Nvoid ADC_DisableInt(ADC_T *adc, uint32_t u32Mask);
N
N
N
N/*@}*/ /* end of group ADC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ADC_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__ADC_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17557 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "ebi.h"
L 1 "..\lib\StdDriver\inc\ebi.h" 1
N/**************************************************************************//**
N * @file     ebi.h
N * @version  V3.00
N * $Revision: 5 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE series External Bus Interface(EBI) driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __EBI_H__
N#define __EBI_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup EBI_Driver EBI Driver
N  @{
N*/
N
N/** @addtogroup EBI_EXPORTED_CONSTANTS EBI Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Miscellaneous Constant Definitions                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_BANK0_BASE_ADDR     0x60000000UL /*!< EBI bank0 base address */
N#define EBI_BANK1_BASE_ADDR     0x60100000UL /*!< EBI bank1 base address */
N#define EBI_MAX_SIZE            0x00100000UL /*!< Maximum EBI size for each bank is 1 MB */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Constants for EBI bank number                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_BANK0               0   /*!< EBI bank 0 */
N#define EBI_BANK1               1   /*!< EBI bank 1 */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Constants for EBI data bus width                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_BUSWIDTH_8BIT       8   /*!< EBI bus width is 8-bit */
N#define EBI_BUSWIDTH_16BIT      16  /*!< EBI bus width is 16-bit */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Constants for EBI CS Active Level                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_CS_ACTIVE_LOW       0   /*!< EBI CS active level is low */
N#define EBI_CS_ACTIVE_HIGH      1   /*!< EBI CS active level is high */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Constants for EBI MCLK divider and Timing                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_MCLKDIV_1           0x0UL /*!< EBI output clock(MCLK) is HCLK/1 */
N#define EBI_MCLKDIV_2           0x1UL /*!< EBI output clock(MCLK) is HCLK/2 */
N#define EBI_MCLKDIV_4           0x2UL /*!< EBI output clock(MCLK) is HCLK/4 */
N#define EBI_MCLKDIV_8           0x3UL /*!< EBI output clock(MCLK) is HCLK/8 */
N#define EBI_MCLKDIV_16          0x4UL /*!< EBI output clock(MCLK) is HCLK/16 */
N#define EBI_MCLKDIV_32          0x5UL /*!< EBI output clock(MCLK) is HCLK/32 */
N
N#define EBI_TIMING_FASTEST      0x0UL /*!< EBI timing is the fastest */
N#define EBI_TIMING_VERYFAST     0x1UL /*!< EBI timing is very fast */
N#define EBI_TIMING_FAST         0x2UL /*!< EBI timing is fast */
N#define EBI_TIMING_NORMAL       0x3UL /*!< EBI timing is normal  */
N#define EBI_TIMING_SLOW         0x4UL /*!< EBI timing is slow */
N#define EBI_TIMING_VERYSLOW     0x5UL /*!< EBI timing is very slow */
N#define EBI_TIMING_SLOWEST      0x6UL /*!< EBI timing is the slowest */
N
N#define EBI_OPMODE_NORMAL       0x0UL                 /*!< EBI bus operate in normal mode */
N#define EBI_OPMODE_CACCESS      (EBI_CTL_CACCESS_Msk) /*!< EBI bus operate in Continuous Data Access mode */
N
N/*@}*/ /* end of group EBI_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup EBI_EXPORTED_FUNCTIONS EBI Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Read 8-bit data on EBI bank0
N  *
N  * @param[in]  u32Addr     The data address on EBI bank0.
N  *
N  * @return     8-bit Data
N  *
N  * @details    This macro is used to read 8-bit data from specify address on EBI bank0.
N  */
N#define EBI0_READ_DATA8(u32Addr)            (*((volatile unsigned char *)(EBI_BANK0_BASE_ADDR+(u32Addr))))
N
N/**
N  * @brief      Write 8-bit data to EBI bank0
N  *
N  * @param[in]  u32Addr     The data address on EBI bank0.
N  * @param[in]  u32Data     Specify data to be written.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to write 8-bit data to specify address on EBI bank0.
N  */
N#define EBI0_WRITE_DATA8(u32Addr, u32Data)  (*((volatile unsigned char *)(EBI_BANK0_BASE_ADDR+(u32Addr))) = (u32Data))
N
N/**
N  * @brief      Read 16-bit data on EBI bank0
N  *
N  * @param[in]  u32Addr     The data address on EBI bank0.
N  *
N  * @return     16-bit Data
N  *
N  * @details    This macro is used to read 16-bit data from specify address on EBI bank0.
N  */
N#define EBI0_READ_DATA16(u32Addr)           (*((volatile unsigned short *)(EBI_BANK0_BASE_ADDR+(u32Addr))))
N
N/**
N  * @brief      Write 16-bit data to EBI bank0
N  *
N  * @param[in]  u32Addr     The data address on EBI bank0.
N  * @param[in]  u32Data     Specify data to be written.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to write 16-bit data to specify address on EBI bank0.
N  */
N#define EBI0_WRITE_DATA16(u32Addr, u32Data) (*((volatile unsigned short *)(EBI_BANK0_BASE_ADDR+(u32Addr))) = (u32Data))
N
N/**
N  * @brief      Read 32-bit data on EBI bank0
N  *
N  * @param[in]  u32Addr     The data address on EBI bank0.
N  *
N  * @return     32-bit Data
N  *
N  * @details    This macro is used to read 32-bit data from specify address on EBI bank0.
N  */
N#define EBI0_READ_DATA32(u32Addr)           (*((volatile unsigned int *)(EBI_BANK0_BASE_ADDR+(u32Addr))))
N
N/**
N  * @brief      Write 32-bit data to EBI bank0
N  *
N  * @param[in]  u32Addr     The data address on EBI bank0.
N  * @param[in]  u32Data     Specify data to be written.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to write 32-bit data to specify address on EBI bank0.
N  */
N#define EBI0_WRITE_DATA32(u32Addr, u32Data) (*((volatile unsigned int *)(EBI_BANK0_BASE_ADDR+(u32Addr))) = (u32Data))
N
N/**
N  * @brief      Read 8-bit data on EBI bank1
N  *
N  * @param[in]  u32Addr     The data address on EBI bank1.
N  *
N  * @return     8-bit Data
N  *
N  * @details    This macro is used to read 8-bit data from specify address on EBI bank1.
N  */
N#define EBI1_READ_DATA8(u32Addr)            (*((volatile unsigned char *)(EBI_BANK1_BASE_ADDR+(u32Addr))))
N
N/**
N  * @brief      Write 8-bit data to EBI bank1
N  *
N  * @param[in]  u32Addr     The data address on EBI bank1.
N  * @param[in]  u32Data     Specify data to be written.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to write 8-bit data to specify address on EBI bank1.
N  */
N#define EBI1_WRITE_DATA8(u32Addr, u32Data)  (*((volatile unsigned char *)(EBI_BANK1_BASE_ADDR+(u32Addr))) = (u32Data))
N
N/**
N  * @brief      Read 16-bit data on EBI bank1
N  *
N  * @param[in]  u32Addr     The data address on EBI bank1.
N  *
N  * @return     16-bit Data
N  *
N  * @details    This macro is used to read 16-bit data from specify address on EBI bank1.
N  */
N#define EBI1_READ_DATA16(u32Addr)           (*((volatile unsigned short *)(EBI_BANK1_BASE_ADDR+(u32Addr))))
N
N/**
N  * @brief      Write 16-bit data to EBI bank1
N  *
N  * @param[in]  u32Addr     The data address on EBI bank1.
N  * @param[in]  u32Data     Specify data to be written.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to write 16-bit data to specify address on EBI bank1.
N  */
N#define EBI1_WRITE_DATA16(u32Addr, u32Data) (*((volatile unsigned short *)(EBI_BANK1_BASE_ADDR+(u32Addr))) = (u32Data))
N
N/**
N  * @brief      Read 32-bit data on EBI bank1
N  *
N  * @param[in]  u32Addr     The data address on EBI bank1.
N  *
N  * @return     32-bit Data
N  *
N  * @details    This macro is used to read 32-bit data from specify address on EBI bank1.
N  */
N#define EBI1_READ_DATA32(u32Addr)           (*((volatile unsigned int *)(EBI_BANK1_BASE_ADDR+(u32Addr))))
N
N/**
N  * @brief      Write 32-bit data to EBI bank1
N  *
N  * @param[in]  u32Addr     The data address on EBI bank1.
N  * @param[in]  u32Data     Specify data to be written.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to write 32-bit data to specify address on EBI bank1.
N  */
N#define EBI1_WRITE_DATA32(u32Addr, u32Data) (*((volatile unsigned int *)(EBI_BANK1_BASE_ADDR+(u32Addr))) = (u32Data))
N
N/**
N * @brief       Enable EBI Write Buffer
N *
N * @param       None
N *
N * @return      None
N *
N * @details     This macro is used to improve EBI write operation for EBI bank0 and bank1.
N */
N#define EBI_ENABLE_WRITE_BUFFER()           (EBI->CTL0 |= EBI_CTL_WBUFEN_Msk);
N
N/**
N * @brief       Disable EBI Write Buffer
N *
N * @param       None
N *
N * @return      None
N *
N * @details     This macro is used to disable EBI write buffer function.
N */
N#define EBI_DISABLE_WRITE_BUFFER()          (EBI->CTL0 &= ~EBI_CTL_WBUFEN_Msk);
N
Nvoid EBI_Open(uint32_t u32Bank, uint32_t u32DataWidth, uint32_t u32TimingClass, uint32_t u32BusMode, uint32_t u32CSActiveLevel);
Nvoid EBI_Close(uint32_t u32Bank);
Nvoid EBI_SetBusTiming(uint32_t u32Bank, uint32_t u32TimingConfig, uint32_t u32MclkDiv);
N
N/*@}*/ /* end of group EBI_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group EBI_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__EBI_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17558 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "fmc.h"
L 1 "..\lib\StdDriver\inc\fmc.h" 1
N/**************************************************************************//**
N * @file     fmc.h
N * @version  V3.0
N * $Revision: 6 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE Series Flash Memory Controller(FMC) driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __FMC_H__
N#define __FMC_H__
N
N#include "NUC029xGE.h"
L 1 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 1
N/**************************************************************************//**
N * @file     NUC029xGE.h
N * @version  V3.0
N * $Revision: 39 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE Series Peripheral Access Layer Header File
N *
N * @note
N * Copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N
N/**
N  \mainpage Introduction
N  *
N  *
N  * This user manual describes the usage of NUC029xGE MCU device driver
N  *
N  * <b>Disclaimer</b>
N  *
N  * The Software is furnished "AS IS", without warranty as to performance or results, and
N  * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N  * warranties, express, implied or otherwise, with regard to the Software, its use, or
N  * operation, including without limitation any and all warranties of merchantability, fitness
N  * for a particular purpose, and non-infringement of intellectual property rights.
N  *
N  * <b>Copyright Notice</b>
N  *
N  * Copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N  */
N
N#ifndef __NUC029xGE_H__
S#define __NUC029xGE_H__
S
S
S/*
S * ==========================================================================
S * ---------- Interrupt Number Definition -----------------------------------
S * ==========================================================================
S */
S
S/**
S * @details  Interrupt Number Definition. The maximum of 32 Specific Interrupts are possible.
S */
Stypedef enum IRQn
S{
S    /******  Cortex-M0 Processor Exceptions Numbers ***************************************************/
S    NonMaskableInt_IRQn       = -14,      /*!< 2 Non Maskable Interrupt                             */
S    HardFault_IRQn            = -13,      /*!< 3 Cortex-M0 Hard Fault Interrupt                     */
S    SVCall_IRQn               = -5,       /*!< 11 Cortex-M0 SV Call Interrupt                       */
S    PendSV_IRQn               = -2,       /*!< 14 Cortex-M0 Pend SV Interrupt                       */
S    SysTick_IRQn              = -1,       /*!< 15 Cortex-M0 System Tick Interrupt                   */
S
S    /******  ARMIKMCU Swift specific Interrupt Numbers ************************************************/
S    BOD_IRQn                  = 0,        /*!< Brown-Out Low Voltage Detected Interrupt             */
S    WDT_IRQn                  = 1,        /*!< Watch Dog Timer Interrupt                            */
S    EINT024_IRQn              = 2,        /*!< EINT0, EINT2 and EINT4 Interrupt                     */
S    EINT135_IRQn              = 3,        /*!< EINT1, EINT3 and EINT5 Interrupt                     */
S    GPAB_IRQn                 = 4,        /*!< GPIO_PA/PB Interrupt                                 */
S    GPCDEF_IRQn               = 5,        /*!< GPIO_PC/PD/PE/PF Interrupt                           */
S    PWM0_IRQn                 = 6,        /*!< PWM0 Interrupt                                       */
S    PWM1_IRQn                 = 7,        /*!< PWM1 Interrupt                                       */
S    TMR0_IRQn                 = 8,        /*!< TIMER0 Interrupt                                     */
S    TMR1_IRQn                 = 9,        /*!< TIMER1 Interrupt                                     */
S    TMR2_IRQn                 = 10,       /*!< TIMER2 Interrupt                                     */
S    TMR3_IRQn                 = 11,       /*!< TIMER3 Interrupt                                     */
S    UART02_IRQn               = 12,       /*!< UART0 and UART2 Interrupt                            */
S    UART1_IRQn                = 13,       /*!< UART1 Interrupt                                      */
S    SPI0_IRQn                 = 14,       /*!< SPI0 Interrupt                                       */
S    SPI1_IRQn                 = 15,       /*!< SPI1 Interrupt                                       */
S    I2C0_IRQn                 = 18,       /*!< I2C0 Interrupt                                       */
S    I2C1_IRQn                 = 19,       /*!< I2C1 Interrupt                                       */
S    USCI_IRQn                 = 22,       /*!< USCI0, USCI1 and USCI2 interrupt                     */
S    USBD_IRQn                 = 23,       /*!< USB Device Interrupt                                 */
S    SC01_IRQn                 = 24,       /*!< SC0 and SC1 Interrupt                                */
S    ACMP01_IRQn               = 25,       /*!< ACMP0/1 Interrupt                                    */
S    PDMA_IRQn                 = 26,       /*!< PDMA Interrupt                                       */
S    PWRWU_IRQn                = 28,       /*!< Power Down Wake Up Interrupt                         */
S    ADC_IRQn                  = 29,       /*!< ADC Interrupt                                        */
S    CLKDIRC_IRQn              = 30,       /*!< Clock fail detect and IRC TRIM Interrupt             */
S    RTC_IRQn                  = 31        /*!< Real Time Clock Interrupt                            */
S
S} IRQn_Type;
S
S
S/*
S * ==========================================================================
S * ----------- Processor and Core Peripheral Section ------------------------
S * ==========================================================================
S */
S
S/* Configuration of the Cortex-M0 Processor and Core Peripherals */
S#define __MPU_PRESENT           0       /*!< armikcmu does not provide a MPU present or not       */
S#define __NVIC_PRIO_BITS        2       /*!< armikcmu Supports 2 Bits for the Priority Levels     */
S#define __Vendor_SysTickConfig  0       /*!< Set to 1 if different SysTick Config is used         */
S
S
S#include "core_cm0.h"                   /*!< Cortex-M0 processor and core peripherals             */
S#include "system_NUC029xGE.h"           /*!< NUC029xGE System                                    */
S
S
S#if defined ( __CC_ARM   )
S#pragma anon_unions
S#endif
S
S
S/**
S * Initialize the system clock
S *
S * @param  None
S * @return None
S *
S * @brief  Setup the microcontroller system
S *         Initialize the PLL and update the SystemFrequency variable
S */
Sextern void SystemInit(void);
S
S
S
S/******************************************************************************/
S/*                Device Specific Peripheral registers structures             */
S/******************************************************************************/
S
S/** @addtogroup REGISTER Control Register
S
S  @{
S
S*/
S
S
S/*---------------------- Analog Comparator Controller -------------------------*/
S/**
S    @addtogroup ACMP Analog Comparator Controller(ACMP)
S    Memory Mapped Structure for ACMP Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var ACMP_T::CTL
S     * Offset: 0x00  Analog Comparator 0 Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ACMPEN    |Comparator Enable Bit
S     * |        |          |0 = Comparator 0 Disabled.
S     * |        |          |1 = Comparator 0 Enabled.
S     * |[1]     |ACMPIE    |Comparator Interrupt Enable Bit
S     * |        |          |0 = Comparator 0 interrupt Disabled.
S     * |        |          |1 = Comparator 0 interrupt Enabled
S     * |        |          |If WKEN (ACMP_CTL0[16]) is set to 1, the wake-up interrupt function will be enabled as well.
S     * |[2]     |HYSEN     |Comparator Hysteresis Enable Bit
S     * |        |          |0 = Comparator 0 hysteresis Disabled.
S     * |        |          |1 = Comparator 0 hysteresis Enabled.
S     * |[3]     |ACMPOINV  |Comparator Output Inverse
S     * |        |          |0 = Comparator 0 output inverse Disabled.
S     * |        |          |1 = Comparator 0 output inverse Enabled.
S     * |[5:4]   |NEGSEL    |Comparator Negative Input Selection
S     * |        |          |00 = ACMP0_N pin.
S     * |        |          |01 = Internal comparator reference voltage (CRV).
S     * |        |          |10 = Band-gap voltage.
S     * |        |          |11 = ReservedGround.
S     * |[7:6]   |POSSEL    |Comparator Positive Input Selection
S     * |        |          |00 = Input from ACMP0_P0.
S     * |        |          |01 = Input from ACMP0_P1.
S     * |        |          |10 = Input from ACMP0_P2.
S     * |        |          |11 = Input from ACMP0_P3.
S     * |[9:8]   |INTPOL    |Interrupt Condition Polarity Selection
S     * |        |          |ACMPIF0 will be set to 1 when comparator output edge condition is detected.
S     * |        |          |00 = Rising edge or falling edge.
S     * |        |          |01 = Rising edge.
S     * |        |          |10 = Falling edge.
S     * |        |          |11 = Reserved.
S     * |[12]    |OUTSEL    |Comparator Output Selection
S     * |        |          |0 = Comparator 0 output to ACMP0_O pin is unfiltered comparator output.
S     * |        |          |1 = Comparator 0 output to ACMP0_O pin is from filter output.
S     * |[15:13] |FILTSEL   |Comparator Output Filter Count Selection
S     * |        |          |000 = Filter function is Disabled.
S     * |        |          |001 = ACMP output is sampled 1 consecutive PCLK.
S     * |        |          |010 = ACMP output is sampled 2 consecutive PCLKs.
S     * |        |          |011 = ACMP output is sampled 4 consecutive PCLKs.
S     * |        |          |100 = ACMP output is sampled 8 consecutive PCLKs.
S     * |        |          |101 = ACMP output is sampled 16 consecutive PCLKs.
S     * |        |          |110 = ACMP output is sampled 32 consecutive PCLKs.
S     * |        |          |111 = ACMP output is sampled 64 consecutive PCLKs.
S     * |[16]    |WKEN      |Power-down Wake-up Enable Bit
S     * |        |          |0 = Wake-up function Disabled.
S     * |        |          |1 = Wake-up function Enabled.
S     * |[17]    |WLATEN    |Window Mode SelectionLatch Function Enable Bit
S     * |        |          |0 = Window Latch Function Disabled.
S     * |        |          |1 = Window Latch Function Enabled.
S     * |[18]    |WCMPSEL   |Window Compare Mode Selection
S     * |        |          |0 = Window Compare Mode Disabled.
S     * |        |          |1 = Window Compare Mode is Selected.
S     * @var ACMP_T::STATUS
S     * Offset: 0x08  Analog Comparator Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ACMPIF0   |Comparator 0 Interrupt Flag
S     * |        |          |This bit is set by hardware when the edge condition defined by INTPOL (ACMP_CTL0[9:8]) is detected on comparator 0 output
S     * |        |          |This will generate an interrupt if ACMPIE (ACMP_CTL0[1]) is set to 1.
S     * |        |          |Note: Write 1 to clear this bit to 0.
S     * |[1]     |ACMPIF1   |Comparator 1 Interrupt Flag
S     * |        |          |This bit is set by hardware when the edge condition defined by INTPOL (ACMP_CTL1[9:8]) is detected on comparator 1 output
S     * |        |          |This will cause an interrupt if ACMPIE (ACMP_CTL1[1]) is set to 1.
S     * |        |          |Note: Write 1 to clear this bit to 0.
S     * |[4]     |ACMPO0    |Comparator 0 Output
S     * |        |          |Synchronized to the PCLK to allow reading by software
S     * |        |          |Cleared when the comparator 0 is disabled, i.e
S     * |        |          |ACMPEN (ACMP_CTL0[0]) is cleared to 0.
S     * |[5]     |ACMPO1    |Comparator 1 Output
S     * |        |          |Synchronized to the PCLK to allow reading by software
S     * |        |          |Cleared when the comparator 1 is disabled, i.e
S     * |        |          |ACMPEN (ACMP_CTL1[0]) is cleared to 0.
S     * |[8]     |WKIF0     |Comparator 0 Power-down Wake-up Interrupt Flag
S     * |        |          |This bit will be set to 1 when ACMP0 wake-up interrupt event occurs.
S     * |        |          |0 = No power-down wake-up occurred.
S     * |        |          |1 = Power-down wake-up occurred.
S     * |        |          |Note: Write 1 to clear this bit to 0.
S     * |[9]     |WKIF1     |Comparator 1 Power-down Wake-up Interrupt Flag
S     * |        |          |This bit will be set to 1 when ACMP1 wake-up interrupt event occurs.
S     * |        |          |0 = No power-down wake-up occurred.
S     * |        |          |1 = Power-down wake-up occurred.
S     * |        |          |Note: Write 1 to clear this bit to 0.
S     * |[12]    |ACMPS0    |Comparator 0 StatusResult
S     * |        |          |Synchronized to the PCLK to allow reading by software
S     * |        |          |Cleared when the comparator 0 is disabled, i.e
S     * |        |          |ACMPEN (ACMP_CTL0[0]) is cleared to 0.Window Compare Output
S     * |[13]    |ACMPS1    |Window Comparator 1 StatusResultOutput
S     * |        |          |Synchronized to the PCLK to allow reading by software
S     * |        |          |Cleared when the comparator 1 is disabled, i.e
S     * |        |          |ACMPEN (ACMP_CTL1[0]) is cleared to 0.
S     * |[16]    |ACMPWO    |Comparator Window Compare Output
S     * |        |          |This bit shows the output status of window compare mode
S     * |        |          |0 = The positvie input voltage is outside the window.
S     * |        |          |1 = The positive input voltage is in the window.
S     * @var ACMP_T::VREF
S     * Offset: 0x0C  Analog Comparator Reference Voltage Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |CRVCTL    |Comparator Reference Voltage Setting
S     * |        |          |CRV = CRV source voltage * (1/6+CRVCTL/24).
S     * |[6]     |CRVSSEL   |CRV Source Voltage Selection
S     * |        |          |0 = AVDD is selected as CRV voltage source.
S     * |        |          |1 = The reference voltage defined by SYS_VREFCTL register is selected as CRV source voltage.
S     */
S    __IO uint32_t CTL[2];                /*!< [0x0000~0x0004] Analog Comparator 0/1 Control Register                    */
S    __IO uint32_t STATUS;                /*!< [0x0008] Analog Comparator Status Register                                */
S    __IO uint32_t VREF;                  /*!< [0x000c] Analog Comparator Reference Voltage Control Register             */
S
S} ACMP_T;
S
S/**
S    @addtogroup ACMP_CONST ACMP Bit Field Definition
S    Constant Definitions for ACMP Controller
S@{ */
S
S#define ACMP_CTL_ACMPEN_Pos             (0)                                                /*!< ACMP_T::CTL: ACMPEN Position          */
S#define ACMP_CTL_ACMPEN_Msk             (0x1ul << ACMP_CTL_ACMPEN_Pos)                     /*!< ACMP_T::CTL: ACMPEN Mask              */
S
S#define ACMP_CTL_ACMPIE_Pos             (1)                                                /*!< ACMP_T::CTL: ACMPIE Position          */
S#define ACMP_CTL_ACMPIE_Msk             (0x1ul << ACMP_CTL_ACMPIE_Pos)                     /*!< ACMP_T::CTL: ACMPIE Mask              */
S
S#define ACMP_CTL_HYSEN_Pos              (2)                                                /*!< ACMP_T::CTL: HYSEN Position           */
S#define ACMP_CTL_HYSEN_Msk              (0x1ul << ACMP_CTL_HYSEN_Pos)                      /*!< ACMP_T::CTL: HYSEN Mask               */
S
S#define ACMP_CTL_ACMPOINV_Pos           (3)                                                /*!< ACMP_T::CTL: ACMPOINV Position        */
S#define ACMP_CTL_ACMPOINV_Msk           (0x1ul << ACMP_CTL_ACMPOINV_Pos)                   /*!< ACMP_T::CTL: ACMPOINV Mask            */
S
S#define ACMP_CTL_NEGSEL_Pos             (4)                                                /*!< ACMP_T::CTL: NEGSEL Position          */
S#define ACMP_CTL_NEGSEL_Msk             (0x3ul << ACMP_CTL_NEGSEL_Pos)                     /*!< ACMP_T::CTL: NEGSEL Mask              */
S
S#define ACMP_CTL_POSSEL_Pos             (6)                                                /*!< ACMP_T::CTL: POSSEL Position          */
S#define ACMP_CTL_POSSEL_Msk             (0x3ul << ACMP_CTL_POSSEL_Pos)                     /*!< ACMP_T::CTL: POSSEL Mask              */
S
S#define ACMP_CTL_INTPOL_Pos             (8)                                                /*!< ACMP_T::CTL: INTPOL Position          */
S#define ACMP_CTL_INTPOL_Msk             (0x3ul << ACMP_CTL_INTPOL_Pos)                     /*!< ACMP_T::CTL: INTPOL Mask              */
S
S#define ACMP_CTL_OUTSEL_Pos             (12)                                               /*!< ACMP_T::CTL: OUTSEL Position          */
S#define ACMP_CTL_OUTSEL_Msk             (0x1ul << ACMP_CTL_OUTSEL_Pos)                     /*!< ACMP_T::CTL: OUTSEL Mask              */
S
S#define ACMP_CTL_FILTSEL_Pos            (13)                                               /*!< ACMP_T::CTL: FILTSEL Position         */
S#define ACMP_CTL_FILTSEL_Msk            (0x7ul << ACMP_CTL_FILTSEL_Pos)                    /*!< ACMP_T::CTL: FILTSEL Mask             */
S
S#define ACMP_CTL_WKEN_Pos               (16)                                               /*!< ACMP_T::CTL: WKEN Position            */
S#define ACMP_CTL_WKEN_Msk               (0x1ul << ACMP_CTL_WKEN_Pos)                       /*!< ACMP_T::CTL: WKEN Mask                */
S
S#define ACMP_CTL_WLATEN_Pos             (17)                                               /*!< ACMP_T::CTL: WLATEN Position          */
S#define ACMP_CTL_WLATEN_Msk             (0x1ul << ACMP_CTL_WLATEN_Pos)                     /*!< ACMP_T::CTL: WLATEN Mask              */
S
S#define ACMP_CTL_WCMPSEL_Pos            (18)                                               /*!< ACMP_T::CTL: WCMPSEL Position         */
S#define ACMP_CTL_WCMPSEL_Msk            (0x1ul << ACMP_CTL_WCMPSEL_Pos)                    /*!< ACMP_T::CTL: WCMPSEL Mask             */
S
S#define ACMP_STATUS_ACMPIF0_Pos          (0)                                               /*!< ACMP_T::STATUS: ACMPIF0 Position       */
S#define ACMP_STATUS_ACMPIF0_Msk          (0x1ul << ACMP_STATUS_ACMPIF0_Pos)                /*!< ACMP_T::STATUS: ACMPIF0 Mask           */
S
S#define ACMP_STATUS_ACMPIF1_Pos          (1)                                               /*!< ACMP_T::STATUS: ACMPIF1 Position       */
S#define ACMP_STATUS_ACMPIF1_Msk          (0x1ul << ACMP_STATUS_ACMPIF1_Pos)                /*!< ACMP_T::STATUS: ACMPIF1 Mask           */
S
S#define ACMP_STATUS_ACMPO0_Pos           (4)                                               /*!< ACMP_T::STATUS: ACMPO0 Position        */
S#define ACMP_STATUS_ACMPO0_Msk           (0x1ul << ACMP_STATUS_ACMPO0_Pos)                 /*!< ACMP_T::STATUS: ACMPO0 Mask            */
S
S#define ACMP_STATUS_ACMPO1_Pos           (5)                                               /*!< ACMP_T::STATUS: ACMPO1 Position        */
S#define ACMP_STATUS_ACMPO1_Msk           (0x1ul << ACMP_STATUS_ACMPO1_Pos)                 /*!< ACMP_T::STATUS: ACMPO1 Mask            */
S
S#define ACMP_STATUS_WKIF0_Pos            (8)                                               /*!< ACMP_T::STATUS: WKIF0 Position         */
S#define ACMP_STATUS_WKIF0_Msk            (0x1ul << ACMP_STATUS_WKIF0_Pos)                  /*!< ACMP_T::STATUS: WKIF0 Mask             */
S
S#define ACMP_STATUS_WKIF1_Pos            (9)                                               /*!< ACMP_T::STATUS: WKIF1 Position         */
S#define ACMP_STATUS_WKIF1_Msk            (0x1ul << ACMP_STATUS_WKIF1_Pos)                  /*!< ACMP_T::STATUS: WKIF1 Mask             */
S
S#define ACMP_STATUS_ACMPS0_Pos           (12)                                              /*!< ACMP_T::STATUS: ACMPS0 Position        */
S#define ACMP_STATUS_ACMPS0_Msk           (0x1ul << ACMP_STATUS_ACMPS0_Pos)                 /*!< ACMP_T::STATUS: ACMPS0 Mask            */
S
S#define ACMP_STATUS_ACMPS1_Pos           (13)                                              /*!< ACMP_T::STATUS: ACMPS1 Position        */
S#define ACMP_STATUS_ACMPS1_Msk           (0x1ul << ACMP_STATUS_ACMPS1_Pos)                 /*!< ACMP_T::STATUS: ACMPS1 Mask            */
S
S#define ACMP_STATUS_ACMPWO_Pos           (16)                                              /*!< ACMP_T::STATUS: ACMPWO Position        */
S#define ACMP_STATUS_ACMPWO_Msk           (0x1ul << ACMP_STATUS_ACMPWO_Pos)                 /*!< ACMP_T::STATUS: ACMPWO Mask            */
S
S#define ACMP_VREF_CRVCTL_Pos             (0)                                               /*!< ACMP_T::VREF: CRVCTL Position          */
S#define ACMP_VREF_CRVCTL_Msk             (0xful << ACMP_VREF_CRVCTL_Pos)                   /*!< ACMP_T::VREF: CRVCTL Mask              */
S
S#define ACMP_VREF_CRVSSEL_Pos            (6)                                               /*!< ACMP_T::VREF: CRVSSEL Position         */
S#define ACMP_VREF_CRVSSEL_Msk            (0x1ul << ACMP_VREF_CRVSSEL_Pos)                  /*!< ACMP_T::VREF: CRVSSEL Mask             */
S
S/**@}*/ /* ACMP_CONST */
S/**@}*/ /* end of ACMP register group */
S
S
S/*---------------------- Analog to Digital Converter -------------------------*/
S/**
S    @addtogroup ADC Analog to Digital Converter(ADC)
S    Memory Mapped Structure for ADC Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var ADC_T::ADDR
S     * Offset: 0x00~0x4C, 0x74~0x7C  ADC Data Register 0~19, 29~31
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RSLT      |A/D Conversion Result (Read Only)
S     * |        |          |This field contains conversion result of ADC.
S     * |[16]    |OVERRUN   |Overrun Flag (Read Only)
S     * |        |          |If converted data in RSLT bits has not been read before new conversion result is loaded to this register, OVERRUN bit is set to 1.
S     * |        |          |It is cleared by hardware after ADDR register is read.
S     * |        |          |0 = Data in RSLT bits is not overwrote.
S     * |        |          |1 = Data in RSLT bits is overwrote..
S     * |[17]    |VALID     |Valid Flag (Read Only)
S     * |        |          |This bit will be set to 1 when the conversion of the corresponding channel is completed.
S     * |        |          |This bit will be cleared to 0 by hardware after ADDR register is read.
S     * |        |          |0 = Data in RSLT bits is not valid.
S     * |        |          |1 = Data in RSLT bits is valid.
S     * @var ADC_T::ADCR
S     * Offset: 0x80  ADC Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ADEN      |A/D Converter Enable
S     * |        |          |0 = A/D converter Disabled.
S     * |        |          |1 = A/D converter Enabled.
S     * |        |          |Note: Before starting A/D conversion function, this bit should be set to 1.
S     * |        |          |Clear it to 0 to disable A/D converter analog circuit to save power consumption.
S     * |[1]     |ADIE      |A/D Interrupt Enable Control
S     * |        |          |A/D conversion end interrupt request is generated if ADIE bit is set to 1.
S     * |        |          |0 = A/D interrupt function Disabled.
S     * |        |          |1 = A/D interrupt function Enabled.
S     * |[3:2]   |ADMD      |A/D Converter Operation Mode Control
S     * |        |          |00 = Single conversion.
S     * |        |          |01 = Burst conversion.
S     * |        |          |10 = Single-cycle Scan.
S     * |        |          |11 = Continuous Scan.
S     * |        |          |Note1: When changing the operation mode, software should clear ADST bit first.
S     * |        |          |Note2: In Burst mode, the A/D result data is always at ADC Data Register 0.
S     * |[5:4]   |TRGS      |Hardware Trigger Source
S     * |        |          |00 = A/D conversion is started by external STADC pin.
S     * |        |          |01 = Timer0 ~ Timer3 overflow pulse trigger.
S     * |        |          |10 = Reserved.
S     * |        |          |11 = A/D conversion is started by PWM trigger.
S     * |        |          |Note: Software should clear TRGEN bit and ADST bit to 0 before changing TRGS bits.
S     * |[7:6]   |TRGCOND   |External Trigger Condition
S     * |        |          |These two bits decide external pin STADC trigger event is level or edge.
S     * |        |          |The signal must be kept at stable state at least 8 PCLKs for level trigger and at least 4 PCLKs for edge trigger.
S     * |        |          |00 = Low level.
S     * |        |          |01 = High level.
S     * |        |          |10 = Falling edge.
S     * |        |          |11 = Rising edge.
S     * |[8]     |TRGEN     |External Trigger Enable Control
S     * |        |          |Enable or disable triggering of A/D conversion by external STADC pin, PWM trigger and Timer trigger.
S     * |        |          |If external trigger is enabled, the ADST bit can be set to 1 by the selected hardware trigger source.
S     * |        |          |0 = External trigger Disabled.
S     * |        |          |1 = External trigger Enabled.
S     * |        |          |Note: The ADC external trigger function is only supported in Single-cycle Scan mode.
S     * |[9]     |PTEN      |PDMA Transfer Enable Bit
S     * |        |          |When A/D conversion is completed, the converted data is loaded into ADDR0~19, ADDR29~ADDR31.
S     * |        |          |Software can enable this bit to generate a PDMA data transfer request.
S     * |        |          |0 = PDMA data transfer Disabled.
S     * |        |          |1 = PDMA data transfer in ADDR0~19, ADDR29~ADDR31 Enabled.
S     * |        |          |Note: When PTEN=1, software must set ADIE=0 to disable interrupt.
S     * |[10]    |DIFFEN    |Differential Input Mode Control
S     * |        |          |0 = Single-end analog input mode.
S     * |        |          |1 = Differential analog input mode.
S     * |        |          |Differential input voltage (Vdiff) = Vplus - Vminus,
S     * |        |          |where Vplus is the analog input; Vminus is the inverted analog input.
S     * |        |          |The Vplus of differential input paired channel x is from ADC0_CHy pin; Vminus is from ADC0_CHz pin, x=0,1..9, y=2*x, z=y+1.
S     * |        |          |0 = Single-end analog input mode.
S     * |        |          |1 = Differential analog input mode.
S     * |        |          |Note: In Differential Input mode, only the even number of the two corresponding channels needs to be enabled in ADCHER register
S     * |        |          |The conversion result will be placed to the corresponding data register of the enabled channel.
S     * |[11]    |ADST      |A/D Conversion Start
S     * |        |          |ADST bit can be set to 1 from four sources: software, external pin STADC, PWM trigger and Timer trigger.
S     * |        |          |ADST bit will be cleared to 0 by hardware automatically at the ends of Single mode and Single-cycle Scan mode.
S     * |        |          |In Continuous Scan mode and Burst mode, A/D conversion is continuously performed until software writes 0 to this bit or chip is reset.
S     * |        |          |0 = Conversion stops and A/D converter enters idle state.
S     * |        |          |1 = Conversion starts.
S     * |[18:16] |SMPTSEL   |ADC Internal Sampling Time Selection
S     * |        |          |Total ADC conversion cycle = sampling cycle + 12
S     * |        |          |000 = 4 ADC clock for sampling; 16 ADC clock for complete conversion.
S     * |        |          |001 = 5 ADC clock for sampling; 17 ADC clock for complete conversion.
S     * |        |          |010 = 6 ADC clock for sampling; 18 ADC clock for complete conversion.
S     * |        |          |011 = 7 ADC clock for sampling; 19 ADC clock for complete conversion.
S     * |        |          |100 = 8 ADC clock for sampling; 20 ADC clock for complete conversion.
S     * |        |          |101 = 9 ADC clock for sampling; 21 ADC clock for complete conversion.
S     * |        |          |110 = 10 ADC clock for sampling; 22 ADC clock for complete conversion.
S     * |        |          |111 = 11 ADC clock for sampling; 23 ADC clock for complete conversion.
S     * |[31]    |DMOF      |Differential Input Mode Output Format
S     * |        |          |If user enables differential input mode, the conversion result can be expressed with binary straight format (unsigned format) or 2's complement format (signed format).
S     * |        |          |0 = A/D Conversion result will be filled in RSLT at ADDRx registers with unsigned format (straight binary format).
S     * |        |          |1 = A/D Conversion result will be filled in RSLT at ADDRx registers with 2's complement format.
S     * @var ADC_T::ADCHER
S     * Offset: 0x84  ADC Channel Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |CHEN      |Analog Input Channel Enable Control
S     * |        |          |Set ADCHENR[19:0] bits to enable the corresponding analog input channel 19 ~ 0
S     * |        |          |If DIFFEN bit is set to 1, only the even number channel needs to be enabled.
S     * |        |          |Besides, set ADCHENR[29] to ADCHENR[31] bits will enable internal channel for band-gap voltage, temperature sensor and battery power respectively.
S     * |        |          |Other bits are reserved.
S     * |        |          |0 = Channel Disabled.
S     * |        |          |1 = Channel Enabled.
S     * |        |          |Note 1 : If the internal channel for band-gap voltage (CHEN[29]) is active, the maximum sampling rate will be 300k SPS.
S     * |        |          |Note 2 : If the internal channel for temperature sensor (CHEN[30]) is active, the maximum sampling rate will be 300k SPS.
S     * @var ADC_T::ADCMPR
S     * Offset: 0x88/0x8C  ADC Compare Register 0/1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CMPEN     |Compare Enable Control
S     * |        |          |Set this bit to 1 to enable ADC controller to compare CMPD (ADCMPRx[27:16]) with specified channel conversion result when converted data is loaded into ADDR register.
S     * |        |          |0 = Compare function Disabled.
S     * |        |          |1 = Compare function Enabled.
S     * |[1]     |CMPIE     |Compare Interrupt Enable Control
S     * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMATCNT, CMPFx bit will be asserted, in the meanwhile, if CMPIE bit is set to 1, a compare interrupt request is generated.
S     * |        |          |0 = Compare function interrupt Disabled.
S     * |        |          |1 = Compare function interrupt Enabled.
S     * |[2]     |CMPCOND   |Compare Condition
S     * |        |          |0 = Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPD (ADCMPRx[27:16])bits, the internal match counter will increase one.
S     * |        |          |1 = Set the compare condition as that when a 12-bit A/D conversion result is greater than or equal to the 12-bit CMPD (ADCMPRx[27:16])bits, the internal match counter will increase one.
S     * |        |          |Note: When the internal counter reaches to (CMPMATCNT +1), the CMPFx bit will be set.
S     * |[7:3]   |CMPCH     |Compare Channel Selection
S     * |        |          |00000 = Channel 0 conversion result is selected to be compared.
S     * |        |          |00001 = Channel 1 conversion result is selected to be compared.
S     * |        |          |00010 = Channel 2 conversion result is selected to be compared.
S     * |        |          |00011 = Channel 3 conversion result is selected to be compared.
S     * |        |          |00100 = Channel 4 conversion result is selected to be compared.
S     * |        |          |00101 = Channel 5 conversion result is selected to be compared.
S     * |        |          |00110 = Channel 6 conversion result is selected to be compared.
S     * |        |          |00111 = Channel 7 conversion result is selected to be compared.
S     * |        |          |01000 = Channel 8 conversion result is selected to be compared.
S     * |        |          |01001 = Channel 9 conversion result is selected to be compared.
S     * |        |          |01010 = Channel 10 conversion result is selected to be compared.
S     * |        |          |01011 = Channel 11 conversion result is selected to be compared.
S     * |        |          |01100 = Channel 12 conversion result is selected to be compared.
S     * |        |          |01101 = Channel 13 conversion result is selected to be compared.
S     * |        |          |01110 = Channel 14 conversion result is selected to be compared.
S     * |        |          |01111 = Channel 15 conversion result is selected to be compared.
S     * |        |          |10000 = Channel 16 conversion result is selected to be compared.
S     * |        |          |10001 = Channel 17 conversion result is selected to be compared.
S     * |        |          |10010 = Channel 18 conversion result is selected to be compared.
S     * |        |          |10011 = Channel 19 conversion result is selected to be compared.
S     * |        |          |11101 = Band-gap voltage conversion result is selected to be compared.
S     * |        |          |11110 = Temperature sensor conversion result is selected to be compared.
S     * |        |          |11111 = Battery power conversion result is selected to be compared.
S     * |        |          |Others = Reserved.
S     * |[11:8]  |CMPMATCNT |Compare Match Count
S     * |        |          |When the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND bit, the internal match counter will increase 1.
S     * |        |          |When the internal counter reaches the value to (CMPMATCNT +1), the CMPFx bit will be set.
S     * |[15]    |CMPWEN    |Compare Window Mode Enable Bit
S     * |        |          |0 = Compare Window Mode Disabled.
S     * |        |          |1 = Compare Window Mode Enabled.
S     * |        |          |Note: This bit is only presented in ADCMPR0 register.
S     * |[27:16] |CMPD      |Comparison Data
S     * |        |          |The 12-bit data is used to compare with conversion result of specified channel.
S     * |        |          |Note: CMPD bits should be filled in unsigned format (straight binary format).
S     * @var ADC_T::ADSR0
S     * Offset: 0x90  ADC Status Register0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ADF       |A/D Conversion End Flag
S     * |        |          |A status flag that indicates the end of A/D conversion. Software can write 1 to clear this bit.
S     * |        |          |ADF bit is set to 1 at the following three conditions:
S     * |        |          |1. When A/D conversion ends in Single mode.
S     * |        |          |2. When A/D conversion ends on all specified channels in Single-cycle Scan mode and Continuous Scan mode.
S     * |        |          |3. When more than or equal to 8 samples in FIFO in Burst mode.
S     * |[1]     |CMPF0     |Compare Flag 0
S     * |        |          |When the A/D conversion result of the selected channel meets setting condition in ADCMPR0 register then this bit is set to 1.
S     * |        |          |This bit is cleared by writing 1 to it.
S     * |        |          |0 = Conversion result in ADDR does not meet ADCMPR0 setting.
S     * |        |          |1 = Conversion result in ADDR meets ADCMPR0 setting.
S     * |[2]     |CMPF1     |Compare Flag 1
S     * |        |          |When the A/D conversion result of the selected channel meets setting condition in ADCMPR1 register then this bit is set to 1; it is cleared by writing 1 to it.
S     * |        |          |0 = Conversion result in ADDR does not meet ADCMPR1 setting.
S     * |        |          |1 = Conversion result in ADDR meets ADCMPR1 setting.
S     * |[7]     |BUSY      |BUSY/IDLE (Read Only)
S     * |        |          |This bit is a mirror of ADST bit in ADCR register.
S     * |        |          |0 = A/D converter is in idle state.
S     * |        |          |1 = A/D converter is busy at conversion.
S     * |[8]     |VALIDF    |Data Valid Flag (Read Only)
S     * |        |          |If any one of VALID (ADDRx[17]) is set, this flag will be set to 1.
S     * |        |          |Note: When ADC is in burst mode and any conversion result is valid, this flag will be set to 1.
S     * |[16]    |OVERRUNF  |Overrun Flag (Read Only)
S     * |        |          |If any one of OVERRUN (ADDRx[16]) is set, this flag will be set to 1.
S     * |        |          |Note: When ADC is in burst mode and the FIFO is overrun, this flag will be set to 1.
S     * |[31:27] |CHANNEL   |Current Conversion Channel (Read Only)
S     * |        |          |When BUSY=1, this filed reflects current conversion channel.
S     * |        |          |When BUSY=0, it shows the number of the next converted channel.
S     * @var ADC_T::ADSR1
S     * Offset: 0x94  ADC Status Register1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |VALID     |Data Valid Flag (Read Only)
S     * |        |          |VALID[31:29, 19:0] are the mirror of the VALID bits in ADDR31[17] ~ ADDR29[17], ADDR19[17]~ ADDR0[17].
S     * |        |          |The other bits are reserved.
S     * |        |          |Note: When ADC is in burst mode and any conversion result is valid, VALID[31:29, 19:0] will be set to 1.
S     * @var ADC_T::ADSR2
S     * Offset: 0x98  ADC Status Register2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |OVERRUN   |Overrun Flag (Read Only)
S     * |        |          |OVERRUN[31:29, 19:0] are the mirror of the OVERRUN bit in ADDR31[16] ~ADDR29[16], ADDR19[16] ~ ADDR0[16].
S     * |        |          |The other bits are reserved.
S     * |        |          |Note: When ADC is in burst mode and the FIFO is overrun, OVERRUN[31:29, 19:0] will be set to 1.
S     * @var ADC_T::ADTDCR
S     * Offset: 0x9C  ADC Trigger Delay Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |PTDT      |PWM Trigger Delay Time
S     * |        |          |Set this field will delay ADC start conversion time after PWM trigger.
S     * |        |          |PWM trigger delay time is (4 * PTDT) * system clock
S     * @var ADC_T::ADPDMA
S     * Offset: 0x100  ADC PDMA Current Transfer Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[17:0]  |CURDAT    |ADC PDMA Current Transfer Data Register (Read Only)
S     * |        |          |When PDMA transferring, read this register can monitor current PDMA transfer data.
S     * |        |          |Current PDMA transfer data could be the content of ADDR0 ~ ADDR19 and ADDR29 ~ ADDR31 registers.
S     */
S
S    __I  uint32_t ADDR[32];              /*!< [0x0000 ~ 0x007c] ADC Data Register 31                                    */
S    __IO uint32_t ADCR;                  /*!< [0x0080] ADC Control Register                                             */
S    __IO uint32_t ADCHER;                /*!< [0x0084] ADC Channel Enable Register                                      */
S    __IO uint32_t ADCMPR[2];             /*!< [0x0088 ~ 0x008C] ADC Compare Register 0 & 1                              */
S    __IO uint32_t ADSR0;                 /*!< [0x0090] ADC Status Register0                                             */
S    __I  uint32_t ADSR1;                 /*!< [0x0094] ADC Status Register1                                             */
S    __I  uint32_t ADSR2;                 /*!< [0x0098] ADC Status Register2                                             */
S    __IO uint32_t ADTDCR;                /*!< [0x009c] ADC Trigger Delay Control Register                               */
S    __I  uint32_t RESERVE0[24];
S    __I  uint32_t ADPDMA;                /*!< [0x0100] ADC PDMA Current Transfer Data Register                          */
S
S} ADC_T;
S
S/**
S    @addtogroup ADC_CONST ADC Bit Field Definition
S    Constant Definitions for ADC Controller
S@{ */
S
S#define ADC_ADDR_RSLT_Pos                (0)                                               /*!< ADC_T::ADDR: RSLT Position             */
S#define ADC_ADDR_RSLT_Msk                (0xfffful << ADC_ADDR_RSLT_Pos)                   /*!< ADC_T::ADDR: RSLT Mask                 */
S
S#define ADC_ADDR_OVERRUN_Pos             (16)                                              /*!< ADC_T::ADDR: OVERRUN Position          */
S#define ADC_ADDR_OVERRUN_Msk             (0x1ul << ADC_ADDR_OVERRUN_Pos)                   /*!< ADC_T::ADDR: OVERRUN Mask              */
S
S#define ADC_ADDR_VALID_Pos               (17)                                              /*!< ADC_T::ADDR: VALID Position            */
S#define ADC_ADDR_VALID_Msk               (0x1ul << ADC_ADDR_VALID_Pos)                     /*!< ADC_T::ADDR: VALID Mask                */
S
S#define ADC_ADCR_ADEN_Pos                (0)                                               /*!< ADC_T::ADCR: ADEN Position             */
S#define ADC_ADCR_ADEN_Msk                (0x1ul << ADC_ADCR_ADEN_Pos)                      /*!< ADC_T::ADCR: ADEN Mask                 */
S
S#define ADC_ADCR_ADIE_Pos                (1)                                               /*!< ADC_T::ADCR: ADIE Position             */
S#define ADC_ADCR_ADIE_Msk                (0x1ul << ADC_ADCR_ADIE_Pos)                      /*!< ADC_T::ADCR: ADIE Mask                 */
S
S#define ADC_ADCR_ADMD_Pos                (2)                                               /*!< ADC_T::ADCR: ADMD Position             */
S#define ADC_ADCR_ADMD_Msk                (0x3ul << ADC_ADCR_ADMD_Pos)                      /*!< ADC_T::ADCR: ADMD Mask                 */
S
S#define ADC_ADCR_TRGS_Pos                (4)                                               /*!< ADC_T::ADCR: TRGS Position             */
S#define ADC_ADCR_TRGS_Msk                (0x3ul << ADC_ADCR_TRGS_Pos)                      /*!< ADC_T::ADCR: TRGS Mask                 */
S
S#define ADC_ADCR_TRGCOND_Pos             (6)                                               /*!< ADC_T::ADCR: TRGCOND Position          */
S#define ADC_ADCR_TRGCOND_Msk             (0x3ul << ADC_ADCR_TRGCOND_Pos)                   /*!< ADC_T::ADCR: TRGCOND Mask              */
S
S#define ADC_ADCR_TRGEN_Pos               (8)                                               /*!< ADC_T::ADCR: TRGEN Position            */
S#define ADC_ADCR_TRGEN_Msk               (0x1ul << ADC_ADCR_TRGEN_Pos)                     /*!< ADC_T::ADCR: TRGEN Mask                */
S
S#define ADC_ADCR_PTEN_Pos                (9)                                               /*!< ADC_T::ADCR: PTEN Position             */
S#define ADC_ADCR_PTEN_Msk                (0x1ul << ADC_ADCR_PTEN_Pos)                      /*!< ADC_T::ADCR: PTEN Mask                 */
S
S#define ADC_ADCR_DIFFEN_Pos              (10)                                              /*!< ADC_T::ADCR: DIFFEN Position           */
S#define ADC_ADCR_DIFFEN_Msk              (0x1ul << ADC_ADCR_DIFFEN_Pos)                    /*!< ADC_T::ADCR: DIFFEN Mask               */
S
S#define ADC_ADCR_ADST_Pos                (11)                                              /*!< ADC_T::ADCR: ADST Position             */
S#define ADC_ADCR_ADST_Msk                (0x1ul << ADC_ADCR_ADST_Pos)                      /*!< ADC_T::ADCR: ADST Mask                 */
S
S#define ADC_ADCR_SMPTSEL_Pos             (16)                                              /*!< ADC_T::ADCR: SMPTSEL Position          */
S#define ADC_ADCR_SMPTSEL_Msk             (0x7ul << ADC_ADCR_SMPTSEL_Pos)                   /*!< ADC_T::ADCR: SMPTSEL Mask              */
S
S#define ADC_ADCR_DMOF_Pos                (31)                                              /*!< ADC_T::ADCR: DMOF Position             */
S#define ADC_ADCR_DMOF_Msk                (0x1ul << ADC_ADCR_DMOF_Pos)                      /*!< ADC_T::ADCR: DMOF Mask                 */
S
S#define ADC_ADCHER_CHEN_Pos              (0)                                               /*!< ADC_T::ADCHER: CHEN Position           */
S#define ADC_ADCHER_CHEN_Msk              (0xfffffffful << ADC_ADCHER_CHEN_Pos)             /*!< ADC_T::ADCHER: CHEN Mask               */
S
S#define ADC_ADCMPR_CMPEN_Pos             (0)                                               /*!< ADC_T::ADCMPR: CMPEN Position          */
S#define ADC_ADCMPR_CMPEN_Msk             (0x1ul << ADC_ADCMPR_CMPEN_Pos)                   /*!< ADC_T::ADCMPR: CMPEN Mask              */
S
S#define ADC_ADCMPR_CMPIE_Pos             (1)                                               /*!< ADC_T::ADCMPR: CMPIE Position          */
S#define ADC_ADCMPR_CMPIE_Msk             (0x1ul << ADC_ADCMPR_CMPIE_Pos)                   /*!< ADC_T::ADCMPR: CMPIE Mask              */
S
S#define ADC_ADCMPR_CMPCOND_Pos           (2)                                               /*!< ADC_T::ADCMPR: CMPCOND Position        */
S#define ADC_ADCMPR_CMPCOND_Msk           (0x1ul << ADC_ADCMPR_CMPCOND_Pos)                 /*!< ADC_T::ADCMPR: CMPCOND Mask            */
S
S#define ADC_ADCMPR_CMPCH_Pos             (3)                                               /*!< ADC_T::ADCMPR: CMPCH Position          */
S#define ADC_ADCMPR_CMPCH_Msk             (0x1ful << ADC_ADCMPR_CMPCH_Pos)                  /*!< ADC_T::ADCMPR: CMPCH Mask              */
S
S#define ADC_ADCMPR_CMPMATCNT_Pos         (8)                                               /*!< ADC_T::ADCMPR: CMPMATCNT Position      */
S#define ADC_ADCMPR_CMPMATCNT_Msk         (0xful << ADC_ADCMPR_CMPMATCNT_Pos)               /*!< ADC_T::ADCMPR: CMPMATCNT Mask          */
S
S#define ADC_ADCMPR_CMPWEN_Pos            (15)                                              /*!< ADC_T::ADCMPR: CMPWEN Position         */
S#define ADC_ADCMPR_CMPWEN_Msk            (0x1ul << ADC_ADCMPR_CMPWEN_Pos)                  /*!< ADC_T::ADCMPR: CMPWEN Mask             */
S
S#define ADC_ADCMPR_CMPD_Pos              (16)                                              /*!< ADC_T::ADCMPR: CMPD Position           */
S#define ADC_ADCMPR_CMPD_Msk              (0xffful << ADC_ADCMPR_CMPD_Pos)                  /*!< ADC_T::ADCMPR: CMPD Mask               */
S
S#define ADC_ADSR0_ADF_Pos                (0)                                               /*!< ADC_T::ADSR0: ADF Position             */
S#define ADC_ADSR0_ADF_Msk                (0x1ul << ADC_ADSR0_ADF_Pos)                      /*!< ADC_T::ADSR0: ADF Mask                 */
S
S#define ADC_ADSR0_CMPF0_Pos              (1)                                               /*!< ADC_T::ADSR0: CMPF0 Position           */
S#define ADC_ADSR0_CMPF0_Msk              (0x1ul << ADC_ADSR0_CMPF0_Pos)                    /*!< ADC_T::ADSR0: CMPF0 Mask               */
S
S#define ADC_ADSR0_CMPF1_Pos              (2)                                               /*!< ADC_T::ADSR0: CMPF1 Position           */
S#define ADC_ADSR0_CMPF1_Msk              (0x1ul << ADC_ADSR0_CMPF1_Pos)                    /*!< ADC_T::ADSR0: CMPF1 Mask               */
S
S#define ADC_ADSR0_BUSY_Pos               (7)                                               /*!< ADC_T::ADSR0: BUSY Position            */
S#define ADC_ADSR0_BUSY_Msk               (0x1ul << ADC_ADSR0_BUSY_Pos)                     /*!< ADC_T::ADSR0: BUSY Mask                */
S
S#define ADC_ADSR0_VALIDF_Pos             (8)                                               /*!< ADC_T::ADSR0: VALIDF Position          */
S#define ADC_ADSR0_VALIDF_Msk             (0x1ul << ADC_ADSR0_VALIDF_Pos)                   /*!< ADC_T::ADSR0: VALIDF Mask              */
S
S#define ADC_ADSR0_OVERRUNF_Pos           (16)                                              /*!< ADC_T::ADSR0: OVERRUNF Position        */
S#define ADC_ADSR0_OVERRUNF_Msk           (0x1ul << ADC_ADSR0_OVERRUNF_Pos)                 /*!< ADC_T::ADSR0: OVERRUNF Mask            */
S
S#define ADC_ADSR0_CHANNEL_Pos            (27)                                              /*!< ADC_T::ADSR0: CHANNEL Position         */
S#define ADC_ADSR0_CHANNEL_Msk            (0x1ful << ADC_ADSR0_CHANNEL_Pos)                 /*!< ADC_T::ADSR0: CHANNEL Mask             */
S
S#define ADC_ADSR1_VALID_Pos              (0)                                               /*!< ADC_T::ADSR1: VALID Position           */
S#define ADC_ADSR1_VALID_Msk              (0xfffffffful << ADC_ADSR1_VALID_Pos)             /*!< ADC_T::ADSR1: VALID Mask               */
S
S#define ADC_ADSR2_OVERRUN_Pos            (0)                                               /*!< ADC_T::ADSR2: OVERRUN Position         */
S#define ADC_ADSR2_OVERRUN_Msk            (0xfffffffful << ADC_ADSR2_OVERRUN_Pos)           /*!< ADC_T::ADSR2: OVERRUN Mask             */
S
S#define ADC_ADTDCR_PTDT_Pos              (0)                                               /*!< ADC_T::ADTDCR: PTDT Position           */
S#define ADC_ADTDCR_PTDT_Msk              (0xfful << ADC_ADTDCR_PTDT_Pos)                   /*!< ADC_T::ADTDCR: PTDT Mask               */
S
S#define ADC_ADPDMA_CURDAT_Pos            (0)                                               /*!< ADC_T::ADPDMA: CURDAT Position         */
S#define ADC_ADPDMA_CURDAT_Msk            (0x3fffful << ADC_ADPDMA_CURDAT_Pos)              /*!< ADC_T::ADPDMA: CURDAT Mask             */
S
S/**@}*/ /* ADC_CONST */
S/**@}*/ /* end of ADC register group */
S
S
S/*---------------------- System Clock Controller -------------------------*/
S/**
S    @addtogroup CLK System Clock Controller(CLK)
S    Memory Mapped Structure for CLK Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var CLK_T::PWRCTL
S     * Offset: 0x00  System Power-down Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |HXTEN     |HXT Enable Bit (Write Protect)
S     * |        |          |The bit default value is set by flash controller user configuration register CONFIG0 [26:24].
S     * |        |          |When the default clock source is from HXT, this bit is set to 1 automatically.
S     * |        |          |0 = 4~24 MHz External High Speed Crystal (HXT) Disabled.
S     * |        |          |1 = 4~24 MHz External High Speed Crystal (HXT) Enabled.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[1]     |LXTEN     |LXT Enable Bit (Write Protect)
S     * |        |          |0 = 32.768 KHz External Low Speed Crystal (LXT) Disabled.
S     * |        |          |1 = 32.768 KHz External Low Speed Crystal (LXT) Enabled.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[2]     |HIRCEN    |HIRC Enable Bit (Write Protect)
S     * |        |          |0 = 22.1184 MHz internal high speed RC oscillator (HIRC) Disabled.
S     * |        |          |1 = 22.1184 MHz internal high speed RC oscillator (HIRC) Enabled.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[3]     |LIRCEN    |LIRC Enable Bit (Write Protect)
S     * |        |          |0 = 10 kHz internal low speed RC oscillator (LIRC) Disabled.
S     * |        |          |1 = 10 kHz internal low speed RC oscillator (LIRC) Enabled.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[4]     |PDWKDLY   |Enable the Wake-up Delay Counter (Write Protect)
S     * |        |          |When the chip wakes up from Power-down mode, the clock control will delay certain clock cycles to wait system clock stable.
S     * |        |          |The delayed clock cycle is 4096 clock cycles when chip work at 4~24 MHz external high speed crystal oscillator (HXT), 256 clock cycles when chip work at 22.1184 MHz internal high speed RC oscillator (HIRC) and 512 clock cycles when chip work at 48 MHz internal high speed RC oscillator (HIRC48).
S     * |        |          |0 = Clock cycles delay Disabled.
S     * |        |          |1 = Clock cycles delay Enabled.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[5]     |PDWKIEN   |Power-down Mode Wake-up Interrupt Enable Bit (Write Protect)
S     * |        |          |0 = Power-down mode wake-up interrupt Disabled.
S     * |        |          |1 = Power-down mode wake-up interrupt Enabled.
S     * |        |          |Note1: The interrupt will occur when both PDWKIF and PDWKIEN are high.
S     * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[6]     |PDWKIF    |Power-down Mode Wake-up Interrupt Status
S     * |        |          |Set by u201CPower-down wake-up eventu201D, it indicates that resume from Power-down modeu201D
S     * |        |          |The flag is set if the EINT0~5, GPIO, USBD, UART0~2, WDT, ACMP01, BOD, EBOD, RTC, TMR0~3, I2C0~1 or USCI0~2 wake-up occurred.
S     * |        |          |Note1: Write 1 to clear the bit to 0.
S     * |        |          |Note2: This bit works only if PDWKIEN (CLK_PWRCTL[5]) set to 1.
S     * |[7]     |PDEN      |System Power-down Enable (Write Protect)
S     * |        |          |When this bit is set to 1, Power-down mode is enabled and chip keeps active till the CPU sleep mode is also active and then the chip enters Power-down mode.
S     * |        |          |When chip wakes up from Power-down mode, this bit is auto cleared.
S     * |        |          |Users need to set this bit again for next Power-down.
S     * |        |          |In Power-down mode, HXT, HIRC and the HIRC48 will be disabled in this mode, but LXT and LIRC are not controlled by Power-down mode.
S     * |        |          |In Power-down mode, the PLL and system clock are disabled, and ignored the clock source selection.
S     * |        |          |The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock source is from LXT or LIRC.
S     * |        |          |0 = Chip operating normally or chip in idle mode because of WFI command.
S     * |        |          |1 = Chip waits CPU sleep command WFI and then enters Power-down mode.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[11:10] |HXTGAIN   |HXT Gain Control Bit (Write Protect)
S     * |        |          |Gain control is used to enlarge the gain of crystal to make sure crystal work normally.
S     * |        |          |If gain control is enabled, crystal will consume more power than gain control off.
S     * |        |          |00 = HXT frequency is lower than from 8 MHz.
S     * |        |          |01 = HXT frequency is from 8 MHz to 12 MHz.
S     * |        |          |10 = HXT frequency is from 12 MHz to 16 MHz.
S     * |        |          |11 = HXT frequency is higher than 16 MHz.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[12]    |HXTSELTYP |HXT Crystal Type Select Bit (Write Protect)
S     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
S     * |        |          |0 = Select INV type.
S     * |        |          |1 = Select GM type.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[13]    |HIRC48EN  |HIRC48 Enable Bit (Write Protect)
S     * |        |          |0 = 48 MHz internal high speed RC oscillator (HIRC48) Disabled.
S     * |        |          |1 = 48 MHz internal high speed RC oscillator (HIRC48) Enabled.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * @var CLK_T::AHBCLK
S     * Offset: 0x04  AHB Devices Clock Enable Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |PDMACKEN  |PDMA Controller Clock Enable Bit
S     * |        |          |0 = PDMA peripheral clock Disabled.
S     * |        |          |1 = PDMA peripheral clock Enabled.
S     * |[2]     |ISPCKEN   |Flash ISP Controller Clock Enable Bit
S     * |        |          |0 = Flash ISP peripheral clock Disabled.
S     * |        |          |1 = Flash ISP peripheral clock Enabled.
S     * |[3]     |EBICKEN   |EBI Controller Clock Enable Bit
S     * |        |          |0 = EBI peripheral clock Disabled.
S     * |        |          |1 = EBI peripheral clock Enabled.
S     * |[4]     |HDIVCKEN  |Hardware Divider Controller Clock Enable Bit
S     * |        |          |0 = Hardware divider peripheral clock Disabled.
S     * |        |          |1 = Hardware divider peripheral clock Enabled.
S     * |[7]     |CRCCKEN   |CRC Generator Controller Clock Enable Bit
S     * |        |          |0 = CRC peripheral clock Disabled.
S     * |        |          |1 = CRC peripheral clock Enabled.
S     * |[15]    |FMCIDLE   |Flash Memory Controller Clock Enable Bit in IDLE Mode
S     * |        |          |0 = FMC peripheral clock Disabled when chip operating at IDLE mode.
S     * |        |          |1 = FMC peripheral clock Enabled when chip operating at IDLE mode.
S     * |[16]    |GPIOACKEN |General Purpose I/O PA Group Clock Enable Bit
S     * |        |          |0 = GPIO PA group clock Disabled.
S     * |        |          |1 = GPIO PA group clock Enabled.
S     * |[17]    |GPIOBCKEN |General Purpose I/O PB Group Clock Enable Bit
S     * |        |          |0 = GPIO PB group clock Disabled.
S     * |        |          |1 = GPIO PB group clock Enabled.
S     * |[18]    |GPIOCCKEN |General Purpose I/O PC Group Clock Enable Bit
S     * |        |          |0 = GPIO PC group clock Disabled.
S     * |        |          |1 = GPIO PC group clock Enabled.
S     * |[19]    |GPIODCKEN |General Purpose I/O PD Group Clock Enable Bit
S     * |        |          |0 = GPIO PD group clock Disabled.
S     * |        |          |1 = GPIO PD group clock Enabled.
S     * |[20]    |GPIOECKEN |General Purpose I/O PE Group Clock Enable Bit
S     * |        |          |0 = GPIO PE group clock Disabled.
S     * |        |          |1 = GPIO PE group clock Enabled.
S     * |[21]    |GPIOFCKEN |General Purpose I/O PF Group Clock Enable Bit
S     * |        |          |0 = GPIO PF group clock Disabled.
S     * |        |          |1 = GPIO PF group clock Enabled.
S     * @var CLK_T::APBCLK0
S     * Offset: 0x08  APB Devices Clock Enable Control Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WDTCKEN   |Watchdog Timer Clock Enable Bit (Write Protect)
S     * |        |          |0 = Watchdog Timer Clock Disabled.
S     * |        |          |1 = Watchdog Timer Clock Enabled.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[1]     |RTCCKEN   |Real-time-clock APB Interface Clock Enable Bit
S     * |        |          |This bit is used to control the RTC APB clock only
S     * |        |          |The RTC peripheral clock source is selected from RTCSEL(CLK_CLKSEL2[18]).
S     * |        |          |It can be selected to external 32.768 kHz low speed crystal (LXT) or 10 kHz internal low speed RC oscillator (LIRC).
S     * |        |          |0 = RTC Clock Disabled.
S     * |        |          |1 = RTC Clock Enabled.
S     * |[2]     |TMR0CKEN  |Timer0 Clock Enable Bit
S     * |        |          |0 = Timer0 Clock Disabled.
S     * |        |          |1 = Timer0 Clock Enabled.
S     * |[3]     |TMR1CKEN  |Timer1 Clock Enable Bit
S     * |        |          |0 = Timer1 Clock Disabled.
S     * |        |          |1 = Timer1 Clock Enabled.
S     * |[4]     |TMR2CKEN  |Timer2 Clock Enable Bit
S     * |        |          |0 = Timer2 Clock Disabled.
S     * |        |          |1 = Timer2 Clock Enabled.
S     * |[5]     |TMR3CKEN  |Timer3 Clock Enable Bit
S     * |        |          |0 = Timer3 Clock Disabled.
S     * |        |          |1 = Timer3 Clock Enabled.
S     * |[6]     |CLKOCKEN  |CLKO Clock Enable Bit
S     * |        |          |0 = CLKO Clock Disabled.
S     * |        |          |1 = CLKO Clock Enabled.
S     * |[8]     |I2C0CKEN  |I2C0 Clock Enable Bit
S     * |        |          |0 = I2C0 Clock Disabled.
S     * |        |          |1 = I2C0 Clock Enabled.
S     * |[9]     |I2C1CKEN  |I2C1 Clock Enable Bit
S     * |        |          |0 = I2C1 Clock Disabled.
S     * |        |          |1 = I2C1 Clock Enabled.
S     * |[12]    |SPI0CKEN  |SPI0 Clock Enable Bit
S     * |        |          |0 = SPI0 Clock Disabled.
S     * |        |          |1 = SPI0 Clock Enabled.
S     * |[13]    |SPI1CKEN  |SPI1 Clock Enable Bit
S     * |        |          |0 = SPI1 Clock Disabled.
S     * |        |          |1 = SPI1 Clock Enabled.
S     * |[16]    |UART0CKEN |UART0 Clock Enable Bit
S     * |        |          |0 = UART0 clock Disabled.
S     * |        |          |1 = UART0 clock Enabled.
S     * |[17]    |UART1CKEN |UART1 Clock Enable Bit
S     * |        |          |0 = UART1 clock Disabled.
S     * |        |          |1 = UART1 clock Enabled.
S     * |[18]    |UART2CKEN |UART2 Clock Enable Bit
S     * |        |          |0 = UART2 clock Disabled.
S     * |        |          |1 = UART2 clock Enabled.
S     * |[20]    |PWM0CKEN  |PWM0 Clock Enable Bit
S     * |        |          |0 = PWM0 clock Disabled.
S     * |        |          |1 = PWM0 clock Enabled.
S     * |[21]    |PWM1CKEN  |PWM1 Clock Enable Bit
S     * |        |          |0 = PWM1 clock Disabled.
S     * |        |          |1 = PWM1 clock Enabled.
S     * |[27]    |USBDCKEN  |USB Device Clock Enable Bit
S     * |        |          |0 = USB Device clock Disabled.
S     * |        |          |1 = USB Device clock Enabled.
S     * |[28]    |ADCCKEN   |Analog-digital-converter (ADC) Clock Enable Bit
S     * |        |          |0 = ADC clock Disabled.
S     * |        |          |1 = ADC clock Enabled.
S     * |[30]    |ACMP01CKEN|Analog Comparator 0/1 Clock Enable Bit
S     * |        |          |0 = Analog Comparator 0/1 clock Disabled.
S     * |        |          |1 = Analog Comparator 0/1 clock Enabled.
S     * @var CLK_T::STATUS
S     * Offset: 0x0C  Clock Status Monitor Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |HXTSTB    |HXT Clock Source Stable Flag (Read Only)
S     * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT) clock is not stable or disabled.
S     * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT)clock is stable and enabled.
S     * |[1]     |LXTSTB    |LXT Clock Source Stable Flag (Read Only)
S     * |        |          |0 = 32.768 kHz external low speed crystal oscillator (LXT) clock is not stable or disabled.
S     * |        |          |1 = 32.768 kHz external low speed crystal oscillator (LXT) clock is stabled and enabled.
S     * |[2]     |PLLSTB    |Internal PLL Clock Source Stable Flag (Read Only)
S     * |        |          |0 = Internal PLL clock is not stable or disabled.
S     * |        |          |1 = Internal PLL clock is stable and enabled.
S     * |[3]     |LIRCSTB   |LIRC Clock Source Stable Flag (Read Only)
S     * |        |          |0 = 10 kHz internal low speed RC oscillator (LIRC) clock is not stable or disabled.
S     * |        |          |1 = 10 kHz internal low speed RC oscillator (LIRC) clock is stable and enabled.
S     * |[4]     |HIRCSTB   |HIRC Clock Source Stable Flag (Read Only)
S     * |        |          |0 = 22.1184 MHz internal high speed RC oscillator (HIRC) clock is not stable or disabled.
S     * |        |          |1 = 22.1184 MHz internal high speed RC oscillator (HIRC) clock is stable and enabled.
S     * |[5]     |HIRC48STB |HIRC48 Clock Source Stable Flag (Read Only)
S     * |        |          |0 = 48 MHz internal high speed RC oscillator (HIRC48) clock is not stable or disabled.
S     * |        |          |1 = 48 MHz internal high speed RC oscillator (HIRC48) clock is stable and enabled.
S     * |[7]     |CLKSFAIL  |Clock Switching Fail Flag (Read Only)
S     * |        |          |This bit is updated when software switches system clock source.
S     * |        |          |If switch target clock is stable, this bit will be set to 0.
S     * |        |          |If switch target clock is not stable, this bit will be set to 1.
S     * |        |          |0 = Clock switching success.
S     * |        |          |1 = Clock switching failure.
S     * |        |          |Note: This bit is read only.
S     * |        |          |After selected clock source is stable, hardware will switch system clock to selected clock automatically, and CLKSFAIL will be cleared automatically by hardware.
S     * @var CLK_T::CLKSEL0
S     * Offset: 0x10  Clock Source Select Control Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2:0]   |HCLKSEL   |HCLK Clock Source Selection (Write Protect)
S     * |        |          |Before clock switching, the related clock sources (both pre-select and new-select) must be turned on.
S     * |        |          |The default value is reloaded from the value of CFOSC (CONFIG0[26:24]) in user configuration register of Flash controller by any reset.
S     * |        |          |Therefore the default value is either 000b or 111b.
S     * |        |          |000 = Clock source from HXT.
S     * |        |          |001 = Clock source from LXT.
S     * |        |          |010 = Clock source from PLL clock.
S     * |        |          |011 = Clock source from LIRC.
S     * |        |          |100 = Clock source from HIRC48.
S     * |        |          |111 = Clock source from HIRC clock.
S     * |        |          |Others = Reserved.
S     * |        |          |Note: These bits are write protected. Refer to the SYS_REGLCTL register.
S     * |[5:3]   |STCLKSEL  |Cortex-M0 SysTick Clock Source Selection (Write Protect)
S     * |        |          |If SYST_CTRL[2]=0, SysTick uses listed clock source below.
S     * |        |          |000 = Clock source from HXT.
S     * |        |          |001 = Clock source from LXT.
S     * |        |          |010 = Clock source from HXT/2.
S     * |        |          |011 = Clock source from HCLK/2.
S     * |        |          |111 = Clock source from HIRC/2.
S     * |        |          |Note1: if SysTick clock source is not from HCLK (i.e. SYST_CTRL[2] = 0), SysTick clock source must less than or equal to HCLK/2.
S     * |        |          |Note2: These bits are write protected. Refer to the SYS_REGLCTL register.
S     * |[6]     |PCLK0SEL  |PCLK0 Clock Source Selection (Write Protect)
S     * |        |          |0 = APB0 BUS clock source from HCLK.
S     * |        |          |1 = APB0 BUS clock source from HCLK/2.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[7]     |PCLK1SEL  |PCLK1 Clock Source Selection (Write Protect)
S     * |        |          |0 = APB1 BUS clock source from HCLK.
S     * |        |          |1 = APB1 BUS clock source from HCLK/2.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * @var CLK_T::CLKSEL1
S     * Offset: 0x14  Clock Source Select Control Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |WDTSEL    |Watchdog Timer Clock Source Selection (Write Protect)
S     * |        |          |00 = Reserved.
S     * |        |          |01 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT) clock.
S     * |        |          |10 = Clock source from HCLK/2048 clock.
S     * |        |          |11 = Clock source from 10 kHz internal low speed RC oscillator (LIRC) clock.
S     * |        |          |Note: This These bits is are write protected. Refer to the SYS_REGLCTL register.
S     * |[3:2]   |ADCSEL    |ADC Clock Source Selection
S     * |        |          |00 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
S     * |        |          |01 = Clock source from PLL.
S     * |        |          |10 = Clock source from PCLK0.
S     * |        |          |11 = Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC) clock.
S     * |[10:8]  |TMR0SEL   |TIMER0 Clock Source Selection
S     * |        |          |000 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
S     * |        |          |001 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT) clock.
S     * |        |          |010 = Clock source from PCLK0.
S     * |        |          |011 = Clock source from external clock T0 pin.
S     * |        |          |101 = Clock source from 10 kHz internal low speed RC oscillator (LIRC) clock.
S     * |        |          |111 = Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC) clock.
S     * |        |          |Others = Reserved.
S     * |[14:12] |TMR1SEL   |TIMER1 Clock Source Selection
S     * |        |          |000 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
S     * |        |          |001 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT) clock.
S     * |        |          |010 = Clock source from PCLK0.
S     * |        |          |011 = Clock source from external clock T1 pin.
S     * |        |          |101 = Clock source from 10 kHz internal low speed RC oscillator (LIRC) clock.
S     * |        |          |111 = Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC) clock.
S     * |        |          |Others = Reserved.
S     * |[18:16] |TMR2SEL   |TIMER2 Clock Source Selection
S     * |        |          |000 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
S     * |        |          |001 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT) clock.
S     * |        |          |010 = Clock source from PCLK1.
S     * |        |          |011 = Clock source from external clock T2 pin.
S     * |        |          |101 = Clock source from 10 kHz internal low speed RC oscillator (LIRC) clock.
S     * |        |          |111 = Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC) clock.
S     * |        |          |Others = Reserved.
S     * |[22:20] |TMR3SEL   |TIMER3 Clock Source Selection
S     * |        |          |000 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
S     * |        |          |001 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT) clock.
S     * |        |          |010 = Clock source from PCLK1.
S     * |        |          |011 = Clock source from external clock T3 pin.
S     * |        |          |101 = Clock source from 10 kHz internal low speed RC oscillator (LIRC) clock.
S     * |        |          |111 = Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC) clock.
S     * |        |          |Others = Reserved.
S     * |[25:24] |UARTSEL   |UART Clock Source Selection
S     * |        |          |00 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
S     * |        |          |01 = Clock source from PLL clock.
S     * |        |          |10 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT) clock.
S     * |        |          |11 = Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC) clock.
S     * |[28]    |PWM0SEL   |PWM0 Clock Source Selection
S     * |        |          |The peripheral clock source of PWM0 is defined by PWM0SEL.
S     * |        |          |0 = Clock source from PLL clock.
S     * |        |          |1 = Clock source from PCLK0.
S     * |[29]    |PWM1SEL   |PWM1 Clock Source Selection
S     * |        |          |The peripheral clock source of PWM1 is defined by PWM1SEL.
S     * |        |          |0 = Clock source from PLL clock.
S     * |        |          |1 = Clock source from PCLK1.
S     * @var CLK_T::CLKDIV0
S     * Offset: 0x18  Clock Divider Number Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |HCLKDIV   |HCLK Clock Divide Number From HCLK Clock Source
S     * |        |          |HCLK clock frequency = (HCLK clock source frequency) / (HCLKDIV + 1).
S     * |[7:4]   |USBDIV    |USB Clock Divide Number From PLL Clock
S     * |        |          |USB clock frequency = (PLL clock source frequency) / (USBDIV + 1).
S     * |        |          |Note: If the HIRC48 is selected, it is delivery to USB clock directly.
S     * |[11:8]  |UARTDIV   |UART Clock Divide Number From UART Clock Source
S     * |        |          |UART clock frequency = (UART clock source frequency) / (UARTDIV + 1).
S     * |[23:16] |ADCDIV    |ADC Clock Divide Number From ADC Clock Source
S     * |        |          |ADC clock frequency = (ADC clock source frequency) / (ADCDIV + 1).
S     * @var CLK_T::CLKSEL2
S     * Offset: 0x1C  Clock Source Select Control Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[4:2]   |CLKOSEL   |Clock Divider Clock Source Selection
S     * |        |          |000 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
S     * |        |          |001 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT) clock.
S     * |        |          |010 = Clock source from HCLK.
S     * |        |          |011 = Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC) clock.
S     * |        |          |100 = Clock source from SOF (USB start of frame event).
S     * |        |          |101 = Clock source from 48 MHz internal high speed RC oscillator (HIRC48) clock.
S     * |        |          |Others = Reserved.
S     * |[17:16] |WWDTSEL   |Window Watchdog Timer Clock Source Selection
S     * |        |          |10 = Clock source from HCLK/2048 clock.
S     * |        |          |11 = Clock source from 10 kHz internal low speed RC oscillator (LIRC).
S     * |        |          |Others = Reserved.
S     * |[18]    |RTCSEL    |RTC Clock Source Selection
S     * |        |          |0 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT).
S     * |        |          |1 = Clock source from 10 kHz internal low speed RC oscillator (LIRC).
S     * |[25:24] |SPI0SEL   |SPI0 Clock Source Selection
S     * |        |          |00 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
S     * |        |          |01 = Clock source from PLL clock.
S     * |        |          |10 = Clock source from PCLK0.
S     * |        |          |11 = Clock source from 48 MHz internal high speed RC oscillator (HIRC48) clock.
S     * |[27:26] |SPI1SEL   |SPI1 Clock Source Selection
S     * |        |          |00 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
S     * |        |          |01 = Clock source from PLL clock.
S     * |        |          |10 = Clock source from PCLK0.
S     * |        |          |11 = Clock source from 48 MHz internal high speed RC oscillator (HIRC48) clock.
S     * @var CLK_T::PLLCTL
S     * Offset: 0x20  PLL Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[8:0]   |FBDIV     |PLL Feedback Divider Control
S     * |        |          |Refer to the PLL formulas.
S     * |[13:9]  |INDIV     |PLL Input Divider Control
S     * |        |          |Refer to the PLL formulas.
S     * |[15:14] |OUTDIV    |PLL Output Divider Control
S     * |        |          |Refer to the PLL formulas.
S     * |[16]    |PD        |Power-down Mode
S     * |        |          |If set PDEN(CLK_PWRCTL[7]) bit to 1, the PLL will enter Power-down mode, too.
S     * |        |          |0 = PLL is in normal mode.
S     * |        |          |1 = PLL is in Power-down mode (default).
S     * |[17]    |BP        |PLL Bypass Control
S     * |        |          |0 = PLL is in normal mode (default).
S     * |        |          |1 = PLL clock output is same as PLL input clock.
S     * |[18]    |OE        |PLL OE (FOUT Enable) Control
S     * |        |          |0 = PLL FOUT Enabled.
S     * |        |          |1 = PLL FOUT is fixed low.
S     * |[19]    |PLLSRC    |PLL Source Clock Selection
S     * |        |          |0 = PLL source clock from external 4~24 MHz high-speed crystal (HXT).
S     * |        |          |1 = PLL source clock from internal 22.1184 MHz high-speed oscillator (HIRC).
S     * |[23]    |STBSEL    |PLL Stable Counter Selection
S     * |        |          |0 = PLL stable time is 6144 PLL source clock (suitable for source clock is equal to or less than 12MHz).
S     * |        |          |1 = PLL stable time is 12288 PLL source clock (suitable for source clock is larger than 12MHz).
S     * @var CLK_T::CLKOCTL
S     * Offset: 0x24  Clock Output Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |FREQSEL   |Clock Output Frequency Selection
S     * |        |          |The formula of output frequency is Fout = Fin/2(N+1).
S     * |        |          |Fin is the input clock frequency.
S     * |        |          |Fout is the frequency of divider output clock.
S     * |        |          |N is the 4-bit value of FREQSEL[3:0].
S     * |[4]     |CLKOEN    |Clock Output Enable Bit
S     * |        |          |0 = Clock Output function Disabled.
S     * |        |          |1 = Clock Output function Enabled.
S     * |[5]     |DIV1EN    |Clock Output Divide One Enable Bit
S     * |        |          |0 = Clock Output will output clock with source frequency divided by FREQSEL.
S     * |        |          |1 = Clock Output will output clock with source frequency.
S     * |[6]     |CLK1HZEN  |Clock Output 1Hz Enable Bit
S     * |        |          |0 = 1 Hz clock output for 32.768 kHz external low speed crystal oscillator (LXT) frequency compensation Disabled.
S     * |        |          |1 = 1 Hz clock output for 32.768 kHz external low speed crystal oscillator (LXT) frequency compensation Enabled.
S     * @var CLK_T::APBCLK1
S     * Offset: 0x30  APB Devices Clock Enable Control Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SC0CKEN   |SC0 Clock Enable Bit
S     * |        |          |0 = SC0 Clock Disabled.
S     * |        |          |1 = SC0 Clock Enabled.
S     * |[1]     |SC1CKEN   |SC1 Clock Enable Bit
S     * |        |          |0 = SC1 clock Disabled.
S     * |        |          |1 = SC1 clock Enabled.
S     * |[8]     |USCI0CKEN |USCI0 Clock Enable Bit
S     * |        |          |0 = USCI0 clock Disabled.
S     * |        |          |1 = USCI0 clock Enabled.
S     * |[9]     |USCI1CKEN |USCI1 Clock Enable Bit
S     * |        |          |0 = USCI1 clock Disabled.
S     * |        |          |1 = USCI1 clock Enabled.
S     * |[10]    |USCI2CKEN |USCI2 Clock Enable Bit
S     * |        |          |0 = USCI2 clock Disabled.
S     * |        |          |1 = USCI2 clock Enabled.
S     * @var CLK_T::CLKSEL3
S     * Offset: 0x34  Clock Source Select Control Register 3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |SC0SEL    |SC0 Clock Source Selection
S     * |        |          |00 = Clock source from 4~24 MHz external high speed crystal oscillator(HXT) clock.
S     * |        |          |01 = Clock source from PLL clock.
S     * |        |          |10 = Clock source from PCLK1.
S     * |        |          |11 = Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC) clock.
S     * |[3:2]   |SC1SEL    |SC1 Clock Source Selection
S     * |        |          |00 = Clock source from 4~24 MHz external high speed crystal oscillator (HXT) clock.
S     * |        |          |01 = Clock source from PLL clock.
S     * |        |          |10 = Clock source from PCLK1.
S     * |        |          |11 = Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC) clock.
S     * |[8]     |USBDSEL   |USBD Clock Source Selection (Write Protect)
S     * |        |          |0 = Clock source from 48MHz internal hight speed RC oscillator (HIRC48) clock.
S     * |        |          |1 = Clock source from PLL clock.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * @var CLK_T::CLKDIV1
S     * Offset: 0x38  Clock Divider Number Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |SC0DIV    |SC0 Clock Divide Number From SC0 Clock Source
S     * |        |          |SC0 clock frequency = (SC0 clock source frequency ) / (SC0DIV + 1).
S     * |[15:8]  |SC1DIV    |SC1 Clock Divide Number From SC1 Clock Source
S     * |        |          |SC1 clock frequency = (SC1 clock source frequency ) / (SC1DIV + 1).
S     * @var CLK_T::BODCLK
S     * Offset: 0x40  Clock Source Select for BOD Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |EBODCKSEL |Clock Source Selection for External BOD
S     * |        |          |The EXTBOD external BOD clock source for detecting external input voltage is defined by EBODCKSEL.
S     * |        |          |0 = Clock source is from 10 kHz internal low speed RC oscillator (LIRC) clock.
S     * |        |          |1 = Clock source is from 32.768 kHz external low speed crystal oscillator (LXT) clock.
S     * |        |          |Note1: If LIRC is selected, LIRCEN (CLK_PWRCTL[3]) must be enabled.
S     * |        |          |Note2: If LXT is selected, LXTEN (CLK_PWRCTL[1]) must be enabled.
S     * @var CLK_T::CLKDCTL
S     * Offset: 0x70  Clock Fail Detector Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[4]     |HXTFDEN   |HXT Clock Fail Detector Enable Bit
S     * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT) clock Fail detector Disabled.
S     * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT) clock Fail detector Enabled.
S     * |[5]     |HXTFIEN   |HXT Clock Fail Interrupt Enable Bit
S     * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT)clock Fail interrupt Disabled.
S     * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT)clock Fail interrupt Enabled.
S     * |[12]    |LXTFDEN   |LXT Clock Fail Detector Enable Bit
S     * |        |          |0 = 32.768 kHz external low speed crystal oscillator (LXT) clock Fail detector Disabled.
S     * |        |          |1 = 32.768 kHz external low speed crystal oscillator (LXT) clock Fail detector Enabled.
S     * |[13]    |LXTFIEN   |LXT Clock Fail Interrupt Enable Bit
S     * |        |          |0 = 32.768 kHz external low speed crystal oscillator (LXT) clock Fail interrupt Disabled.
S     * |        |          |1 = 32.768 kHz external low speed crystal oscillator (LXT) clock Fail interrupt Enabled.
S     * |[16]    |HXTFQDEN  |HXT Clock Frequency Monitor Enable Bit
S     * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT) clock frequency monitor Disabled.
S     * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT) clock frequency monitor Enabled.
S     * |[17]    |HXTFQIEN  |HXT Clock Frequency Monitor Interrupt Enable Bit
S     * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT) clock frequency monitor fail interrupt Disabled.
S     * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT) clock frequency monitor fail interrupt Enabled.
S     * @var CLK_T::CLKDSTS
S     * Offset: 0x74  Clock Fail Detector Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |HXTFIF    |HXT Clock Fail Interrupt Flag (Write Protect)
S     * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT) clock normal.
S     * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT) clock stop.
S     * |        |          |Note1: This bit can be cleared to 0 by software writing 1.
S     * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[1]     |LXTFIF    |LXT Clock Fail Interrupt Flag (Write Protect)
S     * |        |          |0 = 32.768 kHz external low speed crystal oscillator (LXT) clock normal.
S     * |        |          |1 = 32.768 kHz external low speed crystal oscillator (LXT) stop.
S     * |        |          |Note1: This bit can be cleared to 0 by software writing 1.
S     * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[8]     |HXTFQIF   |HXT Clock Frequency Monitor Interrupt Flag (Write Protect)
S     * |        |          |0 = 4~24 MHz external high speed crystal oscillator (HXT) clock normal.
S     * |        |          |1 = 4~24 MHz external high speed crystal oscillator (HXT) clock frequency abnormal.
S     * |        |          |Note1: This bit can be cleared to 0 by software writing 1.
S     * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * @var CLK_T::CDUPB
S     * Offset: 0x78  Clock Frequency Detector Upper Boundary Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[9:0]   |UPERBD    |HXT Clock Frequency Detector Upper Boundary
S     * |        |          |The bits define the high value of frequency monitor window.
S     * |        |          |When HXT frequency monitor value higher than this register, the HXT frequency detect fail interrupt flag will set to 1.
S     * @var CLK_T::CDLOWB
S     * Offset: 0x7C  Clock Frequency Detector Low Boundary Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[9:0]   |LOWERBD   |HXT Clock Frequency Detector Low Boundary
S     * |        |          |The bits define the low value of frequency monitor window.
S     * |        |          |When HXT frequency monitor value lower than this register, the HXT frequency detect fail interrupt flag will set to 1.
S     */
S
S
S    __IO uint32_t PWRCTL;                /*!< [0x0000] System Power-down Control Register                               */
S    __IO uint32_t AHBCLK;                /*!< [0x0004] AHB Devices Clock Enable Control Register                        */
S    __IO uint32_t APBCLK0;               /*!< [0x0008] APB Devices Clock Enable Control Register 0                      */
S    __I  uint32_t STATUS;                /*!< [0x000c] Clock Status Monitor Register                                    */
S    __IO uint32_t CLKSEL0;               /*!< [0x0010] Clock Source Select Control Register 0                           */
S    __IO uint32_t CLKSEL1;               /*!< [0x0014] Clock Source Select Control Register 1                           */
S    __IO uint32_t CLKDIV0;               /*!< [0x0018] Clock Divider Number Register 0                                  */
S    __IO uint32_t CLKSEL2;               /*!< [0x001c] Clock Source Select Control Register 2                           */
S    __IO uint32_t PLLCTL;                /*!< [0x0020] PLL Control Register                                             */
S    __IO uint32_t CLKOCTL;               /*!< [0x0024] Clock Output Control Register                                    */
S    __I  uint32_t RESERVE0[2];
S    __IO uint32_t APBCLK1;               /*!< [0x0030] APB Devices Clock Enable Control Register 1                      */
S    __IO uint32_t CLKSEL3;               /*!< [0x0034] Clock Source Select Control Register 3                           */
S    __IO uint32_t CLKDIV1;               /*!< [0x0038] Clock Divider Number Register 1                                  */
S    __I  uint32_t RESERVE1[1];
S    __IO uint32_t BODCLK;                /*!< [0x0040] Clock Source Select for BOD Control Register                     */
S    __I  uint32_t RESERVE2[11];
S    __IO uint32_t CLKDCTL;               /*!< [0x0070] Clock Fail Detector Control Register                             */
S    __IO uint32_t CLKDSTS;               /*!< [0x0074] Clock Fail Detector Status Register                              */
S    __IO uint32_t CDUPB;                 /*!< [0x0078] Clock Frequency Detector Upper Boundary Register                 */
S    __IO uint32_t CDLOWB;                /*!< [0x007c] Clock Frequency Detector Low Boundary Register                   */
S
S
S} CLK_T;
S
S/**
S    @addtogroup CLK_CONST CLK Bit Field Definition
S    Constant Definitions for CLK Controller
S@{ */
S
S#define CLK_PWRCTL_HXTEN_Pos             (0)                                               /*!< CLK_T::PWRCTL: HXTEN Position          */
S#define CLK_PWRCTL_HXTEN_Msk             (0x1ul << CLK_PWRCTL_HXTEN_Pos)                   /*!< CLK_T::PWRCTL: HXTEN Mask              */
S
S#define CLK_PWRCTL_LXTEN_Pos             (1)                                               /*!< CLK_T::PWRCTL: LXTEN Position          */
S#define CLK_PWRCTL_LXTEN_Msk             (0x1ul << CLK_PWRCTL_LXTEN_Pos)                   /*!< CLK_T::PWRCTL: LXTEN Mask              */
S
S#define CLK_PWRCTL_HIRCEN_Pos            (2)                                               /*!< CLK_T::PWRCTL: HIRCEN Position         */
S#define CLK_PWRCTL_HIRCEN_Msk            (0x1ul << CLK_PWRCTL_HIRCEN_Pos)                  /*!< CLK_T::PWRCTL: HIRCEN Mask             */
S
S#define CLK_PWRCTL_LIRCEN_Pos            (3)                                               /*!< CLK_T::PWRCTL: LIRCEN Position         */
S#define CLK_PWRCTL_LIRCEN_Msk            (0x1ul << CLK_PWRCTL_LIRCEN_Pos)                  /*!< CLK_T::PWRCTL: LIRCEN Mask             */
S
S#define CLK_PWRCTL_PDWKDLY_Pos           (4)                                               /*!< CLK_T::PWRCTL: PDWKDLY Position        */
S#define CLK_PWRCTL_PDWKDLY_Msk           (0x1ul << CLK_PWRCTL_PDWKDLY_Pos)                 /*!< CLK_T::PWRCTL: PDWKDLY Mask            */
S
S#define CLK_PWRCTL_PDWKIEN_Pos           (5)                                               /*!< CLK_T::PWRCTL: PDWKIEN Position        */
S#define CLK_PWRCTL_PDWKIEN_Msk           (0x1ul << CLK_PWRCTL_PDWKIEN_Pos)                 /*!< CLK_T::PWRCTL: PDWKIEN Mask            */
S
S#define CLK_PWRCTL_PDWKIF_Pos            (6)                                               /*!< CLK_T::PWRCTL: PDWKIF Position         */
S#define CLK_PWRCTL_PDWKIF_Msk            (0x1ul << CLK_PWRCTL_PDWKIF_Pos)                  /*!< CLK_T::PWRCTL: PDWKIF Mask             */
S
S#define CLK_PWRCTL_PDEN_Pos              (7)                                               /*!< CLK_T::PWRCTL: PDEN Position           */
S#define CLK_PWRCTL_PDEN_Msk              (0x1ul << CLK_PWRCTL_PDEN_Pos)                    /*!< CLK_T::PWRCTL: PDEN Mask               */
S
S#define CLK_PWRCTL_HXTGAIN_Pos           (10)                                              /*!< CLK_T::PWRCTL: HXTGAIN Position        */
S#define CLK_PWRCTL_HXTGAIN_Msk           (0x3ul << CLK_PWRCTL_HXTGAIN_Pos)                 /*!< CLK_T::PWRCTL: HXTGAIN Mask            */
S
S#define CLK_PWRCTL_HXTSELTYP_Pos         (12)                                              /*!< CLK_T::PWRCTL: HXTSELTYP Position      */
S#define CLK_PWRCTL_HXTSELTYP_Msk         (0x1ul << CLK_PWRCTL_HXTSELTYP_Pos)               /*!< CLK_T::PWRCTL: HXTSELTYP Mask          */
S
S#define CLK_PWRCTL_HIRC48EN_Pos          (13)                                              /*!< CLK_T::PWRCTL: HIRC48EN Position       */
S#define CLK_PWRCTL_HIRC48EN_Msk          (0x1ul << CLK_PWRCTL_HIRC48EN_Pos)                /*!< CLK_T::PWRCTL: HIRC48EN Mask           */
S
S#define CLK_AHBCLK_PDMACKEN_Pos          (1)                                               /*!< CLK_T::AHBCLK: PDMACKEN Position       */
S#define CLK_AHBCLK_PDMACKEN_Msk          (0x1ul << CLK_AHBCLK_PDMACKEN_Pos)                /*!< CLK_T::AHBCLK: PDMACKEN Mask           */
S
S#define CLK_AHBCLK_ISPCKEN_Pos           (2)                                               /*!< CLK_T::AHBCLK: ISPCKEN Position        */
S#define CLK_AHBCLK_ISPCKEN_Msk           (0x1ul << CLK_AHBCLK_ISPCKEN_Pos)                 /*!< CLK_T::AHBCLK: ISPCKEN Mask            */
S
S#define CLK_AHBCLK_EBICKEN_Pos           (3)                                               /*!< CLK_T::AHBCLK: EBICKEN Position        */
S#define CLK_AHBCLK_EBICKEN_Msk           (0x1ul << CLK_AHBCLK_EBICKEN_Pos)                 /*!< CLK_T::AHBCLK: EBICKEN Mask            */
S
S#define CLK_AHBCLK_HDIVCKEN_Pos          (4)                                               /*!< CLK_T::AHBCLK: HDIVCKEN Position       */
S#define CLK_AHBCLK_HDIVCKEN_Msk          (0x1ul << CLK_AHBCLK_HDIVCKEN_Pos)                /*!< CLK_T::AHBCLK: HDIVCKEN Mask           */
S
S#define CLK_AHBCLK_CRCCKEN_Pos           (7)                                               /*!< CLK_T::AHBCLK: CRCCKEN Position        */
S#define CLK_AHBCLK_CRCCKEN_Msk           (0x1ul << CLK_AHBCLK_CRCCKEN_Pos)                 /*!< CLK_T::AHBCLK: CRCCKEN Mask            */
S
S#define CLK_AHBCLK_FMCIDLE_Pos           (15)                                              /*!< CLK_T::AHBCLK: FMCIDLE Position        */
S#define CLK_AHBCLK_FMCIDLE_Msk           (0x1ul << CLK_AHBCLK_FMCIDLE_Pos)                 /*!< CLK_T::AHBCLK: FMCIDLE Mask            */
S
S#define CLK_AHBCLK_GPIOACKEN_Pos         (16)                                              /*!< CLK_T::AHBCLK: GPIOACKEN Position      */
S#define CLK_AHBCLK_GPIOACKEN_Msk         (0x1ul << CLK_AHBCLK_GPIOACKEN_Pos)               /*!< CLK_T::AHBCLK: GPIOACKEN Mask          */
S
S#define CLK_AHBCLK_GPIOBCKEN_Pos         (17)                                              /*!< CLK_T::AHBCLK: GPIOBCKEN Position      */
S#define CLK_AHBCLK_GPIOBCKEN_Msk         (0x1ul << CLK_AHBCLK_GPIOBCKEN_Pos)               /*!< CLK_T::AHBCLK: GPIOBCKEN Mask          */
S
S#define CLK_AHBCLK_GPIOCCKEN_Pos         (18)                                              /*!< CLK_T::AHBCLK: GPIOCCKEN Position      */
S#define CLK_AHBCLK_GPIOCCKEN_Msk         (0x1ul << CLK_AHBCLK_GPIOCCKEN_Pos)               /*!< CLK_T::AHBCLK: GPIOCCKEN Mask          */
S
S#define CLK_AHBCLK_GPIODCKEN_Pos         (19)                                              /*!< CLK_T::AHBCLK: GPIODCKEN Position      */
S#define CLK_AHBCLK_GPIODCKEN_Msk         (0x1ul << CLK_AHBCLK_GPIODCKEN_Pos)               /*!< CLK_T::AHBCLK: GPIODCKEN Mask          */
S
S#define CLK_AHBCLK_GPIOECKEN_Pos         (20)                                              /*!< CLK_T::AHBCLK: GPIOECKEN Position      */
S#define CLK_AHBCLK_GPIOECKEN_Msk         (0x1ul << CLK_AHBCLK_GPIOECKEN_Pos)               /*!< CLK_T::AHBCLK: GPIOECKEN Mask          */
S
S#define CLK_AHBCLK_GPIOFCKEN_Pos         (21)                                              /*!< CLK_T::AHBCLK: GPIOFCKEN Position      */
S#define CLK_AHBCLK_GPIOFCKEN_Msk         (0x1ul << CLK_AHBCLK_GPIOFCKEN_Pos)               /*!< CLK_T::AHBCLK: GPIOFCKEN Mask          */
S
S#define CLK_APBCLK0_WDTCKEN_Pos          (0)                                               /*!< CLK_T::APBCLK0: WDTCKEN Position       */
S#define CLK_APBCLK0_WDTCKEN_Msk          (0x1ul << CLK_APBCLK0_WDTCKEN_Pos)                /*!< CLK_T::APBCLK0: WDTCKEN Mask           */
S
S#define CLK_APBCLK0_RTCCKEN_Pos          (1)                                               /*!< CLK_T::APBCLK0: RTCCKEN Position       */
S#define CLK_APBCLK0_RTCCKEN_Msk          (0x1ul << CLK_APBCLK0_RTCCKEN_Pos)                /*!< CLK_T::APBCLK0: RTCCKEN Mask           */
S
S#define CLK_APBCLK0_TMR0CKEN_Pos         (2)                                               /*!< CLK_T::APBCLK0: TMR0CKEN Position      */
S#define CLK_APBCLK0_TMR0CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR0CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR0CKEN Mask          */
S
S#define CLK_APBCLK0_TMR1CKEN_Pos         (3)                                               /*!< CLK_T::APBCLK0: TMR1CKEN Position      */
S#define CLK_APBCLK0_TMR1CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR1CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR1CKEN Mask          */
S
S#define CLK_APBCLK0_TMR2CKEN_Pos         (4)                                               /*!< CLK_T::APBCLK0: TMR2CKEN Position      */
S#define CLK_APBCLK0_TMR2CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR2CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR2CKEN Mask          */
S
S#define CLK_APBCLK0_TMR3CKEN_Pos         (5)                                               /*!< CLK_T::APBCLK0: TMR3CKEN Position      */
S#define CLK_APBCLK0_TMR3CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR3CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR3CKEN Mask          */
S
S#define CLK_APBCLK0_CLKOCKEN_Pos         (6)                                               /*!< CLK_T::APBCLK0: CLKOCKEN Position      */
S#define CLK_APBCLK0_CLKOCKEN_Msk         (0x1ul << CLK_APBCLK0_CLKOCKEN_Pos)               /*!< CLK_T::APBCLK0: CLKOCKEN Mask          */
S
S#define CLK_APBCLK0_I2C0CKEN_Pos         (8)                                               /*!< CLK_T::APBCLK0: I2C0CKEN Position      */
S#define CLK_APBCLK0_I2C0CKEN_Msk         (0x1ul << CLK_APBCLK0_I2C0CKEN_Pos)               /*!< CLK_T::APBCLK0: I2C0CKEN Mask          */
S
S#define CLK_APBCLK0_I2C1CKEN_Pos         (9)                                               /*!< CLK_T::APBCLK0: I2C1CKEN Position      */
S#define CLK_APBCLK0_I2C1CKEN_Msk         (0x1ul << CLK_APBCLK0_I2C1CKEN_Pos)               /*!< CLK_T::APBCLK0: I2C1CKEN Mask          */
S
S#define CLK_APBCLK0_SPI0CKEN_Pos         (12)                                              /*!< CLK_T::APBCLK0: SPI0CKEN Position      */
S#define CLK_APBCLK0_SPI0CKEN_Msk         (0x1ul << CLK_APBCLK0_SPI0CKEN_Pos)               /*!< CLK_T::APBCLK0: SPI0CKEN Mask          */
S
S#define CLK_APBCLK0_SPI1CKEN_Pos         (13)                                              /*!< CLK_T::APBCLK0: SPI1CKEN Position      */
S#define CLK_APBCLK0_SPI1CKEN_Msk         (0x1ul << CLK_APBCLK0_SPI1CKEN_Pos)               /*!< CLK_T::APBCLK0: SPI1CKEN Mask          */
S
S#define CLK_APBCLK0_UART0CKEN_Pos        (16)                                              /*!< CLK_T::APBCLK0: UART0CKEN Position     */
S#define CLK_APBCLK0_UART0CKEN_Msk        (0x1ul << CLK_APBCLK0_UART0CKEN_Pos)              /*!< CLK_T::APBCLK0: UART0CKEN Mask         */
S
S#define CLK_APBCLK0_UART1CKEN_Pos        (17)                                              /*!< CLK_T::APBCLK0: UART1CKEN Position     */
S#define CLK_APBCLK0_UART1CKEN_Msk        (0x1ul << CLK_APBCLK0_UART1CKEN_Pos)              /*!< CLK_T::APBCLK0: UART1CKEN Mask         */
S
S#define CLK_APBCLK0_UART2CKEN_Pos        (18)                                              /*!< CLK_T::APBCLK0: UART2CKEN Position     */
S#define CLK_APBCLK0_UART2CKEN_Msk        (0x1ul << CLK_APBCLK0_UART2CKEN_Pos)              /*!< CLK_T::APBCLK0: UART2CKEN Mask         */
S
S#define CLK_APBCLK0_PWM0CKEN_Pos         (20)                                              /*!< CLK_T::APBCLK0: PWM0CKEN Position      */
S#define CLK_APBCLK0_PWM0CKEN_Msk         (0x1ul << CLK_APBCLK0_PWM0CKEN_Pos)               /*!< CLK_T::APBCLK0: PWM0CKEN Mask          */
S
S#define CLK_APBCLK0_PWM1CKEN_Pos         (21)                                              /*!< CLK_T::APBCLK0: PWM1CKEN Position      */
S#define CLK_APBCLK0_PWM1CKEN_Msk         (0x1ul << CLK_APBCLK0_PWM1CKEN_Pos)               /*!< CLK_T::APBCLK0: PWM1CKEN Mask          */
S
S#define CLK_APBCLK0_USBDCKEN_Pos         (27)                                              /*!< CLK_T::APBCLK0: USBDCKEN Position      */
S#define CLK_APBCLK0_USBDCKEN_Msk         (0x1ul << CLK_APBCLK0_USBDCKEN_Pos)               /*!< CLK_T::APBCLK0: USBDCKEN Mask          */
S
S#define CLK_APBCLK0_ADCCKEN_Pos          (28)                                              /*!< CLK_T::APBCLK0: ADCCKEN Position       */
S#define CLK_APBCLK0_ADCCKEN_Msk          (0x1ul << CLK_APBCLK0_ADCCKEN_Pos)                /*!< CLK_T::APBCLK0: ADCCKEN Mask           */
S
S#define CLK_APBCLK0_ACMP01CKEN_Pos       (30)                                              /*!< CLK_T::APBCLK0: ACMP01CKEN Position    */
S#define CLK_APBCLK0_ACMP01CKEN_Msk       (0x1ul << CLK_APBCLK0_ACMP01CKEN_Pos)             /*!< CLK_T::APBCLK0: ACMP01CKEN Mask        */
S
S#define CLK_STATUS_HXTSTB_Pos            (0)                                               /*!< CLK_T::STATUS: HXTSTB Position         */
S#define CLK_STATUS_HXTSTB_Msk            (0x1ul << CLK_STATUS_HXTSTB_Pos)                  /*!< CLK_T::STATUS: HXTSTB Mask             */
S
S#define CLK_STATUS_LXTSTB_Pos            (1)                                               /*!< CLK_T::STATUS: LXTSTB Position         */
S#define CLK_STATUS_LXTSTB_Msk            (0x1ul << CLK_STATUS_LXTSTB_Pos)                  /*!< CLK_T::STATUS: LXTSTB Mask             */
S
S#define CLK_STATUS_PLLSTB_Pos            (2)                                               /*!< CLK_T::STATUS: PLLSTB Position         */
S#define CLK_STATUS_PLLSTB_Msk            (0x1ul << CLK_STATUS_PLLSTB_Pos)                  /*!< CLK_T::STATUS: PLLSTB Mask             */
S
S#define CLK_STATUS_LIRCSTB_Pos           (3)                                               /*!< CLK_T::STATUS: LIRCSTB Position        */
S#define CLK_STATUS_LIRCSTB_Msk           (0x1ul << CLK_STATUS_LIRCSTB_Pos)                 /*!< CLK_T::STATUS: LIRCSTB Mask            */
S
S#define CLK_STATUS_HIRCSTB_Pos           (4)                                               /*!< CLK_T::STATUS: HIRCSTB Position        */
S#define CLK_STATUS_HIRCSTB_Msk           (0x1ul << CLK_STATUS_HIRCSTB_Pos)                 /*!< CLK_T::STATUS: HIRCSTB Mask            */
S
S#define CLK_STATUS_HIRC48STB_Pos         (5)                                               /*!< CLK_T::STATUS: HIRC48STB Position      */
S#define CLK_STATUS_HIRC48STB_Msk         (0x1ul << CLK_STATUS_HIRC48STB_Pos)               /*!< CLK_T::STATUS: HIRC48STB Mask          */
S
S#define CLK_STATUS_CLKSFAIL_Pos          (7)                                               /*!< CLK_T::STATUS: CLKSFAIL Position       */
S#define CLK_STATUS_CLKSFAIL_Msk          (0x1ul << CLK_STATUS_CLKSFAIL_Pos)                /*!< CLK_T::STATUS: CLKSFAIL Mask           */
S
S#define CLK_CLKSEL0_HCLKSEL_Pos          (0)                                               /*!< CLK_T::CLKSEL0: HCLKSEL Position       */
S#define CLK_CLKSEL0_HCLKSEL_Msk          (0x7ul << CLK_CLKSEL0_HCLKSEL_Pos)                /*!< CLK_T::CLKSEL0: HCLKSEL Mask           */
S
S#define CLK_CLKSEL0_STCLKSEL_Pos         (3)                                               /*!< CLK_T::CLKSEL0: STCLKSEL Position      */
S#define CLK_CLKSEL0_STCLKSEL_Msk         (0x7ul << CLK_CLKSEL0_STCLKSEL_Pos)               /*!< CLK_T::CLKSEL0: STCLKSEL Mask          */
S
S#define CLK_CLKSEL0_PCLK0SEL_Pos         (6)                                               /*!< CLK_T::CLKSEL0: PCLK0SEL Position      */
S#define CLK_CLKSEL0_PCLK0SEL_Msk         (0x1ul << CLK_CLKSEL0_PCLK0SEL_Pos)               /*!< CLK_T::CLKSEL0: PCLK0SEL Mask          */
S
S#define CLK_CLKSEL0_PCLK1SEL_Pos         (7)                                               /*!< CLK_T::CLKSEL0: PCLK1SEL Position      */
S#define CLK_CLKSEL0_PCLK1SEL_Msk         (0x1ul << CLK_CLKSEL0_PCLK1SEL_Pos)               /*!< CLK_T::CLKSEL0: PCLK1SEL Mask          */
S
S#define CLK_CLKSEL1_WDTSEL_Pos           (0)                                               /*!< CLK_T::CLKSEL1: WDTSEL Position        */
S#define CLK_CLKSEL1_WDTSEL_Msk           (0x3ul << CLK_CLKSEL1_WDTSEL_Pos)                 /*!< CLK_T::CLKSEL1: WDTSEL Mask            */
S
S#define CLK_CLKSEL1_ADCSEL_Pos           (2)                                               /*!< CLK_T::CLKSEL1: ADCSEL Position        */
S#define CLK_CLKSEL1_ADCSEL_Msk           (0x3ul << CLK_CLKSEL1_ADCSEL_Pos)                 /*!< CLK_T::CLKSEL1: ADCSEL Mask            */
S
S#define CLK_CLKSEL1_TMR0SEL_Pos          (8)                                               /*!< CLK_T::CLKSEL1: TMR0SEL Position       */
S#define CLK_CLKSEL1_TMR0SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR0SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR0SEL Mask           */
S
S#define CLK_CLKSEL1_TMR1SEL_Pos          (12)                                              /*!< CLK_T::CLKSEL1: TMR1SEL Position       */
S#define CLK_CLKSEL1_TMR1SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR1SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR1SEL Mask           */
S
S#define CLK_CLKSEL1_TMR2SEL_Pos          (16)                                              /*!< CLK_T::CLKSEL1: TMR2SEL Position       */
S#define CLK_CLKSEL1_TMR2SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR2SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR2SEL Mask           */
S
S#define CLK_CLKSEL1_TMR3SEL_Pos          (20)                                              /*!< CLK_T::CLKSEL1: TMR3SEL Position       */
S#define CLK_CLKSEL1_TMR3SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR3SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR3SEL Mask           */
S
S#define CLK_CLKSEL1_UARTSEL_Pos          (24)                                              /*!< CLK_T::CLKSEL1: UARTSEL Position       */
S#define CLK_CLKSEL1_UARTSEL_Msk          (0x3ul << CLK_CLKSEL1_UARTSEL_Pos)                /*!< CLK_T::CLKSEL1: UARTSEL Mask           */
S
S#define CLK_CLKSEL1_PWM0SEL_Pos          (28)                                              /*!< CLK_T::CLKSEL1: PWM0SEL Position       */
S#define CLK_CLKSEL1_PWM0SEL_Msk          (0x1ul << CLK_CLKSEL1_PWM0SEL_Pos)                /*!< CLK_T::CLKSEL1: PWM0SEL Mask           */
S
S#define CLK_CLKSEL1_PWM1SEL_Pos          (29)                                              /*!< CLK_T::CLKSEL1: PWM1SEL Position       */
S#define CLK_CLKSEL1_PWM1SEL_Msk          (0x1ul << CLK_CLKSEL1_PWM1SEL_Pos)                /*!< CLK_T::CLKSEL1: PWM1SEL Mask           */
S
S#define CLK_CLKDIV0_HCLKDIV_Pos          (0)                                               /*!< CLK_T::CLKDIV0: HCLKDIV Position       */
S#define CLK_CLKDIV0_HCLKDIV_Msk          (0xful << CLK_CLKDIV0_HCLKDIV_Pos)                /*!< CLK_T::CLKDIV0: HCLKDIV Mask           */
S
S#define CLK_CLKDIV0_USBDIV_Pos           (4)                                               /*!< CLK_T::CLKDIV0: USBDIV Position        */
S#define CLK_CLKDIV0_USBDIV_Msk           (0xful << CLK_CLKDIV0_USBDIV_Pos)                 /*!< CLK_T::CLKDIV0: USBDIV Mask            */
S
S#define CLK_CLKDIV0_UARTDIV_Pos          (8)                                               /*!< CLK_T::CLKDIV0: UARTDIV Position       */
S#define CLK_CLKDIV0_UARTDIV_Msk          (0xful << CLK_CLKDIV0_UARTDIV_Pos)                /*!< CLK_T::CLKDIV0: UARTDIV Mask           */
S
S#define CLK_CLKDIV0_ADCDIV_Pos           (16)                                              /*!< CLK_T::CLKDIV0: ADCDIV Position        */
S#define CLK_CLKDIV0_ADCDIV_Msk           (0xfful << CLK_CLKDIV0_ADCDIV_Pos)                /*!< CLK_T::CLKDIV0: ADCDIV Mask            */
S
S#define CLK_CLKSEL2_CLKOSEL_Pos          (2)                                               /*!< CLK_T::CLKSEL2: CLKOSEL Position       */
S#define CLK_CLKSEL2_CLKOSEL_Msk          (0x7ul << CLK_CLKSEL2_CLKOSEL_Pos)                /*!< CLK_T::CLKSEL2: CLKOSEL Mask           */
S
S#define CLK_CLKSEL2_WWDTSEL_Pos          (16)                                              /*!< CLK_T::CLKSEL2: WWDTSEL Position       */
S#define CLK_CLKSEL2_WWDTSEL_Msk          (0x3ul << CLK_CLKSEL2_WWDTSEL_Pos)                /*!< CLK_T::CLKSEL2: WWDTSEL Mask           */
S
S#define CLK_CLKSEL2_RTCSEL_Pos           (18)                                              /*!< CLK_T::CLKSEL2: RTCSEL Position        */
S#define CLK_CLKSEL2_RTCSEL_Msk           (0x1ul << CLK_CLKSEL2_RTCSEL_Pos)                 /*!< CLK_T::CLKSEL2: RTCSEL Mask            */
S
S#define CLK_CLKSEL2_SPI0SEL_Pos          (24)                                              /*!< CLK_T::CLKSEL2: SPI0SEL Position       */
S#define CLK_CLKSEL2_SPI0SEL_Msk          (0x3ul << CLK_CLKSEL2_SPI0SEL_Pos)                /*!< CLK_T::CLKSEL2: SPI0SEL Mask           */
S
S#define CLK_CLKSEL2_SPI1SEL_Pos          (26)                                              /*!< CLK_T::CLKSEL2: SPI1SEL Position       */
S#define CLK_CLKSEL2_SPI1SEL_Msk          (0x3ul << CLK_CLKSEL2_SPI1SEL_Pos)                /*!< CLK_T::CLKSEL2: SPI1SEL Mask           */
S
S#define CLK_PLLCTL_FBDIV_Pos             (0)                                               /*!< CLK_T::PLLCTL: FBDIV Position          */
S#define CLK_PLLCTL_FBDIV_Msk             (0x1fful << CLK_PLLCTL_FBDIV_Pos)                 /*!< CLK_T::PLLCTL: FBDIV Mask              */
S
S#define CLK_PLLCTL_INDIV_Pos             (9)                                               /*!< CLK_T::PLLCTL: INDIV Position          */
S#define CLK_PLLCTL_INDIV_Msk             (0x1ful << CLK_PLLCTL_INDIV_Pos)                  /*!< CLK_T::PLLCTL: INDIV Mask              */
S
S#define CLK_PLLCTL_OUTDIV_Pos            (14)                                              /*!< CLK_T::PLLCTL: OUTDIV Position         */
S#define CLK_PLLCTL_OUTDIV_Msk            (0x3ul << CLK_PLLCTL_OUTDIV_Pos)                  /*!< CLK_T::PLLCTL: OUTDIV Mask             */
S
S#define CLK_PLLCTL_PD_Pos                (16)                                              /*!< CLK_T::PLLCTL: PD Position             */
S#define CLK_PLLCTL_PD_Msk                (0x1ul << CLK_PLLCTL_PD_Pos)                      /*!< CLK_T::PLLCTL: PD Mask                 */
S
S#define CLK_PLLCTL_BP_Pos                (17)                                              /*!< CLK_T::PLLCTL: BP Position             */
S#define CLK_PLLCTL_BP_Msk                (0x1ul << CLK_PLLCTL_BP_Pos)                      /*!< CLK_T::PLLCTL: BP Mask                 */
S
S#define CLK_PLLCTL_OE_Pos                (18)                                              /*!< CLK_T::PLLCTL: OE Position             */
S#define CLK_PLLCTL_OE_Msk                (0x1ul << CLK_PLLCTL_OE_Pos)                      /*!< CLK_T::PLLCTL: OE Mask                 */
S
S#define CLK_PLLCTL_PLLSRC_Pos            (19)                                              /*!< CLK_T::PLLCTL: PLLSRC Position         */
S#define CLK_PLLCTL_PLLSRC_Msk            (0x1ul << CLK_PLLCTL_PLLSRC_Pos)                  /*!< CLK_T::PLLCTL: PLLSRC Mask             */
S
S#define CLK_PLLCTL_STBSEL_Pos            (23)                                              /*!< CLK_T::PLLCTL: STBSEL Position         */
S#define CLK_PLLCTL_STBSEL_Msk            (0x1ul << CLK_PLLCTL_STBSEL_Pos)                  /*!< CLK_T::PLLCTL: STBSEL Mask             */
S
S#define CLK_CLKOCTL_FREQSEL_Pos          (0)                                               /*!< CLK_T::CLKOCTL: FREQSEL Position       */
S#define CLK_CLKOCTL_FREQSEL_Msk          (0xful << CLK_CLKOCTL_FREQSEL_Pos)                /*!< CLK_T::CLKOCTL: FREQSEL Mask           */
S
S#define CLK_CLKOCTL_CLKOEN_Pos           (4)                                               /*!< CLK_T::CLKOCTL: CLKOEN Position        */
S#define CLK_CLKOCTL_CLKOEN_Msk           (0x1ul << CLK_CLKOCTL_CLKOEN_Pos)                 /*!< CLK_T::CLKOCTL: CLKOEN Mask            */
S
S#define CLK_CLKOCTL_DIV1EN_Pos           (5)                                               /*!< CLK_T::CLKOCTL: DIV1EN Position        */
S#define CLK_CLKOCTL_DIV1EN_Msk           (0x1ul << CLK_CLKOCTL_DIV1EN_Pos)                 /*!< CLK_T::CLKOCTL: DIV1EN Mask            */
S
S#define CLK_CLKOCTL_CLK1HZEN_Pos         (6)                                               /*!< CLK_T::CLKOCTL: CLK1HZEN Position      */
S#define CLK_CLKOCTL_CLK1HZEN_Msk         (0x1ul << CLK_CLKOCTL_CLK1HZEN_Pos)               /*!< CLK_T::CLKOCTL: CLK1HZEN Mask          */
S
S#define CLK_APBCLK1_SC0CKEN_Pos          (0)                                               /*!< CLK_T::APBCLK1: SC0CKEN Position       */
S#define CLK_APBCLK1_SC0CKEN_Msk          (0x1ul << CLK_APBCLK1_SC0CKEN_Pos)                /*!< CLK_T::APBCLK1: SC0CKEN Mask           */
S
S#define CLK_APBCLK1_SC1CKEN_Pos          (1)                                               /*!< CLK_T::APBCLK1: SC1CKEN Position       */
S#define CLK_APBCLK1_SC1CKEN_Msk          (0x1ul << CLK_APBCLK1_SC1CKEN_Pos)                /*!< CLK_T::APBCLK1: SC1CKEN Mask           */
S
S#define CLK_APBCLK1_USCI0CKEN_Pos        (8)                                               /*!< CLK_T::APBCLK1: USCI0CKEN Position     */
S#define CLK_APBCLK1_USCI0CKEN_Msk        (0x1ul << CLK_APBCLK1_USCI0CKEN_Pos)              /*!< CLK_T::APBCLK1: USCI0CKEN Mask         */
S
S#define CLK_APBCLK1_USCI1CKEN_Pos        (9)                                               /*!< CLK_T::APBCLK1: USCI1CKEN Position     */
S#define CLK_APBCLK1_USCI1CKEN_Msk        (0x1ul << CLK_APBCLK1_USCI1CKEN_Pos)              /*!< CLK_T::APBCLK1: USCI1CKEN Mask         */
S
S#define CLK_APBCLK1_USCI2CKEN_Pos        (10)                                              /*!< CLK_T::APBCLK1: USCI2CKEN Position     */
S#define CLK_APBCLK1_USCI2CKEN_Msk        (0x1ul << CLK_APBCLK1_USCI2CKEN_Pos)              /*!< CLK_T::APBCLK1: USCI2CKEN Mask         */
S
S#define CLK_CLKSEL3_SC0SEL_Pos           (0)                                               /*!< CLK_T::CLKSEL3: SC0SEL Position        */
S#define CLK_CLKSEL3_SC0SEL_Msk           (0x3ul << CLK_CLKSEL3_SC0SEL_Pos)                 /*!< CLK_T::CLKSEL3: SC0SEL Mask            */
S
S#define CLK_CLKSEL3_SC1SEL_Pos           (2)                                               /*!< CLK_T::CLKSEL3: SC1SEL Position        */
S#define CLK_CLKSEL3_SC1SEL_Msk           (0x3ul << CLK_CLKSEL3_SC1SEL_Pos)                 /*!< CLK_T::CLKSEL3: SC1SEL Mask            */
S
S#define CLK_CLKSEL3_USBDSEL_Pos          (8)                                               /*!< CLK_T::CLKSEL3: USBDSEL Position       */
S#define CLK_CLKSEL3_USBDSEL_Msk          (0x1ul << CLK_CLKSEL3_USBDSEL_Pos)                /*!< CLK_T::CLKSEL3: USBDSEL Mask           */
S
S#define CLK_CLKDIV1_SC0DIV_Pos           (0)                                               /*!< CLK_T::CLKDIV1: SC0DIV Position        */
S#define CLK_CLKDIV1_SC0DIV_Msk           (0xfful << CLK_CLKDIV1_SC0DIV_Pos)                /*!< CLK_T::CLKDIV1: SC0DIV Mask            */
S
S#define CLK_CLKDIV1_SC1DIV_Pos           (8)                                               /*!< CLK_T::CLKDIV1: SC1DIV Position        */
S#define CLK_CLKDIV1_SC1DIV_Msk           (0xfful << CLK_CLKDIV1_SC1DIV_Pos)                /*!< CLK_T::CLKDIV1: SC1DIV Mask            */
S
S#define CLK_BODCLK_EBODCKSEL_Pos         (0)                                               /*!< CLK_T::BODCLK: EBODCKSEL Position      */
S#define CLK_BODCLK_EBODCKSEL_Msk         (0x1ul << CLK_BODCLK_EBODCKSEL_Pos)               /*!< CLK_T::BODCLK: EBODCKSEL Mask          */
S
S#define CLK_CLKDCTL_HXTFDEN_Pos          (4)                                               /*!< CLK_T::CLKDCTL: HXTFDEN Position       */
S#define CLK_CLKDCTL_HXTFDEN_Msk          (0x1ul << CLK_CLKDCTL_HXTFDEN_Pos)                /*!< CLK_T::CLKDCTL: HXTFDEN Mask           */
S
S#define CLK_CLKDCTL_HXTFIEN_Pos          (5)                                               /*!< CLK_T::CLKDCTL: HXTFIEN Position       */
S#define CLK_CLKDCTL_HXTFIEN_Msk          (0x1ul << CLK_CLKDCTL_HXTFIEN_Pos)                /*!< CLK_T::CLKDCTL: HXTFIEN Mask           */
S
S#define CLK_CLKDCTL_LXTFDEN_Pos          (12)                                              /*!< CLK_T::CLKDCTL: LXTFDEN Position       */
S#define CLK_CLKDCTL_LXTFDEN_Msk          (0x1ul << CLK_CLKDCTL_LXTFDEN_Pos)                /*!< CLK_T::CLKDCTL: LXTFDEN Mask           */
S
S#define CLK_CLKDCTL_LXTFIEN_Pos          (13)                                              /*!< CLK_T::CLKDCTL: LXTFIEN Position       */
S#define CLK_CLKDCTL_LXTFIEN_Msk          (0x1ul << CLK_CLKDCTL_LXTFIEN_Pos)                /*!< CLK_T::CLKDCTL: LXTFIEN Mask           */
S
S#define CLK_CLKDCTL_HXTFQDEN_Pos         (16)                                              /*!< CLK_T::CLKDCTL: HXTFQDEN Position      */
S#define CLK_CLKDCTL_HXTFQDEN_Msk         (0x1ul << CLK_CLKDCTL_HXTFQDEN_Pos)               /*!< CLK_T::CLKDCTL: HXTFQDEN Mask          */
S
S#define CLK_CLKDCTL_HXTFQIEN_Pos         (17)                                              /*!< CLK_T::CLKDCTL: HXTFQIEN Position      */
S#define CLK_CLKDCTL_HXTFQIEN_Msk         (0x1ul << CLK_CLKDCTL_HXTFQIEN_Pos)               /*!< CLK_T::CLKDCTL: HXTFQIEN Mask          */
S
S#define CLK_CLKDSTS_HXTFIF_Pos           (0)                                               /*!< CLK_T::CLKDSTS: HXTFIF Position        */
S#define CLK_CLKDSTS_HXTFIF_Msk           (0x1ul << CLK_CLKDSTS_HXTFIF_Pos)                 /*!< CLK_T::CLKDSTS: HXTFIF Mask            */
S
S#define CLK_CLKDSTS_LXTFIF_Pos           (1)                                               /*!< CLK_T::CLKDSTS: LXTFIF Position        */
S#define CLK_CLKDSTS_LXTFIF_Msk           (0x1ul << CLK_CLKDSTS_LXTFIF_Pos)                 /*!< CLK_T::CLKDSTS: LXTFIF Mask            */
S
S#define CLK_CLKDSTS_HXTFQIF_Pos          (8)                                               /*!< CLK_T::CLKDSTS: HXTFQIF Position       */
S#define CLK_CLKDSTS_HXTFQIF_Msk          (0x1ul << CLK_CLKDSTS_HXTFQIF_Pos)                /*!< CLK_T::CLKDSTS: HXTFQIF Mask           */
S
S#define CLK_CDUPB_UPERBD_Pos             (0)                                               /*!< CLK_T::CDUPB: UPERBD Position          */
S#define CLK_CDUPB_UPERBD_Msk             (0x3fful << CLK_CDUPB_UPERBD_Pos)                 /*!< CLK_T::CDUPB: UPERBD Mask              */
S
S#define CLK_CDLOWB_LOWERBD_Pos           (0)                                               /*!< CLK_T::CDLOWB: LOWERBD Position        */
S#define CLK_CDLOWB_LOWERBD_Msk           (0x3fful << CLK_CDLOWB_LOWERBD_Pos)               /*!< CLK_T::CDLOWB: LOWERBD Mask            */
S
S/**@}*/ /* CLK_CONST */
S/**@}*/ /* end of CLK register group */
S
S
S
S/*---------------------- Cyclic Redundancy Check Controller -------------------------*/
S/**
S    @addtogroup CRC Cyclic Redundancy Check Controller(CRC)
S    Memory Mapped Structure for CRC Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var CRC_T::CTL
S     * Offset: 0x00  CRC Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CRCEN     |CRC Channel Generator Enable Bit
S     * |        |          |Set this bit 1 to enable CRC generator for CRC operation.
S     * |        |          |0 = No effect.
S     * |        |          |1 = CRC operation generator is activeEnabled.
S     * |[1]     |CHKSINIT  |CChecksum Initialization
S     * |        |          |Set this bit will auto reolad SEED (CRC_SEED [31:0]) to CHECKSUM (CRC_CHECKSUM[31:0]) as CRC operation initial value.RC Engine Reset
S     * |        |          |0 = No effect.
S     * |        |          |1 = InitialReolad SEED value to CHECKSUM as CRC operation initial value checksum value by auto reloadReset CRC_SEED register value to CRC_CHECKSUM register value.the internal CRC state machine
S     * |        |          |The others contents of CRC_CTL register will not be cleared.
S     * |        |          |Note1: This bit will be cleared automatically
S     * |        |          |Note2: Setting this bit will reload the seed value from CRC_SEED register as checksum initial value.
S     * |[24]    |DATREV    |Write Data Bit Order Reverse Enable Bit
S     * |        |          |This bit is used to enable the bit order reverse function per byte for write data value DATA (CRC_DATA[31:0]) write data value in CRC_DAT register.
S     * |        |          |0 = Bit order reversed for CRC DATACRC write data in Disabled.
S     * |        |          |1 = Bit order reversed for CRC DATACRC write data in Enabled (per byte).
S     * |        |          |Note: If the write data is 0xAABBCCDD, the bit order reverse for CRC write data in is 0x55DD33BB.
S     * |[25]    |CHKSREV   |Checksum Bit Order Reverse Enable Bit
S     * |        |          |This bit is used to enable the bit order reverse function for checksum result CHECKSUM (CRC_CHECKSUM[31:0]) write data value in CRC_CHECKSUM register.
S     * |        |          |0 = Bit order reverse for CRC CHECKSUMCRC checksum Disabled.
S     * |        |          |1 = Bit order reverse for CRC CHECKSUMCRC checksum Enabled.
S     * |        |          |Note: If the checksum result is 0xDD7B0F2E, the bit order reverse result for CRC checksum is 0x74F0DEBB.
S     * |[26]    |DATFMT    |Write Data 1u2019s Complement Enable Bit
S     * |        |          |This bit is used to enable the 1u2019s complement function for write data value DATA (CRC_DATA[31:0]).in CRC_DAT register.
S     * |        |          |0 = 1u2019s complement for CRC CRC writes data inDATA Disabled.
S     * |        |          |1 = 1u2019s complement for CRC DATACRC writes data in Enabled.
S     * |[27]    |CHKSFMT   |Checksum 1u2019s Complement Enable Bit
S     * |        |          |This bit is used to enable the 1u2019s complement function for checksum result in CHECKSUM (CRC_CHECKSUM[31:0]) register.
S     * |        |          |0 = 1u2019s complement for CRC CRC checksumCHECKSUM Disabled.
S     * |        |          |1 = 1u2019s complement for CRC CHECKSUMCRC checksum Enabled.
S     * |[29:28] |DATLEN    |CPU Write Data Length
S     * |        |          |This field indicates the valid write data length of DATA (CRC_DAT[31:0]).
S     * |        |          |00 = Data length is 8-bit mode.
S     * |        |          |01 = Data length is 16-bit mode.
S     * |        |          |1x = Data length is 32-bit mode.
S     * |        |          |Note: When the write data length is 8-bit mode, the valid data in CRC_DAT register is only DATA[7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_DAT register is only DATA[15:0]
S     * |[31:30] |CRCMODE   |CRC Polynomial Mode
S     * |        |          |This field indicates the CRC operation polynomial mode.
S     * |        |          |00 = CRC-CCITT Polynomial mode.
S     * |        |          |01 = CRC-8 Polynomial mode.
S     * |        |          |10 = CRC-16 Polynomial mode.
S     * |        |          |11 = CRC-32 Polynomial mode.
S     * @var CRC_T::DAT
S     * Offset: 0x04  CRC Write Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |DATA      |CRC Write Data Bits
S     * |        |          |User can write data directly by CPU mode or use PDMA function to write data to this field to perform CRC operation.
S     * |        |          |Note: When the write data length is 8-bit mode, the valid data in CRC_DAT register is only DATA[7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_DAT register is only DATA[15:0].
S     * @var CRC_T::SEED
S     * Offset: 0x08  CRC Seed Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |SEED      |CRC Seed Value
S     * |        |          |This field indicates the CRC seed value.
S     * |        |          |Note1: This field SEED value will be reloaded to as checksum initial value CHECKSUM (CRC_CHECKSUM[31:0]) register) a after perform set CRC engine resetCHKSINIT (CRC_CTL[1]) to 1.
S     * |        |          |Note2: The valid bits of CRC_SEED[31:0] is correlated to CRCMODE (CRC_CTL[31:30]).
S     * @var CRC_T::CHECKSUM
S     * Offset: 0x0C  CRC Checksum Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |CHECKSUM  |CRC Checksum Results
S     * |        |          |This field indicates the CRC checksum result.
S     * |        |          |Note: The valid bits of CRC_CHECKSUM[31:0] is correlated to CRCMODE (CRC_CTL[31:30]).
S     */
S    __IO uint32_t CTL;                   /*!< [0x0000] CRC Control Register                                             */
S    __IO uint32_t DAT;                   /*!< [0x0004] CRC Write Data Register                                          */
S    __IO uint32_t SEED;                  /*!< [0x0008] CRC Seed Register                                                */
S    __I  uint32_t CHECKSUM;              /*!< [0x000c] CRC Checksum Register                                            */
S
S} CRC_T;
S
S/**
S    @addtogroup CRC_CONST CRC Bit Field Definition
S    Constant Definitions for CRC Controller
S@{ */
S
S#define CRC_CTL_CRCEN_Pos                (0)                                               /*!< CRC_T::CTL: CRCEN Position             */
S#define CRC_CTL_CRCEN_Msk                (0x1ul << CRC_CTL_CRCEN_Pos)                      /*!< CRC_T::CTL: CRCEN Mask                 */
S
S#define CRC_CTL_CHKSINIT_Pos             (1)                                               /*!< CRC_T::CTL: CHKSINIT Position          */
S#define CRC_CTL_CHKSINIT_Msk             (0x1ul << CRC_CTL_CHKSINIT_Pos)                   /*!< CRC_T::CTL: CHKSINIT Mask              */
S
S#define CRC_CTL_DATREV_Pos               (24)                                              /*!< CRC_T::CTL: DATREV Position            */
S#define CRC_CTL_DATREV_Msk               (0x1ul << CRC_CTL_DATREV_Pos)                     /*!< CRC_T::CTL: DATREV Mask                */
S
S#define CRC_CTL_CHKSREV_Pos              (25)                                              /*!< CRC_T::CTL: CHKSREV Position           */
S#define CRC_CTL_CHKSREV_Msk              (0x1ul << CRC_CTL_CHKSREV_Pos)                    /*!< CRC_T::CTL: CHKSREV Mask               */
S
S#define CRC_CTL_DATFMT_Pos               (26)                                              /*!< CRC_T::CTL: DATFMT Position            */
S#define CRC_CTL_DATFMT_Msk               (0x1ul << CRC_CTL_DATFMT_Pos)                     /*!< CRC_T::CTL: DATFMT Mask                */
S
S#define CRC_CTL_CHKSFMT_Pos              (27)                                              /*!< CRC_T::CTL: CHKSFMT Position           */
S#define CRC_CTL_CHKSFMT_Msk              (0x1ul << CRC_CTL_CHKSFMT_Pos)                    /*!< CRC_T::CTL: CHKSFMT Mask               */
S
S#define CRC_CTL_DATLEN_Pos               (28)                                              /*!< CRC_T::CTL: DATLEN Position            */
S#define CRC_CTL_DATLEN_Msk               (0x3ul << CRC_CTL_DATLEN_Pos)                     /*!< CRC_T::CTL: DATLEN Mask                */
S
S#define CRC_CTL_CRCMODE_Pos              (30)                                              /*!< CRC_T::CTL: CRCMODE Position           */
S#define CRC_CTL_CRCMODE_Msk              (0x3ul << CRC_CTL_CRCMODE_Pos)                    /*!< CRC_T::CTL: CRCMODE Mask               */
S
S#define CRC_DAT_DATA_Pos                 (0)                                               /*!< CRC_T::DAT: DATA Position              */
S#define CRC_DAT_DATA_Msk                 (0xfffffffful << CRC_DAT_DATA_Pos)                /*!< CRC_T::DAT: DATA Mask                  */
S
S#define CRC_SEED_SEED_Pos                (0)                                               /*!< CRC_T::SEED: SEED Position             */
S#define CRC_SEED_SEED_Msk                (0xfffffffful << CRC_SEED_SEED_Pos)               /*!< CRC_T::SEED: SEED Mask                 */
S
S#define CRC_CHECKSUM_CHECKSUM_Pos        (0)                                               /*!< CRC_T::CHECKSUM: CHECKSUM Position     */
S#define CRC_CHECKSUM_CHECKSUM_Msk        (0xfffffffful << CRC_CHECKSUM_CHECKSUM_Pos)       /*!< CRC_T::CHECKSUM: CHECKSUM Mask         */
S
S/**@}*/ /* CRC_CONST */
S/**@}*/ /* end of CRC register group */
S
S
S/*---------------------- External Bus Interface Controller -------------------------*/
S/**
S    @addtogroup EBI External Bus Interface Controller(EBI)
S    Memory Mapped Structure for EBI Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var EBI_T::CTL0
S     * Offset: 0x00  External Bus Interface Bank0 Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |EN        |EBI Enable Bit
S     * |        |          |This bit is the functional enable bit for EBI.
S     * |        |          |0 = EBI function Disabled.
S     * |        |          |1 = EBI function Enabled.
S     * |[1]     |DW16      |EBI Data Width 16-bit Select
S     * |        |          |This bit defines if the EBI data width is 8-bit or 16-bit.
S     * |        |          |0 = EBI data width is 8-bit.
S     * |        |          |1 = EBI data width is 16-bit.
S     * |[2]     |CSPOLINV  |Chip Select Pin Polar Inverse
S     * |        |          |This bit defines the active level of EBI chip select pin (EBI_nCSx), x = 0 or 1..
S     * |        |          |0 = Chip select pin (EBI_nCSx) is active low.
S     * |        |          |1 = Chip select pin (EBI_nCSx) is active high.
S     * |        |          |x = 0, 1
S     * |[4]     |CACCESS   |Continuous Data Access Mode
S     * |        |          |When con ttinuousenuous access mode enabled, the tASU, tALE and tLHD cycles are bypass for continuous data transfer request.
S     * |        |          |0 = Continuous data access mode Disabled.
S     * |        |          |1 = Continuous data access mode Enabled.
S     * |[10:8]  |MCLKDIV   |External Output Clock Divider
S     * |        |          |The frequency of EBI output clock (MCLK) is controlled by MCLKDIV as follow:
S     * |        |          |000 = HCLK/1.
S     * |        |          |001 = HCLK/2.
S     * |        |          |010 = HCLK/4.
S     * |        |          |011 = HCLK/8.
S     * |        |          |100 = HCLK/16.
S     * |        |          |101 = HCLK/32.
S     * |        |          |110 = HCLK/64.
S     * |        |          |111 = HCLK/128.
S     * |[18:16] |TALE      |Extend Time Of of ALE
S     * |        |          |The EBI_ALE high pulse period (tALE) to latch the address can be controlled by TALE.
S     * |        |          |tALE = (TALE + 1)*EBI_MCLK.
S     * |        |          |Note: This field only available in EBI_CTL0 register
S     * |[24]    |WBUFEN    |EBI Write Buffer Enable Bit
S     * |        |          |0 = EBI write buffer Disabled.
S     * |        |          |1 = EBI write buffer Enabled.
S     * |        |          |Note: This bit only available in EBI_CTL0 register
S     * @var EBI_T::TCTL0
S     * Offset: 0x04  External Bus Interface Bank0 Timing Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:3]   |TACC      |EBI Data Access Time
S     * |        |          |TACC define data access time (tACC).
S     * |        |          |tACC = (TACC + 1) * EBI_MCLK.
S     * |[10:8]  |TAHD      |EBI Data Access Hold Time
S     * |        |          |TAHD define data access hold time (tAHD).
S     * |        |          |tAHD = (TAHD + 1) * EBI_MCLK.
S     * |[15:12] |W2X       |Idle Cycle After Write
S     * |        |          |This field defines the number of W2X idle cycle.
S     * |        |          |When write action is finish, W2X idle cycle is inserted and EBI_nCSx return to idle state, x = 0 or 1.
S     * |        |          |W2X idle cycle = (W2X * EBI_MCLK).
S     * |        |          |When write action is finish, W2X idle cycle is inserted and EBI_nCSx return to idle state. (x = 0, 1)
S     * |[22]    |RAHDOFF   |Access Hold Time Disable Control When Read
S     * |        |          |0 = The Data Access Hold Time (tAHD) during EBI reading is Enabled.
S     * |        |          |1 = The Data Access Hold Time (tAHD) during EBI reading is Disabled.
S     * |[23]    |WAHDOFF   |Access Hold Time Disable Control When Write
S     * |        |          |0 = The Data Access Hold Time (tAHD) during EBI writing is Enabled.
S     * |        |          |1 = The Data Access Hold Time (tAHD) during EBI writing is Disabled.
S     * |[27:24] |R2R       |Idle Cycle Between Read-to-read
S     * |        |          |This field defines the number of R2R idle cycle.
S     * |        |          |When read action is finish and next action is going to read, R2R idle cycle is inserted and EBI_nCSx return to idle state, x = 0 or 1.
S     * |        |          |R2R idle cycle = (R2R * EBI_MCLK).
S     * |        |          |When read action is finish and next action is going to read, R2R idle cycle is inserted and EBI_nCSx return to idle state
S     * |        |          |(x = 0, 1)
S     * @var EBI_T::CTL1
S     * Offset: 0x10  External Bus Interface Bank1 Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |EN        |EBI Enable Bit
S     * |        |          |This bit is the functional enable bit for EBI.
S     * |        |          |0 = EBI function Disabled.
S     * |        |          |1 = EBI function Enabled.
S     * |[1]     |DW16      |EBI Data Width 16-bit Select
S     * |        |          |This bit defines if the EBI data width is 8-bit or 16-bit.
S     * |        |          |0 = EBI data width is 8-bit.
S     * |        |          |1 = EBI data width is 16-bit.
S     * |[2]     |CSPOLINV  |Chip Select Pin Polar Inverse
S     * |        |          |This bit defines the active level of EBI chip select pin (EBI_nCSx), x = 0 or 1..
S     * |        |          |0 = Chip select pin (EBI_nCSx) is active low.
S     * |        |          |1 = Chip select pin (EBI_nCSx) is active high.
S     * |        |          |x = 0, 1
S     * |[4]     |CACCESS   |Continuous Data Access Mode
S     * |        |          |When con ttinuousenuous access mode enabled, the tASU, tALE and tLHD cycles are bypass for continuous data transfer request.
S     * |        |          |0 = Continuous data access mode Disabled.
S     * |        |          |1 = Continuous data access mode Enabled.
S     * |[10:8]  |MCLKDIV   |External Output Clock Divider
S     * |        |          |The frequency of EBI output clock (MCLK) is controlled by MCLKDIV as follow:
S     * |        |          |000 = HCLK/1.
S     * |        |          |001 = HCLK/2.
S     * |        |          |010 = HCLK/4.
S     * |        |          |011 = HCLK/8.
S     * |        |          |100 = HCLK/16.
S     * |        |          |101 = HCLK/32.
S     * |        |          |110 = HCLK/64.
S     * |        |          |111 = HCLK/128.
S     * |[18:16] |TALE      |Extend Time Of of ALE
S     * |        |          |The EBI_ALE high pulse period (tALE) to latch the address can be controlled by TALE.
S     * |        |          |tALE = (TALE + 1)*EBI_MCLK.
S     * |        |          |Note: This field only available in EBI_CTL0 register
S     * |[24]    |WBUFEN    |EBI Write Buffer Enable Bit
S     * |        |          |0 = EBI write buffer Disabled.
S     * |        |          |1 = EBI write buffer Enabled.
S     * |        |          |Note: This bit only available in EBI_CTL0 register
S     * @var EBI_T::TCTL1
S     * Offset: 0x14  External Bus Interface Bank1 Timing Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:3]   |TACC      |EBI Data Access Time
S     * |        |          |TACC define data access time (tACC).
S     * |        |          |tACC = (TACC + 1) * EBI_MCLK.
S     * |[10:8]  |TAHD      |EBI Data Access Hold Time
S     * |        |          |TAHD define data access hold time (tAHD).
S     * |        |          |tAHD = (TAHD + 1) * EBI_MCLK.
S     * |[15:12] |W2X       |Idle Cycle After Write
S     * |        |          |This field defines the number of W2X idle cycle.
S     * |        |          |When write action is finish, W2X idle cycle is inserted and EBI_nCSx return to idle state, x = 0 or 1.
S     * |        |          |W2X idle cycle = (W2X * EBI_MCLK).
S     * |        |          |When write action is finish, W2X idle cycle is inserted and EBI_nCSx return to idle state. (x = 0, 1)
S     * |[22]    |RAHDOFF   |Access Hold Time Disable Control When Read
S     * |        |          |0 = The Data Access Hold Time (tAHD) during EBI reading is Enabled.
S     * |        |          |1 = The Data Access Hold Time (tAHD) during EBI reading is Disabled.
S     * |[23]    |WAHDOFF   |Access Hold Time Disable Control When Write
S     * |        |          |0 = The Data Access Hold Time (tAHD) during EBI writing is Enabled.
S     * |        |          |1 = The Data Access Hold Time (tAHD) during EBI writing is Disabled.
S     * |[27:24] |R2R       |Idle Cycle Between Read-to-read
S     * |        |          |This field defines the number of R2R idle cycle.
S     * |        |          |When read action is finish and next action is going to read, R2R idle cycle is inserted and EBI_nCSx return to idle state, x = 0 or 1.
S     * |        |          |R2R idle cycle = (R2R * EBI_MCLK).
S     * |        |          |When read action is finish and next action is going to read, R2R idle cycle is inserted and EBI_nCSx return to idle state
S     * |        |          |(x = 0, 1)
S     */
S    __IO uint32_t CTL0;                  /*!< [0x0000] External Bus Interface Bank0 Control Register                    */
S    __IO uint32_t TCTL0;                 /*!< [0x0004] External Bus Interface Bank0 Timing Control Register             */
S    __I  uint32_t RESERVE0[2];
S    __IO uint32_t CTL1;                  /*!< [0x0010] External Bus Interface Bank1 Control Register                    */
S    __IO uint32_t TCTL1;                 /*!< [0x0014] External Bus Interface Bank1 Timing Control Register             */
S
S} EBI_T;
S
S/**
S    @addtogroup EBI_CONST EBI Bit Field Definition
S    Constant Definitions for EBI Controller
S@{ */
S
S#define EBI_CTL_EN_Pos                   (0)                                               /*!< EBI_T::CTL: EN Position                  */
S#define EBI_CTL_EN_Msk                   (0x1ul << EBI_CTL_EN_Pos)                         /*!< EBI_T::CTL: EN Mask                      */
S
S#define EBI_CTL_DW16_Pos                 (1)                                               /*!< EBI_T::CTL: DW16 Position                */
S#define EBI_CTL_DW16_Msk                 (0x1ul << EBI_CTL_DW16_Pos)                       /*!< EBI_T::CTL: DW16 Mask                    */
S
S#define EBI_CTL_CSPOLINV_Pos             (2)                                               /*!< EBI_T::CTL: CSPOLINV Position            */
S#define EBI_CTL_CSPOLINV_Msk             (0x1ul << EBI_CTL_CSPOLINV_Pos)                   /*!< EBI_T::CTL: CSPOLINV Mask                */
S
S#define EBI_CTL_CACCESS_Pos              (4)                                               /*!< EBI_T::CTL: CACCESS Position             */
S#define EBI_CTL_CACCESS_Msk              (0x1ul << EBI_CTL_CACCESS_Pos)                    /*!< EBI_T::CTL: CACCESS Mask                 */
S
S#define EBI_CTL_MCLKDIV_Pos              (8)                                               /*!< EBI_T::CTL: MCLKDIV Position             */
S#define EBI_CTL_MCLKDIV_Msk              (0x7ul << EBI_CTL_MCLKDIV_Pos)                    /*!< EBI_T::CTL: MCLKDIV Mask                 */
S
S#define EBI_CTL_TALE_Pos                 (16)                                              /*!< EBI_T::CTL: TALE Position                */
S#define EBI_CTL_TALE_Msk                 (0x7ul << EBI_CTL_TALE_Pos)                       /*!< EBI_T::CTL: TALE Mask                    */
S
S#define EBI_CTL_WBUFEN_Pos               (24)                                              /*!< EBI_T::CTL: WBUFEN Position              */
S#define EBI_CTL_WBUFEN_Msk               (0x1ul << EBI_CTL_WBUFEN_Pos)                     /*!< EBI_T::CTL: WBUFEN Mask                  */
S
S#define EBI_TCTL_TACC_Pos                (3)                                               /*!< EBI_T::TCTL: TACC Position               */
S#define EBI_TCTL_TACC_Msk                (0x1ful << EBI_TCTL_TACC_Pos)                     /*!< EBI_T::TCTL: TACC Mask                   */
S
S#define EBI_TCTL_TAHD_Pos                (8)                                               /*!< EBI_T::TCTL: TAHD Position               */
S#define EBI_TCTL_TAHD_Msk                (0x7ul << EBI_TCTL_TAHD_Pos)                      /*!< EBI_T::TCTL: TAHD Mask                   */
S
S#define EBI_TCTL_W2X_Pos                 (12)                                              /*!< EBI_T::TCTL: W2X Position                */
S#define EBI_TCTL_W2X_Msk                 (0xful << EBI_TCTL_W2X_Pos)                       /*!< EBI_T::TCTL: W2X Mask                    */
S
S#define EBI_TCTL_RAHDOFF_Pos             (22)                                              /*!< EBI_T::TCTL: RAHDOFF Position            */
S#define EBI_TCTL_RAHDOFF_Msk             (0x1ul << EBI_TCTL_RAHDOFF_Pos)                   /*!< EBI_T::TCTL: RAHDOFF Mask                */
S
S#define EBI_TCTL_WAHDOFF_Pos             (23)                                              /*!< EBI_T::TCTL: WAHDOFF Position            */
S#define EBI_TCTL_WAHDOFF_Msk             (0x1ul << EBI_TCTL_WAHDOFF_Pos)                   /*!< EBI_T::TCTL: WAHDOFF Mask                */
S
S#define EBI_TCTL_R2R_Pos                 (24)                                              /*!< EBI_T::TCTL: R2R Position                */
S#define EBI_TCTL_R2R_Msk                 (0xful << EBI_TCTL_R2R_Pos)                       /*!< EBI_T::TCTL: R2R Mask                    */
S
S/**@}*/ /* EBI_CONST */
S/**@}*/ /* end of EBI register group */
S
S
S/*---------------------- Flash Memory Controller -------------------------*/
S/**
S    @addtogroup FMC Flash Memory Controller(FMC)
S    Memory Mapped Structure for FMC Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var FMC_T::ISPCTL
S     * Offset: 0x00  ISP Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ISPEN     |ISP Enable Bit (Write Protect)
S     * |        |          |ISP function enable bit. Set this bit to enable ISP function.
S     * |        |          |0 = ISP function Disabled.
S     * |        |          |1 = ISP function Enabled.
S     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
S     * |[1]     |BS        |Boot Select (Write Protect)
S     * |        |          |Set/clear this bit to select next booting from LDROM/APROM, respectively.
S     * |        |          |This bit also functions as chip booting status flag, which can be used to check where chip booted from.
S     * |        |          |This bit is initiated with the inversed value of CBS[1] (CONFIG0[7]) after any reset is happened except CPU reset (CPU is 1) or system reset (SYS) is happened.
S     * |        |          |0 = Booting from APROM.
S     * |        |          |1 = Booting from LDROM.
S     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
S     * |[2]     |SPUEN     |SPROM Update Enable Bit (Write Protect)
S     * |        |          |0 = SPROM cannot be updated.
S     * |        |          |1 = SPROM can be updated.
S     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
S     * |[3]     |APUEN     |APROM Update Enable Bit (Write Protect)
S     * |        |          |0 = APROM cannot be updated when the chip runs in APROM.
S     * |        |          |1 = APROM can be updated when the chip runs in APROM.
S     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
S     * |[4]     |CFGUEN    |CONFIG Update Enable Bit (Write Protect)
S     * |        |          |0 = CONFIG cannot be updated.
S     * |        |          |1 = CONFIG can be updated.
S     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
S     * |[5]     |LDUEN     |LDROM Update Enable Bit (Write Protect)
S     * |        |          |LDROM update enable bit.
S     * |        |          |0 = LDROM cannot be updated.
S     * |        |          |1 = LDROM can be updated.
S     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
S     * |[6]     |ISPFF     |ISP Fail Flag (Write Protect)
S     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
S     * |        |          |This bit needs to be cleared by writing 1 to it.
S     * |        |          |(1) APROM writes to itself if APUEN is set to 0.
S     * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
S     * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
S     * |        |          |(4) SPROM is erased/programmed if SPUEN is set to 0.
S     * |        |          |(5) SPROM is programmed at SPROM secured mode.
S     * |        |          |(6) Page Erase command at LOCK mode with ICE connection.
S     * |        |          |(7) Erase or Program command at brown-out detected.
S     * |        |          |(8) Destination address is illegal, such as over an available range.
S     * |        |          |(9) Invalid ISP commands.
S     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
S     * @var FMC_T::ISPADDR
S     * Offset: 0x04  ISP Address Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |ISPADDR   |ISP Address
S     * |        |          |The NuMicrou00AEu00E4 NUC029xGE series is equipped with embedded flash.
S     * |        |          |ISPADDR[1:0] must be kept 00 for ISP 32-bit operation.
S     * |        |          |ISPADDR[2:0] must be kept 000 for ISP 64-bit operation.
S     * |        |          |For Checksum Calculation command, this field is the flash starting address for checksum calculation, 512 bytes alignment is necessary for checksum calculation.
S     * @var FMC_T::ISPDAT
S     * Offset: 0x08  ISP Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |ISPDAT    |ISP Data
S     * |        |          |Write data to this register before ISP program operation.
S     * |        |          |Read data from this register after ISP read operation.
S     * |        |          |For Run Checksum Calculation command, ISPDAT is the memory size (byte) and 512 bytes alignment.
S     * |        |          |For ISP Read Checksum command, ISPDAT is the checksum result.
S     * |        |          |If ISPDAT = 0x0000_0000, it means that (1) the checksum calculation is in progress, (2) the memory range for checksum calculation is incorrect.
S     * @var FMC_T::ISPCMD
S     * Offset: 0x0C  ISP CMD Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[6:0]   |CMD       |ISP CMD
S     * |        |          |ISP command table is shown below:
S     * |        |          |0x00= FLASH Read.
S     * |        |          |0x40= FLASH 64-bit Read.
S     * |        |          |0x04= Read Unique ID.
S     * |        |          |0x08= Read Flash All-One Result.
S     * |        |          |0x0B= Read Company ID.
S     * |        |          |0x0C= Read Device ID.
S     * |        |          |0x0D= Read Checksum.
S     * |        |          |0x21= FLASH 32-bit Program.
S     * |        |          |0x22= FLASH Page Erase.
S     * |        |          |0x26= FLASH Mass Erase.
S     * |        |          |0x27= FLASH Multi-Word Program.
S     * |        |          |0x28= Run Flash All-One Verification.
S     * |        |          |0x2D= Run Checksum Calculation.
S     * |        |          |0x2E= Vector Remap.
S     * |        |          |0x61= FLASH 64-bit Program.
S     * |        |          |The other commands are invalid.
S     * @var FMC_T::ISPTRG
S     * Offset: 0x10  ISP Trigger Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ISPGO     |ISP Start Trigger (Write Protect)
S     * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.
S     * |        |          |0 = ISP operation is finished.
S     * |        |          |1 = ISP is progressed.
S     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
S     * @var FMC_T::DFBA
S     * Offset: 0x14  Data Flash Base Address
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |DFBA      |Data Flash Base Address
S     * |        |          |This register indicates Data Flash start address. It is a read only register.
S     * |        |          |The Data Flash is shared with APROM. the content of this register is loaded from CONFIG1.
S     * |        |          |This register is valid when DFEN (CONFIG0[0]) =0 .
S     * @var FMC_T::FTCTL
S     * Offset: 0x18  Flash Access Time Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[6:4]   |FOM       |Frequency Optimization Mode (Write Protect)
S     * |        |          |The NuMicro M0564X series support adjustable flash access timing to optimize the flash access cycles in different working frequency.
S     * |        |          |0x1 = Frequency <= 24MHz.
S     * |        |          |1x1 = Frequency <= 72MHz.
S     * |        |          |Others = Frequency <= 48MHz.
S     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
S     * |[7]     |CACHEOFF  |Flash Cache Disable Control (Write Protect)
S     * |        |          |0 = Flash Cache function Enabled (default).
S     * |        |          |1 = Flash Cache [PT1]function Disabled.
S     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
S     * @var FMC_T::ISPSTS
S     * Offset: 0x40  ISP Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ISPBUSY   |ISP Busy Flag (Read Only)
S     * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.
S     * |        |          |This bit is the mirror of ISPGO(FMC_ISPTRG[0]).
S     * |        |          |0 = ISP operation is finished.
S     * |        |          |1 = ISP is progressed.
S     * |[2:1]   |CBS       |Boot Selection of CONFIG (Read Only)
S     * |        |          |This bit is initiated with the CBS (CONFIG0[7:6]) after any reset is happened except CPU reset (CPU is 1) or system reset (SYS) is happened.
S     * |        |          |00 = LDROM with IAP mode.
S     * |        |          |01 = LDROM without IAP mode.
S     * |        |          |10 = APROM with IAP mode.
S     * |        |          |11 = APROM without IAP mode.
S     * |[6]     |ISPFF     |ISP Fail Flag (Write Protect)
S     * |        |          |This bit is the mirror of ISPFF (FMC_ISPCTL[6]), it needs to be cleared by writing 1 to FMC_ISPCTL[6] or FMC_ISPSTS[6].
S     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
S     * |        |          |(1) APROM writes to itself if APUEN is set to 0.
S     * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
S     * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
S     * |        |          |(4) SPROM is erased/programmed if SPUEN is set to 0.
S     * |        |          |(5) SPROM is programmed at SPROM secured mode.
S     * |        |          |(6) Page Erase command at LOCK mode with ICE connection.
S     * |        |          |(7) Erase or Program command at brown-out detected.
S     * |        |          |(8) Destination address is illegal, such as over an available range.
S     * |        |          |(9) Invalid ISP commands.
S     * |        |          |(10) system vector address is remapped to SPROM.
S     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
S     * |[7]     |ALLONE    |Flash All-one Verification Flag
S     * |        |          |This bit is set by hardware if all of flash bits are 1, and clear if flash bits are not all 1 after "Run Flash All-One Verification" complete; this bit also can be clear by writing 1.
S     * |        |          |0 = Flash bits are not all 1 after "Run Flash All-One Verification" complete.
S     * |        |          |1 = All of flash bits are 1 after "Run Flash All-One Verification" complete.
S     * |[29:9]  |VECMAP    |Vector Page Mapping Address (Read Only)
S     * |        |          |All access to 0x0000_0000~0x0000_01FF is remapped to the flash memory or SRAM address {VECMAP[20:0], 9u2019h000} ~ {VECMAP[20:0], 9u2019h1FF}, except SPROM.
S     * |        |          |VECMAP [20:19] = 00 system vector address is mapped to flash memory.
S     * |        |          |VECMAP [20:19] = 10 system vector address is mapped to SRAM memory.
S     * |        |          |VECMAP [18:12] should be 0.
S     * |[31]    |SCODE     |Security Code Active Flag
S     * |        |          |This bit is set by hardware when detecting SPROM secured code is active at flash initiation, or software writes 1 to this bit to make secured code active; this bit is clear by SPROM page erase operation.
S     * |        |          |0 = Secured code is inactive.
S     * |        |          |1 = Secured code is active.
S     * @var FMC_T::MPDAT0
S     * Offset: 0x80  ISP Data0 Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |ISPDAT0   |ISP Data 0
S     * |        |          |This register is the first 32-bit data for 32-bit/64-bit/multi-word programming, and it is also the mirror of FMC_ISPDAT, both registers keep the same data.
S     * @var FMC_T::MPDAT1
S     * Offset: 0x84  ISP Data1 Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |ISPDAT1   |ISP Data 1
S     * |        |          |This register is the second 32-bit data for 64-bit/multi-word programming.
S     * @var FMC_T::MPDAT2
S     * Offset: 0x88  ISP Data2 Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |ISPDAT2   |ISP Data 2
S     * |        |          |This register is the third 32-bit data for multi-word programming.
S     * @var FMC_T::MPDAT3
S     * Offset: 0x8C  ISP Data3 Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |ISPDAT3   |ISP Data 3
S     * |        |          |This register is the fourth 32-bit data for multi-word programming.
S     * @var FMC_T::MPSTS
S     * Offset: 0xC0  ISP Multi-Program Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |MPBUSY    |ISP Multi-word Program Busy Flag (Read Only)
S     * |        |          |Write 1 to start ISP Multi-Word program operation and this bit will be cleared to 0 by hardware automatically when ISP Multi-Word program operation is finished.
S     * |        |          |This bit is the mirror of ISPGO(FMC_ISPTRG[0]).
S     * |        |          |0 = ISP Multi-Word program operation is finished.
S     * |        |          |1 = ISP Multi-Word program operation is progressed.
S     * |[1]     |PPGO      |ISP Multi-program Status (Read Only)
S     * |        |          |0 = ISP multi-word program operation is not active.
S     * |        |          |1 = ISP multi-word program operation is in progress.
S     * |[2]     |ISPFF     |ISP Fail Flag (Read Only)
S     * |        |          |This bit is the mirror of ISPFF (FMC_ISPCTL[6]), it needs to be cleared by writing 1 to FMC_ISPCTL[6] or FMC_ISPSTS[6].
S     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
S     * |        |          |(1) APROM writes to itself if APUEN is set to 0.
S     * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
S     * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
S     * |        |          |(4) Page Erase command at LOCK mode with ICE connection.
S     * |        |          |(5) Erase or Program command at brown-out detected.
S     * |        |          |(6) Destination address is illegal, such as over an available range.
S     * |        |          |(7) Invalid ISP commands.
S     * |[4]     |D0        |ISP DATA 0 Flag (Read Only)
S     * |        |          |This bit is set when FMC_MPDAT0 is written and auto-clear to 0 when the FMC_MPDAT0 data is programmed to flash complete.
S     * |        |          |0 = FMC_MPDAT0 register is empty, or program to flash complete.
S     * |        |          |1 = FMC_MPDAT0 register has been written, and not program to flash complete.
S     * |[5]     |D1        |ISP DATA 1 Flag (Read Only)
S     * |        |          |This bit is set when FMC_MPDAT1 is written and auto-clear to 0 when the FMC_MPDAT1 data is programmed to flash complete.
S     * |        |          |0 = FMC_MPDAT1 register is empty, or program to flash complete.
S     * |        |          |1 = FMC_MPDAT1 register has been written, and not program to flash complete.
S     * |[6]     |D2        |ISP DATA 2 Flag (Read Only)
S     * |        |          |This bit is set when FMC_MPDAT2 is written and auto-clear to 0 when the FMC_MPDAT2 data is programmed to flash complete.
S     * |        |          |0 = FMC_MPDAT2 register is empty, or program to flash complete.
S     * |        |          |1 = FMC_MPDAT2 register has been written, and not program to flash complete.
S     * |[7]     |D3        |ISP DATA 3 Flag (Read Only)
S     * |        |          |This bit is set when FMC_MPDAT3 is written and auto-clear to 0 when the FMC_MPDAT3 data is programmed to flash complete.
S     * |        |          |0 = FMC_MPDAT3 register is empty, or program to flash complete.
S     * |        |          |1 = FMC_MPDAT3 register has been written, and not program to flash complete.
S     * @var FMC_T::MPADDR
S     * Offset: 0xC4  ISP Multi-Program Address Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |MPADDR    |ISP Multi-word Program Address
S     * |        |          |MPADDR is the address of ISP multi-word program operation when ISPGO flag is 1.
S     * |        |          |MPADDR will keep the final ISP address when ISP multi-word program is complete.
S     */
S
S    __IO uint32_t ISPCTL;                /*!< [0x0000] ISP Control Register                                             */
S    __IO uint32_t ISPADDR;               /*!< [0x0004] ISP Address Register                                             */
S    __IO uint32_t ISPDAT;                /*!< [0x0008] ISP Data Register                                                */
S    __IO uint32_t ISPCMD;                /*!< [0x000c] ISP CMD Register                                                 */
S    __IO uint32_t ISPTRG;                /*!< [0x0010] ISP Trigger Control Register                                     */
S    __I  uint32_t DFBA;                  /*!< [0x0014] Data Flash Base Address                                          */
S    __IO uint32_t FTCTL;                 /*!< [0x0018] Flash Access Time Control Register                               */
S    __I  uint32_t RESERVE0[9];
S    __IO uint32_t ISPSTS;                /*!< [0x0040] ISP Status Register                                              */
S    __I  uint32_t RESERVE1[15];
S    __IO uint32_t MPDAT0;                /*!< [0x0080] ISP Data0 Register                                               */
S    __IO uint32_t MPDAT1;                /*!< [0x0084] ISP Data1 Register                                               */
S    __IO uint32_t MPDAT2;                /*!< [0x0088] ISP Data2 Register                                               */
S    __IO uint32_t MPDAT3;                /*!< [0x008c] ISP Data3 Register                                               */
S    __I  uint32_t RESERVE2[12];
S    __I  uint32_t MPSTS;                 /*!< [0x00c0] ISP Multi-Program Status Register                                */
S    __I  uint32_t MPADDR;                /*!< [0x00c4] ISP Multi-Program Address Register                               */
S
S} FMC_T;
S
S/**
S    @addtogroup FMC_CONST FMC Bit Field Definition
S    Constant Definitions for FMC Controller
S@{ */
S
S#define FMC_ISPCTL_ISPEN_Pos             (0)                                               /*!< FMC_T::ISPCTL: ISPEN Position          */
S#define FMC_ISPCTL_ISPEN_Msk             (0x1ul << FMC_ISPCTL_ISPEN_Pos)                   /*!< FMC_T::ISPCTL: ISPEN Mask              */
S
S#define FMC_ISPCTL_BS_Pos                (1)                                               /*!< FMC_T::ISPCTL: BS Position             */
S#define FMC_ISPCTL_BS_Msk                (0x1ul << FMC_ISPCTL_BS_Pos)                      /*!< FMC_T::ISPCTL: BS Mask                 */
S
S#define FMC_ISPCTL_SPUEN_Pos             (2)                                               /*!< FMC_T::ISPCTL: SPUEN Position          */
S#define FMC_ISPCTL_SPUEN_Msk             (0x1ul << FMC_ISPCTL_SPUEN_Pos)                   /*!< FMC_T::ISPCTL: SPUEN Mask              */
S
S#define FMC_ISPCTL_APUEN_Pos             (3)                                               /*!< FMC_T::ISPCTL: APUEN Position          */
S#define FMC_ISPCTL_APUEN_Msk             (0x1ul << FMC_ISPCTL_APUEN_Pos)                   /*!< FMC_T::ISPCTL: APUEN Mask              */
S
S#define FMC_ISPCTL_CFGUEN_Pos            (4)                                               /*!< FMC_T::ISPCTL: CFGUEN Position         */
S#define FMC_ISPCTL_CFGUEN_Msk            (0x1ul << FMC_ISPCTL_CFGUEN_Pos)                  /*!< FMC_T::ISPCTL: CFGUEN Mask             */
S
S#define FMC_ISPCTL_LDUEN_Pos             (5)                                               /*!< FMC_T::ISPCTL: LDUEN Position          */
S#define FMC_ISPCTL_LDUEN_Msk             (0x1ul << FMC_ISPCTL_LDUEN_Pos)                   /*!< FMC_T::ISPCTL: LDUEN Mask              */
S
S#define FMC_ISPCTL_ISPFF_Pos             (6)                                               /*!< FMC_T::ISPCTL: ISPFF Position          */
S#define FMC_ISPCTL_ISPFF_Msk             (0x1ul << FMC_ISPCTL_ISPFF_Pos)                   /*!< FMC_T::ISPCTL: ISPFF Mask              */
S
S#define FMC_ISPADDR_ISPADDR_Pos          (0)                                               /*!< FMC_T::ISPADDR: ISPADDR Position       */
S#define FMC_ISPADDR_ISPADDR_Msk          (0xfffffffful << FMC_ISPADDR_ISPADDR_Pos)         /*!< FMC_T::ISPADDR: ISPADDR Mask           */
S
S#define FMC_ISPDAT_ISPDAT_Pos            (0)                                               /*!< FMC_T::ISPDAT: ISPDAT Position         */
S#define FMC_ISPDAT_ISPDAT_Msk            (0xfffffffful << FMC_ISPDAT_ISPDAT_Pos)           /*!< FMC_T::ISPDAT: ISPDAT Mask             */
S
S#define FMC_ISPCMD_CMD_Pos               (0)                                               /*!< FMC_T::ISPCMD: CMD Position            */
S#define FMC_ISPCMD_CMD_Msk               (0x7ful << FMC_ISPCMD_CMD_Pos)                    /*!< FMC_T::ISPCMD: CMD Mask                */
S
S#define FMC_ISPTRG_ISPGO_Pos             (0)                                               /*!< FMC_T::ISPTRG: ISPGO Position          */
S#define FMC_ISPTRG_ISPGO_Msk             (0x1ul << FMC_ISPTRG_ISPGO_Pos)                   /*!< FMC_T::ISPTRG: ISPGO Mask              */
S
S#define FMC_DFBA_DFBA_Pos                (0)                                               /*!< FMC_T::DFBA: DFBA Position             */
S#define FMC_DFBA_DFBA_Msk                (0xfffffffful << FMC_DFBA_DFBA_Pos)               /*!< FMC_T::DFBA: DFBA Mask                 */
S
S#define FMC_FTCTL_FOM_Pos                (4)                                               /*!< FMC_T::FTCTL: FOM Position             */
S#define FMC_FTCTL_FOM_Msk                (0x7ul << FMC_FTCTL_FOM_Pos)                      /*!< FMC_T::FTCTL: FOM Mask                 */
S
S#define FMC_FTCTL_CACHEOFF_Pos           (7)                                               /*!< FMC_T::FTCTL: CACHEOFF Position        */
S#define FMC_FTCTL_CACHEOFF_Msk           (0x1ul << FMC_FTCTL_CACHEOFF_Pos)                 /*!< FMC_T::FTCTL: CACHEOFF Mask            */
S
S#define FMC_ISPSTS_ISPBUSY_Pos           (0)                                               /*!< FMC_T::ISPSTS: ISPBUSY Position        */
S#define FMC_ISPSTS_ISPBUSY_Msk           (0x1ul << FMC_ISPSTS_ISPBUSY_Pos)                 /*!< FMC_T::ISPSTS: ISPBUSY Mask            */
S
S#define FMC_ISPSTS_CBS_Pos               (1)                                               /*!< FMC_T::ISPSTS: CBS Position            */
S#define FMC_ISPSTS_CBS_Msk               (0x3ul << FMC_ISPSTS_CBS_Pos)                     /*!< FMC_T::ISPSTS: CBS Mask                */
S
S#define FMC_ISPSTS_ISPFF_Pos             (6)                                               /*!< FMC_T::ISPSTS: ISPFF Position          */
S#define FMC_ISPSTS_ISPFF_Msk             (0x1ul << FMC_ISPSTS_ISPFF_Pos)                   /*!< FMC_T::ISPSTS: ISPFF Mask              */
S
S#define FMC_ISPSTS_ALLONE_Pos            (7)                                               /*!< FMC_T::ISPSTS: ALLONE Position         */
S#define FMC_ISPSTS_ALLONE_Msk            (0x1ul << FMC_ISPSTS_ALLONE_Pos)                  /*!< FMC_T::ISPSTS: ALLONE Mask             */
S
S#define FMC_ISPSTS_VECMAP_Pos            (9)                                               /*!< FMC_T::ISPSTS: VECMAP Position         */
S#define FMC_ISPSTS_VECMAP_Msk            (0x1ffffful << FMC_ISPSTS_VECMAP_Pos)             /*!< FMC_T::ISPSTS: VECMAP Mask             */
S
S#define FMC_ISPSTS_SCODE_Pos             (31)                                              /*!< FMC_T::ISPSTS: SCODE Position          */
S#define FMC_ISPSTS_SCODE_Msk             (0x1ul << FMC_ISPSTS_SCODE_Pos)                   /*!< FMC_T::ISPSTS: SCODE Mask              */
S
S#define FMC_MPDAT0_ISPDAT0_Pos           (0)                                               /*!< FMC_T::MPDAT0: ISPDAT0 Position        */
S#define FMC_MPDAT0_ISPDAT0_Msk           (0xfffffffful << FMC_MPDAT0_ISPDAT0_Pos)          /*!< FMC_T::MPDAT0: ISPDAT0 Mask            */
S
S#define FMC_MPDAT1_ISPDAT1_Pos           (0)                                               /*!< FMC_T::MPDAT1: ISPDAT1 Position        */
S#define FMC_MPDAT1_ISPDAT1_Msk           (0xfffffffful << FMC_MPDAT1_ISPDAT1_Pos)          /*!< FMC_T::MPDAT1: ISPDAT1 Mask            */
S
S#define FMC_MPDAT2_ISPDAT2_Pos           (0)                                               /*!< FMC_T::MPDAT2: ISPDAT2 Position        */
S#define FMC_MPDAT2_ISPDAT2_Msk           (0xfffffffful << FMC_MPDAT2_ISPDAT2_Pos)          /*!< FMC_T::MPDAT2: ISPDAT2 Mask            */
S
S#define FMC_MPDAT3_ISPDAT3_Pos           (0)                                               /*!< FMC_T::MPDAT3: ISPDAT3 Position        */
S#define FMC_MPDAT3_ISPDAT3_Msk           (0xfffffffful << FMC_MPDAT3_ISPDAT3_Pos)          /*!< FMC_T::MPDAT3: ISPDAT3 Mask            */
S
S#define FMC_MPSTS_MPBUSY_Pos             (0)                                               /*!< FMC_T::MPSTS: MPBUSY Position          */
S#define FMC_MPSTS_MPBUSY_Msk             (0x1ul << FMC_MPSTS_MPBUSY_Pos)                   /*!< FMC_T::MPSTS: MPBUSY Mask              */
S
S#define FMC_MPSTS_PPGO_Pos               (1)                                               /*!< FMC_T::MPSTS: PPGO Position            */
S#define FMC_MPSTS_PPGO_Msk               (0x1ul << FMC_MPSTS_PPGO_Pos)                     /*!< FMC_T::MPSTS: PPGO Mask                */
S
S#define FMC_MPSTS_ISPFF_Pos              (2)                                               /*!< FMC_T::MPSTS: ISPFF Position           */
S#define FMC_MPSTS_ISPFF_Msk              (0x1ul << FMC_MPSTS_ISPFF_Pos)                    /*!< FMC_T::MPSTS: ISPFF Mask               */
S
S#define FMC_MPSTS_D0_Pos                 (4)                                               /*!< FMC_T::MPSTS: D0 Position              */
S#define FMC_MPSTS_D0_Msk                 (0x1ul << FMC_MPSTS_D0_Pos)                       /*!< FMC_T::MPSTS: D0 Mask                  */
S
S#define FMC_MPSTS_D1_Pos                 (5)                                               /*!< FMC_T::MPSTS: D1 Position              */
S#define FMC_MPSTS_D1_Msk                 (0x1ul << FMC_MPSTS_D1_Pos)                       /*!< FMC_T::MPSTS: D1 Mask                  */
S
S#define FMC_MPSTS_D2_Pos                 (6)                                               /*!< FMC_T::MPSTS: D2 Position              */
S#define FMC_MPSTS_D2_Msk                 (0x1ul << FMC_MPSTS_D2_Pos)                       /*!< FMC_T::MPSTS: D2 Mask                  */
S
S#define FMC_MPSTS_D3_Pos                 (7)                                               /*!< FMC_T::MPSTS: D3 Position              */
S#define FMC_MPSTS_D3_Msk                 (0x1ul << FMC_MPSTS_D3_Pos)                       /*!< FMC_T::MPSTS: D3 Mask                  */
S
S#define FMC_MPADDR_MPADDR_Pos            (0)                                               /*!< FMC_T::MPADDR: MPADDR Position         */
S#define FMC_MPADDR_MPADDR_Msk            (0xfffffffful << FMC_MPADDR_MPADDR_Pos)           /*!< FMC_T::MPADDR: MPADDR Mask             */
S
S/**@}*/ /* FMC_CONST */
S/**@}*/ /* end of FMC register group */
S
S
S/*---------------------- General Purpose Input/Output Controller -------------------------*/
S/**
S    @addtogroup GPIO General Purpose Input/Output Controller(GPIO)
S    Memory Mapped Structure for GPIO Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var GPIO_T::MODE
S     * Offset: 0x00/0x40/0x80/0xC0/0x100/0x140  PA-F I/O Mode Control
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2n+1:2n]|MODEn    |Port A-F I/O Pin[n] Mode Control
S     * |        |          |Determine each I/O mode of Px.n pins.
S     * |        |          |00 = Px.n is in Input mode.
S     * |        |          |01 = Px.n is in Push-pull Output mode.
S     * |        |          |10 = Px.n is in Open-drain Output mode.
S     * |        |          |11 = Px.n is in Quasi-bidirectional mode.
S     * |        |          |Note1: The initial value of this field is defined by CIOINI (CONFIG0 [10]).
S     * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on.
S     * |        |          |If CIOINI is set to 0, the default value is 0x0000_0000 and all pins will be input mode after chip powered on.
S     * |        |          |Note2:
S     * |        |          |Max. n=15 for port A/B/C/D/E.
S     * |        |          |Max. n=7 for port F.
S     * |        |          |Note3: The PE.14/PE.15 pin is ignored.
S     * @var GPIO_T::DINOFF
S     * Offset: 0x04/0x44/0x84/0xC4/0x104/0x144  PA-F Digital Input Path Disable Control
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[n+16]  |DINOFFn   |Port A-F Pin[n] Digital Input Path Disable Control
S     * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.
S     * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
S     * |        |          |0 = Px.n digital input path Enabled.
S     * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
S     * |        |          |Note1:
S     * |        |          |Max. n=15 for port A/B/C/D/E.
S     * |        |          |Max. n=7 for port F.
S     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
S     * @var GPIO_T::DOUT
S     * Offset: 0x08/0x48/0x88/0xC8/0x108/0x148  PA-F Data Output Value
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[n]     |DOUTn     |Port A-F Pin[n] Output Value
S     * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
S     * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
S     * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
S     * |        |          |Note1:
S     * |        |          |Max. n=15 for port A/B/C/D/E.
S     * |        |          |Max. n=7 for port F.
S     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
S     * @var GPIO_T::DATMSK
S     * Offset: 0x0C/0x4C/0x8C/0xCC/0x10C/0x14C  PA-F Data Output Write Mask
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[n]     |DATMSKn   |Port A-F Pin[n] Data Output Write Mask
S     * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.
S     * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.
S     * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
S     * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
S     * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
S     * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
S     * |        |          |Note2:
S     * |        |          |Max. n=15 for port A/B/C/D/E.
S     * |        |          |Max. n=7 for port F.
S     * |        |          |Note3: The PE.14/PE.15 pin is ignored.
S     * @var GPIO_T::PIN
S     * Offset: 0x10/0x50/0x90/0xD0/0x110/0x150  PA-F Pin Value
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[n]     |PINn      |Port A-F Pin[n] Pin Value
S     * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin.
S     * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
S     * |        |          |Note1:
S     * |        |          |Max. n=15 for port A/B/C/D/E.
S     * |        |          |Max. n=7 for port F.
S     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
S     * @var GPIO_T::DBEN
S     * Offset: 0x14/0x54/0x94/0xD4/0x114/0x154  PA-F De-Bounce Enable Control
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[n]     |DBEN0     |Port A-F Pin[n] Input Signal De-bounce Enable Bit
S     * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.
S     * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.
S     * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
S     * |        |          |0 = Px.n de-bounce function Disabled.
S     * |        |          |1 = Px.n de-bounce function Enabled.
S     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
S     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
S     * |        |          |Note1:
S     * |        |          |Max. n=15 for port A/B/C/D/E.
S     * |        |          |Max. n=7 for port F.
S     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
S     * @var GPIO_T::INTTYPE
S     * Offset: 0x18/0x58/0x98/0xD8/0x118/0x158  PA-F Interrupt Trigger Type Control
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[n]     |TYPEn     |Port A-F Pin[n] Edge or Level Detection Interrupt Trigger Type Control
S     * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.
S     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
S     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
S     * |        |          |0 = Edge trigger interrupt.
S     * |        |          |1 = Level trigger interrupt.
S     * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).
S     * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
S     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
S     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
S     * |        |          |Note1:
S     * |        |          |Max. n=15 for port A/B/C/D/E.
S     * |        |          |Max. n=7 for port F.
S     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
S     * @var GPIO_T::INTEN
S     * Offset: 0x1C/0x5C/0x9C/0xDC/0x11C/0x15C  PA-F Interrupt Enable Control
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[n]     |FLIENn    |Port 0-5 Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Bit
S     * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
S     * |        |          |Set bit to 1 also enable the pin wake-up function.
S     * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
S     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
S     * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
S     * |        |          |0 = Px.n level low or high to low interrupt Disabled.
S     * |        |          |1 = Px.n level low or high to low interrupt Enabled.
S     * |        |          |Note1:
S     * |        |          |Max. n=15 for port A/B/C/D/E.
S     * |        |          |Max. n=7 for port F.
S     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
S     * |[n+16   |RHIENn    |Port A-F Pin[n] Rising Edge or High Level Interrupt Trigger Type Enable Bit
S     * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
S     * |        |          |Set bit to 1 also enable the pin wake-up function.
S     * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1 :
S     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
S     * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
S     * |        |          |0 = Px.n level high or low to high interrupt Disabled.
S     * |        |          |1 = Px.n level high or low to high interrupt Enabled.
S     * |        |          |Note1:
S     * |        |          |Max. n=15 for port A/B/C/D/E.
S     * |        |          |Max. n=7 for port F.
S     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
S     * @var GPIO_T::INTSRC
S     * Offset: 0x20/0x60/0xA0/0xE0/0x120/0x160  PA-F Interrupt Source Flag
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[n]     |INTSRCn   |Port A-F Pin[n] Interrupt Source Flag
S     * |        |          |Write Operation :
S     * |        |          |0 = No action.
S     * |        |          |1 = Clear the corresponding pending interrupt.
S     * |        |          |Read Operation :
S     * |        |          |0 = No interrupt at Px.n.
S     * |        |          |1 = Px.n generates an interrupt.
S     * |        |          |Note1:
S     * |        |          |Max. n=15 for port A/B/C/D/E.
S     * |        |          |Max. n=7 for port F.
S     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
S     * @var GPIO_T::SMTEN
S     * Offset: 0x24/0x64/0xA4/0xE4/0x124/0x164  PA-F Input Schmitt Trigger Enable
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[n]     |SMTENn    |Port 0-5 Pin[n] Input Schmitt Trigger Enable Bit
S     * |        |          |0 = Px.n input schmitt trigger function Disabled.
S     * |        |          |1 = Px.n input schmitt trigger function Enabled.
S     * |        |          |Note1:
S     * |        |          |Max. n=15 for port A/B/C/D/E.
S     * |        |          |Max. n=7 for port F.
S     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
S     * @var GPIO_T::SLEWCTL
S     * Offset: 0x28/0x68/0xA8/0xE8/0x128/0x168  PA-F High Slew Rate Control
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[n]     |HSRENn    |Port 0-5 Pin[n] High Slew Rate Control
S     * |        |          |0 = Px.n output with basic slew rate.
S     * |        |          |1 = Px.n output with higher slew rate.
S     * |        |          |Note1:
S     * |        |          |Max. n=15 for port A/B/C/D/E.
S     * |        |          |Max. n=7 for port F.
S     * |        |          |Note2: The PE.14/PE.15 pin is ignored.
S     * @var GPIO_T::DRVCTL
S     * Offset: 0x12C  PE High Drive Strength Control
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[n]     |HDRVENn   |Port E Pin[n] Driving Strength Control
S     * |        |          |0 = Px.n output with basic driving strength.
S     * |        |          |1 = Px.n output with high driving strength.
S     * |        |          |Note:
S     * |        |          |n=8,9..13 for port E.
S     */
S
S
S    __IO uint32_t MODE;                  /*!< [0x00/0x40/0x80/0xC0/0x100/0x140] PA-F I/O Mode Control                   */
S    __IO uint32_t DINOFF;                /*!< [0x04/0x44/0x84/0xC4/0x104/0x144] PA-F Digital Input Path Disable Control */
S    __IO uint32_t DOUT;                  /*!< [0x08/0x48/0x88/0xC8/0x108/0x148] PA-F Data Output Value                  */
S    __IO uint32_t DATMSK;                /*!< [0x0C/0x4C/0x8C/0xCC/0x10C/0x14C] PA-F Data Output Write Mask             */
S    __I  uint32_t PIN;                   /*!< [0x10/0x50/0x90/0xD0/0x110/0x150] PA-F Pin Value                          */
S    __IO uint32_t DBEN;                  /*!< [0x14/0x54/0x94/0xD4/0x114/0x154] PA-F De-Bounce Enable Control           */
S    __IO uint32_t INTTYPE;               /*!< [0x18/0x58/0x98/0xD8/0x118/0x158] PA-F Interrupt Trigger Type Control     */
S    __IO uint32_t INTEN;                 /*!< [0x1C/0x5C/0x9C/0xDC/0x11C/0x15C] PA-F Interrupt Enable Control           */
S    __IO uint32_t INTSRC;                /*!< [0x20/0x60/0xA0/0xE0/0x120/0x160] PA-F Interrupt Source Flag              */
S    __IO uint32_t SMTEN;                 /*!< [0x24/0x64/0xA4/0xE4/0x124/0x164] PA-F Input Schmitt Trigger Enable       */
S    __IO uint32_t SLEWCTL;               /*!< [0x28/0x68/0xA8/0xE8/0x128/0x168] PA-F High Slew Rate Control             */
S    __IO uint32_t DRVCTL;                /*!< [0x012c] PE High Drive Strength Control                                   */
S
S
S} GPIO_T;
S
S
Stypedef struct
S{
S
S
S    /**
S     * @var GPIO_DBCTL_T::DBCTL
S     * Offset: 0x180  Interrupt De-bounce Control
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |DBCLKSEL  |De-bounce Sampling Cycle Selection
S     * |        |          |0000 = Sample interrupt input once per 1 clocks.
S     * |        |          |0001 = Sample interrupt input once per 2 clocks.
S     * |        |          |0010 = Sample interrupt input once per 4 clocks.
S     * |        |          |0011 = Sample interrupt input once per 8 clocks.
S     * |        |          |0100 = Sample interrupt input once per 16 clocks.
S     * |        |          |0101 = Sample interrupt input once per 32 clocks.
S     * |        |          |0110 = Sample interrupt input once per 64 clocks.
S     * |        |          |0111 = Sample interrupt input once per 128 clocks.
S     * |        |          |1000 = Sample interrupt input once per 256 clocks.
S     * |        |          |1001 = Sample interrupt input once per 2*256 clocks.
S     * |        |          |1010 = Sample interrupt input once per 4*256 clocks.
S     * |        |          |1011 = Sample interrupt input once per 8*256 clocks.
S     * |        |          |1100 = Sample interrupt input once per 16*256 clocks.
S     * |        |          |1101 = Sample interrupt input once per 32*256 clocks.
S     * |        |          |1110 = Sample interrupt input once per 64*256 clocks.
S     * |        |          |1111 = Sample interrupt input once per 128*256 clocks.
S     * |[4]     |DBCLKSRC  |De-bounce Counter Clock Source Selection
S     * |        |          |0 = De-bounce counter clock source is the HCLK.
S     * |        |          |1 = De-bounce counter clock source is the internal 10 kHz internal low speed oscillator.
S     * |[5]     |ICLKON    |Interrupt Clock on Mode
S     * |        |          |0 = Edge detection circuit is active only if I/O pin corresponding RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]) bit is set to 1.
S     * |        |          |1 = All I/O pins edge detection circuit is always active after reset.
S     * |        |          |Note: It is recommended to disable this bit to save system power if no special application concern.
S     */
S
S    __IO uint32_t DBCTL;                 /*!< [0x0180] Interrupt De-bounce Control                                      */
S
S} GPIO_DBCTL_T;
S
S
S
S/**
S    @addtogroup GPIO_CONST GPIO Bit Field Definition
S    Constant Definitions for GPIO Controller
S@{ */
S
S#define GPIO_MODE_MODE0_Pos              (0)                                               /*!< GPIO_T::MODE: MODE0 Position           */
S#define GPIO_MODE_MODE0_Msk              (0x3ul << GPIO_MODE_MODE0_Pos)                    /*!< GPIO_T::MODE: MODE0 Mask               */
S
S#define GPIO_MODE_MODE1_Pos              (2)                                               /*!< GPIO_T::MODE: MODE1 Position           */
S#define GPIO_MODE_MODE1_Msk              (0x3ul << GPIO_MODE_MODE1_Pos)                    /*!< GPIO_T::MODE: MODE1 Mask               */
S
S#define GPIO_MODE_MODE2_Pos              (4)                                               /*!< GPIO_T::MODE: MODE2 Position           */
S#define GPIO_MODE_MODE2_Msk              (0x3ul << GPIO_MODE_MODE2_Pos)                    /*!< GPIO_T::MODE: MODE2 Mask               */
S
S#define GPIO_MODE_MODE3_Pos              (6)                                               /*!< GPIO_T::MODE: MODE3 Position           */
S#define GPIO_MODE_MODE3_Msk              (0x3ul << GPIO_MODE_MODE3_Pos)                    /*!< GPIO_T::MODE: MODE3 Mask               */
S
S#define GPIO_MODE_MODE4_Pos              (8)                                               /*!< GPIO_T::MODE: MODE4 Position           */
S#define GPIO_MODE_MODE4_Msk              (0x3ul << GPIO_MODE_MODE4_Pos)                    /*!< GPIO_T::MODE: MODE4 Mask               */
S
S#define GPIO_MODE_MODE5_Pos              (10)                                              /*!< GPIO_T::MODE: MODE5 Position           */
S#define GPIO_MODE_MODE5_Msk              (0x3ul << GPIO_MODE_MODE5_Pos)                    /*!< GPIO_T::MODE: MODE5 Mask               */
S
S#define GPIO_MODE_MODE6_Pos              (12)                                              /*!< GPIO_T::MODE: MODE6 Position           */
S#define GPIO_MODE_MODE6_Msk              (0x3ul << GPIO_MODE_MODE6_Pos)                    /*!< GPIO_T::MODE: MODE6 Mask               */
S
S#define GPIO_MODE_MODE7_Pos              (14)                                              /*!< GPIO_T::MODE: MODE7 Position           */
S#define GPIO_MODE_MODE7_Msk              (0x3ul << GPIO_MODE_MODE7_Pos)                    /*!< GPIO_T::MODE: MODE7 Mask               */
S
S#define GPIO_MODE_MODE8_Pos              (16)                                              /*!< GPIO_T::MODE: MODE8 Position           */
S#define GPIO_MODE_MODE8_Msk              (0x3ul << GPIO_MODE_MODE8_Pos)                    /*!< GPIO_T::MODE: MODE8 Mask               */
S
S#define GPIO_MODE_MODE9_Pos              (18)                                              /*!< GPIO_T::MODE: MODE9 Position           */
S#define GPIO_MODE_MODE9_Msk              (0x3ul << GPIO_MODE_MODE9_Pos)                    /*!< GPIO_T::MODE: MODE9 Mask               */
S
S#define GPIO_MODE_MODE10_Pos             (20)                                              /*!< GPIO_T::MODE: MODE10 Position          */
S#define GPIO_MODE_MODE10_Msk             (0x3ul << GPIO_MODE_MODE10_Pos)                   /*!< GPIO_T::MODE: MODE10 Mask              */
S
S#define GPIO_MODE_MODE11_Pos             (22)                                              /*!< GPIO_T::MODE: MODE11 Position          */
S#define GPIO_MODE_MODE11_Msk             (0x3ul << GPIO_MODE_MODE11_Pos)                   /*!< GPIO_T::MODE: MODE11 Mask              */
S
S#define GPIO_MODE_MODE12_Pos             (24)                                              /*!< GPIO_T::MODE: MODE12 Position          */
S#define GPIO_MODE_MODE12_Msk             (0x3ul << GPIO_MODE_MODE12_Pos)                   /*!< GPIO_T::MODE: MODE12 Mask              */
S
S#define GPIO_MODE_MODE13_Pos             (26)                                              /*!< GPIO_T::MODE: MODE13 Position          */
S#define GPIO_MODE_MODE13_Msk             (0x3ul << GPIO_MODE_MODE13_Pos)                   /*!< GPIO_T::MODE: MODE13 Mask              */
S
S#define GPIO_MODE_MODE14_Pos             (28)                                              /*!< GPIO_T::MODE: MODE14 Position          */
S#define GPIO_MODE_MODE14_Msk             (0x3ul << GPIO_MODE_MODE14_Pos)                   /*!< GPIO_T::MODE: MODE14 Mask              */
S
S#define GPIO_MODE_MODE15_Pos             (30)                                              /*!< GPIO_T::MODE: MODE15 Position          */
S#define GPIO_MODE_MODE15_Msk             (0x3ul << GPIO_MODE_MODE15_Pos)                   /*!< GPIO_T::MODE: MODE15 Mask              */
S
S#define GPIO_DINOFF_DINOFF0_Pos          (16)                                              /*!< GPIO_T::DINOFF: DINOFF0 Position       */
S#define GPIO_DINOFF_DINOFF0_Msk          (0x1ul << GPIO_DINOFF_DINOFF0_Pos)                /*!< GPIO_T::DINOFF: DINOFF0 Mask           */
S
S#define GPIO_DINOFF_DINOFF1_Pos          (17)                                              /*!< GPIO_T::DINOFF: DINOFF1 Position       */
S#define GPIO_DINOFF_DINOFF1_Msk          (0x1ul << GPIO_DINOFF_DINOFF1_Pos)                /*!< GPIO_T::DINOFF: DINOFF1 Mask           */
S
S#define GPIO_DINOFF_DINOFF2_Pos          (18)                                              /*!< GPIO_T::DINOFF: DINOFF2 Position       */
S#define GPIO_DINOFF_DINOFF2_Msk          (0x1ul << GPIO_DINOFF_DINOFF2_Pos)                /*!< GPIO_T::DINOFF: DINOFF2 Mask           */
S
S#define GPIO_DINOFF_DINOFF3_Pos          (19)                                              /*!< GPIO_T::DINOFF: DINOFF3 Position       */
S#define GPIO_DINOFF_DINOFF3_Msk          (0x1ul << GPIO_DINOFF_DINOFF3_Pos)                /*!< GPIO_T::DINOFF: DINOFF3 Mask           */
S
S#define GPIO_DINOFF_DINOFF4_Pos          (20)                                              /*!< GPIO_T::DINOFF: DINOFF4 Position       */
S#define GPIO_DINOFF_DINOFF4_Msk          (0x1ul << GPIO_DINOFF_DINOFF4_Pos)                /*!< GPIO_T::DINOFF: DINOFF4 Mask           */
S
S#define GPIO_DINOFF_DINOFF5_Pos          (21)                                              /*!< GPIO_T::DINOFF: DINOFF5 Position       */
S#define GPIO_DINOFF_DINOFF5_Msk          (0x1ul << GPIO_DINOFF_DINOFF5_Pos)                /*!< GPIO_T::DINOFF: DINOFF5 Mask           */
S
S#define GPIO_DINOFF_DINOFF6_Pos          (22)                                              /*!< GPIO_T::DINOFF: DINOFF6 Position       */
S#define GPIO_DINOFF_DINOFF6_Msk          (0x1ul << GPIO_DINOFF_DINOFF6_Pos)                /*!< GPIO_T::DINOFF: DINOFF6 Mask           */
S
S#define GPIO_DINOFF_DINOFF7_Pos          (23)                                              /*!< GPIO_T::DINOFF: DINOFF7 Position       */
S#define GPIO_DINOFF_DINOFF7_Msk          (0x1ul << GPIO_DINOFF_DINOFF7_Pos)                /*!< GPIO_T::DINOFF: DINOFF7 Mask           */
S
S#define GPIO_DINOFF_DINOFF8_Pos          (24)                                              /*!< GPIO_T::DINOFF: DINOFF8 Position       */
S#define GPIO_DINOFF_DINOFF8_Msk          (0x1ul << GPIO_DINOFF_DINOFF8_Pos)                /*!< GPIO_T::DINOFF: DINOFF8 Mask           */
S
S#define GPIO_DINOFF_DINOFF9_Pos          (25)                                              /*!< GPIO_T::DINOFF: DINOFF9 Position       */
S#define GPIO_DINOFF_DINOFF9_Msk          (0x1ul << GPIO_DINOFF_DINOFF9_Pos)                /*!< GPIO_T::DINOFF: DINOFF9 Mask           */
S
S#define GPIO_DINOFF_DINOFF10_Pos         (26)                                              /*!< GPIO_T::DINOFF: DINOFF10 Position      */
S#define GPIO_DINOFF_DINOFF10_Msk         (0x1ul << GPIO_DINOFF_DINOFF10_Pos)               /*!< GPIO_T::DINOFF: DINOFF10 Mask          */
S
S#define GPIO_DINOFF_DINOFF11_Pos         (27)                                              /*!< GPIO_T::DINOFF: DINOFF11 Position      */
S#define GPIO_DINOFF_DINOFF11_Msk         (0x1ul << GPIO_DINOFF_DINOFF11_Pos)               /*!< GPIO_T::DINOFF: DINOFF11 Mask          */
S
S#define GPIO_DINOFF_DINOFF12_Pos         (28)                                              /*!< GPIO_T::DINOFF: DINOFF12 Position      */
S#define GPIO_DINOFF_DINOFF12_Msk         (0x1ul << GPIO_DINOFF_DINOFF12_Pos)               /*!< GPIO_T::DINOFF: DINOFF12 Mask          */
S
S#define GPIO_DINOFF_DINOFF13_Pos         (29)                                              /*!< GPIO_T::DINOFF: DINOFF13 Position      */
S#define GPIO_DINOFF_DINOFF13_Msk         (0x1ul << GPIO_DINOFF_DINOFF13_Pos)               /*!< GPIO_T::DINOFF: DINOFF13 Mask          */
S
S#define GPIO_DINOFF_DINOFF14_Pos         (30)                                              /*!< GPIO_T::DINOFF: DINOFF14 Position      */
S#define GPIO_DINOFF_DINOFF14_Msk         (0x1ul << GPIO_DINOFF_DINOFF14_Pos)               /*!< GPIO_T::DINOFF: DINOFF14 Mask          */
S
S#define GPIO_DINOFF_DINOFF15_Pos         (31)                                              /*!< GPIO_T::DINOFF: DINOFF15 Position      */
S#define GPIO_DINOFF_DINOFF15_Msk         (0x1ul << GPIO_DINOFF_DINOFF15_Pos)               /*!< GPIO_T::DINOFF: DINOFF15 Mask          */
S
S#define GPIO_DOUT_DOUT0_Pos              (0)                                               /*!< GPIO_T::DOUT: DOUT0 Position           */
S#define GPIO_DOUT_DOUT0_Msk              (0x1ul << GPIO_DOUT_DOUT0_Pos)                    /*!< GPIO_T::DOUT: DOUT0 Mask               */
S
S#define GPIO_DOUT_DOUT1_Pos              (1)                                               /*!< GPIO_T::DOUT: DOUT1 Position           */
S#define GPIO_DOUT_DOUT1_Msk              (0x1ul << GPIO_DOUT_DOUT1_Pos)                    /*!< GPIO_T::DOUT: DOUT1 Mask               */
S
S#define GPIO_DOUT_DOUT2_Pos              (2)                                               /*!< GPIO_T::DOUT: DOUT2 Position           */
S#define GPIO_DOUT_DOUT2_Msk              (0x1ul << GPIO_DOUT_DOUT2_Pos)                    /*!< GPIO_T::DOUT: DOUT2 Mask               */
S
S#define GPIO_DOUT_DOUT3_Pos              (3)                                               /*!< GPIO_T::DOUT: DOUT3 Position           */
S#define GPIO_DOUT_DOUT3_Msk              (0x1ul << GPIO_DOUT_DOUT3_Pos)                    /*!< GPIO_T::DOUT: DOUT3 Mask               */
S
S#define GPIO_DOUT_DOUT4_Pos              (4)                                               /*!< GPIO_T::DOUT: DOUT4 Position           */
S#define GPIO_DOUT_DOUT4_Msk              (0x1ul << GPIO_DOUT_DOUT4_Pos)                    /*!< GPIO_T::DOUT: DOUT4 Mask               */
S
S#define GPIO_DOUT_DOUT5_Pos              (5)                                               /*!< GPIO_T::DOUT: DOUT5 Position           */
S#define GPIO_DOUT_DOUT5_Msk              (0x1ul << GPIO_DOUT_DOUT5_Pos)                    /*!< GPIO_T::DOUT: DOUT5 Mask               */
S
S#define GPIO_DOUT_DOUT6_Pos              (6)                                               /*!< GPIO_T::DOUT: DOUT6 Position           */
S#define GPIO_DOUT_DOUT6_Msk              (0x1ul << GPIO_DOUT_DOUT6_Pos)                    /*!< GPIO_T::DOUT: DOUT6 Mask               */
S
S#define GPIO_DOUT_DOUT7_Pos              (7)                                               /*!< GPIO_T::DOUT: DOUT7 Position           */
S#define GPIO_DOUT_DOUT7_Msk              (0x1ul << GPIO_DOUT_DOUT7_Pos)                    /*!< GPIO_T::DOUT: DOUT7 Mask               */
S
S#define GPIO_DOUT_DOUT8_Pos              (8)                                               /*!< GPIO_T::DOUT: DOUT8 Position           */
S#define GPIO_DOUT_DOUT8_Msk              (0x1ul << GPIO_DOUT_DOUT8_Pos)                    /*!< GPIO_T::DOUT: DOUT8 Mask               */
S
S#define GPIO_DOUT_DOUT9_Pos              (9)                                               /*!< GPIO_T::DOUT: DOUT9 Position           */
S#define GPIO_DOUT_DOUT9_Msk              (0x1ul << GPIO_DOUT_DOUT9_Pos)                    /*!< GPIO_T::DOUT: DOUT9 Mask               */
S
S#define GPIO_DOUT_DOUT10_Pos             (10)                                              /*!< GPIO_T::DOUT: DOUT10 Position          */
S#define GPIO_DOUT_DOUT10_Msk             (0x1ul << GPIO_DOUT_DOUT10_Pos)                   /*!< GPIO_T::DOUT: DOUT10 Mask              */
S
S#define GPIO_DOUT_DOUT11_Pos             (11)                                              /*!< GPIO_T::DOUT: DOUT11 Position          */
S#define GPIO_DOUT_DOUT11_Msk             (0x1ul << GPIO_DOUT_DOUT11_Pos)                   /*!< GPIO_T::DOUT: DOUT11 Mask              */
S
S#define GPIO_DOUT_DOUT12_Pos             (12)                                              /*!< GPIO_T::DOUT: DOUT12 Position          */
S#define GPIO_DOUT_DOUT12_Msk             (0x1ul << GPIO_DOUT_DOUT12_Pos)                   /*!< GPIO_T::DOUT: DOUT12 Mask              */
S
S#define GPIO_DOUT_DOUT13_Pos             (13)                                              /*!< GPIO_T::DOUT: DOUT13 Position          */
S#define GPIO_DOUT_DOUT13_Msk             (0x1ul << GPIO_DOUT_DOUT13_Pos)                   /*!< GPIO_T::DOUT: DOUT13 Mask              */
S
S#define GPIO_DOUT_DOUT14_Pos             (14)                                              /*!< GPIO_T::DOUT: DOUT14 Position          */
S#define GPIO_DOUT_DOUT14_Msk             (0x1ul << GPIO_DOUT_DOUT14_Pos)                   /*!< GPIO_T::DOUT: DOUT14 Mask              */
S
S#define GPIO_DOUT_DOUT15_Pos             (15)                                              /*!< GPIO_T::DOUT: DOUT15 Position          */
S#define GPIO_DOUT_DOUT15_Msk             (0x1ul << GPIO_DOUT_DOUT15_Pos)                   /*!< GPIO_T::DOUT: DOUT15 Mask              */
S
S#define GPIO_DATMSK_DATMSK0_Pos          (0)                                               /*!< GPIO_T::DATMSK: DATMSK0 Position       */
S#define GPIO_DATMSK_DATMSK0_Msk          (0x1ul << GPIO_DATMSK_DATMSK0_Pos)                /*!< GPIO_T::DATMSK: DATMSK0 Mask           */
S
S#define GPIO_DATMSK_DATMSK1_Pos          (1)                                               /*!< GPIO_T::DATMSK: DATMSK1 Position       */
S#define GPIO_DATMSK_DATMSK1_Msk          (0x1ul << GPIO_DATMSK_DATMSK1_Pos)                /*!< GPIO_T::DATMSK: DATMSK1 Mask           */
S
S#define GPIO_DATMSK_DATMSK2_Pos          (2)                                               /*!< GPIO_T::DATMSK: DATMSK2 Position       */
S#define GPIO_DATMSK_DATMSK2_Msk          (0x1ul << GPIO_DATMSK_DATMSK2_Pos)                /*!< GPIO_T::DATMSK: DATMSK2 Mask           */
S
S#define GPIO_DATMSK_DATMSK3_Pos          (3)                                               /*!< GPIO_T::DATMSK: DATMSK3 Position       */
S#define GPIO_DATMSK_DATMSK3_Msk          (0x1ul << GPIO_DATMSK_DATMSK3_Pos)                /*!< GPIO_T::DATMSK: DATMSK3 Mask           */
S
S#define GPIO_DATMSK_DATMSK4_Pos          (4)                                               /*!< GPIO_T::DATMSK: DATMSK4 Position       */
S#define GPIO_DATMSK_DATMSK4_Msk          (0x1ul << GPIO_DATMSK_DATMSK4_Pos)                /*!< GPIO_T::DATMSK: DATMSK4 Mask           */
S
S#define GPIO_DATMSK_DATMSK5_Pos          (5)                                               /*!< GPIO_T::DATMSK: DATMSK5 Position       */
S#define GPIO_DATMSK_DATMSK5_Msk          (0x1ul << GPIO_DATMSK_DATMSK5_Pos)                /*!< GPIO_T::DATMSK: DATMSK5 Mask           */
S
S#define GPIO_DATMSK_DATMSK6_Pos          (6)                                               /*!< GPIO_T::DATMSK: DATMSK6 Position       */
S#define GPIO_DATMSK_DATMSK6_Msk          (0x1ul << GPIO_DATMSK_DATMSK6_Pos)                /*!< GPIO_T::DATMSK: DATMSK6 Mask           */
S
S#define GPIO_DATMSK_DATMSK7_Pos          (7)                                               /*!< GPIO_T::DATMSK: DATMSK7 Position       */
S#define GPIO_DATMSK_DATMSK7_Msk          (0x1ul << GPIO_DATMSK_DATMSK7_Pos)                /*!< GPIO_T::DATMSK: DATMSK7 Mask           */
S
S#define GPIO_DATMSK_DATMSK8_Pos          (8)                                               /*!< GPIO_T::DATMSK: DATMSK8 Position       */
S#define GPIO_DATMSK_DATMSK8_Msk          (0x1ul << GPIO_DATMSK_DATMSK8_Pos)                /*!< GPIO_T::DATMSK: DATMSK8 Mask           */
S
S#define GPIO_DATMSK_DATMSK9_Pos          (9)                                               /*!< GPIO_T::DATMSK: DATMSK9 Position       */
S#define GPIO_DATMSK_DATMSK9_Msk          (0x1ul << GPIO_DATMSK_DATMSK9_Pos)                /*!< GPIO_T::DATMSK: DATMSK9 Mask           */
S
S#define GPIO_DATMSK_DATMSK10_Pos         (10)                                              /*!< GPIO_T::DATMSK: DATMSK10 Position      */
S#define GPIO_DATMSK_DATMSK10_Msk         (0x1ul << GPIO_DATMSK_DATMSK10_Pos)               /*!< GPIO_T::DATMSK: DATMSK10 Mask          */
S
S#define GPIO_DATMSK_DATMSK11_Pos         (11)                                              /*!< GPIO_T::DATMSK: DATMSK11 Position      */
S#define GPIO_DATMSK_DATMSK11_Msk         (0x1ul << GPIO_DATMSK_DATMSK11_Pos)               /*!< GPIO_T::DATMSK: DATMSK11 Mask          */
S
S#define GPIO_DATMSK_DATMSK12_Pos         (12)                                              /*!< GPIO_T::DATMSK: DATMSK12 Position      */
S#define GPIO_DATMSK_DATMSK12_Msk         (0x1ul << GPIO_DATMSK_DATMSK12_Pos)               /*!< GPIO_T::DATMSK: DATMSK12 Mask          */
S
S#define GPIO_DATMSK_DATMSK13_Pos         (13)                                              /*!< GPIO_T::DATMSK: DATMSK13 Position      */
S#define GPIO_DATMSK_DATMSK13_Msk         (0x1ul << GPIO_DATMSK_DATMSK13_Pos)               /*!< GPIO_T::DATMSK: DATMSK13 Mask          */
S
S#define GPIO_DATMSK_DATMSK14_Pos         (14)                                              /*!< GPIO_T::DATMSK: DATMSK14 Position      */
S#define GPIO_DATMSK_DATMSK14_Msk         (0x1ul << GPIO_DATMSK_DATMSK14_Pos)               /*!< GPIO_T::DATMSK: DATMSK14 Mask          */
S
S#define GPIO_DATMSK_DATMSK15_Pos         (15)                                              /*!< GPIO_T::DATMSK: DATMSK15 Position      */
S#define GPIO_DATMSK_DATMSK15_Msk         (0x1ul << GPIO_DATMSK_DATMSK15_Pos)               /*!< GPIO_T::DATMSK: DATMSK15 Mask          */
S
S#define GPIO_PIN_PIN0_Pos                (0)                                               /*!< GPIO_T::PIN: PIN0 Position             */
S#define GPIO_PIN_PIN0_Msk                (0x1ul << GPIO_PIN_PIN0_Pos)                      /*!< GPIO_T::PIN: PIN0 Mask                 */
S
S#define GPIO_PIN_PIN1_Pos                (1)                                               /*!< GPIO_T::PIN: PIN1 Position             */
S#define GPIO_PIN_PIN1_Msk                (0x1ul << GPIO_PIN_PIN1_Pos)                      /*!< GPIO_T::PIN: PIN1 Mask                 */
S
S#define GPIO_PIN_PIN2_Pos                (2)                                               /*!< GPIO_T::PIN: PIN2 Position             */
S#define GPIO_PIN_PIN2_Msk                (0x1ul << GPIO_PIN_PIN2_Pos)                      /*!< GPIO_T::PIN: PIN2 Mask                 */
S
S#define GPIO_PIN_PIN3_Pos                (3)                                               /*!< GPIO_T::PIN: PIN3 Position             */
S#define GPIO_PIN_PIN3_Msk                (0x1ul << GPIO_PIN_PIN3_Pos)                      /*!< GPIO_T::PIN: PIN3 Mask                 */
S
S#define GPIO_PIN_PIN4_Pos                (4)                                               /*!< GPIO_T::PIN: PIN4 Position             */
S#define GPIO_PIN_PIN4_Msk                (0x1ul << GPIO_PIN_PIN4_Pos)                      /*!< GPIO_T::PIN: PIN4 Mask                 */
S
S#define GPIO_PIN_PIN5_Pos                (5)                                               /*!< GPIO_T::PIN: PIN5 Position             */
S#define GPIO_PIN_PIN5_Msk                (0x1ul << GPIO_PIN_PIN5_Pos)                      /*!< GPIO_T::PIN: PIN5 Mask                 */
S
S#define GPIO_PIN_PIN6_Pos                (6)                                               /*!< GPIO_T::PIN: PIN6 Position             */
S#define GPIO_PIN_PIN6_Msk                (0x1ul << GPIO_PIN_PIN6_Pos)                      /*!< GPIO_T::PIN: PIN6 Mask                 */
S
S#define GPIO_PIN_PIN7_Pos                (7)                                               /*!< GPIO_T::PIN: PIN7 Position             */
S#define GPIO_PIN_PIN7_Msk                (0x1ul << GPIO_PIN_PIN7_Pos)                      /*!< GPIO_T::PIN: PIN7 Mask                 */
S
S#define GPIO_PIN_PIN8_Pos                (8)                                               /*!< GPIO_T::PIN: PIN8 Position             */
S#define GPIO_PIN_PIN8_Msk                (0x1ul << GPIO_PIN_PIN8_Pos)                      /*!< GPIO_T::PIN: PIN8 Mask                 */
S
S#define GPIO_PIN_PIN9_Pos                (9)                                               /*!< GPIO_T::PIN: PIN9 Position             */
S#define GPIO_PIN_PIN9_Msk                (0x1ul << GPIO_PIN_PIN9_Pos)                      /*!< GPIO_T::PIN: PIN9 Mask                 */
S
S#define GPIO_PIN_PIN10_Pos               (10)                                              /*!< GPIO_T::PIN: PIN10 Position            */
S#define GPIO_PIN_PIN10_Msk               (0x1ul << GPIO_PIN_PIN10_Pos)                     /*!< GPIO_T::PIN: PIN10 Mask                */
S
S#define GPIO_PIN_PIN11_Pos               (11)                                              /*!< GPIO_T::PIN: PIN11 Position            */
S#define GPIO_PIN_PIN11_Msk               (0x1ul << GPIO_PIN_PIN11_Pos)                     /*!< GPIO_T::PIN: PIN11 Mask                */
S
S#define GPIO_PIN_PIN12_Pos               (12)                                              /*!< GPIO_T::PIN: PIN12 Position            */
S#define GPIO_PIN_PIN12_Msk               (0x1ul << GPIO_PIN_PIN12_Pos)                     /*!< GPIO_T::PIN: PIN12 Mask                */
S
S#define GPIO_PIN_PIN13_Pos               (13)                                              /*!< GPIO_T::PIN: PIN13 Position            */
S#define GPIO_PIN_PIN13_Msk               (0x1ul << GPIO_PIN_PIN13_Pos)                     /*!< GPIO_T::PIN: PIN13 Mask                */
S
S#define GPIO_PIN_PIN14_Pos               (14)                                              /*!< GPIO_T::PIN: PIN14 Position            */
S#define GPIO_PIN_PIN14_Msk               (0x1ul << GPIO_PIN_PIN14_Pos)                     /*!< GPIO_T::PIN: PIN14 Mask                */
S
S#define GPIO_PIN_PIN15_Pos               (15)                                              /*!< GPIO_T::PIN: PIN15 Position            */
S#define GPIO_PIN_PIN15_Msk               (0x1ul << GPIO_PIN_PIN15_Pos)                     /*!< GPIO_T::PIN: PIN15 Mask                */
S
S#define GPIO_DBEN_DBEN0_Pos              (0)                                               /*!< GPIO_T::DBEN: DBEN0 Position           */
S#define GPIO_DBEN_DBEN0_Msk              (0x1ul << GPIO_DBEN_DBEN0_Pos)                    /*!< GPIO_T::DBEN: DBEN0 Mask               */
S
S#define GPIO_DBEN_DBEN1_Pos              (1)                                               /*!< GPIO_T::DBEN: DBEN1 Position           */
S#define GPIO_DBEN_DBEN1_Msk              (0x1ul << GPIO_DBEN_DBEN1_Pos)                    /*!< GPIO_T::DBEN: DBEN1 Mask               */
S
S#define GPIO_DBEN_DBEN2_Pos              (2)                                               /*!< GPIO_T::DBEN: DBEN2 Position           */
S#define GPIO_DBEN_DBEN2_Msk              (0x1ul << GPIO_DBEN_DBEN2_Pos)                    /*!< GPIO_T::DBEN: DBEN2 Mask               */
S
S#define GPIO_DBEN_DBEN3_Pos              (3)                                               /*!< GPIO_T::DBEN: DBEN3 Position           */
S#define GPIO_DBEN_DBEN3_Msk              (0x1ul << GPIO_DBEN_DBEN3_Pos)                    /*!< GPIO_T::DBEN: DBEN3 Mask               */
S
S#define GPIO_DBEN_DBEN4_Pos              (4)                                               /*!< GPIO_T::DBEN: DBEN4 Position           */
S#define GPIO_DBEN_DBEN4_Msk              (0x1ul << GPIO_DBEN_DBEN4_Pos)                    /*!< GPIO_T::DBEN: DBEN4 Mask               */
S
S#define GPIO_DBEN_DBEN5_Pos              (5)                                               /*!< GPIO_T::DBEN: DBEN5 Position           */
S#define GPIO_DBEN_DBEN5_Msk              (0x1ul << GPIO_DBEN_DBEN5_Pos)                    /*!< GPIO_T::DBEN: DBEN5 Mask               */
S
S#define GPIO_DBEN_DBEN6_Pos              (6)                                               /*!< GPIO_T::DBEN: DBEN6 Position           */
S#define GPIO_DBEN_DBEN6_Msk              (0x1ul << GPIO_DBEN_DBEN6_Pos)                    /*!< GPIO_T::DBEN: DBEN6 Mask               */
S
S#define GPIO_DBEN_DBEN7_Pos              (7)                                               /*!< GPIO_T::DBEN: DBEN7 Position           */
S#define GPIO_DBEN_DBEN7_Msk              (0x1ul << GPIO_DBEN_DBEN7_Pos)                    /*!< GPIO_T::DBEN: DBEN7 Mask               */
S
S#define GPIO_DBEN_DBEN8_Pos              (8)                                               /*!< GPIO_T::DBEN: DBEN8 Position           */
S#define GPIO_DBEN_DBEN8_Msk              (0x1ul << GPIO_DBEN_DBEN8_Pos)                    /*!< GPIO_T::DBEN: DBEN8 Mask               */
S
S#define GPIO_DBEN_DBEN9_Pos              (9)                                               /*!< GPIO_T::DBEN: DBEN9 Position           */
S#define GPIO_DBEN_DBEN9_Msk              (0x1ul << GPIO_DBEN_DBEN9_Pos)                    /*!< GPIO_T::DBEN: DBEN9 Mask               */
S
S#define GPIO_DBEN_DBEN10_Pos             (10)                                              /*!< GPIO_T::DBEN: DBEN10 Position          */
S#define GPIO_DBEN_DBEN10_Msk             (0x1ul << GPIO_DBEN_DBEN10_Pos)                   /*!< GPIO_T::DBEN: DBEN10 Mask              */
S
S#define GPIO_DBEN_DBEN11_Pos             (11)                                              /*!< GPIO_T::DBEN: DBEN11 Position          */
S#define GPIO_DBEN_DBEN11_Msk             (0x1ul << GPIO_DBEN_DBEN11_Pos)                   /*!< GPIO_T::DBEN: DBEN11 Mask              */
S
S#define GPIO_DBEN_DBEN12_Pos             (12)                                              /*!< GPIO_T::DBEN: DBEN12 Position          */
S#define GPIO_DBEN_DBEN12_Msk             (0x1ul << GPIO_DBEN_DBEN12_Pos)                   /*!< GPIO_T::DBEN: DBEN12 Mask              */
S
S#define GPIO_DBEN_DBEN13_Pos             (13)                                              /*!< GPIO_T::DBEN: DBEN13 Position          */
S#define GPIO_DBEN_DBEN13_Msk             (0x1ul << GPIO_DBEN_DBEN13_Pos)                   /*!< GPIO_T::DBEN: DBEN13 Mask              */
S
S#define GPIO_DBEN_DBEN14_Pos             (14)                                              /*!< GPIO_T::DBEN: DBEN14 Position          */
S#define GPIO_DBEN_DBEN14_Msk             (0x1ul << GPIO_DBEN_DBEN14_Pos)                   /*!< GPIO_T::DBEN: DBEN14 Mask              */
S
S#define GPIO_DBEN_DBEN15_Pos             (15)                                              /*!< GPIO_T::DBEN: DBEN15 Position          */
S#define GPIO_DBEN_DBEN15_Msk             (0x1ul << GPIO_DBEN_DBEN15_Pos)                   /*!< GPIO_T::DBEN: DBEN15 Mask              */
S
S#define GPIO_INTTYPE_TYPE0_Pos           (0)                                               /*!< GPIO_T::INTTYPE: TYPE0 Position        */
S#define GPIO_INTTYPE_TYPE0_Msk           (0x1ul << GPIO_INTTYPE_TYPE0_Pos)                 /*!< GPIO_T::INTTYPE: TYPE0 Mask            */
S
S#define GPIO_INTTYPE_TYPE1_Pos           (1)                                               /*!< GPIO_T::INTTYPE: TYPE1 Position        */
S#define GPIO_INTTYPE_TYPE1_Msk           (0x1ul << GPIO_INTTYPE_TYPE1_Pos)                 /*!< GPIO_T::INTTYPE: TYPE1 Mask            */
S
S#define GPIO_INTTYPE_TYPE2_Pos           (2)                                               /*!< GPIO_T::INTTYPE: TYPE2 Position        */
S#define GPIO_INTTYPE_TYPE2_Msk           (0x1ul << GPIO_INTTYPE_TYPE2_Pos)                 /*!< GPIO_T::INTTYPE: TYPE2 Mask            */
S
S#define GPIO_INTTYPE_TYPE3_Pos           (3)                                               /*!< GPIO_T::INTTYPE: TYPE3 Position        */
S#define GPIO_INTTYPE_TYPE3_Msk           (0x1ul << GPIO_INTTYPE_TYPE3_Pos)                 /*!< GPIO_T::INTTYPE: TYPE3 Mask            */
S
S#define GPIO_INTTYPE_TYPE4_Pos           (4)                                               /*!< GPIO_T::INTTYPE: TYPE4 Position        */
S#define GPIO_INTTYPE_TYPE4_Msk           (0x1ul << GPIO_INTTYPE_TYPE4_Pos)                 /*!< GPIO_T::INTTYPE: TYPE4 Mask            */
S
S#define GPIO_INTTYPE_TYPE5_Pos           (5)                                               /*!< GPIO_T::INTTYPE: TYPE5 Position        */
S#define GPIO_INTTYPE_TYPE5_Msk           (0x1ul << GPIO_INTTYPE_TYPE5_Pos)                 /*!< GPIO_T::INTTYPE: TYPE5 Mask            */
S
S#define GPIO_INTTYPE_TYPE6_Pos           (6)                                               /*!< GPIO_T::INTTYPE: TYPE6 Position        */
S#define GPIO_INTTYPE_TYPE6_Msk           (0x1ul << GPIO_INTTYPE_TYPE6_Pos)                 /*!< GPIO_T::INTTYPE: TYPE6 Mask            */
S
S#define GPIO_INTTYPE_TYPE7_Pos           (7)                                               /*!< GPIO_T::INTTYPE: TYPE7 Position        */
S#define GPIO_INTTYPE_TYPE7_Msk           (0x1ul << GPIO_INTTYPE_TYPE7_Pos)                 /*!< GPIO_T::INTTYPE: TYPE7 Mask            */
S
S#define GPIO_INTTYPE_TYPE8_Pos           (8)                                               /*!< GPIO_T::INTTYPE: TYPE8 Position        */
S#define GPIO_INTTYPE_TYPE8_Msk           (0x1ul << GPIO_INTTYPE_TYPE8_Pos)                 /*!< GPIO_T::INTTYPE: TYPE8 Mask            */
S
S#define GPIO_INTTYPE_TYPE9_Pos           (9)                                               /*!< GPIO_T::INTTYPE: TYPE9 Position        */
S#define GPIO_INTTYPE_TYPE9_Msk           (0x1ul << GPIO_INTTYPE_TYPE9_Pos)                 /*!< GPIO_T::INTTYPE: TYPE9 Mask            */
S
S#define GPIO_INTTYPE_TYPE10_Pos          (10)                                              /*!< GPIO_T::INTTYPE: TYPE10 Position       */
S#define GPIO_INTTYPE_TYPE10_Msk          (0x1ul << GPIO_INTTYPE_TYPE10_Pos)                /*!< GPIO_T::INTTYPE: TYPE10 Mask           */
S
S#define GPIO_INTTYPE_TYPE11_Pos          (11)                                              /*!< GPIO_T::INTTYPE: TYPE11 Position       */
S#define GPIO_INTTYPE_TYPE11_Msk          (0x1ul << GPIO_INTTYPE_TYPE11_Pos)                /*!< GPIO_T::INTTYPE: TYPE11 Mask           */
S
S#define GPIO_INTTYPE_TYPE12_Pos          (12)                                              /*!< GPIO_T::INTTYPE: TYPE12 Position       */
S#define GPIO_INTTYPE_TYPE12_Msk          (0x1ul << GPIO_INTTYPE_TYPE12_Pos)                /*!< GPIO_T::INTTYPE: TYPE12 Mask           */
S
S#define GPIO_INTTYPE_TYPE13_Pos          (13)                                              /*!< GPIO_T::INTTYPE: TYPE13 Position       */
S#define GPIO_INTTYPE_TYPE13_Msk          (0x1ul << GPIO_INTTYPE_TYPE13_Pos)                /*!< GPIO_T::INTTYPE: TYPE13 Mask           */
S
S#define GPIO_INTTYPE_TYPE14_Pos          (14)                                              /*!< GPIO_T::INTTYPE: TYPE14 Position       */
S#define GPIO_INTTYPE_TYPE14_Msk          (0x1ul << GPIO_INTTYPE_TYPE14_Pos)                /*!< GPIO_T::INTTYPE: TYPE14 Mask           */
S
S#define GPIO_INTTYPE_TYPE15_Pos          (15)                                              /*!< GPIO_T::INTTYPE: TYPE15 Position       */
S#define GPIO_INTTYPE_TYPE15_Msk          (0x1ul << GPIO_INTTYPE_TYPE15_Pos)                /*!< GPIO_T::INTTYPE: TYPE15 Mask           */
S
S#define GPIO_INTEN_FLIEN0_Pos            (0)                                               /*!< GPIO_T::INTEN: FLIEN0 Position         */
S#define GPIO_INTEN_FLIEN0_Msk            (0x1ul << GPIO_INTEN_FLIEN0_Pos)                  /*!< GPIO_T::INTEN: FLIEN0 Mask             */
S
S#define GPIO_INTEN_FLIEN1_Pos            (1)                                               /*!< GPIO_T::INTEN: FLIEN1 Position         */
S#define GPIO_INTEN_FLIEN1_Msk            (0x1ul << GPIO_INTEN_FLIEN1_Pos)                  /*!< GPIO_T::INTEN: FLIEN1 Mask             */
S
S#define GPIO_INTEN_FLIEN2_Pos            (2)                                               /*!< GPIO_T::INTEN: FLIEN2 Position         */
S#define GPIO_INTEN_FLIEN2_Msk            (0x1ul << GPIO_INTEN_FLIEN2_Pos)                  /*!< GPIO_T::INTEN: FLIEN2 Mask             */
S
S#define GPIO_INTEN_FLIEN3_Pos            (3)                                               /*!< GPIO_T::INTEN: FLIEN3 Position         */
S#define GPIO_INTEN_FLIEN3_Msk            (0x1ul << GPIO_INTEN_FLIEN3_Pos)                  /*!< GPIO_T::INTEN: FLIEN3 Mask             */
S
S#define GPIO_INTEN_FLIEN4_Pos            (4)                                               /*!< GPIO_T::INTEN: FLIEN4 Position         */
S#define GPIO_INTEN_FLIEN4_Msk            (0x1ul << GPIO_INTEN_FLIEN4_Pos)                  /*!< GPIO_T::INTEN: FLIEN4 Mask             */
S
S#define GPIO_INTEN_FLIEN5_Pos            (5)                                               /*!< GPIO_T::INTEN: FLIEN5 Position         */
S#define GPIO_INTEN_FLIEN5_Msk            (0x1ul << GPIO_INTEN_FLIEN5_Pos)                  /*!< GPIO_T::INTEN: FLIEN5 Mask             */
S
S#define GPIO_INTEN_FLIEN6_Pos            (6)                                               /*!< GPIO_T::INTEN: FLIEN6 Position         */
S#define GPIO_INTEN_FLIEN6_Msk            (0x1ul << GPIO_INTEN_FLIEN6_Pos)                  /*!< GPIO_T::INTEN: FLIEN6 Mask             */
S
S#define GPIO_INTEN_FLIEN7_Pos            (7)                                               /*!< GPIO_T::INTEN: FLIEN7 Position         */
S#define GPIO_INTEN_FLIEN7_Msk            (0x1ul << GPIO_INTEN_FLIEN7_Pos)                  /*!< GPIO_T::INTEN: FLIEN7 Mask             */
S
S#define GPIO_INTEN_FLIEN8_Pos            (8)                                               /*!< GPIO_T::INTEN: FLIEN8 Position         */
S#define GPIO_INTEN_FLIEN8_Msk            (0x1ul << GPIO_INTEN_FLIEN8_Pos)                  /*!< GPIO_T::INTEN: FLIEN8 Mask             */
S
S#define GPIO_INTEN_FLIEN9_Pos            (9)                                               /*!< GPIO_T::INTEN: FLIEN9 Position         */
S#define GPIO_INTEN_FLIEN9_Msk            (0x1ul << GPIO_INTEN_FLIEN9_Pos)                  /*!< GPIO_T::INTEN: FLIEN9 Mask             */
S
S#define GPIO_INTEN_FLIEN10_Pos           (10)                                              /*!< GPIO_T::INTEN: FLIEN10 Position        */
S#define GPIO_INTEN_FLIEN10_Msk           (0x1ul << GPIO_INTEN_FLIEN10_Pos)                 /*!< GPIO_T::INTEN: FLIEN10 Mask            */
S
S#define GPIO_INTEN_FLIEN11_Pos           (11)                                              /*!< GPIO_T::INTEN: FLIEN11 Position        */
S#define GPIO_INTEN_FLIEN11_Msk           (0x1ul << GPIO_INTEN_FLIEN11_Pos)                 /*!< GPIO_T::INTEN: FLIEN11 Mask            */
S
S#define GPIO_INTEN_FLIEN12_Pos           (12)                                              /*!< GPIO_T::INTEN: FLIEN12 Position        */
S#define GPIO_INTEN_FLIEN12_Msk           (0x1ul << GPIO_INTEN_FLIEN12_Pos)                 /*!< GPIO_T::INTEN: FLIEN12 Mask            */
S
S#define GPIO_INTEN_FLIEN13_Pos           (13)                                              /*!< GPIO_T::INTEN: FLIEN13 Position        */
S#define GPIO_INTEN_FLIEN13_Msk           (0x1ul << GPIO_INTEN_FLIEN13_Pos)                 /*!< GPIO_T::INTEN: FLIEN13 Mask            */
S
S#define GPIO_INTEN_FLIEN14_Pos           (14)                                              /*!< GPIO_T::INTEN: FLIEN14 Position        */
S#define GPIO_INTEN_FLIEN14_Msk           (0x1ul << GPIO_INTEN_FLIEN14_Pos)                 /*!< GPIO_T::INTEN: FLIEN14 Mask            */
S
S#define GPIO_INTEN_FLIEN15_Pos           (15)                                              /*!< GPIO_T::INTEN: FLIEN15 Position        */
S#define GPIO_INTEN_FLIEN15_Msk           (0x1ul << GPIO_INTEN_FLIEN15_Pos)                 /*!< GPIO_T::INTEN: FLIEN15 Mask            */
S
S#define GPIO_INTEN_RHIEN0_Pos            (16)                                              /*!< GPIO_T::INTEN: RHIEN0 Position         */
S#define GPIO_INTEN_RHIEN0_Msk            (0x1ul << GPIO_INTEN_RHIEN0_Pos)                  /*!< GPIO_T::INTEN: RHIEN0 Mask             */
S
S#define GPIO_INTEN_RHIEN1_Pos            (17)                                              /*!< GPIO_T::INTEN: RHIEN1 Position         */
S#define GPIO_INTEN_RHIEN1_Msk            (0x1ul << GPIO_INTEN_RHIEN1_Pos)                  /*!< GPIO_T::INTEN: RHIEN1 Mask             */
S
S#define GPIO_INTEN_RHIEN2_Pos            (18)                                              /*!< GPIO_T::INTEN: RHIEN2 Position         */
S#define GPIO_INTEN_RHIEN2_Msk            (0x1ul << GPIO_INTEN_RHIEN2_Pos)                  /*!< GPIO_T::INTEN: RHIEN2 Mask             */
S
S#define GPIO_INTEN_RHIEN3_Pos            (19)                                              /*!< GPIO_T::INTEN: RHIEN3 Position         */
S#define GPIO_INTEN_RHIEN3_Msk            (0x1ul << GPIO_INTEN_RHIEN3_Pos)                  /*!< GPIO_T::INTEN: RHIEN3 Mask             */
S
S#define GPIO_INTEN_RHIEN4_Pos            (20)                                              /*!< GPIO_T::INTEN: RHIEN4 Position         */
S#define GPIO_INTEN_RHIEN4_Msk            (0x1ul << GPIO_INTEN_RHIEN4_Pos)                  /*!< GPIO_T::INTEN: RHIEN4 Mask             */
S
S#define GPIO_INTEN_RHIEN5_Pos            (21)                                              /*!< GPIO_T::INTEN: RHIEN5 Position         */
S#define GPIO_INTEN_RHIEN5_Msk            (0x1ul << GPIO_INTEN_RHIEN5_Pos)                  /*!< GPIO_T::INTEN: RHIEN5 Mask             */
S
S#define GPIO_INTEN_RHIEN6_Pos            (22)                                              /*!< GPIO_T::INTEN: RHIEN6 Position         */
S#define GPIO_INTEN_RHIEN6_Msk            (0x1ul << GPIO_INTEN_RHIEN6_Pos)                  /*!< GPIO_T::INTEN: RHIEN6 Mask             */
S
S#define GPIO_INTEN_RHIEN7_Pos            (23)                                              /*!< GPIO_T::INTEN: RHIEN7 Position         */
S#define GPIO_INTEN_RHIEN7_Msk            (0x1ul << GPIO_INTEN_RHIEN7_Pos)                  /*!< GPIO_T::INTEN: RHIEN7 Mask             */
S
S#define GPIO_INTEN_RHIEN8_Pos            (24)                                              /*!< GPIO_T::INTEN: RHIEN8 Position         */
S#define GPIO_INTEN_RHIEN8_Msk            (0x1ul << GPIO_INTEN_RHIEN8_Pos)                  /*!< GPIO_T::INTEN: RHIEN8 Mask             */
S
S#define GPIO_INTEN_RHIEN9_Pos            (25)                                              /*!< GPIO_T::INTEN: RHIEN9 Position         */
S#define GPIO_INTEN_RHIEN9_Msk            (0x1ul << GPIO_INTEN_RHIEN9_Pos)                  /*!< GPIO_T::INTEN: RHIEN9 Mask             */
S
S#define GPIO_INTEN_RHIEN10_Pos           (26)                                              /*!< GPIO_T::INTEN: RHIEN10 Position        */
S#define GPIO_INTEN_RHIEN10_Msk           (0x1ul << GPIO_INTEN_RHIEN10_Pos)                 /*!< GPIO_T::INTEN: RHIEN10 Mask            */
S
S#define GPIO_INTEN_RHIEN11_Pos           (27)                                              /*!< GPIO_T::INTEN: RHIEN11 Position        */
S#define GPIO_INTEN_RHIEN11_Msk           (0x1ul << GPIO_INTEN_RHIEN11_Pos)                 /*!< GPIO_T::INTEN: RHIEN11 Mask            */
S
S#define GPIO_INTEN_RHIEN12_Pos           (28)                                              /*!< GPIO_T::INTEN: RHIEN12 Position        */
S#define GPIO_INTEN_RHIEN12_Msk           (0x1ul << GPIO_INTEN_RHIEN12_Pos)                 /*!< GPIO_T::INTEN: RHIEN12 Mask            */
S
S#define GPIO_INTEN_RHIEN13_Pos           (29)                                              /*!< GPIO_T::INTEN: RHIEN13 Position        */
S#define GPIO_INTEN_RHIEN13_Msk           (0x1ul << GPIO_INTEN_RHIEN13_Pos)                 /*!< GPIO_T::INTEN: RHIEN13 Mask            */
S
S#define GPIO_INTEN_RHIEN14_Pos           (30)                                              /*!< GPIO_T::INTEN: RHIEN14 Position        */
S#define GPIO_INTEN_RHIEN14_Msk           (0x1ul << GPIO_INTEN_RHIEN14_Pos)                 /*!< GPIO_T::INTEN: RHIEN14 Mask            */
S
S#define GPIO_INTEN_RHIEN15_Pos           (31)                                              /*!< GPIO_T::INTEN: RHIEN15 Position        */
S#define GPIO_INTEN_RHIEN15_Msk           (0x1ul << GPIO_INTEN_RHIEN15_Pos)                 /*!< GPIO_T::INTEN: RHIEN15 Mask            */
S
S#define GPIO_INTSRC_INTSRC0_Pos          (0)                                               /*!< GPIO_T::INTSRC: INTSRC0 Position       */
S#define GPIO_INTSRC_INTSRC0_Msk          (0x1ul << GPIO_INTSRC_INTSRC0_Pos)                /*!< GPIO_T::INTSRC: INTSRC0 Mask           */
S
S#define GPIO_INTSRC_INTSRC1_Pos          (1)                                               /*!< GPIO_T::INTSRC: INTSRC1 Position       */
S#define GPIO_INTSRC_INTSRC1_Msk          (0x1ul << GPIO_INTSRC_INTSRC1_Pos)                /*!< GPIO_T::INTSRC: INTSRC1 Mask           */
S
S#define GPIO_INTSRC_INTSRC2_Pos          (2)                                               /*!< GPIO_T::INTSRC: INTSRC2 Position       */
S#define GPIO_INTSRC_INTSRC2_Msk          (0x1ul << GPIO_INTSRC_INTSRC2_Pos)                /*!< GPIO_T::INTSRC: INTSRC2 Mask           */
S
S#define GPIO_INTSRC_INTSRC3_Pos          (3)                                               /*!< GPIO_T::INTSRC: INTSRC3 Position       */
S#define GPIO_INTSRC_INTSRC3_Msk          (0x1ul << GPIO_INTSRC_INTSRC3_Pos)                /*!< GPIO_T::INTSRC: INTSRC3 Mask           */
S
S#define GPIO_INTSRC_INTSRC4_Pos          (4)                                               /*!< GPIO_T::INTSRC: INTSRC4 Position       */
S#define GPIO_INTSRC_INTSRC4_Msk          (0x1ul << GPIO_INTSRC_INTSRC4_Pos)                /*!< GPIO_T::INTSRC: INTSRC4 Mask           */
S
S#define GPIO_INTSRC_INTSRC5_Pos          (5)                                               /*!< GPIO_T::INTSRC: INTSRC5 Position       */
S#define GPIO_INTSRC_INTSRC5_Msk          (0x1ul << GPIO_INTSRC_INTSRC5_Pos)                /*!< GPIO_T::INTSRC: INTSRC5 Mask           */
S
S#define GPIO_INTSRC_INTSRC6_Pos          (6)                                               /*!< GPIO_T::INTSRC: INTSRC6 Position       */
S#define GPIO_INTSRC_INTSRC6_Msk          (0x1ul << GPIO_INTSRC_INTSRC6_Pos)                /*!< GPIO_T::INTSRC: INTSRC6 Mask           */
S
S#define GPIO_INTSRC_INTSRC7_Pos          (7)                                               /*!< GPIO_T::INTSRC: INTSRC7 Position       */
S#define GPIO_INTSRC_INTSRC7_Msk          (0x1ul << GPIO_INTSRC_INTSRC7_Pos)                /*!< GPIO_T::INTSRC: INTSRC7 Mask           */
S
S#define GPIO_INTSRC_INTSRC8_Pos          (8)                                               /*!< GPIO_T::INTSRC: INTSRC8 Position       */
S#define GPIO_INTSRC_INTSRC8_Msk          (0x1ul << GPIO_INTSRC_INTSRC8_Pos)                /*!< GPIO_T::INTSRC: INTSRC8 Mask           */
S
S#define GPIO_INTSRC_INTSRC9_Pos          (9)                                               /*!< GPIO_T::INTSRC: INTSRC9 Position       */
S#define GPIO_INTSRC_INTSRC9_Msk          (0x1ul << GPIO_INTSRC_INTSRC9_Pos)                /*!< GPIO_T::INTSRC: INTSRC9 Mask           */
S
S#define GPIO_INTSRC_INTSRC10_Pos         (10)                                              /*!< GPIO_T::INTSRC: INTSRC10 Position      */
S#define GPIO_INTSRC_INTSRC10_Msk         (0x1ul << GPIO_INTSRC_INTSRC10_Pos)               /*!< GPIO_T::INTSRC: INTSRC10 Mask          */
S
S#define GPIO_INTSRC_INTSRC11_Pos         (11)                                              /*!< GPIO_T::INTSRC: INTSRC11 Position      */
S#define GPIO_INTSRC_INTSRC11_Msk         (0x1ul << GPIO_INTSRC_INTSRC11_Pos)               /*!< GPIO_T::INTSRC: INTSRC11 Mask          */
S
S#define GPIO_INTSRC_INTSRC12_Pos         (12)                                              /*!< GPIO_T::INTSRC: INTSRC12 Position      */
S#define GPIO_INTSRC_INTSRC12_Msk         (0x1ul << GPIO_INTSRC_INTSRC12_Pos)               /*!< GPIO_T::INTSRC: INTSRC12 Mask          */
S
S#define GPIO_INTSRC_INTSRC13_Pos         (13)                                              /*!< GPIO_T::INTSRC: INTSRC13 Position      */
S#define GPIO_INTSRC_INTSRC13_Msk         (0x1ul << GPIO_INTSRC_INTSRC13_Pos)               /*!< GPIO_T::INTSRC: INTSRC13 Mask          */
S
S#define GPIO_INTSRC_INTSRC14_Pos         (14)                                              /*!< GPIO_T::INTSRC: INTSRC14 Position      */
S#define GPIO_INTSRC_INTSRC14_Msk         (0x1ul << GPIO_INTSRC_INTSRC14_Pos)               /*!< GPIO_T::INTSRC: INTSRC14 Mask          */
S
S#define GPIO_INTSRC_INTSRC15_Pos         (15)                                              /*!< GPIO_T::INTSRC: INTSRC15 Position      */
S#define GPIO_INTSRC_INTSRC15_Msk         (0x1ul << GPIO_INTSRC_INTSRC15_Pos)               /*!< GPIO_T::INTSRC: INTSRC15 Mask          */
S
S#define GPIO_SMTEN_SMTEN0_Pos            (0)                                               /*!< GPIO_T::SMTEN: SMTEN0 Position         */
S#define GPIO_SMTEN_SMTEN0_Msk            (0x1ul << GPIO_SMTEN_SMTEN0_Pos)                  /*!< GPIO_T::SMTEN: SMTEN0 Mask             */
S
S#define GPIO_SMTEN_SMTEN1_Pos            (1)                                               /*!< GPIO_T::SMTEN: SMTEN1 Position         */
S#define GPIO_SMTEN_SMTEN1_Msk            (0x1ul << GPIO_SMTEN_SMTEN1_Pos)                  /*!< GPIO_T::SMTEN: SMTEN1 Mask             */
S
S#define GPIO_SMTEN_SMTEN2_Pos            (2)                                               /*!< GPIO_T::SMTEN: SMTEN2 Position         */
S#define GPIO_SMTEN_SMTEN2_Msk            (0x1ul << GPIO_SMTEN_SMTEN2_Pos)                  /*!< GPIO_T::SMTEN: SMTEN2 Mask             */
S
S#define GPIO_SMTEN_SMTEN3_Pos            (3)                                               /*!< GPIO_T::SMTEN: SMTEN3 Position         */
S#define GPIO_SMTEN_SMTEN3_Msk            (0x1ul << GPIO_SMTEN_SMTEN3_Pos)                  /*!< GPIO_T::SMTEN: SMTEN3 Mask             */
S
S#define GPIO_SMTEN_SMTEN4_Pos            (4)                                               /*!< GPIO_T::SMTEN: SMTEN4 Position         */
S#define GPIO_SMTEN_SMTEN4_Msk            (0x1ul << GPIO_SMTEN_SMTEN4_Pos)                  /*!< GPIO_T::SMTEN: SMTEN4 Mask             */
S
S#define GPIO_SMTEN_SMTEN5_Pos            (5)                                               /*!< GPIO_T::SMTEN: SMTEN5 Position         */
S#define GPIO_SMTEN_SMTEN5_Msk            (0x1ul << GPIO_SMTEN_SMTEN5_Pos)                  /*!< GPIO_T::SMTEN: SMTEN5 Mask             */
S
S#define GPIO_SMTEN_SMTEN6_Pos            (6)                                               /*!< GPIO_T::SMTEN: SMTEN6 Position         */
S#define GPIO_SMTEN_SMTEN6_Msk            (0x1ul << GPIO_SMTEN_SMTEN6_Pos)                  /*!< GPIO_T::SMTEN: SMTEN6 Mask             */
S
S#define GPIO_SMTEN_SMTEN7_Pos            (7)                                               /*!< GPIO_T::SMTEN: SMTEN7 Position         */
S#define GPIO_SMTEN_SMTEN7_Msk            (0x1ul << GPIO_SMTEN_SMTEN7_Pos)                  /*!< GPIO_T::SMTEN: SMTEN7 Mask             */
S
S#define GPIO_SMTEN_SMTEN8_Pos            (8)                                               /*!< GPIO_T::SMTEN: SMTEN8 Position         */
S#define GPIO_SMTEN_SMTEN8_Msk            (0x1ul << GPIO_SMTEN_SMTEN8_Pos)                  /*!< GPIO_T::SMTEN: SMTEN8 Mask             */
S
S#define GPIO_SMTEN_SMTEN9_Pos            (9)                                               /*!< GPIO_T::SMTEN: SMTEN9 Position         */
S#define GPIO_SMTEN_SMTEN9_Msk            (0x1ul << GPIO_SMTEN_SMTEN9_Pos)                  /*!< GPIO_T::SMTEN: SMTEN9 Mask             */
S
S#define GPIO_SMTEN_SMTEN10_Pos           (10)                                              /*!< GPIO_T::SMTEN: SMTEN10 Position        */
S#define GPIO_SMTEN_SMTEN10_Msk           (0x1ul << GPIO_SMTEN_SMTEN10_Pos)                 /*!< GPIO_T::SMTEN: SMTEN10 Mask            */
S
S#define GPIO_SMTEN_SMTEN11_Pos           (11)                                              /*!< GPIO_T::SMTEN: SMTEN11 Position        */
S#define GPIO_SMTEN_SMTEN11_Msk           (0x1ul << GPIO_SMTEN_SMTEN11_Pos)                 /*!< GPIO_T::SMTEN: SMTEN11 Mask            */
S
S#define GPIO_SMTEN_SMTEN12_Pos           (12)                                              /*!< GPIO_T::SMTEN: SMTEN12 Position        */
S#define GPIO_SMTEN_SMTEN12_Msk           (0x1ul << GPIO_SMTEN_SMTEN12_Pos)                 /*!< GPIO_T::SMTEN: SMTEN12 Mask            */
S
S#define GPIO_SMTEN_SMTEN13_Pos           (13)                                              /*!< GPIO_T::SMTEN: SMTEN13 Position        */
S#define GPIO_SMTEN_SMTEN13_Msk           (0x1ul << GPIO_SMTEN_SMTEN13_Pos)                 /*!< GPIO_T::SMTEN: SMTEN13 Mask            */
S
S#define GPIO_SMTEN_SMTEN14_Pos           (14)                                              /*!< GPIO_T::SMTEN: SMTEN14 Position        */
S#define GPIO_SMTEN_SMTEN14_Msk           (0x1ul << GPIO_SMTEN_SMTEN14_Pos)                 /*!< GPIO_T::SMTEN: SMTEN14 Mask            */
S
S#define GPIO_SMTEN_SMTEN15_Pos           (15)                                              /*!< GPIO_T::SMTEN: SMTEN15 Position        */
S#define GPIO_SMTEN_SMTEN15_Msk           (0x1ul << GPIO_SMTEN_SMTEN15_Pos)                 /*!< GPIO_T::SMTEN: SMTEN15 Mask            */
S
S#define GPIO_SLEWCTL_HSREN0_Pos          (0)                                               /*!< GPIO_T::SLEWCTL: HSREN0 Position       */
S#define GPIO_SLEWCTL_HSREN0_Msk          (0x1ul << GPIO_SLEWCTL_HSREN0_Pos)                /*!< GPIO_T::SLEWCTL: HSREN0 Mask           */
S
S#define GPIO_SLEWCTL_HSREN1_Pos          (1)                                               /*!< GPIO_T::SLEWCTL: HSREN1 Position       */
S#define GPIO_SLEWCTL_HSREN1_Msk          (0x1ul << GPIO_SLEWCTL_HSREN1_Pos)                /*!< GPIO_T::SLEWCTL: HSREN1 Mask           */
S
S#define GPIO_SLEWCTL_HSREN2_Pos          (2)                                               /*!< GPIO_T::SLEWCTL: HSREN2 Position       */
S#define GPIO_SLEWCTL_HSREN2_Msk          (0x1ul << GPIO_SLEWCTL_HSREN2_Pos)                /*!< GPIO_T::SLEWCTL: HSREN2 Mask           */
S
S#define GPIO_SLEWCTL_HSREN3_Pos          (3)                                               /*!< GPIO_T::SLEWCTL: HSREN3 Position       */
S#define GPIO_SLEWCTL_HSREN3_Msk          (0x1ul << GPIO_SLEWCTL_HSREN3_Pos)                /*!< GPIO_T::SLEWCTL: HSREN3 Mask           */
S
S#define GPIO_SLEWCTL_HSREN4_Pos          (4)                                               /*!< GPIO_T::SLEWCTL: HSREN4 Position       */
S#define GPIO_SLEWCTL_HSREN4_Msk          (0x1ul << GPIO_SLEWCTL_HSREN4_Pos)                /*!< GPIO_T::SLEWCTL: HSREN4 Mask           */
S
S#define GPIO_SLEWCTL_HSREN5_Pos          (5)                                               /*!< GPIO_T::SLEWCTL: HSREN5 Position       */
S#define GPIO_SLEWCTL_HSREN5_Msk          (0x1ul << GPIO_SLEWCTL_HSREN5_Pos)                /*!< GPIO_T::SLEWCTL: HSREN5 Mask           */
S
S#define GPIO_SLEWCTL_HSREN6_Pos          (6)                                               /*!< GPIO_T::SLEWCTL: HSREN6 Position       */
S#define GPIO_SLEWCTL_HSREN6_Msk          (0x1ul << GPIO_SLEWCTL_HSREN6_Pos)                /*!< GPIO_T::SLEWCTL: HSREN6 Mask           */
S
S#define GPIO_SLEWCTL_HSREN7_Pos          (7)                                               /*!< GPIO_T::SLEWCTL: HSREN7 Position       */
S#define GPIO_SLEWCTL_HSREN7_Msk          (0x1ul << GPIO_SLEWCTL_HSREN7_Pos)                /*!< GPIO_T::SLEWCTL: HSREN7 Mask           */
S
S#define GPIO_SLEWCTL_HSREN8_Pos          (8)                                               /*!< GPIO_T::SLEWCTL: HSREN8 Position       */
S#define GPIO_SLEWCTL_HSREN8_Msk          (0x1ul << GPIO_SLEWCTL_HSREN8_Pos)                /*!< GPIO_T::SLEWCTL: HSREN8 Mask           */
S
S#define GPIO_SLEWCTL_HSREN9_Pos          (9)                                               /*!< GPIO_T::SLEWCTL: HSREN9 Position       */
S#define GPIO_SLEWCTL_HSREN9_Msk          (0x1ul << GPIO_SLEWCTL_HSREN9_Pos)                /*!< GPIO_T::SLEWCTL: HSREN9 Mask           */
S
S#define GPIO_SLEWCTL_HSREN10_Pos         (10)                                              /*!< GPIO_T::SLEWCTL: HSREN10 Position      */
S#define GPIO_SLEWCTL_HSREN10_Msk         (0x1ul << GPIO_SLEWCTL_HSREN10_Pos)               /*!< GPIO_T::SLEWCTL: HSREN10 Mask          */
S
S#define GPIO_SLEWCTL_HSREN11_Pos         (11)                                              /*!< GPIO_T::SLEWCTL: HSREN11 Position      */
S#define GPIO_SLEWCTL_HSREN11_Msk         (0x1ul << GPIO_SLEWCTL_HSREN11_Pos)               /*!< GPIO_T::SLEWCTL: HSREN11 Mask          */
S
S#define GPIO_SLEWCTL_HSREN12_Pos         (12)                                              /*!< GPIO_T::SLEWCTL: HSREN12 Position      */
S#define GPIO_SLEWCTL_HSREN12_Msk         (0x1ul << GPIO_SLEWCTL_HSREN12_Pos)               /*!< GPIO_T::SLEWCTL: HSREN12 Mask          */
S
S#define GPIO_SLEWCTL_HSREN13_Pos         (13)                                              /*!< GPIO_T::SLEWCTL: HSREN13 Position      */
S#define GPIO_SLEWCTL_HSREN13_Msk         (0x1ul << GPIO_SLEWCTL_HSREN13_Pos)               /*!< GPIO_T::SLEWCTL: HSREN13 Mask          */
S
S#define GPIO_SLEWCTL_HSREN14_Pos         (14)                                              /*!< GPIO_T::SLEWCTL: HSREN14 Position      */
S#define GPIO_SLEWCTL_HSREN14_Msk         (0x1ul << GPIO_SLEWCTL_HSREN14_Pos)               /*!< GPIO_T::SLEWCTL: HSREN14 Mask          */
S
S#define GPIO_SLEWCTL_HSREN15_Pos         (15)                                              /*!< GPIO_T::SLEWCTL: HSREN15 Position      */
S#define GPIO_SLEWCTL_HSREN15_Msk         (0x1ul << GPIO_SLEWCTL_HSREN15_Pos)               /*!< GPIO_T::SLEWCTL: HSREN15 Mask          */
S
S#define GPIO_DRVCTL_HDRVEN8_Pos          (8)                                               /*!< GPIO_T::DRVCTL: HDRVEN8 Position       */
S#define GPIO_DRVCTL_HDRVEN8_Msk          (0x1ul << GPIO_DRVCTL_HDRVEN8_Pos)                /*!< GPIO_T::DRVCTL: HDRVEN8 Mask           */
S
S#define GPIO_DRVCTL_HDRVEN9_Pos          (9)                                               /*!< GPIO_T::DRVCTL: HDRVEN9 Position       */
S#define GPIO_DRVCTL_HDRVEN9_Msk          (0x1ul << GPIO_DRVCTL_HDRVEN9_Pos)                /*!< GPIO_T::DRVCTL: HDRVEN9 Mask           */
S
S#define GPIO_DRVCTL_HDRVEN10_Pos         (10)                                              /*!< GPIO_T::DRVCTL: HDRVEN10 Position      */
S#define GPIO_DRVCTL_HDRVEN10_Msk         (0x1ul << GPIO_DRVCTL_HDRVEN10_Pos)               /*!< GPIO_T::DRVCTL: HDRVEN10 Mask          */
S
S#define GPIO_DRVCTL_HDRVEN11_Pos         (11)                                              /*!< GPIO_T::DRVCTL: HDRVEN11 Position      */
S#define GPIO_DRVCTL_HDRVEN11_Msk         (0x1ul << GPIO_DRVCTL_HDRVEN11_Pos)               /*!< GPIO_T::DRVCTL: HDRVEN11 Mask          */
S
S#define GPIO_DRVCTL_HDRVEN12_Pos         (12)                                              /*!< GPIO_T::DRVCTL: HDRVEN12 Position      */
S#define GPIO_DRVCTL_HDRVEN12_Msk         (0x1ul << GPIO_DRVCTL_HDRVEN12_Pos)               /*!< GPIO_T::DRVCTL: HDRVEN12 Mask          */
S
S#define GPIO_DRVCTL_HDRVEN13_Pos         (13)                                              /*!< GPIO_T::DRVCTL: HDRVEN13 Position      */
S#define GPIO_DRVCTL_HDRVEN13_Msk         (0x1ul << GPIO_DRVCTL_HDRVEN13_Pos)               /*!< GPIO_T::DRVCTL: HDRVEN13 Mask          */
S
S#define GPIO_DBCTL_DBCLKSEL_Pos          (0)                                               /*!< GPIO_DBCTL_T::DBCTL: DBCLKSEL Position */
S#define GPIO_DBCTL_DBCLKSEL_Msk          (0xful << GPIO_DBCTL_DBCLKSEL_Pos)                /*!< GPIO_DBCTL_T::DBCTL: DBCLKSEL Mask     */
S
S#define GPIO_DBCTL_DBCLKSRC_Pos          (4)                                               /*!< GPIO_DBCTL_T::DBCTL: DBCLKSRC Position */
S#define GPIO_DBCTL_DBCLKSRC_Msk          (0x1ul << GPIO_DBCTL_DBCLKSRC_Pos)                /*!< GPIO_DBCTL_T::DBCTL: DBCLKSRC Mask     */
S
S#define GPIO_DBCTL_ICLKON_Pos            (5)                                               /*!< GPIO_DBCTL_T::DBCTL: ICLKON Position   */
S#define GPIO_DBCTL_ICLKON_Msk            (0x1ul << GPIO_DBCTL_ICLKON_Pos)                  /*!< GPIO_DBCTL_T::DBCTL: ICLKON Mask       */
S
S
S/**@}*/ /* GPIO_CONST */
S/**@}*/ /* end of GPIO register group */
S
S/*---------------------- Hardware Divider --------------------------------*/
S/**
S    @addtogroup HDIV Hardware Divider(HDIV)
S    Memory Mapped Structure for HDIV Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var HDIV_T::DIVIDEND
S     * Offset: 0x00  Dividend Source Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |DIVIDEND  |Dividend Source
S     * |        |          |This register is given the dividend of divider before calculation starting.
S     * @var HDIV_T::DIVISOR
S     * Offset: 0x04  Divisor Source Resister
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |DIVISOR   |Divisor Source
S     * |        |          |This register is given the divisor of divider before calculation starts.
S     * |        |          |Note: When this register is written, hardware divider will start calculate.
S     * @var HDIV_T::DIVQUO
S     * Offset: 0x08  Quotient Result Resister
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |QUOTIENT  |Quotient Result
S     * |        |          |This register holds the quotient result of divider after calculation complete.
S     * @var HDIV_T::DIVREM
S     * Offset: 0x0C  Remainder Result Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |REMAINDER |Remainder Result
S     * |        |          |The remainder of hardware divider is 16-bit sign integer (REMAINDER[15:0]), which holds the remainder result of divider after calculation complete.
S     * |        |          |The remainder of hardware divider with sign extension (REMAINDER[31:16]) to 32-bit integer.
S     * |        |          |This register holds the remainder result of divider after calculation complete.
S     * @var HDIV_T::DIVSTS
S     * Offset: 0x10  Divider Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |FINISH    |Division Finish Flag
S     * |        |          |0 = Under Calculation.
S     * |        |          |1 = Calculation finished.
S     * |        |          |The flag will become low when the divider is in calculation.
S     * |        |          |The flag will go back to high once the calculation finished.
S     * |[1]     |DIV0      |Divisor Zero Warning
S     * |        |          |0 = The divisor is not 0.
S     * |        |          |1 = The divisor is 0.
S     * |        |          |Note: The DIV0 flag is used to indicate divide-by-zero situation and updated whenever DIVISOR is written
S     * |        |          |This register is read only.
S     */
S    __IO uint32_t DIVIDEND;              /*!< [0x0000] Dividend Source Register                                         */
S    __IO uint32_t DIVISOR;               /*!< [0x0004] Divisor Source Resister                                          */
S    __IO uint32_t DIVQUO;                /*!< [0x0008] Quotient Result Resister                                         */
S    __IO uint32_t DIVREM;                /*!< [0x000c] Remainder Result Register                                        */
S    __I  uint32_t DIVSTS;                /*!< [0x0010] Divider Status Register                                          */
S
S} HDIV_T;
S
S/**
S    @addtogroup HDIV_CONST HDIV Bit Field Definition
S    Constant Definitions for HDIV Controller
S@{ */
S
S#define HDIV_DIVIDEND_DIVIDEND_Pos       (0)                                               /*!< HDIV_T::DIVIDEND: DIVIDEND Position    */
S#define HDIV_DIVIDEND_DIVIDEND_Msk       (0xfffffffful << HDIV_DIVIDEND_DIVIDEND_Pos)      /*!< HDIV_T::DIVIDEND: DIVIDEND Mask        */
S
S#define HDIV_DIVISOR_DIVISOR_Pos         (0)                                               /*!< HDIV_T::DIVISOR: DIVISOR Position      */
S#define HDIV_DIVISOR_DIVISOR_Msk         (0xfffful << HDIV_DIVISOR_DIVISOR_Pos)            /*!< HDIV_T::DIVISOR: DIVISOR Mask          */
S
S#define HDIV_DIVQUO_QUOTIENT_Pos         (0)                                               /*!< HDIV_T::DIVQUO: QUOTIENT Position      */
S#define HDIV_DIVQUO_QUOTIENT_Msk         (0xfffffffful << HDIV_DIVQUO_QUOTIENT_Pos)        /*!< HDIV_T::DIVQUO: QUOTIENT Mask          */
S
S#define HDIV_DIVREM_REMAINDER_Pos        (0)                                               /*!< HDIV_T::DIVREM: REMAINDER Position     */
S#define HDIV_DIVREM_REMAINDER_Msk        (0xfffffffful << HDIV_DIVREM_REMAINDER_Pos)       /*!< HDIV_T::DIVREM: REMAINDER Mask         */
S
S#define HDIV_DIVSTS_FINISH_Pos           (0)                                               /*!< HDIV_T::DIVSTS: FINISH Position        */
S#define HDIV_DIVSTS_FINISH_Msk           (0x1ul << HDIV_DIVSTS_FINISH_Pos)                 /*!< HDIV_T::DIVSTS: FINISH Mask            */
S
S#define HDIV_DIVSTS_DIV0_Pos             (1)                                               /*!< HDIV_T::DIVSTS: DIV0 Position          */
S#define HDIV_DIVSTS_DIV0_Msk             (0x1ul << HDIV_DIVSTS_DIV0_Pos)                   /*!< HDIV_T::DIVSTS: DIV0 Mask              */
S
S/**@}*/ /* HDIV_CONST */
S/**@}*/ /* end of HDIV register group */
S
S
S/*---------------------- Inter-IC Bus Controller -------------------------*/
S/**
S    @addtogroup I2C Inter-IC Bus Controller(I2C)
S    Memory Mapped Structure for I2C Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var I2C_T::CTL
S     * Offset: 0x00  I2C Control Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2]     |AA        |Assert Acknowledge Control
S     * |        |          |When AA=1 prior to address or data is received, an acknowledged (low level to SDA) will be returned during the acknowledge clock pulse on the SCL line when 1.) A slave is acknowledging the address sent from master, 2.) The receiver devices are acknowledging the data sent by transmitter,
S     * |        |          |When AA=0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse on the SCL line.
S     * |[3]     |SI        |I2C Interrupt Flag
S     * |        |          |When a new I2C state is present in the I2C_STATUS register, the SI flag is set by hardware.
S     * |        |          |If bit INTEN (I2C_CTL [7]) is set, the I2C interrupt is requested.
S     * |        |          |SI must be cleared by software.Clear SI by writing 1 to this bit.
S     * |        |          |For ACKMEN is set in slave read mode, the SI flag is set in 8th clock period for user to confirm the acknowledge bit and 9th clock period for user to read the data in the data buffer.
S     * |[4]     |STO       |I2C STOP Control
S     * |        |          |In Master mode, setting STO to transmit a STOP condition to bus then I2C controller will check the bus condition if a STOP condition is detected.
S     * |        |          |This bit will be cleared by hardware automatically.
S     * |[5]     |STA       |I2C START Control
S     * |        |          |Setting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.
S     * |[6]     |I2CEN     |I2C Controller Enable Bit
S     * |        |          |Set to enable I2C serial function controller.When I2CEN=1 the I2C serial function enable.
S     * |        |          |The multi-function pin function must set to SDA, and SCL of I2C function first.
S     * |        |          |0 = I2C serial function Disabled.
S     * |        |          |1 = I2C serial function Enabled.
S     * |[7]     |INTEN     |Enable Interrupt
S     * |        |          |0 = I2C interrupt Disabled.
S     * |        |          |1 = I2C interrupt Enabled.
S     * @var I2C_T::ADDR0
S     * Offset: 0x04  I2C Slave Address Register0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = General Call Function Disabled.
S     * |        |          |1 = General Call Function Enabled.
S     * |[7:1]   |ADDR      |I2C Address
S     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
S     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
S     * |        |          |The I2C hardware will react if either of the address is matched.
S     * @var I2C_T::DAT
S     * Offset: 0x08  I2C Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |DAT       |I2C Data
S     * |        |          |Bit [7:0] is located with the 8-bit transferred/received data of I2C serial port.
S     * @var I2C_T::STATUS
S     * Offset: 0x0C  I2C Status Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |STATUS    |I2C Status
S     * |        |          |There are 28 possible status codes. When the content of I2C_STATUS is F8H, no serial interrupt is requested.
S     * |        |          |Others I2C_STATUS values correspond to defined I2C states.
S     * |        |          |When each of these states is entered, a status interrupt is requested (SI = 1).
S     * |        |          |A valid status code is present in I2C_STATUS one cycle after SI is set by hardware and is still present one cycle after SI has been reset by software.
S     * |        |          |In addition, states 00H stands for a Bus Error. A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame.
S     * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.
S     * @var I2C_T::CLKDIV
S     * Offset: 0x10  I2C Clock Divided Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |DIVIDER   |I2C Clock Divided
S     * |        |          |Indicates the I2C clock rate: Data Baud Rate of I2C = (system clock) / (4x (I2C_CLKDIV+1)).
S     * |        |          |Note: The minimum value of I2C_CLKDIV is 4.
S     * @var I2C_T::TOCTL
S     * Offset: 0x14  I2C Time-out Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TOIF      |Time-out Flag
S     * |        |          |This bit is set by hardware when I2C time-out happened and it can interrupt CPU if I2C interrupt enable bit (INTEN) is set to 1.
S     * |        |          |Note: Software can write 1 to clear this bit.
S     * |[1]     |TOCDIV4   |Time-out Counter Input Clock Divided by 4
S     * |        |          |When Enabled, The time-out period is extend 4 times.
S     * |        |          |0 = Time-out period is extend 4 times Disabled.
S     * |        |          |1 = Time-out period is extend 4 times Enabled.
S     * |[2]     |TOCEN     |Time-out Counter Enable Bit
S     * |        |          |When Enabled, the 14-bit time-out counter will start counting when SI is clear.
S     * |        |          |Setting flag SI to '1' will reset counter and re-start up counting after SI is cleared.
S     * |        |          |0 = Time-out counter Disabled.
S     * |        |          |1 = Time-out counter Enabled.
S     * @var I2C_T::ADDR1
S     * Offset: 0x18  I2C Slave Address Register1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = General Call Function Disabled.
S     * |        |          |1 = General Call Function Enabled.
S     * |[7:1]   |ADDR      |I2C Address
S     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
S     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
S     * |        |          |The I2C hardware will react if either of the address is matched.
S     * @var I2C_T::ADDR2
S     * Offset: 0x1C  I2C Slave Address Register2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = General Call Function Disabled.
S     * |        |          |1 = General Call Function Enabled.
S     * |[7:1]   |ADDR      |I2C Address
S     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
S     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
S     * |        |          |The I2C hardware will react if either of the address is matched.
S     * @var I2C_T::ADDR3
S     * Offset: 0x20  I2C Slave Address Register3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = General Call Function Disabled.
S     * |        |          |1 = General Call Function Enabled.
S     * |[7:1]   |ADDR      |I2C Address
S     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
S     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
S     * |        |          |The I2C hardware will react if either of the address is matched.
S     * @var I2C_T::ADDRMSK0
S     * Offset: 0x24  I2C Slave Address Mask Register0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:1]   |ADDRMSK   |I2C Address Mask
S     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
S     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
S     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
S     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
S     * @var I2C_T::ADDRMSK1
S     * Offset: 0x28  I2C Slave Address Mask Register1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:1]   |ADDRMSK   |I2C Address Mask
S     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
S     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
S     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
S     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
S     * @var I2C_T::ADDRMSK2
S     * Offset: 0x2C  I2C Slave Address Mask Register2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:1]   |ADDRMSK   |I2C Address Mask
S     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
S     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
S     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
S     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
S     * @var I2C_T::ADDRMSK3
S     * Offset: 0x30  I2C Slave Address Mask Register3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:1]   |ADDRMSK   |I2C Address Mask
S     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
S     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
S     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
S     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
S     * @var I2C_T::WKCTL
S     * Offset: 0x3C  I2C Wake-up Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WKEN      |I2C Wake-up Enable Bit
S     * |        |          |0 = I2C wake-up function Disabled.
S     * |        |          |1= I2C wake-up function Enabled.
S     * |[7]     |NHDBUSEN  |I2C No Hold BUS Enable Bit
S     * |        |          |0 = I2C don't hold bus after wake-up disable.
S     * |        |          |1 = I2C don't hold bus after wake-up enable.
S     * |        |          |Note: I2C controller could response when WKIF event is not clear, it may cause error data transmitted or received.
S     * |        |          |If data transmitted or received when WKIF event is not clear, user must reset I2C controller and execute the original operation again.
S     * @var I2C_T::WKSTS
S     * Offset: 0x40  I2C Wake-up Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WKIF      |I2C Wake-up Flag
S     * |        |          |When chip is woken up from Power-down mode by I2C, this bit is set to 1.
S     * |        |          |Software can write 1 to clear this bit.
S     * |[1]     |WKAKDONE  |Wakeup Address Frame Acknowledge Bit Done
S     * |        |          |0 = The ACK bit cycle of address match frame isn't done.
S     * |        |          |1 = The ACK bit cycle of address match frame is done in power-down.
S     * |        |          |Note: This bit can't release WKIF. Software can write 1 to clear this bit.
S     * |[2]     |WRSTSWK   |Read/Write Status Bit in Address Wakeup Frame
S     * |        |          |0 = Write command be record on the address match wakeup frame.
S     * |        |          |1 = Read command be record on the address match wakeup frame.
S     * |        |          |Note: This bit will be cleared when software can write 1 to WKAKDONE bit.
S     * @var I2C_T::CTL1
S     * Offset: 0x44  I2C Control Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TXPDMAEN  |PDMA Transmit Channel Available
S     * |        |          |0 = Transmit PDMA function disable.
S     * |        |          |1 = Transmit PDMA function enable.
S     * |[1]     |RXPDMAEN  |PDMA Receive Channel Available
S     * |        |          |0 = Receive PDMA function disable.
S     * |        |          |1 = Receive PDMA function enable.
S     * |[2]     |PDMARST   |PDMA Reset
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset the PDMA control logic. This bit will be cleared to 0 automatically.
S     * |[3]     |OVRIEN    |I2C over Run Interrupt Control Bit
S     * |        |          |Setting OVRIEN to logic 1 will send a interrupt to system when the TWOBUFEN bit is enabled and there is over run event in received buffer.
S     * |[4]     |UDRIEN    |I2C Under Run Interrupt Control Bit
S     * |        |          |Setting UDRIEN to logic 1 will send a interrupt to system when the TWOBUFEN bit is enabled and there is under run event happened in transmitted buffer.
S     * |[5]     |TWOBUFEN  |Two-level Buffer Enable Bit
S     * |        |          |0 = Two-level buffer Disabled.
S     * |        |          |1 = Two-level buffer Enabled.
S     * |        |          |Set to enable the two-level buffer for I2C transmitted or received buffer.
S     * |        |          |It is used to improve the performance of the I2C bus.
S     * |        |          |If this bit is set = 1, the control bit of STA for repeat start or STO bit should be set after the current SI is clear.
S     * |        |          |For example: if there are 4 data shall be transmitted and then stop it.
S     * |        |          |The STO bit shall be set after the 3rd data's SI event being clear.
S     * |        |          |In this time, the 4th data can be transmitted and the I2C stop after the 4th data transmission done.
S     * |[6]     |TWOBUFRST |Two-level Buffer Reset
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset the related counters, two-level buffer state machine, and the content of data buffer.
S     * |[7]     |NSTRETCH  |No Stretch on the I2C Bus
S     * |        |          |0 = The I2C SCL bus is stretched by hardware if the SI is not cleared in master mode.
S     * |        |          |1 = The I2C SCL bus is not stretched by hardware if the SI is not cleared in master mode.
S     * |[8]     |PDMASTR   |PDMA Stretch Bit
S     * |        |          |0 = I2C send STOP automatically after PDMA transfer done. (only master TX)
S     * |        |          |1 = I2C SCL bus is stretched by hardware after PDMA transfer done if the SI is not cleared. (only master TX)
S     * @var I2C_T::STATUS1
S     * Offset: 0x48  I2C Status Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[4]     |FULL      |Two-level Buffer Full
S     * |        |          |This bit indicates two-level buffer TX or RX full or not when the TWOBUFEN = 1.
S     * |        |          |This bit is set when POINTER is equal to 2.
S     * |[5]     |EMPTY     |Two-level Buffer Empty
S     * |        |          |This bit indicates two-level buffer TX or RX empty or not when the TWOBUFEN = 1.
S     * |        |          |This bit is set when POINTER is equal to 0.
S     * |[6]     |OVR       |I2C over Run Status Bit
S     * |        |          |This bit indicates the received two-level buffer TX or RX is over run when the TWOBUFEN = 1.
S     * |[7]     |UDR       |I2C Under Run Status Bit
S     * |        |          |This bit indicates the transmitted two-level buffer TX or RX is under run when the TWOBUFEN = 1.
S     * |[8]     |ONBUSY    |on Bus Busy
S     * |        |          |Indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected.
S     * |        |          |It is cleared by hardware when a STOP condition is detected.
S     * |        |          |0 = The bus is IDLE (both SCLK and SDA High).
S     * |        |          |1 = The bus is busy.
S     * @var I2C_T::TMCTL
S     * Offset: 0x4C  I2C Timing Configure Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |STCTL     |Setup Time Configure Control Register
S     * |        |          |This field is used to generate a delay timing between SDA falling edge and SCL rising edge in transmission mode.
S     * |        |          |The delay setup time is numbers of peripheral clock = STCTL x PCLK.
S     * |        |          |Note: Setup time setting should not make SCL output less than three PCLKs.
S     * |[11:6]  |HTCTL     |Hold Time Configure Control Register
S     * |        |          |This field is used to generate the delay timing between SCL falling edge and SDA rising edge in transmission mode.
S     * |        |          |The delay hold time is numbers of peripheral clock = HTCTL x PCLK.
S     */
S
S    __IO uint32_t CTL;                   /*!< [0x0000] I2C Control Register                                             */
S    __IO uint32_t ADDR0;                 /*!< [0x0004] I2C Slave Address Register 0                                     */
S    __IO uint32_t DAT;                   /*!< [0x0008] I2C Data Register                                                */
S    __I  uint32_t STATUS;                /*!< [0x000c] I2C Status Register 0                                            */
S    __IO uint32_t CLKDIV;                /*!< [0x0010] I2C Clock Divided Register                                       */
S    __IO uint32_t TOCTL;                 /*!< [0x0014] I2C Time-out Control Register                                    */
S    __IO uint32_t ADDR1;                 /*!< [0x0018] I2C Slave Address Register1                                      */
S    __IO uint32_t ADDR2;                 /*!< [0x001c] I2C Slave Address Register2                                      */
S    __IO uint32_t ADDR3;                 /*!< [0x0020] I2C Slave Address Register3                                      */
S    __IO uint32_t ADDRMSK0;              /*!< [0x0024] I2C Slave Address Mask Register0                                 */
S    __IO uint32_t ADDRMSK1;              /*!< [0x0028] I2C Slave Address Mask Register1                                 */
S    __IO uint32_t ADDRMSK2;              /*!< [0x002c] I2C Slave Address Mask Register2                                 */
S    __IO uint32_t ADDRMSK3;              /*!< [0x0030] I2C Slave Address Mask Register3                                 */
S    __I  uint32_t RESERVE0[2];
S    __IO uint32_t WKCTL;                 /*!< [0x003c] I2C Wake-up Control Register                                     */
S    __IO uint32_t WKSTS;                 /*!< [0x0040] I2C Wake-up Status Register                                      */
S    __IO uint32_t CTL1;                  /*!< [0x0044] I2C Control Register 1                                           */
S    __I  uint32_t STATUS1;               /*!< [0x0048] I2C Status Register 1                                            */
S    __IO uint32_t TMCTL;                 /*!< [0x004c] I2C Timing Configure Control Register                            */
S
S} I2C_T;
S
S/**
S    @addtogroup I2C_CONST I2C Bit Field Definition
S    Constant Definitions for I2C Controller
S@{ */
S
S#define I2C_CTL_AA_Pos                   (2)                                               /*!< I2C_T::CTL: AA Position                */
S#define I2C_CTL_AA_Msk                   (0x1ul << I2C_CTL_AA_Pos)                         /*!< I2C_T::CTL: AA Mask                    */
S
S#define I2C_CTL_SI_Pos                   (3)                                               /*!< I2C_T::CTL: SI Position                */
S#define I2C_CTL_SI_Msk                   (0x1ul << I2C_CTL_SI_Pos)                         /*!< I2C_T::CTL: SI Mask                    */
S
S#define I2C_CTL_STO_Pos                  (4)                                               /*!< I2C_T::CTL: STO Position               */
S#define I2C_CTL_STO_Msk                  (0x1ul << I2C_CTL_STO_Pos)                        /*!< I2C_T::CTL: STO Mask                   */
S
S#define I2C_CTL_STA_Pos                  (5)                                               /*!< I2C_T::CTL: STA Position               */
S#define I2C_CTL_STA_Msk                  (0x1ul << I2C_CTL_STA_Pos)                        /*!< I2C_T::CTL: STA Mask                   */
S
S#define I2C_CTL_I2CEN_Pos                (6)                                               /*!< I2C_T::CTL: I2CEN Position             */
S#define I2C_CTL_I2CEN_Msk                (0x1ul << I2C_CTL_I2CEN_Pos)                      /*!< I2C_T::CTL: I2CEN Mask                 */
S
S#define I2C_CTL_INTEN_Pos                (7)                                               /*!< I2C_T::CTL: INTEN Position             */
S#define I2C_CTL_INTEN_Msk                (0x1ul << I2C_CTL_INTEN_Pos)                      /*!< I2C_T::CTL: INTEN Mask                 */
S
S#define I2C_ADDR0_GC_Pos                 (0)                                               /*!< I2C_T::ADDR0: GC Position              */
S#define I2C_ADDR0_GC_Msk                 (0x1ul << I2C_ADDR0_GC_Pos)                       /*!< I2C_T::ADDR0: GC Mask                  */
S
S#define I2C_ADDR0_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR0: ADDR Position            */
S#define I2C_ADDR0_ADDR_Msk               (0x7ful << I2C_ADDR0_ADDR_Pos)                    /*!< I2C_T::ADDR0: ADDR Mask                */
S
S#define I2C_DAT_DAT_Pos                  (0)                                               /*!< I2C_T::DAT: DAT Position               */
S#define I2C_DAT_DAT_Msk                  (0xfful << I2C_DAT_DAT_Pos)                       /*!< I2C_T::DAT: DAT Mask                   */
S
S#define I2C_STATUS_STATUS_Pos            (0)                                               /*!< I2C_T::STATUS: STATUS Position         */
S#define I2C_STATUS_STATUS_Msk            (0xfful << I2C_STATUS_STATUS_Pos)                 /*!< I2C_T::STATUS: STATUS Mask             */
S
S#define I2C_CLKDIV_DIVIDER_Pos           (0)                                               /*!< I2C_T::CLKDIV: DIVIDER Position        */
S#define I2C_CLKDIV_DIVIDER_Msk           (0xfful << I2C_CLKDIV_DIVIDER_Pos)                /*!< I2C_T::CLKDIV: DIVIDER Mask            */
S
S#define I2C_TOCTL_TOIF_Pos               (0)                                               /*!< I2C_T::TOCTL: TOIF Position            */
S#define I2C_TOCTL_TOIF_Msk               (0x1ul << I2C_TOCTL_TOIF_Pos)                     /*!< I2C_T::TOCTL: TOIF Mask                */
S
S#define I2C_TOCTL_TOCDIV4_Pos            (1)                                               /*!< I2C_T::TOCTL: TOCDIV4 Position         */
S#define I2C_TOCTL_TOCDIV4_Msk            (0x1ul << I2C_TOCTL_TOCDIV4_Pos)                  /*!< I2C_T::TOCTL: TOCDIV4 Mask             */
S
S#define I2C_TOCTL_TOCEN_Pos              (2)                                               /*!< I2C_T::TOCTL: TOCEN Position           */
S#define I2C_TOCTL_TOCEN_Msk              (0x1ul << I2C_TOCTL_TOCEN_Pos)                    /*!< I2C_T::TOCTL: TOCEN Mask               */
S
S#define I2C_ADDR1_GC_Pos                 (0)                                               /*!< I2C_T::ADDR1: GC Position              */
S#define I2C_ADDR1_GC_Msk                 (0x1ul << I2C_ADDR1_GC_Pos)                       /*!< I2C_T::ADDR1: GC Mask                  */
S
S#define I2C_ADDR1_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR1: ADDR Position            */
S#define I2C_ADDR1_ADDR_Msk               (0x7ful << I2C_ADDR1_ADDR_Pos)                    /*!< I2C_T::ADDR1: ADDR Mask                */
S
S#define I2C_ADDR2_GC_Pos                 (0)                                               /*!< I2C_T::ADDR2: GC Position              */
S#define I2C_ADDR2_GC_Msk                 (0x1ul << I2C_ADDR2_GC_Pos)                       /*!< I2C_T::ADDR2: GC Mask                  */
S
S#define I2C_ADDR2_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR2: ADDR Position            */
S#define I2C_ADDR2_ADDR_Msk               (0x7ful << I2C_ADDR2_ADDR_Pos)                    /*!< I2C_T::ADDR2: ADDR Mask                */
S
S#define I2C_ADDR3_GC_Pos                 (0)                                               /*!< I2C_T::ADDR3: GC Position              */
S#define I2C_ADDR3_GC_Msk                 (0x1ul << I2C_ADDR3_GC_Pos)                       /*!< I2C_T::ADDR3: GC Mask                  */
S
S#define I2C_ADDR3_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR3: ADDR Position            */
S#define I2C_ADDR3_ADDR_Msk               (0x7ful << I2C_ADDR3_ADDR_Pos)                    /*!< I2C_T::ADDR3: ADDR Mask                */
S
S#define I2C_ADDRMSK0_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK0: ADDRMSK Position      */
S#define I2C_ADDRMSK0_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK0_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK0: ADDRMSK Mask          */
S
S#define I2C_ADDRMSK1_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK1: ADDRMSK Position      */
S#define I2C_ADDRMSK1_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK1_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK1: ADDRMSK Mask          */
S
S#define I2C_ADDRMSK2_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK2: ADDRMSK Position      */
S#define I2C_ADDRMSK2_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK2_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK2: ADDRMSK Mask          */
S
S#define I2C_ADDRMSK3_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK3: ADDRMSK Position      */
S#define I2C_ADDRMSK3_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK3_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK3: ADDRMSK Mask          */
S
S#define I2C_WKCTL_WKEN_Pos               (0)                                               /*!< I2C_T::WKCTL: WKEN Position            */
S#define I2C_WKCTL_WKEN_Msk               (0x1ul << I2C_WKCTL_WKEN_Pos)                     /*!< I2C_T::WKCTL: WKEN Mask                */
S
S#define I2C_WKCTL_NHDBUSEN_Pos           (7)                                               /*!< I2C_T::WKCTL: NHDBUSEN Position        */
S#define I2C_WKCTL_NHDBUSEN_Msk           (0x1ul << I2C_WKCTL_NHDBUSEN_Pos)                 /*!< I2C_T::WKCTL: NHDBUSEN Mask            */
S
S#define I2C_WKSTS_WKIF_Pos               (0)                                               /*!< I2C_T::WKSTS: WKIF Position            */
S#define I2C_WKSTS_WKIF_Msk               (0x1ul << I2C_WKSTS_WKIF_Pos)                     /*!< I2C_T::WKSTS: WKIF Mask                */
S
S#define I2C_WKSTS_WKAKDONE_Pos           (1)                                               /*!< I2C_T::WKSTS: WKAKDONE Position        */
S#define I2C_WKSTS_WKAKDONE_Msk           (0x1ul << I2C_WKSTS_WKAKDONE_Pos)                 /*!< I2C_T::WKSTS: WKAKDONE Mask            */
S
S#define I2C_WKSTS_WRSTSWK_Pos            (2)                                               /*!< I2C_T::WKSTS: WRSTSWK Position         */
S#define I2C_WKSTS_WRSTSWK_Msk            (0x1ul << I2C_WKSTS_WRSTSWK_Pos)                  /*!< I2C_T::WKSTS: WRSTSWK Mask             */
S
S#define I2C_CTL1_TXPDMAEN_Pos            (0)                                               /*!< I2C_T::CTL1: TXPDMAEN Position         */
S#define I2C_CTL1_TXPDMAEN_Msk            (0x1ul << I2C_CTL1_TXPDMAEN_Pos)                  /*!< I2C_T::CTL1: TXPDMAEN Mask             */
S
S#define I2C_CTL1_RXPDMAEN_Pos            (1)                                               /*!< I2C_T::CTL1: RXPDMAEN Position         */
S#define I2C_CTL1_RXPDMAEN_Msk            (0x1ul << I2C_CTL1_RXPDMAEN_Pos)                  /*!< I2C_T::CTL1: RXPDMAEN Mask             */
S
S#define I2C_CTL1_PDMARST_Pos             (2)                                               /*!< I2C_T::CTL1: PDMARST Position          */
S#define I2C_CTL1_PDMARST_Msk             (0x1ul << I2C_CTL1_PDMARST_Pos)                   /*!< I2C_T::CTL1: PDMARST Mask              */
S
S#define I2C_CTL1_OVRIEN_Pos              (3)                                               /*!< I2C_T::CTL1: OVRIEN Position           */
S#define I2C_CTL1_OVRIEN_Msk              (0x1ul << I2C_CTL1_OVRIEN_Pos)                    /*!< I2C_T::CTL1: OVRIEN Mask               */
S
S#define I2C_CTL1_UDRIEN_Pos              (4)                                               /*!< I2C_T::CTL1: UDRIEN Position           */
S#define I2C_CTL1_UDRIEN_Msk              (0x1ul << I2C_CTL1_UDRIEN_Pos)                    /*!< I2C_T::CTL1: UDRIEN Mask               */
S
S#define I2C_CTL1_TWOBUFEN_Pos            (5)                                               /*!< I2C_T::CTL1: TWOBUFEN Position         */
S#define I2C_CTL1_TWOBUFEN_Msk            (0x1ul << I2C_CTL1_TWOBUFEN_Pos)                  /*!< I2C_T::CTL1: TWOBUFEN Mask             */
S
S#define I2C_CTL1_TWOBUFRST_Pos           (6)                                               /*!< I2C_T::CTL1: TWOBUFRST Position        */
S#define I2C_CTL1_TWOBUFRST_Msk           (0x1ul << I2C_CTL1_TWOBUFRST_Pos)                 /*!< I2C_T::CTL1: TWOBUFRST Mask            */
S
S#define I2C_CTL1_NSTRETCH_Pos            (7)                                               /*!< I2C_T::CTL1: NSTRETCH Position         */
S#define I2C_CTL1_NSTRETCH_Msk            (0x1ul << I2C_CTL1_NSTRETCH_Pos)                  /*!< I2C_T::CTL1: NSTRETCH Mask             */
S
S#define I2C_CTL1_PDMASTR_Pos             (8)                                               /*!< I2C_T::CTL1: PDMASTR Position          */
S#define I2C_CTL1_PDMASTR_Msk             (0x1ul << I2C_CTL1_PDMASTR_Pos)                   /*!< I2C_T::CTL1: PDMASTR Mask              */
S
S#define I2C_STATUS1_FULL_Pos             (4)                                               /*!< I2C_T::STATUS1: FULL Position          */
S#define I2C_STATUS1_FULL_Msk             (0x1ul << I2C_STATUS1_FULL_Pos)                   /*!< I2C_T::STATUS1: FULL Mask              */
S
S#define I2C_STATUS1_EMPTY_Pos            (5)                                               /*!< I2C_T::STATUS1: EMPTY Position         */
S#define I2C_STATUS1_EMPTY_Msk            (0x1ul << I2C_STATUS1_EMPTY_Pos)                  /*!< I2C_T::STATUS1: EMPTY Mask             */
S
S#define I2C_STATUS1_OVR_Pos              (6)                                               /*!< I2C_T::STATUS1: OVR Position           */
S#define I2C_STATUS1_OVR_Msk              (0x1ul << I2C_STATUS1_OVR_Pos)                    /*!< I2C_T::STATUS1: OVR Mask               */
S
S#define I2C_STATUS1_UDR_Pos              (7)                                               /*!< I2C_T::STATUS1: UDR Position           */
S#define I2C_STATUS1_UDR_Msk              (0x1ul << I2C_STATUS1_UDR_Pos)                    /*!< I2C_T::STATUS1: UDR Mask               */
S
S#define I2C_STATUS1_ONBUSY_Pos           (8)                                               /*!< I2C_T::STATUS1: ONBUSY Position        */
S#define I2C_STATUS1_ONBUSY_Msk           (0x1ul << I2C_STATUS1_ONBUSY_Pos)                 /*!< I2C_T::STATUS1: ONBUSY Mask            */
S
S#define I2C_TMCTL_STCTL_Pos              (0)                                               /*!< I2C_T::TMCTL: STCTL Position           */
S#define I2C_TMCTL_STCTL_Msk              (0x3ful << I2C_TMCTL_STCTL_Pos)                   /*!< I2C_T::TMCTL: STCTL Mask               */
S
S#define I2C_TMCTL_HTCTL_Pos              (6)                                               /*!< I2C_T::TMCTL: HTCTL Position           */
S#define I2C_TMCTL_HTCTL_Msk              (0x3ful << I2C_TMCTL_HTCTL_Pos)                   /*!< I2C_T::TMCTL: HTCTL Mask               */
S
S/**@}*/ /* I2C_CONST */
S/**@}*/ /* end of I2C register group */
S
S
S/*---------------------- Peripheral Direct Memory Access Controller -------------------------*/
S/**
S    @addtogroup PDMA Peripheral Direct Memory Access Controller(PDMA)
S    Memory Mapped Structure for PDMA Controller
S@{ */
S
S
S
Stypedef struct
S{
S    /**
S     * @var DSCT_T::CTL
S     * Offset: 0x00/0x10/0x20/0x30/0x40  Descriptor Table Control Register of PDMA Channel 0~4
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
S     * |        |          |00 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
S     * |        |          |01 = Basic mode: The descriptor table only has one task
S     * |        |          |When this task is finished, the TDIF(PDMA_INTSTS[1]) will be asserted.
S     * |        |          |10 = Scatter-Gather mode: When operating in this mode, user must give the first descriptor table address in PDMA_DSCT_FIRST register; PDMA controller will ignore this task, then load the next task to execute.
S     * |        |          |11 = Reserved.
S     * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
S     * |[2]     |TXTYPE    |Transfer Type
S     * |        |          |0 = Burst transfer type.
S     * |        |          |1 = Single transfer type.
S     * |[6:4]   |BURSIZE   |Burst Size
S     * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
S     * |        |          |000 = 128 Transfers.
S     * |        |          |001 = 64 Transfers.
S     * |        |          |010 = 32 Transfers.
S     * |        |          |011 = 16 Transfers.
S     * |        |          |100 = 8 Transfers.
S     * |        |          |101 = 4 Transfers.
S     * |        |          |110 = 2 Transfers.
S     * |        |          |111 = 1 Transfers.
S     * |        |          |Note: This field is only useful in burst transfer type.
S     * |[7]     |TBINTDIS  |Table Interrupt Disable Bit
S     * |        |          |This field can be used to decide whether to enable table interrupt or not
S     * |        |          |If the TBINTDIS bit is enabled when PDMA controller finishes transfer task, it will not generates transfer done interrupt.
S     * |        |          |0 = Table interrupt Enabled.
S     * |        |          |1 = Table interrupt Disabled.
S     * |        |          |Note: If this bit set to 1, the TEMPTYF will not be set.
S     * |[9:8]   |SAINC     |Source Address Increment
S     * |        |          |This Field Is Used To Set The Source Address Increment Size.
S     * |        |          |11 = No Increment (Fixed Address).
S     * |        |          |Others = Increment And Size Is Depended On TXWIDTH Selection.
S     * |[11:10] |DAINC     |Destination Address Increment
S     * |        |          |This field is used to set the destination address increment size.
S     * |        |          |11 = No increment (fixed address).
S     * |        |          |Others = Increment and size is depended on TXWIDTH selection.
S     * |[13:12] |TXWIDTH   |Transfer Width Selection
S     * |        |          |This field is used for transfer width.
S     * |        |          |00 = One byte (8 bit) is transferred for every operation.
S     * |        |          |01 = One half-word (16 bit) is transferred for every operation.
S     * |        |          |10 = One word (32-bit) is transferred for every operation.
S     * |        |          |11 = Reserved.
S     * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
S     * |        |          |For example, if source address is 0x2000_0202, but TXWIDTH is word transfer, the source address is not word alignment
S     * |        |          |The source address is aligned when TXWIDTH is byte or half-word transfer.
S     * |[29:16] |TXCNT     |Transfer Count
S     * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
S     * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
S     * @var DSCT_T::SA
S     * Offset: 0x04/0x14/0x24/0x34/0x44  Source Address Register of PDMA Channel 0~4
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |SA        |PDMA Transfer Source Address Register
S     * |        |          |This field indicates a 32-bit source address of PDMA controller.
S     * |        |          |Note: The PDMA transfer source address should be aligned with the TXWIDTH(PDMA_DSCTn_CTL[13:12], n=0,1..4) selection.
S     * @var DSCT_T::DA
S     * Offset: 0x08/0x18/0x28/0x38/0x48  Destination Address Register of PDMA Channel 0~4
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |DA        |PDMA Transfer Destination Address Register
S     * |        |          |This field indicates a 32-bit destination address of PDMA controller.
S     * |        |          |Note: The PDMA transfer destination address should be aligned with the TXWIDTH(PDMA_DSCTn_CTL[13:12], n=0,1..4) selection.
S     * @var DSCT_T::FIRST
S     * Offset: 0x0C/0x1C/0x2C/0x3C/0x4C  First Scatter-Gather Descriptor Table Offset of PDMA Channel 0~4
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FIRST     |PDMA First Descriptor Table Offset
S     * |        |          |This field indicates the offset of the first descriptor table address in system memory.
S     * |        |          |Write Operation:
S     * |        |          |If the system memory based address is 0x2000_0000 (PDMA_SCATBA), and the first descriptor table is start from 0x2000_0100, then this field must fill in 0x0100.
S     * |        |          |Read Operation:
S     * |        |          |When operating in scatter-gather mode, the last two bits FIRST[1:0] will become reserved.
S     * |        |          |Note1: The first descriptor table address must be word boundary.
S     * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
S     * |[31:16] |NEXT      |PDMA Next Descriptor Table Offset
S     * |        |          |This field indicates the offset of next descriptor table address in system memory.
S     * |        |          |Note: write operation is useless in this field.
S     */
S
S    __IO uint32_t CTL;             /*!< [0x00/0x10/0x20/0x30/0x40] Descriptor Table Control Register of PDMA Channel 0~4              */
S    __IO uint32_t SA;              /*!< [0x04/0x14/0x24/0x34/0x44] Source Address Register of PDMA Channel 0~4                        */
S    __IO uint32_t DA;              /*!< [0x08/0x18/0x28/0x38/0x48] Destination Address Register of PDMA Channel 0~4                   */
S    union
S    {
S        __IO uint32_t FIRST;       /*!< [0x0C/0x1C/0x2C/0x3C/0x4C] First Scatter-Gather Descriptor Table Offset of PDMA Channel 0~4   */
S        __IO uint32_t NEXT;        /*!< Next Scatter-Gather Descriptor Table Offset                                                   */
S    };
S
S} DSCT_T;
S
Stypedef struct
S{
S
S
S    /**
S     * @var PDMA_T::CURSCAT
S     * Offset: 0x50/0x54/0x58/0x5C/0x60  Current Scatter-Gather Descriptor Table Address of PDMA Channel 0~4
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
S     * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
S     * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
S     * @var PDMA_T::CHCTL
S     * Offset: 0x400  PDMA Channel Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CHEN0     |PDMA Channel N Enable Bit
S     * |        |          |Set this bit to 1 to enable PDMAn operation. Channel cannot be active if it is not set as enabled.
S     * |        |          |0 = PDMA channel [n] Disabled.
S     * |        |          |1 = PDMA channel [n] Enabled.
S     * |        |          |Note: Set PDMA_PAUSE or PDMA_RESET register will also clear this bit.
S     * |[1]     |CHEN1     |PDMA Channel N Enable Bit
S     * |        |          |Set this bit to 1 to enable PDMAn operation. Channel cannot be active if it is not set as enabled.
S     * |        |          |0 = PDMA channel [n] Disabled.
S     * |        |          |1 = PDMA channel [n] Enabled.
S     * |        |          |Note: Set PDMA_PAUSE or PDMA_RESET register will also clear this bit.
S     * |[2]     |CHEN2     |PDMA Channel N Enable Bit
S     * |        |          |Set this bit to 1 to enable PDMAn operation. Channel cannot be active if it is not set as enabled.
S     * |        |          |0 = PDMA channel [n] Disabled.
S     * |        |          |1 = PDMA channel [n] Enabled.
S     * |        |          |Note: Set PDMA_PAUSE or PDMA_RESET register will also clear this bit.
S     * |[3]     |CHEN3     |PDMA Channel N Enable Bit
S     * |        |          |Set this bit to 1 to enable PDMAn operation. Channel cannot be active if it is not set as enabled.
S     * |        |          |0 = PDMA channel [n] Disabled.
S     * |        |          |1 = PDMA channel [n] Enabled.
S     * |        |          |Note: Set PDMA_PAUSE or PDMA_RESET register will also clear this bit.
S     * |[4]     |CHEN4     |PDMA Channel N Enable Bit
S     * |        |          |Set this bit to 1 to enable PDMAn operation. Channel cannot be active if it is not set as enabled.
S     * |        |          |0 = PDMA channel [n] Disabled.
S     * |        |          |1 = PDMA channel [n] Enabled.
S     * |        |          |Note: Set PDMA_PAUSE or PDMA_RESET register will also clear this bit.
S     * @var PDMA_T::PAUSE
S     * Offset: 0x404  PDMA Transfer Pause Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PAUSE0    |PDMA Channel N Transfer Pause Control Register (Write Only)
S     * |        |          |User can set PAUSEn bit field to pause the PDMA transfer
S     * |        |          |When user sets PAUSEn bit, the PDMA controller will pause the on-going transfer, then clear the channel enable bit CHEN(PDMA_CHCTL [n], n=0,1..4) and clear request active flag
S     * |        |          |If re-enable the paused channel agian, the remaining transfers will be processed.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Pause PDMA channel n transfer.
S     * |[1]     |PAUSE1    |PDMA Channel N Transfer Pause Control Register (Write Only)
S     * |        |          |User can set PAUSEn bit field to pause the PDMA transfer
S     * |        |          |When user sets PAUSEn bit, the PDMA controller will pause the on-going transfer, then clear the channel enable bit CHEN(PDMA_CHCTL [n], n=0,1..4) and clear request active flag
S     * |        |          |If re-enable the paused channel agian, the remaining transfers will be processed.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Pause PDMA channel n transfer.
S     * |[2]     |PAUSE2    |PDMA Channel N Transfer Pause Control Register (Write Only)
S     * |        |          |User can set PAUSEn bit field to pause the PDMA transfer
S     * |        |          |When user sets PAUSEn bit, the PDMA controller will pause the on-going transfer, then clear the channel enable bit CHEN(PDMA_CHCTL [n], n=0,1..4) and clear request active flag
S     * |        |          |If re-enable the paused channel agian, the remaining transfers will be processed.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Pause PDMA channel n transfer.
S     * |[3]     |PAUSE3    |PDMA Channel N Transfer Pause Control Register (Write Only)
S     * |        |          |User can set PAUSEn bit field to pause the PDMA transfer
S     * |        |          |When user sets PAUSEn bit, the PDMA controller will pause the on-going transfer, then clear the channel enable bit CHEN(PDMA_CHCTL [n], n=0,1..4) and clear request active flag
S     * |        |          |If re-enable the paused channel agian, the remaining transfers will be processed.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Pause PDMA channel n transfer.
S     * |[4]     |PAUSE4    |PDMA Channel N Transfer Pause Control Register (Write Only)
S     * |        |          |User can set PAUSEn bit field to pause the PDMA transfer
S     * |        |          |When user sets PAUSEn bit, the PDMA controller will pause the on-going transfer, then clear the channel enable bit CHEN(PDMA_CHCTL [n], n=0,1..4) and clear request active flag
S     * |        |          |If re-enable the paused channel agian, the remaining transfers will be processed.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Pause PDMA channel n transfer.
S     * @var PDMA_T::SWREQ
S     * Offset: 0x408  PDMA Software Request Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SWREQ0    |PDMA Channel N Software Request Register (Write Only)
S     * |        |          |Set this bit to 1 to generate a software request to PDMA [n].
S     * |        |          |0 = No effect.
S     * |        |          |1 = Generate a software request.
S     * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
S     * |        |          |Active flag may be triggered by software request or peripheral request.
S     * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
S     * |[1]     |SWREQ1    |PDMA Channel N Software Request Register (Write Only)
S     * |        |          |Set this bit to 1 to generate a software request to PDMA [n].
S     * |        |          |0 = No effect.
S     * |        |          |1 = Generate a software request.
S     * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
S     * |        |          |Active flag may be triggered by software request or peripheral request.
S     * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
S     * |[2]     |SWREQ2    |PDMA Channel N Software Request Register (Write Only)
S     * |        |          |Set this bit to 1 to generate a software request to PDMA [n].
S     * |        |          |0 = No effect.
S     * |        |          |1 = Generate a software request.
S     * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
S     * |        |          |Active flag may be triggered by software request or peripheral request.
S     * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
S     * |[3]     |SWREQ3    |PDMA Channel N Software Request Register (Write Only)
S     * |        |          |Set this bit to 1 to generate a software request to PDMA [n].
S     * |        |          |0 = No effect.
S     * |        |          |1 = Generate a software request.
S     * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
S     * |        |          |Active flag may be triggered by software request or peripheral request.
S     * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
S     * |[4]     |SWREQ4    |PDMA Channel N Software Request Register (Write Only)
S     * |        |          |Set this bit to 1 to generate a software request to PDMA [n].
S     * |        |          |0 = No effect.
S     * |        |          |1 = Generate a software request.
S     * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active
S     * |        |          |Active flag may be triggered by software request or peripheral request.
S     * |        |          |Note2: If user does not enable corresponding PDMA channel, the software request will be ignored.
S     * @var PDMA_T::TRGSTS
S     * Offset: 0x40C  PDMA Channel Request Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |REQSTS0   |PDMA Channel N Request Status (Read Only)
S     * |        |          |This flag indicates whether channel[n] have a request or not, no matter request from software or peripheral
S     * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
S     * |        |          |0 = PDMA Channel n has no request.
S     * |        |          |1 = PDMA Channel n has a request.
S     * |        |          |Note: If user pauses or resets each PDMA transfer by setting PDMA_PAUSE or PDMA_RESET register respectively, this bit will be cleared automatically after finishing current transfer.
S     * |[1]     |REQSTS1   |PDMA Channel N Request Status (Read Only)
S     * |        |          |This flag indicates whether channel[n] have a request or not, no matter request from software or peripheral
S     * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
S     * |        |          |0 = PDMA Channel n has no request.
S     * |        |          |1 = PDMA Channel n has a request.
S     * |        |          |Note: If user pauses or resets each PDMA transfer by setting PDMA_PAUSE or PDMA_RESET register respectively, this bit will be cleared automatically after finishing current transfer.
S     * |[2]     |REQSTS2   |PDMA Channel N Request Status (Read Only)
S     * |        |          |This flag indicates whether channel[n] have a request or not, no matter request from software or peripheral
S     * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
S     * |        |          |0 = PDMA Channel n has no request.
S     * |        |          |1 = PDMA Channel n has a request.
S     * |        |          |Note: If user pauses or resets each PDMA transfer by setting PDMA_PAUSE or PDMA_RESET register respectively, this bit will be cleared automatically after finishing current transfer.
S     * |[3]     |REQSTS3   |PDMA Channel N Request Status (Read Only)
S     * |        |          |This flag indicates whether channel[n] have a request or not, no matter request from software or peripheral
S     * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
S     * |        |          |0 = PDMA Channel n has no request.
S     * |        |          |1 = PDMA Channel n has a request.
S     * |        |          |Note: If user pauses or resets each PDMA transfer by setting PDMA_PAUSE or PDMA_RESET register respectively, this bit will be cleared automatically after finishing current transfer.
S     * |[4]     |REQSTS4   |PDMA Channel N Request Status (Read Only)
S     * |        |          |This flag indicates whether channel[n] have a request or not, no matter request from software or peripheral
S     * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
S     * |        |          |0 = PDMA Channel n has no request.
S     * |        |          |1 = PDMA Channel n has a request.
S     * |        |          |Note: If user pauses or resets each PDMA transfer by setting PDMA_PAUSE or PDMA_RESET register respectively, this bit will be cleared automatically after finishing current transfer.
S     * @var PDMA_T::PRISET
S     * Offset: 0x410  PDMA Fixed Priority Setting Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |FPRISET0  |PDMA Channel N Fixed Priority Setting Register
S     * |        |          |Set this bit to 1 to enable fixed priority level
S     * |        |          |The fixed priority channel has higher priority than round-robin priority channel
S     * |        |          |If multiple channels are set as the same priority, the higher number of channels have higher priority.
S     * |        |          |Write Operation:
S     * |        |          |0 = No effect.
S     * |        |          |1 = Set PDMA channel [n] to fixed priority channel.
S     * |        |          |Read Operation:
S     * |        |          |0 = Corresponding PDMA channel is round-robin priority.
S     * |        |          |1 = Corresponding PDMA channel is fixed priority.
S     * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
S     * |[1]     |FPRISET1  |PDMA Channel N Fixed Priority Setting Register
S     * |        |          |Set this bit to 1 to enable fixed priority level
S     * |        |          |The fixed priority channel has higher priority than round-robin priority channel
S     * |        |          |If multiple channels are set as the same priority, the higher number of channels have higher priority.
S     * |        |          |Write Operation:
S     * |        |          |0 = No effect.
S     * |        |          |1 = Set PDMA channel [n] to fixed priority channel.
S     * |        |          |Read Operation:
S     * |        |          |0 = Corresponding PDMA channel is round-robin priority.
S     * |        |          |1 = Corresponding PDMA channel is fixed priority.
S     * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
S     * |[2]     |FPRISET2  |PDMA Channel N Fixed Priority Setting Register
S     * |        |          |Set this bit to 1 to enable fixed priority level
S     * |        |          |The fixed priority channel has higher priority than round-robin priority channel
S     * |        |          |If multiple channels are set as the same priority, the higher number of channels have higher priority.
S     * |        |          |Write Operation:
S     * |        |          |0 = No effect.
S     * |        |          |1 = Set PDMA channel [n] to fixed priority channel.
S     * |        |          |Read Operation:
S     * |        |          |0 = Corresponding PDMA channel is round-robin priority.
S     * |        |          |1 = Corresponding PDMA channel is fixed priority.
S     * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
S     * |[3]     |FPRISET3  |PDMA Channel N Fixed Priority Setting Register
S     * |        |          |Set this bit to 1 to enable fixed priority level
S     * |        |          |The fixed priority channel has higher priority than round-robin priority channel
S     * |        |          |If multiple channels are set as the same priority, the higher number of channels have higher priority.
S     * |        |          |Write Operation:
S     * |        |          |0 = No effect.
S     * |        |          |1 = Set PDMA channel [n] to fixed priority channel.
S     * |        |          |Read Operation:
S     * |        |          |0 = Corresponding PDMA channel is round-robin priority.
S     * |        |          |1 = Corresponding PDMA channel is fixed priority.
S     * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
S     * |[4]     |FPRISET4  |PDMA Channel N Fixed Priority Setting Register
S     * |        |          |Set this bit to 1 to enable fixed priority level
S     * |        |          |The fixed priority channel has higher priority than round-robin priority channel
S     * |        |          |If multiple channels are set as the same priority, the higher number of channels have higher priority.
S     * |        |          |Write Operation:
S     * |        |          |0 = No effect.
S     * |        |          |1 = Set PDMA channel [n] to fixed priority channel.
S     * |        |          |Read Operation:
S     * |        |          |0 = Corresponding PDMA channel is round-robin priority.
S     * |        |          |1 = Corresponding PDMA channel is fixed priority.
S     * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
S     * @var PDMA_T::PRICLR
S     * Offset: 0x414  PDMA Fixed Priority Clear Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |FPRICLR0  |PDMA Channel N Fixed Priority Clear Register (Write Only)
S     * |        |          |Set this bit to 1 to clear fixed priority level.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear PDMA channel [n] fixed priority setting.
S     * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
S     * |[1]     |FPRICLR1  |PDMA Channel N Fixed Priority Clear Register (Write Only)
S     * |        |          |Set this bit to 1 to clear fixed priority level.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear PDMA channel [n] fixed priority setting.
S     * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
S     * |[2]     |FPRICLR2  |PDMA Channel N Fixed Priority Clear Register (Write Only)
S     * |        |          |Set this bit to 1 to clear fixed priority level.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear PDMA channel [n] fixed priority setting.
S     * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
S     * |[3]     |FPRICLR3  |PDMA Channel N Fixed Priority Clear Register (Write Only)
S     * |        |          |Set this bit to 1 to clear fixed priority level.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear PDMA channel [n] fixed priority setting.
S     * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
S     * |[4]     |FPRICLR4  |PDMA Channel N Fixed Priority Clear Register (Write Only)
S     * |        |          |Set this bit to 1 to clear fixed priority level.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear PDMA channel [n] fixed priority setting.
S     * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
S     * @var PDMA_T::INTEN
S     * Offset: 0x418  PDMA Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |INTEN0    |PDMA Channel N Interrupt Enable Register
S     * |        |          |This field is used for enabling PDMA channel[n] interrupt.
S     * |        |          |0 = PDMA channel n interrupt Disabled.
S     * |        |          |1 = PDMA channel n interrupt Enabled.
S     * |[1]     |INTEN1    |PDMA Channel N Interrupt Enable Register
S     * |        |          |This field is used for enabling PDMA channel[n] interrupt.
S     * |        |          |0 = PDMA channel n interrupt Disabled.
S     * |        |          |1 = PDMA channel n interrupt Enabled.
S     * |[2]     |INTEN2    |PDMA Channel N Interrupt Enable Register
S     * |        |          |This field is used for enabling PDMA channel[n] interrupt.
S     * |        |          |0 = PDMA channel n interrupt Disabled.
S     * |        |          |1 = PDMA channel n interrupt Enabled.
S     * |[3]     |INTEN3    |PDMA Channel N Interrupt Enable Register
S     * |        |          |This field is used for enabling PDMA channel[n] interrupt.
S     * |        |          |0 = PDMA channel n interrupt Disabled.
S     * |        |          |1 = PDMA channel n interrupt Enabled.
S      * |[4]     |INTEN4    |PDMA Channel N Interrupt Enable Register
S     * |        |          |This field is used for enabling PDMA channel[n] interrupt.
S     * |        |          |0 = PDMA channel n interrupt Disabled.
S     * |        |          |1 = PDMA channel n interrupt Enabled.
S     * @var PDMA_T::INTSTS
S     * Offset: 0x41C  PDMA Interrupt Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ABTIF     |PDMA Read/Write Target Abort Interrupt Flag (Read Only)
S     * |        |          |This bit indicates that PDMA has target abort error; Software can read PDMA_ABTSTS register to find which channel has target abort error.
S     * |        |          |0 = No AHB bus ERROR response received.
S     * |        |          |1 = AHB bus ERROR response received.
S     * |[1]     |TDIF      |Transfer Done Interrupt Flag (Read Only)
S     * |        |          |This bit indicates that PDMA controller has finished transmission; User can read PDMA_TDSTS register to indicate which channel finished transfer.
S     * |        |          |0 = Not finished yet.
S     * |        |          |1 = PDMA channel has finished transmission.
S     * |[2]     |TEIF      |Table Empty Interrupt Flag (Read Only)
S     * |        |          |This bit indicates PDMA channel scatter-gather table is empty
S     * |        |          |User can read PDMA_SCATSTS register to indicate which channel scatter-gather table is empty.
S     * |        |          |0 = PDMA channel scatter-gather table is not empty.
S     * |        |          |1 = PDMA channel scatter-gather table is empty.
S     * |[8]     |REQTOF0   |PDMA Channel N Request Time-out Flag for Each Channel [N]
S     * |        |          |This flag indicates that PDMA controller has waited peripheral request for a period defined by PDMA_TOC0, user can write 1 to clear these bits.
S     * |        |          |0 = No request time-out.
S     * |        |          |1 = Peripheral request time-out.
S     * |[9]     |REQTOF1   |PDMA Channel N Request Time-out Flag for Each Channel [N]
S     * |        |          |This flag indicates that PDMA controller has waited peripheral request for a period defined by PDMA_TOC10, user can write 1 to clear these bits.
S     * |        |          |0 = No request time-out.
S     * |        |          |1 = Peripheral request time-out.
S     * @var PDMA_T::ABTSTS
S     * Offset: 0x420  PDMA Channel Read/Write Target Abort Flag Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ABTIF0    |PDMA Channel 0 Read/Write Target Abort Interrupt Status Flag
S     * |        |          |This bit indicates which PDMA controller has target abort error; User can write 1 to clear these bits.
S     * |        |          |0 = No AHB bus ERROR response received when channel n transfer.
S     * |        |          |1 = AHB bus ERROR response received when channel n transfer.
S     * |[1]     |ABTIF1    |PDMA Channel 1 Read/Write Target Abort Interrupt Status Flag
S     * |        |          |This bit indicates which PDMA controller has target abort error; User can write 1 to clear these bits.
S     * |        |          |0 = No AHB bus ERROR response received when channel n transfer.
S     * |        |          |1 = AHB bus ERROR response received when channel n transfer.
S     * |[2]     |ABTIF2    |PDMA Channel 2 Read/Write Target Abort Interrupt Status Flag
S     * |        |          |This bit indicates which PDMA controller has target abort error; User can write 1 to clear these bits.
S     * |        |          |0 = No AHB bus ERROR response received when channel n transfer.
S     * |        |          |1 = AHB bus ERROR response received when channel n transfer.
S     * |[3]     |ABTIF3    |PDMA Channel 3 Read/Write Target Abort Interrupt Status Flag
S     * |        |          |This bit indicates which PDMA controller has target abort error; User can write 1 to clear these bits.
S     * |        |          |0 = No AHB bus ERROR response received when channel n transfer.
S     * |        |          |1 = AHB bus ERROR response received when channel n transfer.
S     * |[4]     |ABTIF4    |PDMA Channel 4 Read/Write Target Abort Interrupt Status Flag
S     * |        |          |This bit indicates which PDMA controller has target abort error; User can write 1 to clear these bits.
S     * |        |          |0 = No AHB bus ERROR response received when channel n transfer.
S     * |        |          |1 = AHB bus ERROR response received when channel n transfer.
S     * @var PDMA_T::TDSTS
S     * Offset: 0x424  PDMA Channel Transfer Done Flag Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TDIF0     |PDMA Channel 0 Transfer Done Flag Register
S     * |        |          |This bit indicates whether PDMA controller channel transfer has been finished or not, user can write 1 to clear these bits.
S     * |        |          |0 = PDMA channel transfer has not finished.
S     * |        |          |1 = PDMA channel has finished transmission.
S     * |[1]     |TDIF1     |PDMA Channel 1 Transfer Done Flag Register
S     * |        |          |This bit indicates whether PDMA controller channel transfer has been finished or not, user can write 1 to clear these bits.
S     * |        |          |0 = PDMA channel transfer has not finished.
S     * |        |          |1 = PDMA channel has finished transmission.
S     * |[2]     |TDIF2     |PDMA Channel 2 Transfer Done Flag Register
S     * |        |          |This bit indicates whether PDMA controller channel transfer has been finished or not, user can write 1 to clear these bits.
S     * |        |          |0 = PDMA channel transfer has not finished.
S     * |        |          |1 = PDMA channel has finished transmission.
S     * |[3]     |TDIF3     |PDMA Channel 3 Transfer Done Flag Register
S     * |        |          |This bit indicates whether PDMA controller channel transfer has been finished or not, user can write 1 to clear these bits.
S     * |        |          |0 = PDMA channel transfer has not finished.
S     * |        |          |1 = PDMA channel has finished transmission.
S     * |[4]     |TDIF4     |PDMA Channel 4 Transfer Done Flag Register
S     * |        |          |This bit indicates whether PDMA controller channel transfer has been finished or not, user can write 1 to clear these bits.
S     * |        |          |0 = PDMA channel transfer has not finished.
S     * |        |          |1 = PDMA channel has finished transmission.
S     * @var PDMA_T::SCATSTS
S     * Offset: 0x428  PDMA Scatter-Gather Table Empty Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TEMPTYF0  |Table Empty Flag Register
S     * |        |          |T This bit indicates which PDMA channel table is empty when channel have a request , no matter request from software or peripheral, but operation mode of channel descriptor table is idle state, or channel has finished current transfer and next table operation mode is idle state for PDMA Scatter-Gather mode
S     * |        |          |User can write 1 to clear these bits.
S     * |        |          |0 = PDMA channel scatter-gather table is not empty.
S     * |        |          |1 = PDMA channel scatter-gather table is empty and PDMA SWREQ has be set.
S     * |[1]     |TEMPTYF1  |Table Empty Flag Register
S     * |        |          |T This bit indicates which PDMA channel table is empty when channel have a request , no matter request from software or peripheral, but operation mode of channel descriptor table is idle state, or channel has finished current transfer and next table operation mode is idle state for PDMA Scatter-Gather mode
S     * |        |          |User can write 1 to clear these bits.
S     * |        |          |0 = PDMA channel scatter-gather table is not empty.
S     * |        |          |1 = PDMA channel scatter-gather table is empty and PDMA SWREQ has be set.
S     * |[2]     |TEMPTYF2  |Table Empty Flag Register
S     * |        |          |T This bit indicates which PDMA channel table is empty when channel have a request , no matter request from software or peripheral, but operation mode of channel descriptor table is idle state, or channel has finished current transfer and next table operation mode is idle state for PDMA Scatter-Gather mode
S     * |        |          |User can write 1 to clear these bits.
S     * |        |          |0 = PDMA channel scatter-gather table is not empty.
S     * |        |          |1 = PDMA channel scatter-gather table is empty and PDMA SWREQ has be set.
S     * |[3]     |TEMPTYF3  |Table Empty Flag Register
S     * |        |          |T This bit indicates which PDMA channel table is empty when channel have a request , no matter request from software or peripheral, but operation mode of channel descriptor table is idle state, or channel has finished current transfer and next table operation mode is idle state for PDMA Scatter-Gather mode
S     * |        |          |User can write 1 to clear these bits.
S     * |        |          |0 = PDMA channel scatter-gather table is not empty.
S     * |        |          |1 = PDMA channel scatter-gather table is empty and PDMA SWREQ has be set.
S     * |[4]     |TEMPTYF4  |Table Empty Flag Register
S     * |        |          |T This bit indicates which PDMA channel table is empty when channel have a request , no matter request from software or peripheral, but operation mode of channel descriptor table is idle state, or channel has finished current transfer and next table operation mode is idle state for PDMA Scatter-Gather mode
S     * |        |          |User can write 1 to clear these bits.
S     * |        |          |0 = PDMA channel scatter-gather table is not empty.
S     * |        |          |1 = PDMA channel scatter-gather table is empty and PDMA SWREQ has be set.
S     * @var PDMA_T::TACTSTS
S     * Offset: 0x42C  PDMA Transfer Active Flag Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TXACTF0   |PDMA Channel 0 Transfer on Active Flag Register (Read Only)
S     * |        |          |This bit indicates which PDMA channel is in active.
S     * |        |          |0 = PDMA channel is not finished.
S     * |        |          |1 = PDMA channel is active.
S     * |[1]     |TXACTF1   |PDMA Channel 1 Transfer on Active Flag Register (Read Only)
S     * |        |          |This bit indicates which PDMA channel is in active.
S     * |        |          |0 = PDMA channel is not finished.
S     * |        |          |1 = PDMA channel is active.
S     * |[2]     |TXACTF2   |PDMA Channel 2 Transfer on Active Flag Register (Read Only)
S     * |        |          |This bit indicates which PDMA channel is in active.
S     * |        |          |0 = PDMA channel is not finished.
S     * |        |          |1 = PDMA channel is active.
S     * |[3]     |TXACTF3   |PDMA Channel 3 Transfer on Active Flag Register (Read Only)
S     * |        |          |This bit indicates which PDMA channel is in active.
S     * |        |          |0 = PDMA channel is not finished.
S     * |        |          |1 = PDMA channel is active.
S     * |[4]     |TXACTF4   |PDMA Channel 4 Transfer on Active Flag Register (Read Only)
S     * |        |          |This bit indicates which PDMA channel is in active.
S     * |        |          |0 = PDMA channel is not finished.
S     * |        |          |1 = PDMA channel is active.
S     * @var PDMA_T::TOUTPSC
S     * Offset: 0x430  PDMA Time-out Prescaler Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2:0]   |TOUTPSC0  |PDMA Channel 0 Time-out Clock Source Prescaler Bits
S     * |        |          |000 = PDMA channel 0 time-out clock source is HCLK/2^8.
S     * |        |          |001 = PDMA channel 0 time-out clock source is HCLK/2^9.
S     * |        |          |010 = PDMA channel 0 time-out clock source is HCLK/2^10.
S     * |        |          |011 = PDMA channel 0 time-out clock source is HCLK/2^11.
S     * |        |          |100 = PDMA channel 0 time-out clock source is HCLK/2^12.
S     * |        |          |101 = PDMA channel 0 time-out clock source is HCLK/2^13.
S     * |        |          |110 = PDMA channel 0 time-out clock source is HCLK/2^14.
S     * |        |          |111 = PDMA channel 0 time-out clock source is HCLK/2^15.
S     * |[6:4]   |TOUTPSC1  |PDMA Channel 1 Time-out Clock Source Prescaler Bits
S     * |        |          |000 = PDMA channel 1 time-out clock source is HCLK/2^8.
S     * |        |          |001 = PDMA channel 1 time-out clock source is HCLK/2^9.
S     * |        |          |010 = PDMA channel 1 time-out clock source is HCLK/2^10.
S     * |        |          |011 = PDMA channel 1 time-out clock source is HCLK/2^11.
S     * |        |          |100 = PDMA channel 1 time-out clock source is HCLK/2^12.
S     * |        |          |101 = PDMA channel 1 time-out clock source is HCLK/2^13.
S     * |        |          |110 = PDMA channel 1 time-out clock source is HCLK/2^14.
S     * |        |          |111 = PDMA channel 1 time-out clock source is HCLK/2^15.
S     * @var PDMA_T::TOUTEN
S     * Offset: 0x434  PDMA Time-out Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TOUTEN0   |PDMA Channel 0 Time-out Enable Bit
S     * |        |          |0 = PDMA Channel 0 time-out function Disable.
S     * |        |          |1 = PDMA Channel 0 time-out function Enable.
S     * |[1]     |TOUTEN1   |PDMA Channel 1 Time-out Enable Bit
S     * |        |          |0 = PDMA Channel 1 time-out function Disable.
S     * |        |          |1 = PDMA Channel 1 time-out function Enable.
S     * @var PDMA_T::TOUTIEN
S     * Offset: 0x438  PDMA Time-out Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TOUTIEN0  |PDMA Channel 0 Time-out Interrupt Enable Bit
S     * |        |          |0 = PDMA Channel 0 time-out interrupt Disable.
S     * |        |          |1 = PDMA Channel 0 time-out interrupt Enable.
S     * |[1]     |TOUTIEN1  |PDMA Channel 1 Time-out Interrupt Enable Bit
S     * |        |          |0 = PDMA Channel 1 time-out interrupt Disable.
S     * |        |          |1 = PDMA Channel 1 time-out interrupt Enable.
S     * @var PDMA_T::SCATBA
S     * Offset: 0x43C  PDMA Scatter-Gather Descriptor Table Base Address Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:16] |SCATBA    |PDMA Scatter-gather Descriptor Table Address Register
S     * |        |          |In Scatter-Gather mode, this is the base address for calculating the next link - list address
S     * |        |          |The next link address equation is
S     * |        |          |Next Link Address = PDMA_SCATBA + PDMA_DSCT_FIRST.
S     * |        |          |Note: Only useful in Scatter-Gather mode.
S     * @var PDMA_T::TOC0_1
S     * Offset: 0x440  PDMA Channel 0 and Channel 1 Time-out Counter Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |TOC0      |Time-out Counter for Channel 0
S     * |        |          |This controls the period of time-out function for channel 0
S     * |        |          |The calculation unit is based on TOUTPSC0 (PDMA_TOUTPSC[2:0]) clock.
S     * |        |          |Time-out period = (Period of time-out clock) * (16-bit TOCn),n = 0,1.
S     * |[31:16] |TOC1      |Time-out Counter for Channel 1
S     * |        |          |This controls the period of time-out function for channel 1
S     * |        |          |The calculation unit is based on TOUTPSC1 (PDMA_TOUTPSC[5:3]) clock
S     * |        |          |The example of time-out period can refer TOC0 bit description.
S     * @var PDMA_T::RESET
S     * Offset: 0x460  PDMA Channel Reset Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RESET0    |PDMA Channel 0 Reset Control Register
S     * |        |          |User can set this bit field to reset the PDMA channel
S     * |        |          |When user sets RESETn bit, the PDMA controller will finish the on-going transfer then clear the channel enable bit CHEN(PDMA_CHCTL [0]) and clear request active flag
S     * |        |          |If re-enable channel after channel reset, PDMA will re-load the channel description table to execute PDMA task.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset PDMA channel 0.
S     * |        |          |Note: This bit will be cleared automatically after finishing reset process.
S     * |[1]     |RESET1    |PDMA Channel 1 Reset Control Register
S     * |        |          |User can set this bit field to reset the PDMA channel
S     * |        |          |When user sets RESETn bit, the PDMA controller will finish the on-going transfer then clear the channel enable bit CHEN(PDMA_CHCTL [1]) and clear request active flag
S     * |        |          |If re-enable channel after channel reset, PDMA will re-load the channel description table to execute PDMA task.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset PDMA channel 1.
S     * |        |          |Note: This bit will be cleared automatically after finishing reset process.
S     * |[2]     |RESET2    |PDMA Channel 2 Reset Control Register
S     * |        |          |User can set this bit field to reset the PDMA channel
S     * |        |          |When user sets RESETn bit, the PDMA controller will finish the on-going transfer then clear the channel enable bit CHEN(PDMA_CHCTL [2]) and clear request active flag
S     * |        |          |If re-enable channel after channel reset, PDMA will re-load the channel description table to execute PDMA task.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset PDMA channel 2.
S     * |        |          |Note: This bit will be cleared automatically after finishing reset process.
S     * |[3]     |RESET3    |PDMA Channel 3 Reset Control Register
S     * |        |          |User can set this bit field to reset the PDMA channel
S     * |        |          |When user sets RESETn bit, the PDMA controller will finish the on-going transfer then clear the channel enable bit CHEN(PDMA_CHCTL [3]) and clear request active flag
S     * |        |          |If re-enable channel after channel reset, PDMA will re-load the channel description table to execute PDMA task.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset PDMA channel 3.
S     * |        |          |Note: This bit will be cleared automatically after finishing reset process.
S     * |[4]     |RESET4    |PDMA Channel 4 Reset Control Register
S     * |        |          |User can set this bit field to reset the PDMA channel
S     * |        |          |When user sets RESETn bit, the PDMA controller will finish the on-going transfer then clear the channel enable bit CHEN(PDMA_CHCTL [4]) and clear request active flag
S     * |        |          |If re-enable channel after channel reset, PDMA will re-load the channel description table to execute PDMA task.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset PDMA channel 4.
S     * |        |          |Note: This bit will be cleared automatically after finishing reset process.
S     * @var PDMA_T::REQSEL0_3
S     * Offset: 0x480  PDMA Channel 0 to Channel 3 Request Source Select Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |REQSRC0   |Channel 0 Request Source Selection
S     * |        |          |This filed defines which peripheral is connected to PDMA channel 0
S     * |        |          |User can configure the peripheral by setting REQSRC0.
S     * |        |          |0 = Disable PDMA.
S     * |        |          |1 = Reserved.
S     * |        |          |2 = Channel connects to USB_TX.
S     * |        |          |3 = Channel connects to USB_RX.
S     * |        |          |4 = Channel connects to UART0_TX.
S     * |        |          |5 = Channel connects to UART0_RX.
S     * |        |          |6 = Channel connects to UART1_TX.
S     * |        |          |7 = Channel connects to UART1_RX.
S     * |        |          |8 = Channel connects to UART2_TX.
S     * |        |          |9 = Channel connects to UART2_RX.
S     * |        |          |16 = Channel connects to SPI0_TX.
S     * |        |          |17 = Channel connects to SPI0_RX.
S     * |        |          |18 = Channel connects to SPI1_TX.
S     * |        |          |19 = Channel connects to SPI1_RX.
S     * |        |          |20 = Channel connects to ADC_RX.
S     * |        |          |21 = Channel connects to PWM0_P1_RX.
S     * |        |          |22 = Channel connects to PWM0_P2_RX.
S     * |        |          |23 = Channel connects to PWM0_P3_RX.
S     * |        |          |24 = Channel connects to PWM1_P1_RX.
S     * |        |          |25 = Channel connects to PWM1_P2_RX.
S     * |        |          |26 = Channel connects to PWM1_P3_RX.
S     * |        |          |27 = Reserved.
S     * |        |          |28 = Channel connects to I2C0_TX.
S     * |        |          |29 = Channel connects to I2C0_RX.
S     * |        |          |30 = Channel connects to I2C1_TX.
S     * |        |          |31 = Channel connects to I2C1_RX.
S     * |        |          |32 = Channel connects to TMR0.
S     * |        |          |33 = Channel connects to TMR1.
S     * |        |          |34 = Channel connects to TMR2.
S     * |        |          |35 = Channel connects to TMR3.
S     * |        |          |Others = Reserved.
S     * |        |          |Note 1: A request source cannot assign to two channels at the same time.
S     * |        |          |Note 2: This field is useless when transfer between memory and memory.
S     * |[13:8]  |REQSRC1   |Channel 1 Request Source Selection
S     * |        |          |This filed defines which peripheral is connected to PDMA channel 1
S     * |        |          |User can configure the peripheral setting by REQSRC1.
S     * |        |          |Note: The channel configuration is the same as REQSRC0 field
S     * |        |          |Please refer to the explanation of REQSRC0.
S     * |[21:16] |REQSRC2   |Channel 2 Request Source Selection
S     * |        |          |This filed defines which peripheral is connected to PDMA channel 2
S     * |        |          |User can configure the peripheral setting by REQSRC2.
S     * |        |          |Note: The channel configuration is the same as REQSRC0 field
S     * |        |          |Please refer to the explanation of REQSRC0.
S     * |[29:24] |REQSRC3   |Channel 3 Request Source Selection
S     * |        |          |This filed defines which peripheral is connected to PDMA channel 3
S     * |        |          |User can configure the peripheral setting by REQSRC3.
S     * |        |          |Note: The channel configuration is the same as REQSRC0 field
S     * |        |          |Please refer to the explanation of REQSRC0.
S     * @var PDMA_T::REQSEL4
S     * Offset: 0x484  PDMA Channel 4 Request Source Select Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |REQSRC4   |Channel 4 Request Source Selection
S     * |        |          |This filed defines which peripheral is connected to PDMA channel 4
S     * |        |          |User can configure the peripheral setting by REQSRC4.
S     * |        |          |Note: The channel configuration is the same as REQSRC0 field
S     * |        |          |Please refer to the explanation of REQSRC0.
S     */
S
S    DSCT_T        DSCT[5];               /*!< [0x0000 ~ 0x004C] DMA Embedded Description Table 0~4                      */
S    __I  uint32_t CURSCAT[5];            /*!< [0x0050~0x0060] Current Scatter-Gather Descriptor Table Address of PDMA Channel 0~4 */
S    __I  uint32_t RESERVE0[231];
S    __IO uint32_t CHCTL;                 /*!< [0x0400] PDMA Channel Control Register                                    */
S    __O  uint32_t PAUSE;                 /*!< [0x0404] PDMA Transfer Pause Control Register                             */
S    __O  uint32_t SWREQ;                 /*!< [0x0408] PDMA Software Request Register                                   */
S    __I  uint32_t TRGSTS;                /*!< [0x040c] PDMA Channel Request Status Register                             */
S    __IO uint32_t PRISET;                /*!< [0x0410] PDMA Fixed Priority Setting Register                             */
S    __O  uint32_t PRICLR;                /*!< [0x0414] PDMA Fixed Priority Clear Register                               */
S    __IO uint32_t INTEN;                 /*!< [0x0418] PDMA Interrupt Enable Register                                   */
S    __IO uint32_t INTSTS;                /*!< [0x041c] PDMA Interrupt Status Register                                   */
S    __IO uint32_t ABTSTS;                /*!< [0x0420] PDMA Channel Read/Write Target Abort Flag Register               */
S    __IO uint32_t TDSTS;                 /*!< [0x0424] PDMA Channel Transfer Done Flag Register                         */
S    __IO uint32_t SCATSTS;               /*!< [0x0428] PDMA Scatter-Gather Table Empty Status Register                  */
S    __I  uint32_t TACTSTS;               /*!< [0x042c] PDMA Transfer Active Flag Register                               */
S    __IO uint32_t TOUTPSC;               /*!< [0x0430] PDMA Time-out Prescaler Register                                 */
S    __IO uint32_t TOUTEN;                /*!< [0x0434] PDMA Time-out Enable Register                                    */
S    __IO uint32_t TOUTIEN;               /*!< [0x0438] PDMA Time-out Interrupt Enable Register                          */
S    __IO uint32_t SCATBA;                /*!< [0x043c] PDMA Scatter-Gather Descriptor Table Base Address Register       */
S    __IO uint32_t TOC0_1;                /*!< [0x0440] PDMA Channel 0 and Channel 1 Time-out Counter Register           */
S    __I  uint32_t RESERVE1[7];
S    __IO uint32_t RESET;                 /*!< [0x0460] PDMA Channel Reset Control Register                              */
S    __I  uint32_t RESERVE2[7];
S    __IO uint32_t REQSEL0_3;             /*!< [0x0480] PDMA Channel 0 to Channel 3 Request Source Select Register       */
S    __IO uint32_t REQSEL4;               /*!< [0x0484] PDMA Channel 4 Request Source Select Register                    */
S
S} PDMA_T;
S
S
S
S
S/**
S    @addtogroup PDMA_CONST PDMA Bit Field Definition
S    Constant Definitions for PDMA Controller
S@{ */
S
S#define PDMA_DSCT_CTL_OPMODE_Pos         (0)                                               /*!< PDMA_T::DSCT_CTL: OPMODE Position     */
S#define PDMA_DSCT_CTL_OPMODE_Msk         (0x3ul << PDMA_DSCT_CTL_OPMODE_Pos)               /*!< PDMA_T::DSCT_CTL: OPMODE Mask         */
S
S#define PDMA_DSCT_CTL_TXTYPE_Pos         (2)                                               /*!< PDMA_T::DSCT_CTL: TXTYPE Position     */
S#define PDMA_DSCT_CTL_TXTYPE_Msk         (0x1ul << PDMA_DSCT_CTL_TXTYPE_Pos)               /*!< PDMA_T::DSCT_CTL: TXTYPE Mask         */
S
S#define PDMA_DSCT_CTL_BURSIZE_Pos        (4)                                               /*!< PDMA_T::DSCT_CTL: BURSIZE Position    */
S#define PDMA_DSCT_CTL_BURSIZE_Msk        (0x7ul << PDMA_DSCT_CTL_BURSIZE_Pos)              /*!< PDMA_T::DSCT_CTL: BURSIZE Mask        */
S
S#define PDMA_DSCT_CTL_TBINTDIS_Pos       (7)                                               /*!< PDMA_T::DSCT_CTL: TBINTDIS Position   */
S#define PDMA_DSCT_CTL_TBINTDIS_Msk       (0x1ul << PDMA_DSCT_CTL_TBINTDIS_Pos)             /*!< PDMA_T::DSCT_CTL: TBINTDIS Mask       */
S
S#define PDMA_DSCT_CTL_SAINC_Pos          (8)                                               /*!< PDMA_T::DSCT_CTL: SAINC Position      */
S#define PDMA_DSCT_CTL_SAINC_Msk          (0x3ul << PDMA_DSCT_CTL_SAINC_Pos)                /*!< PDMA_T::DSCT_CTL: SAINC Mask          */
S
S#define PDMA_DSCT_CTL_DAINC_Pos          (10)                                              /*!< PDMA_T::DSCT_CTL: DAINC Position      */
S#define PDMA_DSCT_CTL_DAINC_Msk          (0x3ul << PDMA_DSCT_CTL_DAINC_Pos)                /*!< PDMA_T::DSCT_CTL: DAINC Mask          */
S
S#define PDMA_DSCT_CTL_TXWIDTH_Pos        (12)                                              /*!< PDMA_T::DSCT_CTL: TXWIDTH Position    */
S#define PDMA_DSCT_CTL_TXWIDTH_Msk        (0x3ul << PDMA_DSCT_CTL_TXWIDTH_Pos)              /*!< PDMA_T::DSCT_CTL: TXWIDTH Mask        */
S
S#define PDMA_DSCT_CTL_TXCNT_Pos          (16)                                              /*!< PDMA_T::DSCT_CTL: TXCNT Position      */
S#define PDMA_DSCT_CTL_TXCNT_Msk          (0x3ffful << PDMA_DSCT_CTL_TXCNT_Pos)             /*!< PDMA_T::DSCT_CTL: TXCNT Mask          */
S
S#define PDMA_DSCT_SA_SA_Pos              (0)                                               /*!< PDMA_T::DSCT_SA: SA Position          */
S#define PDMA_DSCT_SA_SA_Msk              (0xfffffffful << PDMA_DSCT_SA_SA_Pos)             /*!< PDMA_T::DSCT_SA: SA Mask              */
S
S#define PDMA_DSCT_DA_DA_Pos              (0)                                               /*!< PDMA_T::DSCT_DA: DA Position          */
S#define PDMA_DSCT_DA_DA_Msk              (0xfffffffful << PDMA_DSCT_DA_DA_Pos)             /*!< PDMA_T::DSCT_DA: DA Mask              */
S
S#define PDMA_DSCT_FIRST_FIRST_Pos        (0)                                               /*!< PDMA_T::DSCT_FIRST: FIRST Position    */
S#define PDMA_DSCT_FIRST_FIRST_Msk        (0xfffful << PDMA_DSCT_FIRST_FIRST_Pos)           /*!< PDMA_T::DSCT_FIRST: FIRST Mask        */
S
S#define PDMA_DSCT_FIRST_NEXT_Pos         (16)                                              /*!< PDMA_T::DSCT_FIRST: NEXT Position     */
S#define PDMA_DSCT_FIRST_NEXT_Msk         (0xfffful << PDMA_DSCT_FIRST_NEXT_Pos)            /*!< PDMA_T::DSCT_FIRST: NEXT Mask         */
S
S#define PDMA_CURSCAT_CURADDR_Pos         (0)                                               /*!< PDMA_T::CURSCAT: CURADDR Position     */
S#define PDMA_CURSCAT_CURADDR_Msk         (0xfffffffful << PDMA_CURSCAT_CURADDR_Pos)        /*!< PDMA_T::CURSCAT: CURADDR Mask         */
S
S#define PDMA_CHCTL_CHEN0_Pos             (0)                                               /*!< PDMA_T::CHCTL: CHEN0 Position          */
S#define PDMA_CHCTL_CHEN0_Msk             (0x1ul << PDMA_CHCTL_CHEN0_Pos)                   /*!< PDMA_T::CHCTL: CHEN0 Mask              */
S
S#define PDMA_CHCTL_CHEN1_Pos             (1)                                               /*!< PDMA_T::CHCTL: CHEN1 Position          */
S#define PDMA_CHCTL_CHEN1_Msk             (0x1ul << PDMA_CHCTL_CHEN1_Pos)                   /*!< PDMA_T::CHCTL: CHEN1 Mask              */
S
S#define PDMA_CHCTL_CHEN2_Pos             (2)                                               /*!< PDMA_T::CHCTL: CHEN2 Position          */
S#define PDMA_CHCTL_CHEN2_Msk             (0x1ul << PDMA_CHCTL_CHEN2_Pos)                   /*!< PDMA_T::CHCTL: CHEN2 Mask              */
S
S#define PDMA_CHCTL_CHEN3_Pos             (3)                                               /*!< PDMA_T::CHCTL: CHEN3 Position          */
S#define PDMA_CHCTL_CHEN3_Msk             (0x1ul << PDMA_CHCTL_CHEN3_Pos)                   /*!< PDMA_T::CHCTL: CHEN3 Mask              */
S
S#define PDMA_CHCTL_CHEN4_Pos             (4)                                               /*!< PDMA_T::CHCTL: CHEN4 Position          */
S#define PDMA_CHCTL_CHEN4_Msk             (0x1ul << PDMA_CHCTL_CHEN4_Pos)                   /*!< PDMA_T::CHCTL: CHEN4 Mask              */
S
S#define PDMA_PAUSE_PAUSE0_Pos            (0)                                               /*!< PDMA_T::PAUSE: PAUSE0 Position         */
S#define PDMA_PAUSE_PAUSE0_Msk            (0x1ul << PDMA_PAUSE_PAUSE0_Pos)                  /*!< PDMA_T::PAUSE: PAUSE0 Mask             */
S
S#define PDMA_PAUSE_PAUSE1_Pos            (1)                                               /*!< PDMA_T::PAUSE: PAUSE1 Position         */
S#define PDMA_PAUSE_PAUSE1_Msk            (0x1ul << PDMA_PAUSE_PAUSE1_Pos)                  /*!< PDMA_T::PAUSE: PAUSE1 Mask             */
S
S#define PDMA_PAUSE_PAUSE2_Pos            (2)                                               /*!< PDMA_T::PAUSE: PAUSE2 Position         */
S#define PDMA_PAUSE_PAUSE2_Msk            (0x1ul << PDMA_PAUSE_PAUSE2_Pos)                  /*!< PDMA_T::PAUSE: PAUSE2 Mask             */
S
S#define PDMA_PAUSE_PAUSE3_Pos            (3)                                               /*!< PDMA_T::PAUSE: PAUSE3 Position         */
S#define PDMA_PAUSE_PAUSE3_Msk            (0x1ul << PDMA_PAUSE_PAUSE3_Pos)                  /*!< PDMA_T::PAUSE: PAUSE3 Mask             */
S
S#define PDMA_PAUSE_PAUSE4_Pos            (4)                                               /*!< PDMA_T::PAUSE: PAUSE4 Position         */
S#define PDMA_PAUSE_PAUSE4_Msk            (0x1ul << PDMA_PAUSE_PAUSE4_Pos)                  /*!< PDMA_T::PAUSE: PAUSE4 Mask             */
S
S#define PDMA_SWREQ_SWREQ0_Pos            (0)                                               /*!< PDMA_T::SWREQ: SWREQ0 Position         */
S#define PDMA_SWREQ_SWREQ0_Msk            (0x1ul << PDMA_SWREQ_SWREQ0_Pos)                  /*!< PDMA_T::SWREQ: SWREQ0 Mask             */
S
S#define PDMA_SWREQ_SWREQ1_Pos            (1)                                               /*!< PDMA_T::SWREQ: SWREQ1 Position         */
S#define PDMA_SWREQ_SWREQ1_Msk            (0x1ul << PDMA_SWREQ_SWREQ1_Pos)                  /*!< PDMA_T::SWREQ: SWREQ1 Mask             */
S
S#define PDMA_SWREQ_SWREQ2_Pos            (2)                                               /*!< PDMA_T::SWREQ: SWREQ2 Position         */
S#define PDMA_SWREQ_SWREQ2_Msk            (0x1ul << PDMA_SWREQ_SWREQ2_Pos)                  /*!< PDMA_T::SWREQ: SWREQ2 Mask             */
S
S#define PDMA_SWREQ_SWREQ3_Pos            (3)                                               /*!< PDMA_T::SWREQ: SWREQ3 Position         */
S#define PDMA_SWREQ_SWREQ3_Msk            (0x1ul << PDMA_SWREQ_SWREQ3_Pos)                  /*!< PDMA_T::SWREQ: SWREQ3 Mask             */
S
S#define PDMA_SWREQ_SWREQ4_Pos            (4)                                               /*!< PDMA_T::SWREQ: SWREQ4 Position         */
S#define PDMA_SWREQ_SWREQ4_Msk            (0x1ul << PDMA_SWREQ_SWREQ4_Pos)                  /*!< PDMA_T::SWREQ: SWREQ4 Mask             */
S
S#define PDMA_TRGSTS_REQSTS0_Pos          (0)                                               /*!< PDMA_T::TRGSTS: REQSTS0 Position       */
S#define PDMA_TRGSTS_REQSTS0_Msk          (0x1ul << PDMA_TRGSTS_REQSTS0_Pos)                /*!< PDMA_T::TRGSTS: REQSTS0 Mask           */
S
S#define PDMA_TRGSTS_REQSTS1_Pos          (1)                                               /*!< PDMA_T::TRGSTS: REQSTS1 Position       */
S#define PDMA_TRGSTS_REQSTS1_Msk          (0x1ul << PDMA_TRGSTS_REQSTS1_Pos)                /*!< PDMA_T::TRGSTS: REQSTS1 Mask           */
S
S#define PDMA_TRGSTS_REQSTS2_Pos          (2)                                               /*!< PDMA_T::TRGSTS: REQSTS2 Position       */
S#define PDMA_TRGSTS_REQSTS2_Msk          (0x1ul << PDMA_TRGSTS_REQSTS2_Pos)                /*!< PDMA_T::TRGSTS: REQSTS2 Mask           */
S
S#define PDMA_TRGSTS_REQSTS3_Pos          (3)                                               /*!< PDMA_T::TRGSTS: REQSTS3 Position       */
S#define PDMA_TRGSTS_REQSTS3_Msk          (0x1ul << PDMA_TRGSTS_REQSTS3_Pos)                /*!< PDMA_T::TRGSTS: REQSTS3 Mask           */
S
S#define PDMA_TRGSTS_REQSTS4_Pos          (4)                                               /*!< PDMA_T::TRGSTS: REQSTS4 Position       */
S#define PDMA_TRGSTS_REQSTS4_Msk          (0x1ul << PDMA_TRGSTS_REQSTS4_Pos)                /*!< PDMA_T::TRGSTS: REQSTS4 Mask           */
S
S#define PDMA_PRISET_FPRISET0_Pos         (0)                                               /*!< PDMA_T::PRISET: FPRISET0 Position      */
S#define PDMA_PRISET_FPRISET0_Msk         (0x1ul << PDMA_PRISET_FPRISET0_Pos)               /*!< PDMA_T::PRISET: FPRISET0 Mask          */
S
S#define PDMA_PRISET_FPRISET1_Pos         (1)                                               /*!< PDMA_T::PRISET: FPRISET1 Position      */
S#define PDMA_PRISET_FPRISET1_Msk         (0x1ul << PDMA_PRISET_FPRISET1_Pos)               /*!< PDMA_T::PRISET: FPRISET1 Mask          */
S
S#define PDMA_PRISET_FPRISET2_Pos         (2)                                               /*!< PDMA_T::PRISET: FPRISET2 Position      */
S#define PDMA_PRISET_FPRISET2_Msk         (0x1ul << PDMA_PRISET_FPRISET2_Pos)               /*!< PDMA_T::PRISET: FPRISET2 Mask          */
S
S#define PDMA_PRISET_FPRISET3_Pos         (3)                                               /*!< PDMA_T::PRISET: FPRISET3 Position      */
S#define PDMA_PRISET_FPRISET3_Msk         (0x1ul << PDMA_PRISET_FPRISET3_Pos)               /*!< PDMA_T::PRISET: FPRISET3 Mask          */
S
S#define PDMA_PRISET_FPRISET4_Pos         (4)                                               /*!< PDMA_T::PRISET: FPRISET4 Position      */
S#define PDMA_PRISET_FPRISET4_Msk         (0x1ul << PDMA_PRISET_FPRISET4_Pos)               /*!< PDMA_T::PRISET: FPRISET4 Mask          */
S
S#define PDMA_PRICLR_FPRICLR0_Pos         (0)                                               /*!< PDMA_T::PRICLR: FPRICLR0 Position      */
S#define PDMA_PRICLR_FPRICLR0_Msk         (0x1ul << PDMA_PRICLR_FPRICLR0_Pos)               /*!< PDMA_T::PRICLR: FPRICLR0 Mask          */
S
S#define PDMA_PRICLR_FPRICLR1_Pos         (1)                                               /*!< PDMA_T::PRICLR: FPRICLR1 Position      */
S#define PDMA_PRICLR_FPRICLR1_Msk         (0x1ul << PDMA_PRICLR_FPRICLR1_Pos)               /*!< PDMA_T::PRICLR: FPRICLR1 Mask          */
S
S#define PDMA_PRICLR_FPRICLR2_Pos         (2)                                               /*!< PDMA_T::PRICLR: FPRICLR2 Position      */
S#define PDMA_PRICLR_FPRICLR2_Msk         (0x1ul << PDMA_PRICLR_FPRICLR2_Pos)               /*!< PDMA_T::PRICLR: FPRICLR2 Mask          */
S
S#define PDMA_PRICLR_FPRICLR3_Pos         (3)                                               /*!< PDMA_T::PRICLR: FPRICLR3 Position      */
S#define PDMA_PRICLR_FPRICLR3_Msk         (0x1ul << PDMA_PRICLR_FPRICLR3_Pos)               /*!< PDMA_T::PRICLR: FPRICLR3 Mask          */
S
S#define PDMA_PRICLR_FPRICLR4_Pos         (4)                                               /*!< PDMA_T::PRICLR: FPRICLR4 Position      */
S#define PDMA_PRICLR_FPRICLR4_Msk         (0x1ul << PDMA_PRICLR_FPRICLR4_Pos)               /*!< PDMA_T::PRICLR: FPRICLR4 Mask          */
S
S#define PDMA_INTEN_INTEN0_Pos            (0)                                               /*!< PDMA_T::INTEN: INTEN0 Position         */
S#define PDMA_INTEN_INTEN0_Msk            (0x1ul << PDMA_INTEN_INTEN0_Pos)                  /*!< PDMA_T::INTEN: INTEN0 Mask             */
S
S#define PDMA_INTEN_INTEN1_Pos            (1)                                               /*!< PDMA_T::INTEN: INTEN1 Position         */
S#define PDMA_INTEN_INTEN1_Msk            (0x1ul << PDMA_INTEN_INTEN1_Pos)                  /*!< PDMA_T::INTEN: INTEN1 Mask             */
S
S#define PDMA_INTEN_INTEN2_Pos            (2)                                               /*!< PDMA_T::INTEN: INTEN2 Position         */
S#define PDMA_INTEN_INTEN2_Msk            (0x1ul << PDMA_INTEN_INTEN2_Pos)                  /*!< PDMA_T::INTEN: INTEN2 Mask             */
S
S#define PDMA_INTEN_INTEN3_Pos            (3)                                               /*!< PDMA_T::INTEN: INTEN3 Position         */
S#define PDMA_INTEN_INTEN3_Msk            (0x1ul << PDMA_INTEN_INTEN3_Pos)                  /*!< PDMA_T::INTEN: INTEN3 Mask             */
S
S#define PDMA_INTEN_INTEN4_Pos            (4)                                               /*!< PDMA_T::INTEN: INTEN4 Position         */
S#define PDMA_INTEN_INTEN4_Msk            (0x1ul << PDMA_INTEN_INTEN4_Pos)                  /*!< PDMA_T::INTEN: INTEN4 Mask             */
S
S#define PDMA_INTSTS_ABTIF_Pos            (0)                                               /*!< PDMA_T::INTSTS: ABTIF Position         */
S#define PDMA_INTSTS_ABTIF_Msk            (0x1ul << PDMA_INTSTS_ABTIF_Pos)                  /*!< PDMA_T::INTSTS: ABTIF Mask             */
S
S#define PDMA_INTSTS_TDIF_Pos             (1)                                               /*!< PDMA_T::INTSTS: TDIF Position          */
S#define PDMA_INTSTS_TDIF_Msk             (0x1ul << PDMA_INTSTS_TDIF_Pos)                   /*!< PDMA_T::INTSTS: TDIF Mask              */
S
S#define PDMA_INTSTS_TEIF_Pos             (2)                                               /*!< PDMA_T::INTSTS: TEIF Position          */
S#define PDMA_INTSTS_TEIF_Msk             (0x1ul << PDMA_INTSTS_TEIF_Pos)                   /*!< PDMA_T::INTSTS: TEIF Mask              */
S
S#define PDMA_INTSTS_REQTOF0_Pos          (8)                                               /*!< PDMA_T::INTSTS: REQTOF0 Position       */
S#define PDMA_INTSTS_REQTOF0_Msk          (0x1ul << PDMA_INTSTS_REQTOF0_Pos)                /*!< PDMA_T::INTSTS: REQTOF0 Mask           */
S
S#define PDMA_INTSTS_REQTOF1_Pos          (9)                                               /*!< PDMA_T::INTSTS: REQTOF1 Position       */
S#define PDMA_INTSTS_REQTOF1_Msk          (0x1ul << PDMA_INTSTS_REQTOF1_Pos)                /*!< PDMA_T::INTSTS: REQTOF1 Mask           */
S
S#define PDMA_ABTSTS_ABTIF0_Pos           (0)                                               /*!< PDMA_T::ABTSTS: ABTIF0 Position        */
S#define PDMA_ABTSTS_ABTIF0_Msk           (0x1ul << PDMA_ABTSTS_ABTIF0_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF0 Mask            */
S
S#define PDMA_ABTSTS_ABTIF1_Pos           (1)                                               /*!< PDMA_T::ABTSTS: ABTIF1 Position        */
S#define PDMA_ABTSTS_ABTIF1_Msk           (0x1ul << PDMA_ABTSTS_ABTIF1_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF1 Mask            */
S
S#define PDMA_ABTSTS_ABTIF2_Pos           (2)                                               /*!< PDMA_T::ABTSTS: ABTIF2 Position        */
S#define PDMA_ABTSTS_ABTIF2_Msk           (0x1ul << PDMA_ABTSTS_ABTIF2_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF2 Mask            */
S
S#define PDMA_ABTSTS_ABTIF3_Pos           (3)                                               /*!< PDMA_T::ABTSTS: ABTIF3 Position        */
S#define PDMA_ABTSTS_ABTIF3_Msk           (0x1ul << PDMA_ABTSTS_ABTIF3_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF3 Mask            */
S
S#define PDMA_ABTSTS_ABTIF4_Pos           (4)                                               /*!< PDMA_T::ABTSTS: ABTIF4 Position        */
S#define PDMA_ABTSTS_ABTIF4_Msk           (0x1ul << PDMA_ABTSTS_ABTIF4_Pos)                 /*!< PDMA_T::ABTSTS: ABTIF4 Mask            */
S
S#define PDMA_TDSTS_TDIF0_Pos             (0)                                               /*!< PDMA_T::TDSTS: TDIF0 Position          */
S#define PDMA_TDSTS_TDIF0_Msk             (0x1ul << PDMA_TDSTS_TDIF0_Pos)                   /*!< PDMA_T::TDSTS: TDIF0 Mask              */
S
S#define PDMA_TDSTS_TDIF1_Pos             (1)                                               /*!< PDMA_T::TDSTS: TDIF1 Position          */
S#define PDMA_TDSTS_TDIF1_Msk             (0x1ul << PDMA_TDSTS_TDIF1_Pos)                   /*!< PDMA_T::TDSTS: TDIF1 Mask              */
S
S#define PDMA_TDSTS_TDIF2_Pos             (2)                                               /*!< PDMA_T::TDSTS: TDIF2 Position          */
S#define PDMA_TDSTS_TDIF2_Msk             (0x1ul << PDMA_TDSTS_TDIF2_Pos)                   /*!< PDMA_T::TDSTS: TDIF2 Mask              */
S
S#define PDMA_TDSTS_TDIF3_Pos             (3)                                               /*!< PDMA_T::TDSTS: TDIF3 Position          */
S#define PDMA_TDSTS_TDIF3_Msk             (0x1ul << PDMA_TDSTS_TDIF3_Pos)                   /*!< PDMA_T::TDSTS: TDIF3 Mask              */
S
S#define PDMA_TDSTS_TDIF4_Pos             (4)                                               /*!< PDMA_T::TDSTS: TDIF4 Position          */
S#define PDMA_TDSTS_TDIF4_Msk             (0x1ul << PDMA_TDSTS_TDIF4_Pos)                   /*!< PDMA_T::TDSTS: TDIF4 Mask              */
S
S#define PDMA_SCATSTS_TEMPTYF0_Pos        (0)                                               /*!< PDMA_T::SCATSTS: TEMPTYF0 Position     */
S#define PDMA_SCATSTS_TEMPTYF0_Msk        (0x1ul << PDMA_SCATSTS_TEMPTYF0_Pos)              /*!< PDMA_T::SCATSTS: TEMPTYF0 Mask         */
S
S#define PDMA_SCATSTS_TEMPTYF1_Pos        (1)                                               /*!< PDMA_T::SCATSTS: TEMPTYF1 Position     */
S#define PDMA_SCATSTS_TEMPTYF1_Msk        (0x1ul << PDMA_SCATSTS_TEMPTYF1_Pos)              /*!< PDMA_T::SCATSTS: TEMPTYF1 Mask         */
S
S#define PDMA_SCATSTS_TEMPTYF2_Pos        (2)                                               /*!< PDMA_T::SCATSTS: TEMPTYF2 Position     */
S#define PDMA_SCATSTS_TEMPTYF2_Msk        (0x1ul << PDMA_SCATSTS_TEMPTYF2_Pos)              /*!< PDMA_T::SCATSTS: TEMPTYF2 Mask         */
S
S#define PDMA_SCATSTS_TEMPTYF3_Pos        (3)                                               /*!< PDMA_T::SCATSTS: TEMPTYF3 Position     */
S#define PDMA_SCATSTS_TEMPTYF3_Msk        (0x1ul << PDMA_SCATSTS_TEMPTYF3_Pos)              /*!< PDMA_T::SCATSTS: TEMPTYF3 Mask         */
S
S#define PDMA_SCATSTS_TEMPTYF4_Pos        (4)                                               /*!< PDMA_T::SCATSTS: TEMPTYF4 Position     */
S#define PDMA_SCATSTS_TEMPTYF4_Msk        (0x1ul << PDMA_SCATSTS_TEMPTYF4_Pos)              /*!< PDMA_T::SCATSTS: TEMPTYF4 Mask         */
S
S#define PDMA_TACTSTS_TXACTF0_Pos         (0)                                               /*!< PDMA_T::TACTSTS: TXACTF0 Position      */
S#define PDMA_TACTSTS_TXACTF0_Msk         (0x1ul << PDMA_TACTSTS_TXACTF0_Pos)               /*!< PDMA_T::TACTSTS: TXACTF0 Mask          */
S
S#define PDMA_TACTSTS_TXACTF1_Pos         (1)                                               /*!< PDMA_T::TACTSTS: TXACTF1 Position      */
S#define PDMA_TACTSTS_TXACTF1_Msk         (0x1ul << PDMA_TACTSTS_TXACTF1_Pos)               /*!< PDMA_T::TACTSTS: TXACTF1 Mask          */
S
S#define PDMA_TACTSTS_TXACTF2_Pos         (2)                                               /*!< PDMA_T::TACTSTS: TXACTF2 Position      */
S#define PDMA_TACTSTS_TXACTF2_Msk         (0x1ul << PDMA_TACTSTS_TXACTF2_Pos)               /*!< PDMA_T::TACTSTS: TXACTF2 Mask          */
S
S#define PDMA_TACTSTS_TXACTF3_Pos         (3)                                               /*!< PDMA_T::TACTSTS: TXACTF3 Position      */
S#define PDMA_TACTSTS_TXACTF3_Msk         (0x1ul << PDMA_TACTSTS_TXACTF3_Pos)               /*!< PDMA_T::TACTSTS: TXACTF3 Mask          */
S
S#define PDMA_TACTSTS_TXACTF4_Pos         (4)                                               /*!< PDMA_T::TACTSTS: TXACTF4 Position      */
S#define PDMA_TACTSTS_TXACTF4_Msk         (0x1ul << PDMA_TACTSTS_TXACTF4_Pos)               /*!< PDMA_T::TACTSTS: TXACTF4 Mask          */
S
S#define PDMA_TOUTPSC_TOUTPSC0_Pos        (0)                                               /*!< PDMA_T::TOUTPSC: TOUTPSC0 Position     */
S#define PDMA_TOUTPSC_TOUTPSC0_Msk        (0x7ul << PDMA_TOUTPSC_TOUTPSC0_Pos)              /*!< PDMA_T::TOUTPSC: TOUTPSC0 Mask         */
S
S#define PDMA_TOUTPSC_TOUTPSC1_Pos        (4)                                               /*!< PDMA_T::TOUTPSC: TOUTPSC1 Position     */
S#define PDMA_TOUTPSC_TOUTPSC1_Msk        (0x7ul << PDMA_TOUTPSC_TOUTPSC1_Pos)              /*!< PDMA_T::TOUTPSC: TOUTPSC1 Mask         */
S
S#define PDMA_TOUTEN_TOUTEN0_Pos          (0)                                               /*!< PDMA_T::TOUTEN: TOUTEN0 Position       */
S#define PDMA_TOUTEN_TOUTEN0_Msk          (0x1ul << PDMA_TOUTEN_TOUTEN0_Pos)                /*!< PDMA_T::TOUTEN: TOUTEN0 Mask           */
S
S#define PDMA_TOUTEN_TOUTEN1_Pos          (1)                                               /*!< PDMA_T::TOUTEN: TOUTEN1 Position       */
S#define PDMA_TOUTEN_TOUTEN1_Msk          (0x1ul << PDMA_TOUTEN_TOUTEN1_Pos)                /*!< PDMA_T::TOUTEN: TOUTEN1 Mask           */
S
S#define PDMA_TOUTIEN_TOUTIEN0_Pos        (0)                                               /*!< PDMA_T::TOUTIEN: TOUTIEN0 Position     */
S#define PDMA_TOUTIEN_TOUTIEN0_Msk        (0x1ul << PDMA_TOUTIEN_TOUTIEN0_Pos)              /*!< PDMA_T::TOUTIEN: TOUTIEN0 Mask         */
S
S#define PDMA_TOUTIEN_TOUTIEN1_Pos        (1)                                               /*!< PDMA_T::TOUTIEN: TOUTIEN1 Position     */
S#define PDMA_TOUTIEN_TOUTIEN1_Msk        (0x1ul << PDMA_TOUTIEN_TOUTIEN1_Pos)              /*!< PDMA_T::TOUTIEN: TOUTIEN1 Mask         */
S
S#define PDMA_SCATBA_SCATBA_Pos           (16)                                              /*!< PDMA_T::SCATBA: SCATBA Position        */
S#define PDMA_SCATBA_SCATBA_Msk           (0xfffful << PDMA_SCATBA_SCATBA_Pos)              /*!< PDMA_T::SCATBA: SCATBA Mask            */
S
S#define PDMA_TOC0_1_TOC0_Pos             (0)                                               /*!< PDMA_T::TOC0_1: TOC0 Position          */
S#define PDMA_TOC0_1_TOC0_Msk             (0xfffful << PDMA_TOC0_1_TOC0_Pos)                /*!< PDMA_T::TOC0_1: TOC0 Mask              */
S
S#define PDMA_TOC0_1_TOC1_Pos             (16)                                              /*!< PDMA_T::TOC0_1: TOC1 Position          */
S#define PDMA_TOC0_1_TOC1_Msk             (0xfffful << PDMA_TOC0_1_TOC1_Pos)                /*!< PDMA_T::TOC0_1: TOC1 Mask              */
S
S#define PDMA_RESET_RESET0_Pos            (0)                                               /*!< PDMA_T::RESET: RESET0 Position         */
S#define PDMA_RESET_RESET0_Msk            (0x1ul << PDMA_RESET_RESET0_Pos)                  /*!< PDMA_T::RESET: RESET0 Mask             */
S
S#define PDMA_RESET_RESET1_Pos            (1)                                               /*!< PDMA_T::RESET: RESET1 Position         */
S#define PDMA_RESET_RESET1_Msk            (0x1ul << PDMA_RESET_RESET1_Pos)                  /*!< PDMA_T::RESET: RESET1 Mask             */
S
S#define PDMA_RESET_RESET2_Pos            (2)                                               /*!< PDMA_T::RESET: RESET2 Position         */
S#define PDMA_RESET_RESET2_Msk            (0x1ul << PDMA_RESET_RESET2_Pos)                  /*!< PDMA_T::RESET: RESET2 Mask             */
S
S#define PDMA_RESET_RESET3_Pos            (3)                                               /*!< PDMA_T::RESET: RESET3 Position         */
S#define PDMA_RESET_RESET3_Msk            (0x1ul << PDMA_RESET_RESET3_Pos)                  /*!< PDMA_T::RESET: RESET3 Mask             */
S
S#define PDMA_RESET_RESET4_Pos            (4)                                               /*!< PDMA_T::RESET: RESET4 Position         */
S#define PDMA_RESET_RESET4_Msk            (0x1ul << PDMA_RESET_RESET4_Pos)                  /*!< PDMA_T::RESET: RESET4 Mask             */
S
S#define PDMA_REQSEL0_3_REQSRC0_Pos       (0)                                               /*!< PDMA_T::REQSEL0_3: REQSRC0 Position    */
S#define PDMA_REQSEL0_3_REQSRC0_Msk       (0x3ful << PDMA_REQSEL0_3_REQSRC0_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC0 Mask        */
S
S#define PDMA_REQSEL0_3_REQSRC1_Pos       (8)                                               /*!< PDMA_T::REQSEL0_3: REQSRC1 Position    */
S#define PDMA_REQSEL0_3_REQSRC1_Msk       (0x3ful << PDMA_REQSEL0_3_REQSRC1_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC1 Mask        */
S
S#define PDMA_REQSEL0_3_REQSRC2_Pos       (16)                                              /*!< PDMA_T::REQSEL0_3: REQSRC2 Position    */
S#define PDMA_REQSEL0_3_REQSRC2_Msk       (0x3ful << PDMA_REQSEL0_3_REQSRC2_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC2 Mask        */
S
S#define PDMA_REQSEL0_3_REQSRC3_Pos       (24)                                              /*!< PDMA_T::REQSEL0_3: REQSRC3 Position    */
S#define PDMA_REQSEL0_3_REQSRC3_Msk       (0x3ful << PDMA_REQSEL0_3_REQSRC3_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC3 Mask        */
S
S#define PDMA_REQSEL4_REQSRC4_Pos         (0)                                               /*!< PDMA_T::REQSEL4: REQSRC4 Position      */
S#define PDMA_REQSEL4_REQSRC4_Msk         (0x3ful << PDMA_REQSEL4_REQSRC4_Pos)              /*!< PDMA_T::REQSEL4: REQSRC4 Mask          */
S
S/**@}*/ /* PDMA_CONST */
S/**@}*/ /* end of PDMA register group */
S
S
S/*---------------------- Pulse Width Modulation Controller -------------------------*/
S/**
S    @addtogroup PWM Pulse Width Modulation Controller(PWM)
S    Memory Mapped Structure for PWM Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var PWM_T::CTL0
S     * Offset: 0x00  PWM Control Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CTRLD0    |Center Re-load
S     * |        |          |Bit 0 controls the PWM channel 0.
S     * |        |          |In up-down counter type, PERIOD0 register will load to PBUF0 register at the end point of each period.
S     * |        |          |CMPDAT0 register will load to CMPBUF0 register at the center point of a period.
S     * |[1]     |CTRLD1    |Center Re-load
S     * |        |          |Bit 1 controls the PWM channel 1.
S     * |        |          |In up-down counter type, PERIOD1 register will load to PBUF1 register at the end point of each period.
S     * |        |          |CMPDAT1 register will load to CMPBUF1 register at the center point of a period.
S     * |[2]     |CTRLD2    |Center Re-load
S     * |        |          |Bit 2 controls the PWM channel 2.
S     * |        |          |In up-down counter type, PERIOD2 register will load to PBUF2 register at the end point of each period.
S     * |        |          |CMPDAT2 register will load to CMPBUF2 register at the center point of a period.
S     * |[3]     |CTRLD3    |Center Re-load
S     * |        |          |Bit 3 controls the PWM channel 3.
S     * |        |          |In up-down counter type, PERIOD3 register will load to PBUF3 register at the end point of each period.
S     * |        |          |CMPDAT3 register will load to CMPBUF3 register at the center point of a period.
S     * |[4]     |CTRLD4    |Center Re-load
S     * |        |          |Bit 4 controls the PWM channel 4.
S     * |        |          |In up-down counter type, PERIOD4 register will load to PBUF4 register at the end point of each period.
S     * |        |          |CMPDAT4 register will load to CMPBUF4 register at the center point of a period.
S     * |[5]     |CTRLD5    |Center Re-load
S     * |        |          |Bit 5 controls the PWM channel 5.
S     * |        |          |In up-down counter type, PERIOD5 register will load to PBUF5 register at the end point of each period.
S     * |        |          |CMPDAT5 register will load to CMPBUF5 register at the center point of a period.
S     * |[8]     |WINLDEN0  |Window Load Enable Bits
S     * |        |          |Bit 0 controls the PWM channel 0.
S     * |        |          |0 = PERIOD0 register will load to PBUF0 register at the end point of each period.
S     * |        |          |CMPDAT0 register will load to CMPBUF0 register at the end point or center point of each period by setting CTRLD0 bit.
S     * |        |          |1 = PERIOD0 register will load to PBUF0 and CMPDAT0 registers will load to CMPBUF0 register at the end point of each period when valid reload window is set.
S     * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register, and cleared by hardware after load success.
S     * |[9]     |WINLDEN1  |Window Load Enable Bits
S     * |        |          |Bit 1 controls the PWM channel 1.
S     * |        |          |0 = PERIOD1 register will load to PBUF1 register at the end point of each period.
S     * |        |          |CMPDAT1 register will load to CMPBUF1 register at the end point or center point of each period by setting CTRLD1 bit.
S     * |        |          |1 = PERIOD1 register will load to PBUF1 and CMPDAT1 registers will load to CMPBUF1 register at the end point of each period when valid reload window is set.
S     * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register, and cleared by hardware after load success.
S     * |[10]    |WINLDEN2  |Window Load Enable Bits
S     * |        |          |Bit 2 controls the PWM channel 2.
S     * |        |          |0 = PERIOD2 register will load to PBUF2 register at the end point of each period.
S     * |        |          |CMPDAT2 register will load to CMPBUF2 register at the end point or center point of each period by setting CTRLD2 bit.
S     * |        |          |1 = PERIOD2 register will load to PBUF2 and CMPDAT2 registers will load to CMPBUF2 register at the end point of each period when valid reload window is set.
S     * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register, and cleared by hardware after load success.
S     * |[11]    |WINLDEN3  |Window Load Enable Bits
S     * |        |          |Bit 3 controls the PWM channel 3.
S     * |        |          |0 = PERIOD3 register will load to PBUF3 register at the end point of each period.
S     * |        |          |CMPDAT3 register will load to CMPBUF3 register at the end point or center point of each period by setting CTRLD3 bit.
S     * |        |          |1 = PERIOD3 register will load to PBUF3 and CMPDAT3 registers will load to CMPBUF3 register at the end point of each period when valid reload window is set.
S     * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register, and cleared by hardware after load success.
S     * |[12]    |WINLDEN4  |Window Load Enable Bits
S     * |        |          |Bit 4 controls the PWM channel 4.
S     * |        |          |0 = PERIOD4 register will load to PBUF4 register at the end point of each period.
S     * |        |          |CMPDAT4 register will load to CMPBUF4 register at the end point or center point of each period by setting CTRLD4 bit.
S     * |        |          |1 = PERIOD4 register will load to PBUF4 and CMPDAT4 registers will load to CMPBUF4 register at the end point of each period when valid reload window is set.
S     * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register, and cleared by hardware after load success.
S     * |[13]    |WINLDEN5  |Window Load Enable Bits
S     * |        |          |Bit 5 controls the PWM channel 5.
S     * |        |          |0 = PERIOD5 register will load to PBUF5 register at the end point of each period.
S     * |        |          |CMPDAT5 register will load to CMPBUF5 register at the end point or center point of each period by setting CTRLD5 bit.
S     * |        |          |1 = PERIOD5 register will load to PBUF5 and CMPDAT5 registers will load to CMPBUF5 register at the end point of each period when valid reload window is set.
S     * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register, and cleared by hardware after load success.
S     * |[16]    |IMMLDEN0  |Immediately Load Enable Bits
S     * |        |          |Bit 0 controls the PWM channel 0.
S     * |        |          |0 = PERIOD0 register will load to PBUF0 register at the end point of each period.
S     * |        |          |CMPDAT0 register will load to CMPBUF0 register at the end point or center point of each period by setting CTRLD0 bit.
S     * |        |          |1 = PERIOD0/CMPDAT0 registers will load to PBUF0 and CMPBUF0 register immediately when software update PERIOD0/CMPDAT0 register.
S     * |        |          |Note: If IMMLDEN0 bit is enabled, WINLDEN0 bit and CTRLD0 bits will be invalid.
S     * |[17]    |IMMLDEN1  |Immediately Load Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PERIODn register will load to PBUFn register at the end point of each period.
S     * |        |          |CMPDAT n register will load to CMPBUFn register at the end point or center point of each period by setting CTRLDn bit.
S     * |        |          |1 = PERIODn/CMPDATn registers will load to PBUFn and CMPBUFn register immediately when software update PERIODn/CMPDATn register.
S     * |        |          |Note: If IMMLDENn bit is enabled, WINLDENn bit and CTRLDn bits will be invalid.
S     * |[18]    |IMMLDEN2  |Immediately Load Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PERIODn register will load to PBUFn register at the end point of each period.
S     * |        |          |CMPDAT n register will load to CMPBUFn register at the end point or center point of each period by setting CTRLDn bit.
S     * |        |          |1 = PERIODn/CMPDATn registers will load to PBUFn and CMPBUFn register immediately when software update PERIODn/CMPDATn register.
S     * |        |          |Note: If IMMLDENn bit is enabled, WINLDENn bit and CTRLDn bits will be invalid.
S     * |[19]    |IMMLDEN3  |Immediately Load Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PERIODn register will load to PBUFn register at the end point of each period.
S     * |        |          |CMPDAT n register will load to CMPBUFn register at the end point or center point of each period by setting CTRLDn bit.
S     * |        |          |1 = PERIODn/CMPDATn registers will load to PBUFn and CMPBUFn register immediately when software update PERIODn/CMPDATn register.
S     * |        |          |Note: If IMMLDENn bit is enabled, WINLDENn bit and CTRLDn bits will be invalid.
S     * |[20]    |IMMLDEN4  |Immediately Load Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PERIODn register will load to PBUFn register at the end point of each period.
S     * |        |          |CMPDAT n register will load to CMPBUFn register at the end point or center point of each period by setting CTRLDn bit.
S     * |        |          |1 = PERIODn/CMPDATn registers will load to PBUFn and CMPBUFn register immediately when software update PERIODn/CMPDATn register.
S     * |        |          |Note: If IMMLDENn bit is enabled, WINLDENn bit and CTRLDn bits will be invalid.
S     * |[21]    |IMMLDEN5  |Immediately Load Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PERIODn register will load to PBUFn register at the end point of each period.
S     * |        |          |CMPDAT n register will load to CMPBUFn register at the end point or center point of each period by setting CTRLDn bit.
S     * |        |          |1 = PERIODn/CMPDATn registers will load to PBUFn and CMPBUFn register immediately when software update PERIODn/CMPDATn register.
S     * |        |          |Note: If IMMLDENn bit is enabled, WINLDENn bit and CTRLDn bits will be invalid.
S     * |[24]    |GROUPEN   |Group Function Enable Bit
S     * |        |          |0 = The output waveform of each PWM channel are independent.
S     * |        |          |1 = Unify the PWMx_CH2 and PWMx_CH4 to output the same waveform as PWMx_CH0 and unify the PWMx_CH3 and PWMx_CH5 to output the same waveform as PWMx_CH1.
S     * |[30]    |DBGHALT   |ICE Debug Mode Counter Halt (Write Protect)
S     * |        |          |If counter halt is enabled, PWM all counters will keep current value until exit ICE debug mode.
S     * |        |          |0 = ICE debug mode counter halt disable.
S     * |        |          |1 = ICE debug mode counter halt enable.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[31]    |DBGTRIOFF |ICE Debug Mode Acknowledge Disable (Write Protect)
S     * |        |          |0 = ICE debug mode acknowledgement effects PWM output.
S     * |        |          |PWM pin will be forced as tri-state while ICE debug mode acknowledged.
S     * |        |          |1 = ICE debug mode acknowledgement disabled.
S     * |        |          |PWM pin will keep output no matter ICE debug mode acknowledged or not.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * @var PWM_T::CTL1
S     * Offset: 0x04  PWM Control Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |CNTTYPE0  |PWM Counter Behavior Type
S     * |        |          |Each bit n controls corresponding PWM channel n.
S     * |        |          |00 = Up counter type (supports in capture mode).
S     * |        |          |01 = Down count type (supports in capture mode).
S     * |        |          |10 = Up-down counter type.
S     * |        |          |11 = Reserved.
S     * |[3:2]   |CNTTYPE1  |PWM Counter Behavior Type
S     * |        |          |Each bit n controls corresponding PWM channel n.
S     * |        |          |00 = Up counter type (supports in capture mode).
S     * |        |          |01 = Down count type (supports in capture mode).
S     * |        |          |10 = Up-down counter type.
S     * |        |          |11 = Reserved.
S     * |[5:4]   |CNTTYPE2  |PWM Counter Behavior Type
S     * |        |          |Each bit n controls corresponding PWM channel n.
S     * |        |          |00 = Up counter type (supports in capture mode).
S     * |        |          |01 = Down count type (supports in capture mode).
S     * |        |          |10 = Up-down counter type.
S     * |        |          |11 = Reserved.
S     * |[7:6]   |CNTTYPE3  |PWM Counter Behavior Type
S     * |        |          |Each bit n controls corresponding PWM channel n.
S     * |        |          |00 = Up counter type (supports in capture mode).
S     * |        |          |01 = Down count type (supports in capture mode).
S     * |        |          |10 = Up-down counter type.
S     * |        |          |11 = Reserved.
S     * |[9:8]   |CNTTYPE4  |PWM Counter Behavior Type
S     * |        |          |Each bit n controls corresponding PWM channel n.
S     * |        |          |00 = Up counter type (supports in capture mode).
S     * |        |          |01 = Down count type (supports in capture mode).
S     * |        |          |10 = Up-down counter type.
S     * |        |          |11 = Reserved.
S     * |[11:10] |CNTTYPE5  |PWM Counter Behavior Type
S     * |        |          |Each bit n controls corresponding PWM channel n.
S     * |        |          |00 = Up counter type (supports in capture mode).
S     * |        |          |01 = Down count type (supports in capture mode).
S     * |        |          |10 = Up-down counter type.
S     * |        |          |11 = Reserved.
S     * |[16]    |CNTMODE0  |PWM Counter Mode
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Auto-reload mode.
S     * |        |          |1 = One-shot mode.
S     * |[17]    |CNTMODE1  |PWM Counter Mode
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Auto-reload mode.
S     * |        |          |1 = One-shot mode.
S     * |[18]    |CNTMODE2  |PWM Counter Mode
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Auto-reload mode.
S     * |        |          |1 = One-shot mode.
S     * |[19]    |CNTMODE3  |PWM Counter Mode
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Auto-reload mode.
S     * |        |          |1 = One-shot mode.
S     * |[20]    |CNTMODE4  |PWM Counter Mode
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Auto-reload mode.
S     * |        |          |1 = One-shot mode.
S     * |[21]    |CNTMODE5  |PWM Counter Mode
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Auto-reload mode.
S     * |        |          |1 = One-shot mode.
S     * |[24]    |OUTMODE0  |PWM Output Mode
S     * |        |          |Each bit n controls the output mode of corresponding PWM channel n.
S     * |        |          |0 = PWM independent mode.
S     * |        |          |1 = PWM complementary mode.
S     * |        |          |Note: When operating in group function, these bits must all set to the same mode.
S     * |[25]    |OUTMODE2  |PWM Output Mode
S     * |        |          |Each bit n controls the output mode of corresponding PWM channel n.
S     * |        |          |0 = PWM independent mode.
S     * |        |          |1 = PWM complementary mode.
S     * |        |          |Note: When operating in group function, these bits must all set to the same mode.
S     * |[26]    |OUTMODE4  |PWM Output Mode
S     * |        |          |Each bit n controls the output mode of corresponding PWM channel n.
S     * |        |          |0 = PWM independent mode.
S     * |        |          |1 = PWM complementary mode.
S     * |        |          |Note: When operating in group function, these bits must all set to the same mode.
S     * @var PWM_T::SYNC
S     * Offset: 0x08  PWM Synchronization Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PHSEN0    |SYNC Phase Enable Bits
S     * |        |          |Each bit n denotes controls corresponding PWM channel 0,2,4 and m denotes channel 1,3,5.
S     * |        |          |0 = PWM counter disable to load value of PHS(PWM_PHSn_m[15:0]) bits.
S     * |        |          |1 = PWM counter enable to load value of PHS(PWM_PHSn_m[15:0]) bits.
S     * |[1]     |PHSEN2    |SYNC Phase Enable Bits
S     * |        |          |Each bit n denotes controls corresponding PWM channel 0,2,4 and m denotes channel 1,3,5.
S     * |        |          |0 = PWM counter disable to load value of PHS(PWM_PHSn_m[15:0]) bits.
S     * |        |          |1 = PWM counter enable to load value of PHS(PWM_PHSn_m[15:0]) bits.
S     * |[2]     |PHSEN4    |SYNC Phase Enable Bits
S     * |        |          |Each bit n denotes controls corresponding PWM channel 0,2,4 and m denotes channel 1,3,5.
S     * |        |          |0 = PWM counter disable to load value of PHS(PWM_PHSn_m[15:0]) bits.
S     * |        |          |1 = PWM counter enable to load value of PHS(PWM_PHSn_m[15:0]) bits.
S     * |[9:8]   |SINSRC0   |PWM0_SYNC_IN Source Selection
S     * |        |          |Each bit n controls corresponding PWM channel n.
S     * |        |          |00 = Synchronize source from SYNC_IN or SWSYNC.
S     * |        |          |01 = Counter equal to 0.
S     * |        |          |10 = Counter equal to PWM_CMPDATm, m denotes 1, 3, 5.
S     * |        |          |11 = SYNC_OUT signal will not be generated.
S     * |[11:10] |SINSRC2   |PWM0_SYNC_IN Source Selection
S     * |        |          |Each bit n controls corresponding PWM channel n.
S     * |        |          |00 = Synchronize source from SYNC_IN or SWSYNC.
S     * |        |          |01 = Counter equal to 0.
S     * |        |          |10 = Counter equal to PWM_CMPDATm, m denotes 1, 3, 5.
S     * |        |          |11 = SYNC_OUT signal will not be generated.
S     * |[13:12] |SINSRC4   |PWM0_SYNC_IN Source Selection
S     * |        |          |Each bit n controls corresponding PWM channel n.
S     * |        |          |00 = Synchronize source from SYNC_IN or SWSYNC.
S     * |        |          |01 = Counter equal to 0.
S     * |        |          |10 = Counter equal to PWM_CMPDATm, m denotes 1, 3, 5.
S     * |        |          |11 = SYNC_OUT signal will not be generated.
S     * |[16]    |SNFLTEN   |PWM0_SYNC_IN Noise Filter Enable Bit
S     * |        |          |0 = Noise filter of input PWM0_SYNC_IN pin is Disabled.
S     * |        |          |1 = Noise filter of input PWM0_SYNC_IN pin is Enabled.
S     * |[19:17] |SFLTCSEL  |SYNC Edge Detector Filter Clock Selection
S     * |        |          |000 = Filter clock = HCLK.
S     * |        |          |001 = Filter clock = HCLK/2.
S     * |        |          |010 = Filter clock = HCLK/4.
S     * |        |          |011 = Filter clock = HCLK/8.
S     * |        |          |100 = Filter clock = HCLK/16.
S     * |        |          |101 = Filter clock = HCLK/32.
S     * |        |          |110 = Filter clock = HCLK/64.
S     * |        |          |111 = Filter clock = HCLK/128.
S     * |[22:20] |SFLTCNT   |SYNC Edge Detector Filter Count
S     * |        |          |The register bits control the counter number of edge detector.
S     * |[23]    |SINPINV   |SYNC Input Pin Inverse
S     * |        |          |0 = The state of PWM0_SYNC_IN pin is passed to the negative edge detector.
S     * |        |          |1 = The inversed state of PWM0_SYNC_IN pin is passed to the negative edge detector.
S     * |[24]    |PHSDIR0   |PWM Phase Direction Control
S     * |        |          |Each bit n controls corresponding PWM channel n.
S     * |        |          |0 = Control PWM counter count decrement after synchronizing.
S     * |        |          |1 = Control PWM counter count increment after synchronizing.
S     * |[25]    |PHSDIR2   |PWM Phase Direction Control
S     * |        |          |Each bit n controls corresponding PWM channel n.
S     * |        |          |0 = Control PWM counter count decrement after synchronizing.
S     * |        |          |1 = Control PWM counter count increment after synchronizing.
S     * |[26]    |PHSDIR4   |PWM Phase Direction Control
S     * |        |          |Each bit n controls corresponding PWM channel n.
S     * |        |          |0 = Control PWM counter count decrement after synchronizing.
S     * |        |          |1 = Control PWM counter count increment after synchronizing.
S     * @var PWM_T::SWSYNC
S     * Offset: 0x0C  PWM Software Control Synchronization Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SWSYNC0   |Software SYNC Function
S     * |        |          |Each bit n controls corresponding PWM channel n.
S     * |        |          |When SINSRCn (PWM_SYNC[13:8]) is selected to 0, SYNC_OUT source is come from SYNC_IN or this bit.
S     * |[1]     |SWSYNC2   |Software SYNC Function
S     * |        |          |Each bit n controls corresponding PWM channel n.
S     * |        |          |When SINSRCn (PWM_SYNC[13:8]) is selected to 0, SYNC_OUT source is come from SYNC_IN or this bit.
S     * |[2]     |SWSYNC4   |Software SYNC Function
S     * |        |          |Each bit n controls corresponding PWM channel n.
S     * |        |          |When SINSRCn (PWM_SYNC[13:8]) is selected to 0, SYNC_OUT source is come from SYNC_IN or this bit.
S     * @var PWM_T::CLKSRC
S     * Offset: 0x10  PWM Clock Source Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2:0]   |ECLKSRC0  |PWMx_CH0/1 External Clock Source Select
S     * |        |          |000 = PWMx_CLK, x denotes 0 or 1.
S     * |        |          |001 = TIMER0 time-out event.
S     * |        |          |010 = TIMER1 time-out event.
S     * |        |          |011 = TIMER2 time-out event.
S     * |        |          |100 = TIMER3 time-out event.
S     * |        |          |Others = Reserved.
S     * |[10:8]  |ECLKSRC2  |PWMx_CH2/3 External Clock Source Select
S     * |        |          |000 = PWMx_CLK, x denotes 0 or 1.
S     * |        |          |001 = TIMER0 time-out event.
S     * |        |          |010 = TIMER1 time-out event.
S     * |        |          |011 = TIMER2 time-out event.
S     * |        |          |100 = TIMER3 time-out event.
S     * |        |          |Others = Reserved.
S     * |[18:16] |ECLKSRC4  |PWMx_CH4/5 External Clock Source Select
S     * |        |          |000 = PWMx_CLK, x denotes 0 or 1.
S     * |        |          |001 = TIMER0 time-out event.
S     * |        |          |010 = TIMER1 time-out event.
S     * |        |          |011 = TIMER2 time-out event.
S     * |        |          |100 = TIMER3 time-out event.
S     * |        |          |Others = Reserved.
S     * @var PWM_T::CLKPSC0_1
S     * Offset: 0x14  PWM Clock Pre-scale Register 0/1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-scale
S     * |        |          |The clock of PWM counter is decided by clock prescaler.
S     * |        |          |Each PWM pair share one PWM counter clock prescaler.
S     * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1).
S     * @var PWM_T::CLKPSC2_3
S     * Offset: 0x18  PWM Clock Pre-scale Register 2/3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-scale
S     * |        |          |The clock of PWM counter is decided by clock prescaler.
S     * |        |          |Each PWM pair share one PWM counter clock prescaler.
S     * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1).
S     * @var PWM_T::CLKPSC4_5
S     * Offset: 0x1C  PWM Clock Pre-scale Register 4/5
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-scale
S     * |        |          |The clock of PWM counter is decided by clock prescaler.
S     * |        |          |Each PWM pair share one PWM counter clock prescaler.
S     * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1).
S     * @var PWM_T::CNTEN
S     * Offset: 0x20  PWM Counter Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CNTEN0    |PWM Counter Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM Counter and clock prescaler Stop Running.
S     * |        |          |1 = PWM Counter and clock prescaler Start Running.
S     * |[1]     |CNTEN1    |PWM Counter Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM Counter and clock prescaler Stop Running.
S     * |        |          |1 = PWM Counter and clock prescaler Start Running.
S     * |[2]     |CNTEN2    |PWM Counter Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM Counter and clock prescaler Stop Running.
S     * |        |          |1 = PWM Counter and clock prescaler Start Running.
S     * |[3]     |CNTEN3    |PWM Counter Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM Counter and clock prescaler Stop Running.
S     * |        |          |1 = PWM Counter and clock prescaler Start Running.
S     * |[4]     |CNTEN4    |PWM Counter Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM Counter and clock prescaler Stop Running.
S     * |        |          |1 = PWM Counter and clock prescaler Start Running.
S     * |[5]     |CNTEN5    |PWM Counter Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM Counter and clock prescaler Stop Running.
S     * |        |          |1 = PWM Counter and clock prescaler Start Running.
S     * @var PWM_T::CNTCLR
S     * Offset: 0x24  PWM Clear Counter Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CNTCLR0   |Clear PWM Counter Control Bit
S     * |        |          |It is automatically cleared by hardware. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear 16-bit PWM counter to 0x0000(CNT(PWM_CNTn[15:0])).
S     * |[1]     |CNTCLR1   |Clear PWM Counter Control Bit
S     * |        |          |It is automatically cleared by hardware. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear 16-bit PWM counter to 0x0000(CNT(PWM_CNTn[15:0])).
S     * |[2]     |CNTCLR2   |Clear PWM Counter Control Bit
S     * |        |          |It is automatically cleared by hardware. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear 16-bit PWM counter to 0x0000(CNT(PWM_CNTn[15:0])).
S     * |[3]     |CNTCLR3   |Clear PWM Counter Control Bit
S     * |        |          |It is automatically cleared by hardware. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear 16-bit PWM counter to 0x0000(CNT(PWM_CNTn[15:0])).
S     * |[4]     |CNTCLR4   |Clear PWM Counter Control Bit
S     * |        |          |It is automatically cleared by hardware. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear 16-bit PWM counter to 0x0000(CNT(PWM_CNTn[15:0])).
S     * |[5]     |CNTCLR5   |Clear PWM Counter Control Bit
S     * |        |          |It is automatically cleared by hardware. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear 16-bit PWM counter to 0x0000(CNT(PWM_CNTn[15:0])).
S     * @var PWM_T::LOAD
S     * Offset: 0x28  PWM Load Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |LOAD0     |Re-load PWM Comparator Register (CMPDAT) Control Bit
S     * |        |          |This bit is software write, and hardware clear when current PWM period end
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Write Operation:
S     * |        |          |0 = No effect.
S     * |        |          |1 = Set load window of window loading mode.
S     * |        |          |Read Operation:
S     * |        |          |0 = No load window is set.
S     * |        |          |1 = Load window is set.
S     * |        |          |Note: This bit only use in window loading mode, WINLDENn(PWM_CTL0[13:8]) = 1.
S     * |[1]     |LOAD1     |Re-load PWM Comparator Register (CMPDAT) Control Bit
S     * |        |          |This bit is software write, and hardware clear when current PWM period end
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Write Operation:
S     * |        |          |0 = No effect.
S     * |        |          |1 = Set load window of window loading mode.
S     * |        |          |Read Operation:
S     * |        |          |0 = No load window is set.
S     * |        |          |1 = Load window is set.
S     * |        |          |Note: This bit only use in window loading mode, WINLDENn(PWM_CTL0[13:8]) = 1.
S     * |[2]     |LOAD2     |Re-load PWM Comparator Register (CMPDAT) Control Bit
S     * |        |          |This bit is software write, and hardware clear when current PWM period end
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Write Operation:
S     * |        |          |0 = No effect.
S     * |        |          |1 = Set load window of window loading mode.
S     * |        |          |Read Operation:
S     * |        |          |0 = No load window is set.
S     * |        |          |1 = Load window is set.
S     * |        |          |Note: This bit only use in window loading mode, WINLDENn(PWM_CTL0[13:8]) = 1.
S     * |[3]     |LOAD3     |Re-load PWM Comparator Register (CMPDAT) Control Bit
S     * |        |          |This bit is software write, and hardware clear when current PWM period end
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Write Operation:
S     * |        |          |0 = No effect.
S     * |        |          |1 = Set load window of window loading mode.
S     * |        |          |Read Operation:
S     * |        |          |0 = No load window is set.
S     * |        |          |1 = Load window is set.
S     * |        |          |Note: This bit only use in window loading mode, WINLDENn(PWM_CTL0[13:8]) = 1.
S     * |[4]     |LOAD4     |Re-load PWM Comparator Register (CMPDAT) Control Bit
S     * |        |          |This bit is software write, and hardware clear when current PWM period end
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Write Operation:
S     * |        |          |0 = No effect.
S     * |        |          |1 = Set load window of window loading mode.
S     * |        |          |Read Operation:
S     * |        |          |0 = No load window is set.
S     * |        |          |1 = Load window is set.
S     * |        |          |Note: This bit only use in window loading mode, WINLDENn(PWM_CTL0[13:8]) = 1.
S     * |[5]     |LOAD5     |Re-load PWM Comparator Register (CMPDAT) Control Bit
S     * |        |          |This bit is software write, and hardware clear when current PWM period end
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Write Operation:
S     * |        |          |0 = No effect.
S     * |        |          |1 = Set load window of window loading mode.
S     * |        |          |Read Operation:
S     * |        |          |0 = No load window is set.
S     * |        |          |1 = Load window is set.
S     * |        |          |Note: This bit only use in window loading mode, WINLDENn(PWM_CTL0[13:8]) = 1.
S     * @var PWM_T::PERIOD
S     * Offset: 0x30/0x34/0x38/0x3C/0x40/0x44  PWM Period Register 0~5
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |PERIOD    |PWM Period Register
S     * |        |          |Up-Count mode:
S     * |        |          |In this mode, PWM counter counts from 0 to PERIOD, and restarts from 0.
S     * |        |          |PWM period time = (PERIOD+1) * (CLKPSC+1) * PWMx_CLK.
S     * |        |          |Down-Count mode:
S     * |        |          |In this mode, PWM counter counts from PERIOD to 0, and restarts from PERIOD.
S     * |        |          |PWM period time = (PERIOD+1) * (CLKPSC+1) * PWMx_CLK.
S     * |        |          |Up-Down-Count mode:
S     * |        |          |In this mode, PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
S     * |        |          |PWM period time = (2 * PERIOD) * (CLKPSC+1) * PWMx_CLK.
S     * @var PWM_T::CMPDAT
S     * Offset: 0x50/0x54/0x58/0x5C/0x60/0x64  PWM Comparator Register 0~5
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CMP       |PWM Comparator Register
S     * |        |          |CMP bits use to compare with CNTR(PWM_CNTn[15:0]) bits to generate PWM waveform, interrupt and trigger ADC.
S     * |        |          |In independent mode, CMPDAT0~5 registers denote as 6 independent PWMx_CH0~5 compared point.
S     * |        |          |In complementary mode, CMPDAT0, 2, 4 registers denote as first compared point, and CMPDAT1, 3, 5 register denote as second compared point for the corresponding 3 complementary pairs PWMx_CH0 and PWMx_CH1, PWMx_CH2 and PWMx_CH3, PWMx_CH4 and PWMx_CH5.
S     * @var PWM_T::DTCTL0_1
S     * Offset: 0x70  PWM Dead-Time Control Register 0/1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |DTCNT     |Dead-time Counter (Write Protect)
S     * |        |          |The dead-time can be calculated from the following formula:
S     * |        |          |Dead-time = (DTCNT+1) * PWMx_CLK period, if DTCKSEL bit is 0.
S     * |        |          |Dead-time = (DTCNT+1) * (CLKPSC (PWM_CLKPSCn [11:0])+1)*PWMx_CLK period, if DTCKSEL bit is 1.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * |[16]    |DTEN      |Enable Dead-time Insertion for PWM Pair (PWMx_CH0, PWMx_CH1) (PWMx_CH2, PWMx_CH3) (PWMx_CH4, PWMx_CH5) (Write Protect)
S     * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled.
S     * |        |          |If dead- time insertion is inactive, the outputs of pin pair are complementary without any delay.
S     * |        |          |0 = Dead-time insertion Disabled on the pin pair.
S     * |        |          |1 = Dead-time insertion Enabled on the pin pair.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * |[24]    |DTCKSEL   |Dead-time Clock Select (Write Protect)
S     * |        |          |0 = Dead-time clock source from PWMx_CLK without counter clock prescale.
S     * |        |          |1 = Dead-time clock source from prescaler output with counter clock prescale.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * @var PWM_T::DTCTL2_3
S     * Offset: 0x74  PWM Dead-Time Control Register 2/3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |DTCNT     |Dead-time Counter (Write Protect)
S     * |        |          |The dead-time can be calculated from the following formula:
S     * |        |          |Dead-time = (DTCNT+1) * PWMx_CLK period, if DTCKSEL bit is 0.
S     * |        |          |Dead-time = (DTCNT+1) * (CLKPSC (PWM_CLKPSCn [11:0])+1)*PWMx_CLK period, if DTCKSEL bit is 1.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * |[16]    |DTEN      |Enable Dead-time Insertion for PWM Pair (PWMx_CH0, PWMx_CH1) (PWMx_CH2, PWMx_CH3) (PWMx_CH4, PWMx_CH5) (Write Protect)
S     * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled.
S     * |        |          |If dead- time insertion is inactive, the outputs of pin pair are complementary without any delay.
S     * |        |          |0 = Dead-time insertion Disabled on the pin pair.
S     * |        |          |1 = Dead-time insertion Enabled on the pin pair.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * |[24]    |DTCKSEL   |Dead-time Clock Select (Write Protect)
S     * |        |          |0 = Dead-time clock source from PWMx_CLK without counter clock prescale.
S     * |        |          |1 = Dead-time clock source from prescaler output with counter clock prescale.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * @var PWM_T::DTCTL4_5
S     * Offset: 0x78  PWM Dead-Time Control Register 4/5
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |DTCNT     |Dead-time Counter (Write Protect)
S     * |        |          |The dead-time can be calculated from the following formula:
S     * |        |          |Dead-time = (DTCNT+1) * PWMx_CLK period, if DTCKSEL bit is 0.
S     * |        |          |Dead-time = (DTCNT+1) * (CLKPSC (PWM_CLKPSCn [11:0])+1)*PWMx_CLK period, if DTCKSEL bit is 1.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * |[16]    |DTEN      |Enable Dead-time Insertion for PWM Pair (PWMx_CH0, PWMx_CH1) (PWMx_CH2, PWMx_CH3) (PWMx_CH4, PWMx_CH5) (Write Protect)
S     * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled.
S     * |        |          |If dead- time insertion is inactive, the outputs of pin pair are complementary without any delay.
S     * |        |          |0 = Dead-time insertion Disabled on the pin pair.
S     * |        |          |1 = Dead-time insertion Enabled on the pin pair.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * |[24]    |DTCKSEL   |Dead-time Clock Select (Write Protect)
S     * |        |          |0 = Dead-time clock source from PWMx_CLK without counter clock prescale.
S     * |        |          |1 = Dead-time clock source from prescaler output with counter clock prescale.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * @var PWM_T::PHS0_1
S     * Offset: 0x80  PWM Counter Phase Register 0/1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |PHS       |PWM Synchronous Start Phase Bits
S     * |        |          |PHS bits determines the PWM synchronous start phase value. These bits only use in synchronous function.
S     * @var PWM_T::PHS2_3
S     * Offset: 0x84  PWM Counter Phase Register 2/3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |PHS       |PWM Synchronous Start Phase Bits
S     * |        |          |PHS bits determines the PWM synchronous start phase value. These bits only use in synchronous function.
S     * @var PWM_T::PHS4_5
S     * Offset: 0x88  PWM Counter Phase Register 4/5
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |PHS       |PWM Synchronous Start Phase Bits
S     * |        |          |PHS bits determines the PWM synchronous start phase value. These bits only use in synchronous function.
S     * @var PWM_T::CNT
S     * Offset: 0x90/0x94/0x98/0x9C/0xA0/0xA4  PWM Counter Register 0~5
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CNT       |PWM Counter Data Bits (Read Only)
S     * |        |          |User can monitor CNT to know the current value in 16-bit period counter.
S     * |[16]    |DIRF      |PWM Direction Indicator Flag (Read Only)
S     * |        |          |0 = Counter is Down count.
S     * |        |          |1 = Counter is UP count.
S     * @var PWM_T::WGCTL0
S     * Offset: 0xB0  PWM Generation Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |ZPCTL0    |PWM Zero Point Control
S     * |        |          |PWM can control output level on zero point event. Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM zero point output Low.
S     * |        |          |10 = PWM zero point output High.
S     * |        |          |11 = PWM zero point output Toggle.
S     * |[3:2]   |ZPCTL1    |PWM Zero Point Control
S     * |        |          |PWM can control output level on zero point event. Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM zero point output Low.
S     * |        |          |10 = PWM zero point output High.
S     * |        |          |11 = PWM zero point output Toggle.
S     * |[5:4]   |ZPCTL2    |PWM Zero Point Control
S     * |        |          |PWM can control output level on zero point event. Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM zero point output Low.
S     * |        |          |10 = PWM zero point output High.
S     * |        |          |11 = PWM zero point output Toggle.
S     * |[7:6]   |ZPCTL3    |PWM Zero Point Control
S     * |        |          |PWM can control output level on zero point event. Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM zero point output Low.
S     * |        |          |10 = PWM zero point output High.
S     * |        |          |11 = PWM zero point output Toggle.
S     * |[9:8]   |ZPCTL4    |PWM Zero Point Control
S     * |        |          |PWM can control output level on zero point event. Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM zero point output Low.
S     * |        |          |10 = PWM zero point output High.
S     * |        |          |11 = PWM zero point output Toggle.
S     * |[11:10] |ZPCTL5    |PWM Zero Point Control
S     * |        |          |PWM can control output level on zero point event. Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM zero point output Low.
S     * |        |          |10 = PWM zero point output High.
S     * |        |          |11 = PWM zero point output Toggle.
S     * |[17:16] |PRDPCTL0  |PWM Period (Center) Point Control
S     * |        |          |PWM can control output level on period(center) point event
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM period (center) point output Low.
S     * |        |          |10 = PWM period (center) point output High.
S     * |        |          |11 = PWM period (center) point output Toggle.
S     * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
S     * |[19:18] |PRDPCTL1  |PWM Period (Center) Point Control
S     * |        |          |PWM can control output level on period(center) point event
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM period (center) point output Low.
S     * |        |          |10 = PWM period (center) point output High.
S     * |        |          |11 = PWM period (center) point output Toggle.
S     * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
S     * |[21:20] |PRDPCTL2  |PWM Period (Center) Point Control
S     * |        |          |PWM can control output level on period(center) point event
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM period (center) point output Low.
S     * |        |          |10 = PWM period (center) point output High.
S     * |        |          |11 = PWM period (center) point output Toggle.
S     * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
S     * |[23:22] |PRDPCTL3  |PWM Period (Center) Point Control
S     * |        |          |PWM can control output level on period(center) point event
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM period (center) point output Low.
S     * |        |          |10 = PWM period (center) point output High.
S     * |        |          |11 = PWM period (center) point output Toggle.
S     * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
S     * |[25:24] |PRDPCTL4  |PWM Period (Center) Point Control
S     * |        |          |PWM can control output level on period(center) point event
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM period (center) point output Low.
S     * |        |          |10 = PWM period (center) point output High.
S     * |        |          |11 = PWM period (center) point output Toggle.
S     * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
S     * |[27:26] |PRDPCTL5  |PWM Period (Center) Point Control
S     * |        |          |PWM can control output level on period(center) point event
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM period (center) point output Low.
S     * |        |          |10 = PWM period (center) point output High.
S     * |        |          |11 = PWM period (center) point output Toggle.
S     * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
S     * @var PWM_T::WGCTL1
S     * Offset: 0xB4  PWM Generation Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |CMPUCTL0  |PWM Compare Up Point Control
S     * |        |          |PWM can control output level on compare up point event
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM compare up point output Low.
S     * |        |          |10 = PWM compare up point output High.
S     * |        |          |11 = PWM compare up point output Toggle.
S     * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
S     * |[3:2]   |CMPUCTL1  |PWM Compare Up Point Control
S     * |        |          |PWM can control output level on compare up point event
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM compare up point output Low.
S     * |        |          |10 = PWM compare up point output High.
S     * |        |          |11 = PWM compare up point output Toggle.
S     * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
S     * |[5:4]   |CMPUCTL2  |PWM Compare Up Point Control
S     * |        |          |PWM can control output level on compare up point event
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM compare up point output Low.
S     * |        |          |10 = PWM compare up point output High.
S     * |        |          |11 = PWM compare up point output Toggle.
S     * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
S     * |[7:6]   |CMPUCTL3  |PWM Compare Up Point Control
S     * |        |          |PWM can control output level on compare up point event
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM compare up point output Low.
S     * |        |          |10 = PWM compare up point output High.
S     * |        |          |11 = PWM compare up point output Toggle.
S     * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
S     * |[9:8]   |CMPUCTL4  |PWM Compare Up Point Control
S     * |        |          |PWM can control output level on compare up point event
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM compare up point output Low.
S     * |        |          |10 = PWM compare up point output High.
S     * |        |          |11 = PWM compare up point output Toggle.
S     * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
S     * |[11:10] |CMPUCTL5  |PWM Compare Up Point Control
S     * |        |          |PWM can control output level on compare up point event
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM compare up point output Low.
S     * |        |          |10 = PWM compare up point output High.
S     * |        |          |11 = PWM compare up point output Toggle.
S     * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
S     * |[17:16] |CMPDCTL0  |PWM Compare Down Point Control
S     * |        |          |PWM can control output level on compare down point event
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM compare down point output Low.
S     * |        |          |10 = PWM compare down point output High.
S     * |        |          |11 = PWM compare down point output Toggle.
S     * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
S     * |[19:18] |CMPDCTL1  |PWM Compare Down Point Control
S     * |        |          |PWM can control output level on compare down point event
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM compare down point output Low.
S     * |        |          |10 = PWM compare down point output High.
S     * |        |          |11 = PWM compare down point output Toggle.
S     * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
S     * |[21:20] |CMPDCTL2  |PWM Compare Down Point Control
S     * |        |          |PWM can control output level on compare down point event
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM compare down point output Low.
S     * |        |          |10 = PWM compare down point output High.
S     * |        |          |11 = PWM compare down point output Toggle.
S     * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
S     * |[23:22] |CMPDCTL3  |PWM Compare Down Point Control
S     * |        |          |PWM can control output level on compare down point event
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM compare down point output Low.
S     * |        |          |10 = PWM compare down point output High.
S     * |        |          |11 = PWM compare down point output Toggle.
S     * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
S     * |[25:24] |CMPDCTL4  |PWM Compare Down Point Control
S     * |        |          |PWM can control output level on compare down point event
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM compare down point output Low.
S     * |        |          |10 = PWM compare down point output High.
S     * |        |          |11 = PWM compare down point output Toggle.
S     * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
S     * |[27:26] |CMPDCTL5  |PWM Compare Down Point Control
S     * |        |          |PWM can control output level on compare down point event
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM compare down point output Low.
S     * |        |          |10 = PWM compare down point output High.
S     * |        |          |11 = PWM compare down point output Toggle.
S     * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
S     * @var PWM_T::MSKEN
S     * Offset: 0xB8  PWM Mask Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |MSKEN0    |PWM Mask Enable Bits
S     * |        |          |The PWM output signal will be masked when this bit is enabled.
S     * |        |          |The corresponding PWM channel n will output MSKDATn (PWM_MSK[5:0]) data.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM output signal is non-masked.
S     * |        |          |1 = PWM output signal is masked and output MSKDATn data.
S     * |[1]     |MSKEN1    |PWM Mask Enable Bits
S     * |        |          |The PWM output signal will be masked when this bit is enabled.
S     * |        |          |The corresponding PWM channel n will output MSKDATn (PWM_MSK[5:0]) data.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM output signal is non-masked.
S     * |        |          |1 = PWM output signal is masked and output MSKDATn data.
S     * |[2]     |MSKEN2    |PWM Mask Enable Bits
S     * |        |          |The PWM output signal will be masked when this bit is enabled.
S     * |        |          |The corresponding PWM channel n will output MSKDATn (PWM_MSK[5:0]) data.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM output signal is non-masked.
S     * |        |          |1 = PWM output signal is masked and output MSKDATn data.
S     * |[3]     |MSKEN3    |PWM Mask Enable Bits
S     * |        |          |The PWM output signal will be masked when this bit is enabled.
S     * |        |          |The corresponding PWM channel n will output MSKDATn (PWM_MSK[5:0]) data.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM output signal is non-masked.
S     * |        |          |1 = PWM output signal is masked and output MSKDATn data.
S     * |[4]     |MSKEN4    |PWM Mask Enable Bits
S     * |        |          |The PWM output signal will be masked when this bit is enabled.
S     * |        |          |The corresponding PWM channel n will output MSKDATn (PWM_MSK[5:0]) data.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM output signal is non-masked.
S     * |        |          |1 = PWM output signal is masked and output MSKDATn data.
S     * |[5]     |MSKEN5    |PWM Mask Enable Bits
S     * |        |          |The PWM output signal will be masked when this bit is enabled.
S     * |        |          |The corresponding PWM channel n will output MSKDATn (PWM_MSK[5:0]) data.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM output signal is non-masked.
S     * |        |          |1 = PWM output signal is masked and output MSKDATn data.
S     * @var PWM_T::MSK
S     * Offset: 0xBC  PWM Mask Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |MSKDAT0   |PWM Mask Data Bit
S     * |        |          |This data bit control the state of PWMx_CHn output pin, if corresponding mask function is enabled.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Output logic low to PWMx_CHn.
S     * |        |          |1 = Output logic high to PWMx_CHn.
S     * |[1]     |MSKDAT1   |PWM Mask Data Bit
S     * |        |          |This data bit control the state of PWMx_CHn output pin, if corresponding mask function is enabled.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Output logic low to PWMx_CHn.
S     * |        |          |1 = Output logic high to PWMx_CHn.
S     * |[2]     |MSKDAT2   |PWM Mask Data Bit
S     * |        |          |This data bit control the state of PWMx_CHn output pin, if corresponding mask function is enabled.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Output logic low to PWMx_CHn.
S     * |        |          |1 = Output logic high to PWMx_CHn.
S     * |[3]     |MSKDAT3   |PWM Mask Data Bit
S     * |        |          |This data bit control the state of PWMx_CHn output pin, if corresponding mask function is enabled.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Output logic low to PWMx_CHn.
S     * |        |          |1 = Output logic high to PWMx_CHn.
S     * |[4]     |MSKDAT4   |PWM Mask Data Bit
S     * |        |          |This data bit control the state of PWMx_CHn output pin, if corresponding mask function is enabled.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Output logic low to PWMx_CHn.
S     * |        |          |1 = Output logic high to PWMx_CHn.
S     * |[5]     |MSKDAT5   |PWM Mask Data Bit
S     * |        |          |This data bit control the state of PWMx_CHn output pin, if corresponding mask function is enabled.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Output logic low to PWMx_CHn.
S     * |        |          |1 = Output logic high to PWMx_CHn.
S     * @var PWM_T::BNF
S     * Offset: 0xC0  PWM Brake Noise Filter Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |BRK0NFEN  |PWM Brake 0 Noise Filter Enable Bit
S     * |        |          |0 = Noise filter of PWM Brake 0 Disabled.
S     * |        |          |1 = Noise filter of PWM Brake 0 Enabled.
S     * |[3:1]   |BRK0NFSEL |Brake 0 Edge Detector Filter Clock Selection
S     * |        |          |000 = Filter clock = HCLK.
S     * |        |          |001 = Filter clock = HCLK/2.
S     * |        |          |010 = Filter clock = HCLK/4.
S     * |        |          |011 = Filter clock = HCLK/8.
S     * |        |          |100 = Filter clock = HCLK/16.
S     * |        |          |101 = Filter clock = HCLK/32.
S     * |        |          |110 = Filter clock = HCLK/64.
S     * |        |          |111 = Filter clock = HCLK/128.
S     * |[6:4]   |BRK0FCNT  |Brake 0 Edge Detector Filter Count
S     * |        |          |The register bits control the Brake0 filter counter to count from 0 to BRK0FCNT.
S     * |[7]     |BRK0PINV  |Brake 0 Pin Inverse
S     * |        |          |0 = Brake pin event will be detected if PWM0_BRAKEx pin status transfer from low to high in edge-detect, or pin status is high in level-detect.
S     * |        |          |1 = Brake pin event will be detected if PWM0_BRAKEx pin status transfer from high to low in edge-detect, or pin status is low in level-detect.
S     * |[8]     |BRK1NFEN  |PWM Brake 1 Noise Filter Enable Bit
S     * |        |          |0 = Noise filter of PWM Brake 1 Disabled.
S     * |        |          |1 = Noise filter of PWM Brake 1 Enabled.
S     * |[11:9]  |BRK1NFSEL |Brake 1 Edge Detector Filter Clock Selection
S     * |        |          |000 = Filter clock = HCLK.
S     * |        |          |001 = Filter clock = HCLK/2.
S     * |        |          |010 = Filter clock = HCLK/4.
S     * |        |          |011 = Filter clock = HCLK/8.
S     * |        |          |100 = Filter clock = HCLK/16.
S     * |        |          |101 = Filter clock = HCLK/32.
S     * |        |          |110 = Filter clock = HCLK/64.
S     * |        |          |111 = Filter clock = HCLK/128.
S     * |[14:12] |BRK1FCNT  |Brake 1 Edge Detector Filter Count
S     * |        |          |The register bits control the Brake1 filter counter to count from 0 to BRK1FCNT.
S     * |[15]    |BRK1PINV  |Brake 1 Pin Inverse
S     * |        |          |0 = Brake pin event will be detected if PWM1_BRAKEx pin status transfer from low to high in edge-detect, or pin status is high in level-detect.
S     * |        |          |1 = Brake pin event will be detected if PWM1_BRAKEx pin status transfer from high to low in edge-detect, or pin status is low in level-detect.
S     * |[16]    |BK0SRC    |Brake 0 Pin Source Select
S     * |        |          |For PWM0 setting:
S     * |        |          |0 = Brake 0 pin source come from PWM0_BRAKE0.
S     * |        |          |1 = Brake 0 pin source come from PWM1_BRAKE0.
S     * |        |          |For PWM1 setting:
S     * |        |          |0 = Brake 0 pin source come from PWM1_BRAKE0.
S     * |        |          |1 = Brake 0 pin source come from PWM0_BRAKE0.
S     * |[24]    |BK1SRC    |Brake 1 Pin Source Select
S     * |        |          |For PWM0 setting:
S     * |        |          |0 = Brake 1 pin source come from PWM0_BRAKE1.
S     * |        |          |1 = Brake 1 pin source come from PWM1_BRAKE1.
S     * |        |          |For PWM1 setting:
S     * |        |          |0 = Brake 1 pin source come from PWM1_BRAKE1.
S     * |        |          |1 = Brake 1 pin source come from PWM0_BRAKE1.
S     * @var PWM_T::FAILBRK
S     * Offset: 0xC4  PWM System Fail Brake Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CSSBRKEN  |Clock Security System Detection Trigger PWM Brake Function Enable Bit
S     * |        |          |0 = Brake Function triggered by clock fail detection Disabled.
S     * |        |          |1 = Brake Function triggered by clock fail detection Enabled.
S     * |[1]     |BODBRKEN  |Brown-out Detection Trigger PWM Brake Function Enable Bit
S     * |        |          |0 = Brake Function triggered by BOD event Disabled.
S     * |        |          |1 = Brake Function triggered by BOD event Enabled.
S     * |[3]     |CORBRKEN  |Core Lockup Detection Trigger PWM Brake Function Enable Bit
S     * |        |          |0 = Brake Function triggered by Core lockup event Disabled.
S     * |        |          |1 = Brake Function triggered by Core lockup event Enabled.
S     * @var PWM_T::BRKCTL0_1
S     * Offset: 0xC8  PWM Brake Edge Detect Control Register 0/1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CPO0EBEN  |Enable ACMP0_O Digital Output As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = ACMP0_O as edge-detect brake source Disabled.
S     * |        |          |1 = ACMP0_O as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[1]     |CPO1EBEN  |Enable ACMP1_O Digital Output As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = ACMP1_O as edge-detect brake source Disabled.
S     * |        |          |1 = ACMP1_O as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[4]     |BRKP0EEN  |Enable PWMx_BRAKE0 Pin As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = PWMx_BRAKE0 pin as edge-detect brake source Disabled.
S     * |        |          |1 = PWMx_BRAKE0 pin as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[5]     |BRKP1EEN  |Enable PWMx_BRAKE1 Pin As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = PWMx_BRAKE1 pin as edge-detect brake source Disabled.
S     * |        |          |1 = PWMx_BRAKE1 pin as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[7]     |SYSEBEN   |Enable System Fail As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
S     * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[8]     |CPO0LBEN  |Enable ACMP0_O Digital Output As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = ACMP0_O as level-detect brake source Disabled.
S     * |        |          |1 = ACMP0_O as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[9]     |CPO1LBEN  |Enable ACMP1_O Digital Output As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = ACMP1_O as level-detect brake source Disabled.
S     * |        |          |1 = ACMP1_O as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = PWMx_BRAKE0 pin as level-detect brake source Disabled.
S     * |        |          |1 = PWMx_BRAKE0 pin as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = PWMx_BRAKE1 pin as level-detect brake source Disabled.
S     * |        |          |1 = PWMx_BRAKE1 pin as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[15]    |SYSLBEN   |Enable System Fail As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = System Fail condition as level-detect brake source Disabled.
S     * |        |          |1 = System Fail condition as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[17:16] |BRKAEVEN  |PWM Brake Action Select for Even Channel (Write Protect)
S     * |        |          |00 = PWMx brake event will not affect even channels output.
S     * |        |          |01 = PWM even channel output tri-state when PWMx brake event happened.
S     * |        |          |10 = PWM even channel output low level when PWMx brake event happened.
S     * |        |          |11 = PWM even channel output high level when PWMx brake event happened.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[19:18] |BRKAODD   |PWM Brake Action Select for Odd Channel (Write Protect)
S     * |        |          |00 = PWMx brake event will not affect odd channels output.
S     * |        |          |01 = PWM odd channel output tri-state when PWMx brake event happened.
S     * |        |          |10 = PWM odd channel output low level when PWMx brake event happened.
S     * |        |          |11 = PWM odd channel output high level when PWMx brake event happened.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[20]    |ADCEBEN   |Enable ADC Result Monitor (ADCRM) As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = ADCRM as edge-detect brake source Disabled.
S     * |        |          |1 = ADCRM as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[28]    |ADCLBEN   |Enable ADC Result Monitor (ADCRM) As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = ADCRM as level-detect brake source Disabled.
S     * |        |          |1 = ADCRM as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * @var PWM_T::BRKCTL2_3
S     * Offset: 0xCC  PWM Brake Edge Detect Control Register 2/3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CPO0EBEN  |Enable ACMP0_O Digital Output As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = ACMP0_O as edge-detect brake source Disabled.
S     * |        |          |1 = ACMP0_O as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[1]     |CPO1EBEN  |Enable ACMP1_O Digital Output As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = ACMP1_O as edge-detect brake source Disabled.
S     * |        |          |1 = ACMP1_O as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[4]     |BRKP0EEN  |Enable PWMx_BRAKE0 Pin As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = PWMx_BRAKE0 pin as edge-detect brake source Disabled.
S     * |        |          |1 = PWMx_BRAKE0 pin as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[5]     |BRKP1EEN  |Enable PWMx_BRAKE1 Pin As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = PWMx_BRAKE1 pin as edge-detect brake source Disabled.
S     * |        |          |1 = PWMx_BRAKE1 pin as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[7]     |SYSEBEN   |Enable System Fail As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
S     * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[8]     |CPO0LBEN  |Enable ACMP0_O Digital Output As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = ACMP0_O as level-detect brake source Disabled.
S     * |        |          |1 = ACMP0_O as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[9]     |CPO1LBEN  |Enable ACMP1_O Digital Output As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = ACMP1_O as level-detect brake source Disabled.
S     * |        |          |1 = ACMP1_O as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = PWMx_BRAKE0 pin as level-detect brake source Disabled.
S     * |        |          |1 = PWMx_BRAKE0 pin as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = PWMx_BRAKE1 pin as level-detect brake source Disabled.
S     * |        |          |1 = PWMx_BRAKE1 pin as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[15]    |SYSLBEN   |Enable System Fail As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = System Fail condition as level-detect brake source Disabled.
S     * |        |          |1 = System Fail condition as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[17:16] |BRKAEVEN  |PWM Brake Action Select for Even Channel (Write Protect)
S     * |        |          |00 = PWMx brake event will not affect even channels output.
S     * |        |          |01 = PWM even channel output tri-state when PWMx brake event happened.
S     * |        |          |10 = PWM even channel output low level when PWMx brake event happened.
S     * |        |          |11 = PWM even channel output high level when PWMx brake event happened.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[19:18] |BRKAODD   |PWM Brake Action Select for Odd Channel (Write Protect)
S     * |        |          |00 = PWMx brake event will not affect odd channels output.
S     * |        |          |01 = PWM odd channel output tri-state when PWMx brake event happened.
S     * |        |          |10 = PWM odd channel output low level when PWMx brake event happened.
S     * |        |          |11 = PWM odd channel output high level when PWMx brake event happened.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[20]    |ADCEBEN   |Enable ADC Result Monitor (ADCRM) As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = ADCRM as edge-detect brake source Disabled.
S     * |        |          |1 = ADCRM as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[28]    |ADCLBEN   |Enable ADC Result Monitor (ADCRM) As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = ADCRM as level-detect brake source Disabled.
S     * |        |          |1 = ADCRM as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * @var PWM_T::BRKCTL4_5
S     * Offset: 0xD0  PWM Brake Edge Detect Control Register 4/5
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CPO0EBEN  |Enable ACMP0_O Digital Output As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = ACMP0_O as edge-detect brake source Disabled.
S     * |        |          |1 = ACMP0_O as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[1]     |CPO1EBEN  |Enable ACMP1_O Digital Output As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = ACMP1_O as edge-detect brake source Disabled.
S     * |        |          |1 = ACMP1_O as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[4]     |BRKP0EEN  |Enable PWMx_BRAKE0 Pin As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = PWMx_BRAKE0 pin as edge-detect brake source Disabled.
S     * |        |          |1 = PWMx_BRAKE0 pin as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[5]     |BRKP1EEN  |Enable PWMx_BRAKE1 Pin As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = PWMx_BRAKE1 pin as edge-detect brake source Disabled.
S     * |        |          |1 = PWMx_BRAKE1 pin as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[7]     |SYSEBEN   |Enable System Fail As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
S     * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[8]     |CPO0LBEN  |Enable ACMP0_O Digital Output As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = ACMP0_O as level-detect brake source Disabled.
S     * |        |          |1 = ACMP0_O as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[9]     |CPO1LBEN  |Enable ACMP1_O Digital Output As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = ACMP1_O as level-detect brake source Disabled.
S     * |        |          |1 = ACMP1_O as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = PWMx_BRAKE0 pin as level-detect brake source Disabled.
S     * |        |          |1 = PWMx_BRAKE0 pin as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = PWMx_BRAKE1 pin as level-detect brake source Disabled.
S     * |        |          |1 = PWMx_BRAKE1 pin as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[15]    |SYSLBEN   |Enable System Fail As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = System Fail condition as level-detect brake source Disabled.
S     * |        |          |1 = System Fail condition as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[17:16] |BRKAEVEN  |PWM Brake Action Select for Even Channel (Write Protect)
S     * |        |          |00 = PWMx brake event will not affect even channels output.
S     * |        |          |01 = PWM even channel output tri-state when PWMx brake event happened.
S     * |        |          |10 = PWM even channel output low level when PWMx brake event happened.
S     * |        |          |11 = PWM even channel output high level when PWMx brake event happened.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[19:18] |BRKAODD   |PWM Brake Action Select for Odd Channel (Write Protect)
S     * |        |          |00 = PWMx brake event will not affect odd channels output.
S     * |        |          |01 = PWM odd channel output tri-state when PWMx brake event happened.
S     * |        |          |10 = PWM odd channel output low level when PWMx brake event happened.
S     * |        |          |11 = PWM odd channel output high level when PWMx brake event happened.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[20]    |ADCEBEN   |Enable ADC Result Monitor (ADCRM) As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = ADCRM as edge-detect brake source Disabled.
S     * |        |          |1 = ADCRM as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[28]    |ADCLBEN   |Enable ADC Result Monitor (ADCRM) As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = ADCRM as level-detect brake source Disabled.
S     * |        |          |1 = ADCRM as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * @var PWM_T::POLCTL
S     * Offset: 0xD4  PWM Pin Polar Inverse Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PINV0     |PWM PIN Polar Inverse Control
S     * |        |          |The register controls polarity state of PWMx_CHn output pin
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWMx_CHn output pin polar inverse Disabled.
S     * |        |          |1 = PWMx_CHn output pin polar inverse Enabled.
S     * |[1]     |PINV1     |PWM PIN Polar Inverse Control
S     * |        |          |The register controls polarity state of PWMx_CHn output pin
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWMx_CHn output pin polar inverse Disabled.
S     * |        |          |1 = PWMx_CHn output pin polar inverse Enabled.
S     * |[2]     |PINV2     |PWM PIN Polar Inverse Control
S     * |        |          |The register controls polarity state of PWMx_CHn output pin
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWMx_CHn output pin polar inverse Disabled.
S     * |        |          |1 = PWMx_CHn output pin polar inverse Enabled.
S     * |[3]     |PINV3     |PWM PIN Polar Inverse Control
S     * |        |          |The register controls polarity state of PWMx_CHn output pin
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWMx_CHn output pin polar inverse Disabled.
S     * |        |          |1 = PWMx_CHn output pin polar inverse Enabled.
S     * |[4]     |PINV4     |PWM PIN Polar Inverse Control
S     * |        |          |The register controls polarity state of PWMx_CHn output pin
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWMx_CHn output pin polar inverse Disabled.
S     * |        |          |1 = PWMx_CHn output pin polar inverse Enabled.
S     * |[5]     |PINV5     |PWM PIN Polar Inverse Control
S     * |        |          |The register controls polarity state of PWMx_CHn output pin
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWMx_CHn output pin polar inverse Disabled.
S     * |        |          |1 = PWMx_CHn output pin polar inverse Enabled.
S     * @var PWM_T::POEN
S     * Offset: 0xD8  PWM Output Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |POEN0     |PWMx_CHn Pin Output Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWMx_CHn pin at tri-state.
S     * |        |          |1 = PWMx_CHn pin in output mode.
S     * |[1]     |POEN1     |PWMx_CHn Pin Output Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWMx_CHn pin at tri-state.
S     * |        |          |1 = PWMx_CHn pin in output mode.
S     * |[2]     |POEN2     |PWMx_CHn Pin Output Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWMx_CHn pin at tri-state.
S     * |        |          |1 = PWMx_CHn pin in output mode.
S     * |[3]     |POEN3     |PWMx_CHn Pin Output Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWMx_CHn pin at tri-state.
S     * |        |          |1 = PWMx_CHn pin in output mode.
S     * |[4]     |POEN4     |PWMx_CHn Pin Output Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWMx_CHn pin at tri-state.
S     * |        |          |1 = PWMx_CHn pin in output mode.
S     * |[5]     |POEN5     |PWMx_CHn Pin Output Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWMx_CHn pin at tri-state.
S     * |        |          |1 = PWMx_CHn pin in output mode.
S     * @var PWM_T::SWBRK
S     * Offset: 0xDC  PWM Software Brake Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |BRKETRG0  |PWM Edge Brake Software Trigger (Write Only) (Write Protect)
S     * |        |          |Write 1 to this bit will trigger Edge brake, and set BRKEIFn bits to 1 in PWM_INTSTS1 register.
S     * |        |          |Each bit n controls the corresponding PWM pair n.
S     * |        |          |Note: This register is write protected. Refer toREGWRPROT register.
S     * |[1]     |BRKETRG2  |PWM Edge Brake Software Trigger (Write Only) (Write Protect)
S     * |        |          |Write 1 to this bit will trigger Edge brake, and set BRKEIFn bits to 1 in PWM_INTSTS1 register.
S     * |        |          |Each bit n controls the corresponding PWM pair n.
S     * |        |          |Note: This register is write protected. Refer toREGWRPROT register.
S     * |[2]     |BRKETRG4  |PWM Edge Brake Software Trigger (Write Only) (Write Protect)
S     * |        |          |Write 1 to this bit will trigger Edge brake, and set BRKEIFn bits to 1 in PWM_INTSTS1 register.
S     * |        |          |Each bit n controls the corresponding PWM pair n.
S     * |        |          |Note: This register is write protected. Refer toREGWRPROT register.
S     * |[8]     |BRKLTRG0  |PWM Level Brake Software Trigger (Write Only) (Write Protect)
S     * |        |          |Write 1 to this bit will trigger level brake, and set BRKLIFn bits to 1 in PWM_INTSTS1 register.
S     * |        |          |Each bit n controls the corresponding PWM pair n.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[9]     |BRKLTRG2  |PWM Level Brake Software Trigger (Write Only) (Write Protect)
S     * |        |          |Write 1 to this bit will trigger level brake, and set BRKLIFn bits to 1 in PWM_INTSTS1 register.
S     * |        |          |Each bit n controls the corresponding PWM pair n.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[10]    |BRKLTRG4  |PWM Level Brake Software Trigger (Write Only) (Write Protect)
S     * |        |          |Write 1 to this bit will trigger level brake, and set BRKLIFn bits to 1 in PWM_INTSTS1 register.
S     * |        |          |Each bit n controls the corresponding PWM pair n.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * @var PWM_T::INTEN0
S     * Offset: 0xE0  PWM Interrupt Enable Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ZIEN0     |PWM Zero Point Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Zero point interrupt Disabled.
S     * |        |          |1 = Zero point interrupt Enabled.
S     * |        |          |Note: Odd channels will read always 0 at complementary mode.
S     * |[1]     |ZIEN1     |PWM Zero Point Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Zero point interrupt Disabled.
S     * |        |          |1 = Zero point interrupt Enabled.
S     * |        |          |Note: Odd channels will read always 0 at complementary mode.
S     * |[2]     |ZIEN2     |PWM Zero Point Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Zero point interrupt Disabled.
S     * |        |          |1 = Zero point interrupt Enabled.
S     * |        |          |Note: Odd channels will read always 0 at complementary mode.
S     * |[3]     |ZIEN3     |PWM Zero Point Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Zero point interrupt Disabled.
S     * |        |          |1 = Zero point interrupt Enabled.
S     * |        |          |Note: Odd channels will read always 0 at complementary mode.
S     * |[4]     |ZIEN4     |PWM Zero Point Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Zero point interrupt Disabled.
S     * |        |          |1 = Zero point interrupt Enabled.
S     * |        |          |Note: Odd channels will read always 0 at complementary mode.
S     * |[5]     |ZIEN5     |PWM Zero Point Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Zero point interrupt Disabled.
S     * |        |          |1 = Zero point interrupt Enabled.
S     * |        |          |Note: Odd channels will read always 0 at complementary mode.
S     * |[7]     |IFAIEN0_1 |PWM Channel 0/1 Interrupt Flag Accumulator Interrupt Enable Bit
S     * |        |          |0 = Interrupt Flag accumulator interrupt Disabled.
S     * |        |          |1 = Interrupt Flag accumulator interrupt Enabled.
S     * |[8]     |PIEN0     |PWM Period Point Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Period point interrupt Disabled.
S     * |        |          |1 = Period point interrupt Enabled.
S     * |        |          |Note1: When up-down counter type period point means center point.
S     * |        |          |Note2: Odd channels will read always 0 at complementary mode.
S     * |[9]     |PIEN1     |PWM Period Point Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Period point interrupt Disabled.
S     * |        |          |1 = Period point interrupt Enabled.
S     * |        |          |Note1: When up-down counter type period point means center point.
S     * |        |          |Note2: Odd channels will read always 0 at complementary mode.
S     * |[10]    |PIEN2     |PWM Period Point Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Period point interrupt Disabled.
S     * |        |          |1 = Period point interrupt Enabled.
S     * |        |          |Note1: When up-down counter type period point means center point.
S     * |        |          |Note2: Odd channels will read always 0 at complementary mode.
S     * |[11]    |PIEN3     |PWM Period Point Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Period point interrupt Disabled.
S     * |        |          |1 = Period point interrupt Enabled.
S     * |        |          |Note1: When up-down counter type period point means center point.
S     * |        |          |Note2: Odd channels will read always 0 at complementary mode.
S     * |[12]    |PIEN4     |PWM Period Point Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Period point interrupt Disabled.
S     * |        |          |1 = Period point interrupt Enabled.
S     * |        |          |Note1: When up-down counter type period point means center point.
S     * |        |          |Note2: Odd channels will read always 0 at complementary mode.
S     * |[13]    |PIEN5     |PWM Period Point Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Period point interrupt Disabled.
S     * |        |          |1 = Period point interrupt Enabled.
S     * |        |          |Note1: When up-down counter type period point means center point.
S     * |        |          |Note2: Odd channels will read always 0 at complementary mode.
S     * |[15]    |IFAIEN2_3 |PWM Channel 2/3 Interrupt Flag Accumulator Interrupt Enable Bit
S     * |        |          |0 = Interrupt Flag accumulator interrupt Disabled.
S     * |        |          |1 = Interrupt Flag accumulator interrupt Enabled.
S     * |[16]    |CMPUIEN0  |PWM Compare Up Count Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Compare up count interrupt Disabled.
S     * |        |          |1 = Compare up count interrupt Enabled.
S     * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
S     * |[17]    |CMPUIEN1  |PWM Compare Up Count Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Compare up count interrupt Disabled.
S     * |        |          |1 = Compare up count interrupt Enabled.
S     * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
S     * |[18]    |CMPUIEN2  |PWM Compare Up Count Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Compare up count interrupt Disabled.
S     * |        |          |1 = Compare up count interrupt Enabled.
S     * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
S     * |[19]    |CMPUIEN3  |PWM Compare Up Count Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Compare up count interrupt Disabled.
S     * |        |          |1 = Compare up count interrupt Enabled.
S     * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
S     * |[20]    |CMPUIEN4  |PWM Compare Up Count Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Compare up count interrupt Disabled.
S     * |        |          |1 = Compare up count interrupt Enabled.
S     * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
S     * |[21]    |CMPUIEN5  |PWM Compare Up Count Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Compare up count interrupt Disabled.
S     * |        |          |1 = Compare up count interrupt Enabled.
S     * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
S     * |[23]    |IFAIEN4_5 |PWM Channel 4/5 Interrupt Flag Accumulator Interrupt Enable Bit
S     * |        |          |0 = Interrupt Flag accumulator interrupt Disabled.
S     * |        |          |1 = Interrupt Flag accumulator interrupt Enabled.
S     * |[24]    |CMPDIEN0  |PWM Compare Down Count Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Compare down count interrupt Disabled.
S     * |        |          |1 = Compare down count interrupt Enabled.
S     * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
S     * |[25]    |CMPDIEN1  |PWM Compare Down Count Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Compare down count interrupt Disabled.
S     * |        |          |1 = Compare down count interrupt Enabled.
S     * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
S     * |[26]    |CMPDIEN2  |PWM Compare Down Count Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Compare down count interrupt Disabled.
S     * |        |          |1 = Compare down count interrupt Enabled.
S     * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
S     * |[27]    |CMPDIEN3  |PWM Compare Down Count Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Compare down count interrupt Disabled.
S     * |        |          |1 = Compare down count interrupt Enabled.
S     * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
S     * |[28]    |CMPDIEN4  |PWM Compare Down Count Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Compare down count interrupt Disabled.
S     * |        |          |1 = Compare down count interrupt Enabled.
S     * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
S     * |[29]    |CMPDIEN5  |PWM Compare Down Count Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Compare down count interrupt Disabled.
S     * |        |          |1 = Compare down count interrupt Enabled.
S     * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
S     * @var PWM_T::INTEN1
S     * Offset: 0xE4  PWM Interrupt Enable Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |BRKEIEN0_1|PWM Edge-detect Brake Interrupt Enable for Channel0/1 (Write Protect)
S     * |        |          |0 = Edge-detect Brake interrupt for channel0/1 Disabled.
S     * |        |          |1 = Edge-detect Brake interrupt for channel0/1 Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[1]     |BRKEIEN2_3|PWM Edge-detect Brake Interrupt Enable for Channel2/3 (Write Protect)
S     * |        |          |0 = Edge-detect Brake interrupt for channel2/3 Disabled.
S     * |        |          |1 = Edge-detect Brake interrupt for channel2/3 Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[2]     |BRKEIEN4_5|PWM Edge-detect Brake Interrupt Enable for Channel4/5 (Write Protect)
S     * |        |          |0 = Edge-detect Brake interrupt for channel4/5 Disabled.
S     * |        |          |1 = Edge-detect Brake interrupt for channel4/5 Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[8]     |BRKLIEN0_1|PWM Level-detect Brake Interrupt Enable for Channel0/1 (Write Protect)
S     * |        |          |0 = Level-detect Brake interrupt for channel0/1 Disabled.
S     * |        |          |1 = Level-detect Brake interrupt for channel0/1 Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[9]     |BRKLIEN2_3|PWM Level-detect Brake Interrupt Enable for Channel2/3 (Write Protect)
S     * |        |          |0 = Level-detect Brake interrupt for channel2/3 Disabled.
S     * |        |          |1 = Level-detect Brake interrupt for channel2/3 Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[10]    |BRKLIEN4_5|PWM Level-detect Brake Interrupt Enable for Channel4/5 (Write Protect)
S     * |        |          |0 = Level-detect Brake interrupt for channel4/5 Disabled.
S     * |        |          |1 = Level-detect Brake interrupt for channel4/5 Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * @var PWM_T::INTSTS0
S     * Offset: 0xE8  PWM Interrupt Flag Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ZIF0      |PWM Zero Point Interrupt Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
S     * |[1]     |ZIF1      |PWM Zero Point Interrupt Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
S     * |[2]     |ZIF2      |PWM Zero Point Interrupt Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
S     * |[3]     |ZIF3      |PWM Zero Point Interrupt Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
S     * |[4]     |ZIF4      |PWM Zero Point Interrupt Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
S     * |[5]     |ZIF5      |PWM Zero Point Interrupt Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
S     * |[7]     |IFAIF0_1  |PWM Channel 0/1 Interrupt Flag Accumulator Interrupt Flag
S     * |        |          |Flag is set by hardware when condition match IFSEL0_1 bits in PWM_IFA register, software can clear this bit by writing 1 to it.
S     * |[8]     |PIF0      |PWM Period Point Interrupt Flag
S     * |        |          |This bit is set by hardware when PWM counter reaches PERIOD(PWM_PERIODn[15:0]), software can write 1 to clear this bit to zero.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |[9]     |PIF1      |PWM Period Point Interrupt Flag
S     * |        |          |This bit is set by hardware when PWM counter reaches PERIOD(PWM_PERIODn[15:0]), software can write 1 to clear this bit to zero.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |[10]    |PIF2      |PWM Period Point Interrupt Flag
S     * |        |          |This bit is set by hardware when PWM counter reaches PERIOD(PWM_PERIODn[15:0]), software can write 1 to clear this bit to zero.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |[11]    |PIF3      |PWM Period Point Interrupt Flag
S     * |        |          |This bit is set by hardware when PWM counter reaches PERIOD(PWM_PERIODn[15:0]), software can write 1 to clear this bit to zero.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |[12]    |PIF4      |PWM Period Point Interrupt Flag
S     * |        |          |This bit is set by hardware when PWM counter reaches PERIOD(PWM_PERIODn[15:0]), software can write 1 to clear this bit to zero.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |[13]    |PIF5      |PWM Period Point Interrupt Flag
S     * |        |          |This bit is set by hardware when PWM counter reaches PERIOD(PWM_PERIODn[15:0]), software can write 1 to clear this bit to zero.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |[15]    |IFAIF2_3  |PWM Channel 2/3 Interrupt Flag Accumulator Interrupt Flag
S     * |        |          |Flag is set by hardware when condition match IFSEL2_3 bits in PWM_IFA register, software can clear this bit by writing 1 to it.
S     * |[16]    |CMPUIF0   |PWM Compare Up Count Interrupt Flag
S     * |        |          |Flag is set by hardware when PWM counter up count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
S     * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
S     * |[17]    |CMPUIF1   |PWM Compare Up Count Interrupt Flag
S     * |        |          |Flag is set by hardware when PWM counter up count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
S     * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
S     * |[18]    |CMPUIF2   |PWM Compare Up Count Interrupt Flag
S     * |        |          |Flag is set by hardware when PWM counter up count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
S     * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
S     * |[19]    |CMPUIF3   |PWM Compare Up Count Interrupt Flag
S     * |        |          |Flag is set by hardware when PWM counter up count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
S     * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
S     * |[20]    |CMPUIF4   |PWM Compare Up Count Interrupt Flag
S     * |        |          |Flag is set by hardware when PWM counter up count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
S     * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
S     * |[21]    |CMPUIF5   |PWM Compare Up Count Interrupt Flag
S     * |        |          |Flag is set by hardware when PWM counter up count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
S     * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
S     * |[23]    |IFAIF4_5  |PWM_Channel 4/5 Interrupt Flag Accumulator Interrupt Flag
S     * |        |          |Flag is set by hardware when condition match IFSEL4_5 bits in PWM_IFA register, software can clear this bit by writing 1 to it.
S     * |[24]    |CMPDIF0   |PWM Compare Down Count Interrupt Flag
S     * |        |          |Flag is set by hardware when PWM counter down count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note1: If CMP equal to PERIOD, this flag is not working in down counter type selection.
S     * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
S     * |[25]    |CMPDIF1   |PWM Compare Down Count Interrupt Flag
S     * |        |          |Flag is set by hardware when PWM counter down count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note1: If CMP equal to PERIOD, this flag is not working in down counter type selection.
S     * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
S     * |[26]    |CMPDIF2   |PWM Compare Down Count Interrupt Flag
S     * |        |          |Flag is set by hardware when PWM counter down count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note1: If CMP equal to PERIOD, this flag is not working in down counter type selection.
S     * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
S     * |[27]    |CMPDIF3   |PWM Compare Down Count Interrupt Flag
S     * |        |          |Flag is set by hardware when PWM counter down count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note1: If CMP equal to PERIOD, this flag is not working in down counter type selection.
S     * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
S     * |[28]    |CMPDIF4   |PWM Compare Down Count Interrupt Flag
S     * |        |          |Flag is set by hardware when PWM counter down count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note1: If CMP equal to PERIOD, this flag is not working in down counter type selection.
S     * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
S     * |[29]    |CMPDIF5   |PWM Compare Down Count Interrupt Flag
S     * |        |          |Flag is set by hardware when PWM counter down count and reaches CMP(PWM_CMPDATn[15:0]), software can clear this bit by writing 1 to it.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note1: If CMP equal to PERIOD, this flag is not working in down counter type selection.
S     * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
S     * @var PWM_T::INTSTS1
S     * Offset: 0xEC  PWM Interrupt Flag Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |BRKEIF0   |PWM Channel 0 Edge-detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel 0 edge-detect brake event do not happened.
S     * |        |          |1 = When PWM channel 0 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * |[1]     |BRKEIF1   |PWM Channel 1 Edge-detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel 1 edge-detect brake event do not happened.
S     * |        |          |1 = When PWM channel 1 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * |[2]     |BRKEIF2   |PWM Channel 2 Edge-detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel 2 edge-detect brake event do not happened.
S     * |        |          |1 = When PWM channel 2 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * |[3]     |BRKEIF3   |PWM Channel 3 Edge-detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel 3 edge-detect brake event do not happened.
S     * |        |          |1 = When PWM channel 3 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * |[4]     |BRKEIF4   |PWM Channel 4 Edge-detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel 4 edge-detect brake event do not happened.
S     * |        |          |1 = When PWM channel 4 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * |[5]     |BRKEIF5   |PWM Channel 5 Edge-detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel 5 edge-detect brake event do not happened.
S     * |        |          |1 = When PWM channel 5 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * |[8]     |BRKLIF0   |PWM Channel 0 Level-detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel 0 level-detect brake event do not happened.
S     * |        |          |1 = When PWM channel 0 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * |[9]     |BRKLIF1   |PWM Channel 1 Level-detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel 1 level-detect brake event do not happened.
S     * |        |          |1 = When PWM channel 1 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * |[10]    |BRKLIF2   |PWM Channel 2 Level-detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel 2 level-detect brake event do not happened.
S     * |        |          |1 = When PWM channel 2 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * |[11]    |BRKLIF3   |PWM Channel 3 Level-detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel 3 level-detect brake event do not happened.
S     * |        |          |1 = When PWM channel 3 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * |[12]    |BRKLIF4   |PWM Channel 4 Level-detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel 4 level-detect brake event do not happened.
S     * |        |          |1 = When PWM channel 4 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * |[13]    |BRKLIF5   |PWM Channel 5 Level-detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel 5 level-detect brake event do not happened.
S     * |        |          |1 = When PWM channel 5 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S     * |[16]    |BRKESTS0  |PWM Channel 0 Edge-detect Brake Status
S     * |        |          |0 = PWM channel 0 edge-detect brake state is released.
S     * |        |          |1 = When PWM channel 0 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 0 at brake state, writing 1 to clear.
S     * |[17]    |BRKESTS1  |PWM Channel 1 Edge-detect Brake Status
S     * |        |          |0 = PWM channel 1 edge-detect brake state is released.
S     * |        |          |1 = When PWM channel 1 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 1 at brake state, writing 1 to clear.
S     * |[18]    |BRKESTS2  |PWM Channel 2 Edge-detect Brake Status
S     * |        |          |0 = PWM channel 2 edge-detect brake state is released.
S     * |        |          |1 = When PWM channel 2 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 2 at brake state, writing 1 to clear.
S     * |[19]    |BRKESTS3  |PWM Channel n5 Edge-detect Brake Status
S     * |        |          |0 = PWM channel 3 edge-detect brake state is released.
S     * |        |          |1 = When PWM channel 3 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 3 at brake state, writing 1 to clear.
S     * |[20]    |BRKESTS4  |PWM Channel 4 Edge-detect Brake Status
S     * |        |          |0 = PWM channel 4 edge-detect brake state is released.
S     * |        |          |1 = When PWM channel 4 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 4 at brake state, writing 1 to clear.
S     * |[21]    |BRKESTS5  |PWM Channel 5 Edge-detect Brake Status
S     * |        |          |0 = PWM channel 5 edge-detect brake state is released.
S     * |        |          |1 = When PWM channel 5 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 5 at brake state, writing 1 to clear.
S     * |[24]    |BRKLSTS0  |PWM Channel 0 Level-detect Brake Status (Read Only)
S     * |        |          |0 = PWM channel 0 level-detect brake state is released.
S     * |        |          |1 = When PWM channel 0 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 0 at brake state.
S     * |        |          |Note: This bit is read only and auto cleared by hardware.
S     * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
S     * |        |          |The PWM waveform will start output from next full PWM period.
S     * |[25]    |BRKLSTS1  |PWM Channel 1 Level-detect Brake Status (Read Only)
S     * |        |          |0 = PWM channel 1 level-detect brake state is released.
S     * |        |          |1 = When PWM channel 1 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 1 at brake state.
S     * |        |          |Note: This bit is read only and auto cleared by hardware.
S     * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
S     * |        |          |The PWM waveform will start output from next full PWM period.
S     * |[26]    |BRKLSTS2  |PWM Channel 2 Level-detect Brake Status (Read Only)
S     * |        |          |0 = PWM channel 2 level-detect brake state is released.
S     * |        |          |1 = When PWM channel 2 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 2 at brake state.
S     * |        |          |Note: This bit is read only and auto cleared by hardware.
S     * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
S     * |        |          |The PWM waveform will start output from next full PWM period.
S     * |[27]    |BRKLSTS3  |PWM Channel 3 Level-detect Brake Status (Read Only)
S     * |        |          |0 = PWM channel 3 level-detect brake state is released.
S     * |        |          |1 = When PWM channel 3 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 3 at brake state.
S     * |        |          |Note: This bit is read only and auto cleared by hardware.
S     * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
S     * |        |          |The PWM waveform will start output from next full PWM period.
S     * |[28]    |BRKLSTS4  |PWM Channel 4 Level-detect Brake Status (Read Only)
S     * |        |          |0 = PWM channel 4 level-detect brake state is released.
S     * |        |          |1 = When PWM channel 4 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 4 at brake state.
S     * |        |          |Note: This bit is read only and auto cleared by hardware.
S     * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
S     * |        |          |The PWM waveform will start output from next full PWM period.
S     * |[29]    |BRKLSTS5  |PWM Channel 5 Level-detect Brake Status (Read Only)
S     * |        |          |0 = PWM channel 5 level-detect brake state is released.
S     * |        |          |1 = When PWM channel 5 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel 5 at brake state.
S     * |        |          |Note: This bit is read only and auto cleared by hardware.
S     * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
S     * |        |          |The PWM waveform will start output from next full PWM period.
S     * @var PWM_T::IFA
S     * Offset: 0xF0  PWM Interrupt Flag Accumulator Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |IFCNT0_1  |PWM Channel 0/1 Interrupt Flag Counter
S     * |        |          |The register sets the count number which defines how many times of PWM Channel 0/1 period occurs to set IFAIF0_1 bit to request the PWM period interrupt.
S     * |        |          |PWM flag will be set in every IFCNT0_1 [3:0] times of PWM period.
S     * |[6:4]   |IFSEL0_1  |PWM Channel 0/1 Interrupt Flag Accumulator Source Select
S     * |        |          |000 = CNT equal to Zero in channel 0.
S     * |        |          |001 = CNT equal to PERIOD in channel 0.
S     * |        |          |010 = CNT equal to CMPU in channel 0.
S     * |        |          |011 = CNT equal to CMPD in channel 0.
S     * |        |          |100 = CNT equal to Zero in channel 1.
S     * |        |          |101 = CNT equal to PERIOD in channel 1.
S     * |        |          |110 = CNT equal to CMPU in channel 1.
S     * |        |          |111 = CNT equal to CMPD in channel 1.
S     * |[7]     |IFAEN0_1  |PWM Channel 0/1 Interrupt Flag Accumulator Enable Bit
S     * |        |          |0 = PWM Channel 0/1 interrupt flag accumulator disable.
S     * |        |          |1 = PWM Channel 0/1 interrupt flag accumulator enable.
S     * |[11:8]  |IFCNT2_3  |PWM Channel 2/3 Interrupt Flag Counter
S     * |        |          |The register sets the count number which defines how many times of PWM Channel 2/3 period occurs to set IFAIF2_3 bit to request the PWM period interrupt.
S     * |        |          |PWM flag will be set in every IFCNT2_3[3:0] times of PWM period.
S     * |[14:12] |IFSEL2_3  |PWM Channel 2/3 Interrupt Flag Accumulator Source Select
S     * |        |          |000 = CNT equal to Zero in channel 2.
S     * |        |          |001 = CNT equal to PERIOD in channel 2.
S     * |        |          |010 = CNT equal to CMPU in channel 2.
S     * |        |          |011 = CNT equal to CMPD in channel 2.
S     * |        |          |100 = CNT equal to Zero in channel 3.
S     * |        |          |101 = CNT equal to PERIOD in channel 3.
S     * |        |          |110 = CNT equal to CMPU in channel 3.
S     * |        |          |111 = CNT equal to CMPD in channel 3.
S     * |[15]    |IFAEN2_3  |PWM Channel 2/3 Interrupt Flag Accumulator Enable Bit
S     * |        |          |0 = PWM Channel 2/3 interrupt flag accumulator disable.
S     * |        |          |1 = PWM Channel 2/3 interrupt flag accumulator enable.
S     * |[19:16] |IFCNT4_5  |PWM Channel 4/5 Interrupt Flag Counter
S     * |        |          |The register sets the count number which defines how many times of PWM Channel 4/5 period occurs to set IFAIF4_5 bit to request the PWM period interrupt.
S     * |        |          |PWM flag will be set in every IFCNT4_5[3:0] times of PWM period.
S     * |[22:20] |IFSEL4_5  |PWM Channel 4/5 Interrupt Flag Accumulator Source Select
S     * |        |          |000 = CNT equal to Zero in channel 4.
S     * |        |          |001 = CNT equal to PERIOD in channel 4.
S     * |        |          |010 = CNT equal to CMPU in channel 4.
S     * |        |          |011 = CNT equal to CMPD in channel 4.
S     * |        |          |100 = CNT equal to Zero in channel 5.
S     * |        |          |101 = CNT equal to PERIOD in channel 5.
S     * |        |          |110 = CNT equal to CMPU in channel 5.
S     * |        |          |111 = CNT equal to CMPD in channel 5.
S     * |[23]    |IFAEN4_5  |PWM Channel 4/5 Interrupt Flag Accumulator Enable Bit
S     * |        |          |0 = PWM Channel 4/5 interrupt flag accumulator disable.
S     * |        |          |1 = PWM Channel 4/5 interrupt flag accumulator enable.
S     * @var PWM_T::ADCTS0
S     * Offset: 0xF8  PWM Trigger ADC Source Select Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |TRGSEL0   |PWM_CH0 Trigger ADC Source Select
S     * |        |          |0000 = PWM_CH0 zero point.
S     * |        |          |0001 = PWM_CH0 period point.
S     * |        |          |0010 = PWM_CH0 zero or period point.
S     * |        |          |0011 = PWM_CH0 up-count compared point.
S     * |        |          |0100 = PWM_CH0 down-count compared point.
S     * |        |          |0101 = PWM_CH1 zero point.
S     * |        |          |0110 = PWM_CH1 period point.
S     * |        |          |0111 = PWM_CH1 zero or period point.
S     * |        |          |1000 = PWM_CH1 up-count compared point.
S     * |        |          |1001 = PWM_CH1 down-count compared point.
S     * |        |          |1010 = PWM_CH0 up-count free trigger compared point.
S     * |        |          |1011 = PWM_CH0 down-count free trigger compared point.
S     * |        |          |1100 = PWM_CH2 up-count free trigger compared point.
S     * |        |          |1101 = PWM_CH2 down-count free trigger compared point.
S     * |        |          |1110 = PWM_CH4 up-count free trigger compared point.
S     * |        |          |1111 = PWM_CH4 down-count free trigger compared point.
S     * |[7]     |TRGEN0    |PWM_CH0 Trigger ADC enable bit
S     * |[11:8]  |TRGSEL1   |PWM_CH1 Trigger ADC Source Select
S     * |        |          |0000 = PWM_CH0 zero point.
S     * |        |          |0001 = PWM_CH0 period point.
S     * |        |          |0010 = PWM_CH0 zero or period point.
S     * |        |          |0011 = PWM_CH0 up-count compared point.
S     * |        |          |0100 = PWM_CH0 down-count compared point.
S     * |        |          |0101 = PWM_CH1 zero point.
S     * |        |          |0110 = PWM_CH1 period point.
S     * |        |          |0111 = PWM_CH1 zero or period point.
S     * |        |          |1000 = PWM_CH1 up-count compared point.
S     * |        |          |1001 = PWM_CH1 down-count compared point.
S     * |        |          |1010 = PWM_CH0 up-count free trigger compared point.
S     * |        |          |1011 = PWM_CH0 down-count free trigger compared point.
S     * |        |          |1100 = PWM_CH2 up-count free trigger compared point.
S     * |        |          |1101 = PWM_CH2 down-count free trigger compared point.
S     * |        |          |1110 = PWM_CH4 up-count free trigger compared point.
S     * |        |          |1111 = PWM_CH4 down-count free trigger compared point.
S     * |[15]    |TRGEN1    |PWM_CH1 Trigger ADC enable bit
S     * |[19:16] |TRGSEL2   |PWM_CH2 Trigger ADC Source Select
S     * |        |          |0000 = PWM_CH2 zero point.
S     * |        |          |0001 = PWM_CH2 period point.
S     * |        |          |0010 = PWM_CH2 zero or period point.
S     * |        |          |0011 = PWM_CH2 up-count compared point.
S     * |        |          |0100 = PWM_CH2 down-count compared point.
S     * |        |          |0101 = PWM_CH3 zero point.
S     * |        |          |0110 = PWM_CH3 period point.
S     * |        |          |0111 = PWM_CH3 zero or period point.
S     * |        |          |1000 = PWM_CH3 up-count compared point.
S     * |        |          |1001 = PWM_CH3 down-count compared point.
S     * |        |          |1010 = PWM_CH0 up-count free trigger compared point.
S     * |        |          |1011 = PWM_CH0 down-count free trigger compared point.
S     * |        |          |1100 = PWM_CH2 up-count free trigger compared point.
S     * |        |          |1101 = PWM_CH2 down-count free trigger compared point.
S     * |        |          |1110 = PWM_CH4 up-count free trigger compared point.
S     * |        |          |1111 = PWM_CH4 down-count free trigger compared point.
S     * |[23]    |TRGEN2    |PWM_CH2 Trigger ADC enable bit
S     * |[27:24] |TRGSEL3   |PWM_CH3 Trigger ADC Source Select
S     * |        |          |0000 = PWM_CH2 zero point.
S     * |        |          |0001 = PWM_CH2 period point.
S     * |        |          |0010 = PWM_CH2 zero or period point.
S     * |        |          |0011 = PWM_CH2 up-count compared point.
S     * |        |          |0100 = PWM_CH2 down-count compared point.
S     * |        |          |0101 = PWM_CH3 zero point.
S     * |        |          |0110 = PWM_CH3 period point.
S     * |        |          |0111 = PWM_CH3 zero or period point.
S     * |        |          |1000 = PWM_CH3 up-count compared point.
S     * |        |          |1001 = PWM_CH3 down-count compared point.
S     * |        |          |1010 = PWM_CH0 up-count free trigger compared point.
S     * |        |          |1011 = PWM_CH0 down-count free trigger compared point.
S     * |        |          |1100 = PWM_CH2 up-count free trigger compared point.
S     * |        |          |1101 = PWM_CH2 down-count free trigger compared point.
S     * |        |          |1110 = PWM_CH4 up-count free trigger compared point.
S     * |        |          |1111 = PWM_CH4 down-count free trigger compared point.
S     * |[31]    |TRGEN3    |PWM_CH3 Trigger ADC enable bit
S     * @var PWM_T::ADCTS1
S     * Offset: 0xFC  PWM Trigger ADC Source Select Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |TRGSEL4   |PWM_CH4 Trigger ADC Source Select
S     * |        |          |0000 = PWM_CH4 zero point.
S     * |        |          |0001 = PWM_CH4 period point.
S     * |        |          |0010 = PWM_CH4 zero or period point.
S     * |        |          |0011 = PWM_CH4 up-count compared point.
S     * |        |          |0100 = PWM_CH4 down-count compared point.
S     * |        |          |0101 = PWM_CH5 zero point.
S     * |        |          |0110 = PWM_CH5 period point.
S     * |        |          |0111 = PWM_CH5 zero or period point.
S     * |        |          |1000 = PWM_CH5 up-count compared point.
S     * |        |          |1001 = PWM_CH5 down-count compared point.
S     * |        |          |1010 = PWM_CH0 up-count free trigger compared point.
S     * |        |          |1011 = PWM_CH0 down-count free trigger compared point.
S     * |        |          |1100 = PWM_CH2 up-count free trigger compared point.
S     * |        |          |1101 = PWM_CH2 down-count free trigger compared point.
S     * |        |          |1110 = PWM_CH4 up-count free trigger compared point.
S     * |        |          |1111 = PWM_CH4 down-count free trigger compared point.
S     * |[7]     |TRGEN4    |PWM_CH4 Trigger ADC enable bit
S     * |[11:8]  |TRGSEL5   |PWM_CH5 Trigger ADC Source Select
S     * |        |          |0000 = PWM_CH4 zero point.
S     * |        |          |0001 = PWM_CH4 period point.
S     * |        |          |0010 = PWM_CH4 zero or period point.
S     * |        |          |0011 = PWM_CH4 up-count compared point.
S     * |        |          |0100 = PWM_CH4 down-count compared point.
S     * |        |          |0101 = PWM_CH5 zero point.
S     * |        |          |0110 = PWM_CH5 period point.
S     * |        |          |0111 = PWM_CH5 zero or period point.
S     * |        |          |1000 = PWM_CH5 up-count compared point.
S     * |        |          |1001 = PWM_CH5 down-count compared point.
S     * |        |          |1010 = PWM_CH0 up-count free trigger compared point.
S     * |        |          |1011 = PWM_CH0 down-count free trigger compared point.
S     * |        |          |1100 = PWM_CH2 up-count free trigger compared point.
S     * |        |          |1101 = PWM_CH2 down-count free trigger compared point.
S     * |        |          |1110 = PWM_CH4 up-count free trigger compared point.
S     * |        |          |1111 = PWM_CH4 down-count free trigger compared point.
S     * |[15]    |TRGEN5    |PWM_CH5 Trigger ADC enable bit
S     * @var PWM_T::FTCMPDAT0_1
S     * Offset: 0x100  PWM Free Trigger Compare Register 0/1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FTCMP     |PWM Free Trigger Compare Register
S     * |        |          |FTCMP use to compare with even CNT(PWM_CNTm[15:0], m=0,2,4) to trigger ADC
S     * |        |          |FTCMPDAT0, 2, 4 corresponding complementary pairs PWMx_CH0 and PWMx_CH1, PWMx_CH2 and PWMx_CH3, PWMx_CH4 and PWMx_CH5.
S     * @var PWM_T::FTCMPDAT2_3
S     * Offset: 0x104  PWM Free Trigger Compare Register 2/3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FTCMP     |PWM Free Trigger Compare Register
S     * |        |          |FTCMP use to compare with even CNT(PWM_CNTm[15:0], m=0,2,4) to trigger ADC
S     * |        |          |FTCMPDAT0, 2, 4 corresponding complementary pairs PWMx_CH0 and PWMx_CH1, PWMx_CH2 and PWMx_CH3, PWMx_CH4 and PWMx_CH5.
S     * @var PWM_T::FTCMPDAT4_5
S     * Offset: 0x108  PWM Free Trigger Compare Register 4/5
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FTCMP     |PWM Free Trigger Compare Register
S     * |        |          |FTCMP use to compare with even CNT(PWM_CNTm[15:0], m=0,2,4) to trigger ADC
S     * |        |          |FTCMPDAT0, 2, 4 corresponding complementary pairs PWMx_CH0 and PWMx_CH1, PWMx_CH2 and PWMx_CH3, PWMx_CH4 and PWMx_CH5.
S     * @var PWM_T::SSCTL
S     * Offset: 0x110  PWM Synchronous Start Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SSEN0     |PWM Synchronous Start Function Enable Bits
S     * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM synchronous start function Disabled.
S     * |        |          |1 = PWM synchronous start function Enabled.
S     * |[1]     |SSEN1     |PWM Synchronous Start Function Enable Bits
S     * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM synchronous start function Disabled.
S     * |        |          |1 = PWM synchronous start function Enabled.
S     * |[2]     |SSEN2     |PWM Synchronous Start Function Enable Bits
S     * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM synchronous start function Disabled.
S     * |        |          |1 = PWM synchronous start function Enabled.
S     * |[3]     |SSEN3     |PWM Synchronous Start Function Enable Bits
S     * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM synchronous start function Disabled.
S     * |        |          |1 = PWM synchronous start function Enabled.
S     * |[4]     |SSEN4     |PWM Synchronous Start Function Enable Bits
S     * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM synchronous start function Disabled.
S     * |        |          |1 = PWM synchronous start function Enabled.
S     * |[5]     |SSEN5     |PWM Synchronous Start Function Enable Bits
S     * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM synchronous start function Disabled.
S     * |        |          |1 = PWM synchronous start function Enabled.
S     * |[8]     |SSRC      |PWM Synchronous Start Source Select Bit
S     * |        |          |0 = Synchronous start source come from PWM0.
S     * |        |          |1 = Synchronous start source come from PWM1.
S     * @var PWM_T::SSTRG
S     * Offset: 0x114  PWM Synchronous Start Trigger Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CNTSEN    |PWM Counter Synchronous Start Enable (Write Only)
S     * |        |          |PMW counter synchronous enable function is used to make selected PWM channels (PWMx_CHn) start counting at the same time.
S     * |        |          |Writing this bit to 1 will also set the counter enable bit (CNTENn, n denotes channel 0 to 5) if correlated PWM channel counter synchronous start function is enabled.
S     * @var PWM_T::LEBCTL
S     * Offset: 0x118  PWM Leading Edge Blanking Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |LEBEN     |PWM Leading Edge Blanking Enable Bit
S     * |        |          |0 = PWM Leading Edge Blanking Disabled.
S     * |        |          |1 = PWM Leading Edge Blanking Enabled.
S     * |[8]     |SRCEN0    |PWM Leading Edge Blanking Source From PWMx_CH0 Enable Bit
S     * |        |          |0 = PWM Leading Edge Blanking Source from PWMx_CH0 Disabled.
S     * |        |          |1 = PWM Leading Edge Blanking Source from PWMx_CH0 Enabled.
S     * |[9]     |SRCEN2    |PWM Leading Edge Blanking Source From PWMx_CH2 Enable Bit
S     * |        |          |0 = PWM Leading Edge Blanking Source from PWMx_CH2 Disabled.
S     * |        |          |1 = PWM Leading Edge Blanking Source from PWMx_CH2 Enabled.
S     * |[10]    |SRCEN4    |PWM Leading Edge Blanking Source From PWMx_CH4 Enable Bit
S     * |        |          |0 = PWM Leading Edge Blanking Source from PWMx_CH4 Disabled.
S     * |        |          |1 = PWM Leading Edge Blanking Source from PWMx_CH4 Enabled.
S     * |[17:16] |TRGTYPE   |PWM Leading Edge Blanking Trigger Type
S     * |        |          |00 = When detect leading edge blanking source rising edge, blanking counter start counting.
S     * |        |          |01 = When detect leading edge blanking source falling edge, blanking counter start counting.
S     * |        |          |10 = When detect leading edge blanking source rising or falling edge, blanking counter start counting.
S     * |        |          |11 = Reserved.
S     * @var PWM_T::LEBCNT
S     * Offset: 0x11C  PWM Leading Edge Blanking Counter Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[8:0]   |LEBCNT    |PWM Leading Edge Blanking Counter
S     * |        |          |This counter value decides leading edge blanking window size.
S     * |        |          |Blanking window size = LEBCNT+1, and LEB counter clock base is ECLK.
S     * @var PWM_T::STATUS
S     * Offset: 0x120  PWM Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CNTMAXF0  |Time-base Counter Equal to 0xFFFF Latched Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = indicates the time-base counter(PWM_CNTn[15:0]) never reached its maximum value 0xFFFF.
S     * |        |          |1 = indicates the time-base counter(PWM_CNTn[15:0]) reached its maximum value, software can write 1 to clear this bit.
S     * |[1]     |CNTMAXF1  |Time-base Counter Equal to 0xFFFF Latched Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = indicates the time-base counter(PWM_CNTn[15:0]) never reached its maximum value 0xFFFF.
S     * |        |          |1 = indicates the time-base counter(PWM_CNTn[15:0]) reached its maximum value, software can write 1 to clear this bit.
S     * |[2]     |CNTMAXF2  |Time-base Counter Equal to 0xFFFF Latched Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = indicates the time-base counter(PWM_CNTn[15:0]) never reached its maximum value 0xFFFF.
S     * |        |          |1 = indicates the time-base counter(PWM_CNTn[15:0]) reached its maximum value, software can write 1 to clear this bit.
S     * |[3]     |CNTMAXF3  |Time-base Counter Equal to 0xFFFF Latched Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = indicates the time-base counter(PWM_CNTn[15:0]) never reached its maximum value 0xFFFF.
S     * |        |          |1 = indicates the time-base counter(PWM_CNTn[15:0]) reached its maximum value, software can write 1 to clear this bit.
S     * |[4]     |CNTMAXF4  |Time-base Counter Equal to 0xFFFF Latched Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = indicates the time-base counter(PWM_CNTn[15:0]) never reached its maximum value 0xFFFF.
S     * |        |          |1 = indicates the time-base counter(PWM_CNTn[15:0]) reached its maximum value, software can write 1 to clear this bit.
S     * |[5]     |CNTMAXF5  |Time-base Counter Equal to 0xFFFF Latched Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = indicates the time-base counter(PWM_CNTn[15:0]) never reached its maximum value 0xFFFF.
S     * |        |          |1 = indicates the time-base counter(PWM_CNTn[15:0]) reached its maximum value, software can write 1 to clear this bit.
S     * |[8]     |SYNCINF0  |Input Synchronization Latched Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Indicates no SYNC_IN event has occurred.
S     * |        |          |1 = Indicates an SYNC_IN event has occurred, software can write 1 to clear this bit.
S     * |[9]     |SYNCINF2  |Input Synchronization Latched Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Indicates no SYNC_IN event has occurred.
S     * |        |          |1 = Indicates an SYNC_IN event has occurred, software can write 1 to clear this bit.
S     * |[10]    |SYNCINF4  |Input Synchronization Latched Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Indicates no SYNC_IN event has occurred.
S     * |        |          |1 = Indicates an SYNC_IN event has occurred, software can write 1 to clear this bit.
S     * |[16]    |ADCTRGF0  |ADC Start of Conversion Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Indicates no ADC start of conversion trigger event has occurred.
S     * |        |          |1 = Indicates an ADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
S     * |[17]    |ADCTRGF1  |ADC Start of Conversion Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Indicates no ADC start of conversion trigger event has occurred.
S     * |        |          |1 = Indicates an ADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
S     * |[18]    |ADCTRGF2  |ADC Start of Conversion Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Indicates no ADC start of conversion trigger event has occurred.
S     * |        |          |1 = Indicates an ADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
S     * |[19]    |ADCTRGF3  |ADC Start of Conversion Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Indicates no ADC start of conversion trigger event has occurred.
S     * |        |          |1 = Indicates an ADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
S     * |[20]    |ADCTRGF4  |ADC Start of Conversion Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Indicates no ADC start of conversion trigger event has occurred.
S     * |        |          |1 = Indicates an ADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
S     * |[21]    |ADCTRGF5  |ADC Start of Conversion Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Indicates no ADC start of conversion trigger event has occurred.
S     * |        |          |1 = Indicates an ADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
S     * @var PWM_T::CAPINEN
S     * Offset: 0x200  PWM Capture Input Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CAPINEN0  |Capture Input Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM Channel capture input path Disabled.
S     * |        |          |The input of PWM channel capture function is always regarded as 0.
S     * |        |          |1 = PWM Channel capture input path Enabled.
S     * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
S     * |[1]     |CAPINEN1  |Capture Input Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM Channel capture input path Disabled.
S     * |        |          |The input of PWM channel capture function is always regarded as 0.
S     * |        |          |1 = PWM Channel capture input path Enabled.
S     * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
S     * |[2]     |CAPINEN2  |Capture Input Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM Channel capture input path Disabled.
S     * |        |          |The input of PWM channel capture function is always regarded as 0.
S     * |        |          |1 = PWM Channel capture input path Enabled.
S     * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
S     * |[3]     |CAPINEN3  |Capture Input Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM Channel capture input path Disabled.
S     * |        |          |The input of PWM channel capture function is always regarded as 0.
S     * |        |          |1 = PWM Channel capture input path Enabled.
S     * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
S     * |[4]     |CAPINEN4  |Capture Input Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM Channel capture input path Disabled.
S     * |        |          |The input of PWM channel capture function is always regarded as 0.
S     * |        |          |1 = PWM Channel capture input path Enabled.
S     * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
S     * |[5]     |CAPINEN5  |Capture Input Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM Channel capture input path Disabled.
S     * |        |          |The input of PWM channel capture function is always regarded as 0.
S     * |        |          |1 = PWM Channel capture input path Enabled.
S     * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
S     * @var PWM_T::CAPCTL
S     * Offset: 0x204  PWM Capture Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CAPEN0    |Capture Function Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT registers will not be updated.
S     * |        |          |1 = Capture function Enabled
S     * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch) registers.
S     * |[1]     |CAPEN1    |Capture Function Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT registers will not be updated.
S     * |        |          |1 = Capture function Enabled
S     * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch) registers.
S     * |[2]     |CAPEN2    |Capture Function Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT registers will not be updated.
S     * |        |          |1 = Capture function Enabled
S     * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch) registers.
S     * |[3]     |CAPEN3    |Capture Function Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT registers will not be updated.
S     * |        |          |1 = Capture function Enabled
S     * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch) registers.
S     * |[4]     |CAPEN4    |Capture Function Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT registers will not be updated.
S     * |        |          |1 = Capture function Enabled
S     * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch) registers.
S     * |[5]     |CAPEN5    |Capture Function Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT registers will not be updated.
S     * |        |          |1 = Capture function Enabled
S     * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch) registers.
S     * |[8]     |CAPINV0   |Capture Inverter Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture source inverter Disabled.
S     * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
S     * |[9]     |CAPINV1   |Capture Inverter Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture source inverter Disabled.
S     * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
S     * |[10]    |CAPINV2   |Capture Inverter Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture source inverter Disabled.
S     * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
S     * |[11]    |CAPINV3   |Capture Inverter Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture source inverter Disabled.
S     * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
S     * |[12]    |CAPINV4   |Capture Inverter Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture source inverter Disabled.
S     * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
S     * |[13]    |CAPINV5   |Capture Inverter Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture source inverter Disabled.
S     * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
S     * |[16]    |RCRLDEN0  |Rising Capture Reload Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Rising capture reload counter Disabled.
S     * |        |          |1 = Rising capture reload counter Enabled.
S     * |[17]    |RCRLDEN1  |Rising Capture Reload Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Rising capture reload counter Disabled.
S     * |        |          |1 = Rising capture reload counter Enabled.
S     * |[18]    |RCRLDEN2  |Rising Capture Reload Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Rising capture reload counter Disabled.
S     * |        |          |1 = Rising capture reload counter Enabled.
S     * |[19]    |RCRLDEN3  |Rising Capture Reload Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Rising capture reload counter Disabled.
S     * |        |          |1 = Rising capture reload counter Enabled.
S     * |[20]    |RCRLDEN4  |Rising Capture Reload Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Rising capture reload counter Disabled.
S     * |        |          |1 = Rising capture reload counter Enabled.
S     * |[21]    |RCRLDEN5  |Rising Capture Reload Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Rising capture reload counter Disabled.
S     * |        |          |1 = Rising capture reload counter Enabled.
S     * |[24]    |FCRLDEN0  |Falling Capture Reload Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Falling capture reload counter Disabled.
S     * |        |          |1 = Falling capture reload counter Enabled.
S     * |[25]    |FCRLDEN1  |Falling Capture Reload Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Falling capture reload counter Disabled.
S     * |        |          |1 = Falling capture reload counter Enabled.
S     * |[26]    |FCRLDEN2  |Falling Capture Reload Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Falling capture reload counter Disabled.
S     * |        |          |1 = Falling capture reload counter Enabled.
S     * |[27]    |FCRLDEN3  |Falling Capture Reload Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Falling capture reload counter Disabled.
S     * |        |          |1 = Falling capture reload counter Enabled.
S     * |[28]    |FCRLDEN4  |Falling Capture Reload Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Falling capture reload counter Disabled.
S     * |        |          |1 = Falling capture reload counter Enabled.
S     * |[29]    |FCRLDEN5  |Falling Capture Reload Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Falling capture reload counter Disabled.
S     * |        |          |1 = Falling capture reload counter Enabled.
S     * @var PWM_T::CAPSTS
S     * Offset: 0x208  PWM Capture Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CRLIFOV0  |Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
S     * |        |          |This flag indicates if rising latch happened when the corresponding CRLIFn(PWM_CAPIF[5:0]) bit is 1.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIFn bit.
S     * |[1]     |CRLIFOV1  |Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
S     * |        |          |This flag indicates if rising latch happened when the corresponding CRLIFn(PWM_CAPIF[5:0]) bit is 1.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIFn bit.
S     * |[2]     |CRLIFOV2  |Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
S     * |        |          |This flag indicates if rising latch happened when the corresponding CRLIFn(PWM_CAPIF[5:0]) bit is 1.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIFn bit.
S     * |[3]     |CRLIFOV3  |Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
S     * |        |          |This flag indicates if rising latch happened when the corresponding CRLIFn(PWM_CAPIF[5:0]) bit is 1.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIFn bit.
S     * |[4]     |CRLIFOV4  |Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
S     * |        |          |This flag indicates if rising latch happened when the corresponding CRLIFn(PWM_CAPIF[5:0]) bit is 1.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIFn bit.
S     * |[5]     |CRLIFOV5  |Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
S     * |        |          |This flag indicates if rising latch happened when the corresponding CRLIFn(PWM_CAPIF[5:0]) bit is 1.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIFn bit.
S     * |[8]     |CFLIFOV0  |Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
S     * |        |          |This flag indicates if falling latch happened when the corresponding CFLIFn(PWM_CAPIF[13:8]) bit is 1.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIFn bit.
S     * |[9]     |CFLIFOV1  |Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
S     * |        |          |This flag indicates if falling latch happened when the corresponding CFLIFn(PWM_CAPIF[13:8]) bit is 1.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIFn bit.
S     * |[10]    |CFLIFOV2  |Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
S     * |        |          |This flag indicates if falling latch happened when the corresponding CFLIFn(PWM_CAPIF[13:8]) bit is 1.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIFn bit.
S     * |[11]    |CFLIFOV3  |Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
S     * |        |          |This flag indicates if falling latch happened when the corresponding CFLIFn(PWM_CAPIF[13:8]) bit is 1.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIFn bit.
S     * |[12]    |CFLIFOV4  |Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
S     * |        |          |This flag indicates if falling latch happened when the corresponding CFLIFn(PWM_CAPIF[13:8]) bit is 1.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIFn bit.
S     * |[13]    |CFLIFOV5  |Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
S     * |        |          |This flag indicates if falling latch happened when the corresponding CFLIFn(PWM_CAPIF[13:8]) bit is 1.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIFn bit.
S     * @var PWM_T::RCAPDAT0
S     * Offset: 0x20C  PWM Rising Capture Data Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
S     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
S     * @var PWM_T::FCAPDAT0
S     * Offset: 0x210  PWM Falling Capture Data Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
S     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
S     * @var PWM_T::RCAPDAT1
S     * Offset: 0x214  PWM Rising Capture Data Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
S     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
S     * @var PWM_T::FCAPDAT1
S     * Offset: 0x218  PWM Falling Capture Data Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
S     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
S     * @var PWM_T::RCAPDAT2
S     * Offset: 0x21C  PWM Rising Capture Data Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
S     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
S     * @var PWM_T::FCAPDAT2
S     * Offset: 0x220  PWM Falling Capture Data Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
S     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
S     * @var PWM_T::RCAPDAT3
S     * Offset: 0x224  PWM Rising Capture Data Register 3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
S     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
S     * @var PWM_T::FCAPDAT3
S     * Offset: 0x228  PWM Falling Capture Data Register 3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
S     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
S     * @var PWM_T::RCAPDAT4
S     * Offset: 0x22C  PWM Rising Capture Data Register 4
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
S     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
S     * @var PWM_T::FCAPDAT4
S     * Offset: 0x230  PWM Falling Capture Data Register 4
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
S     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
S     * @var PWM_T::RCAPDAT5
S     * Offset: 0x234  PWM Rising Capture Data Register 5
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
S     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
S     * @var PWM_T::FCAPDAT5
S     * Offset: 0x238  PWM Falling Capture Data Register 5
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
S     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
S     * @var PWM_T::PDMACTL
S     * Offset: 0x23C  PWM PDMA Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CHEN0_1   |Channel 0/1 PDMA Enable
S     * |        |          |0 = Channel 0/1 PDMA function Disabled.
S     * |        |          |1 = Channel 0/1 PDMA function Enabled for the channel 0/1 captured data and transfer to memory.
S     * |[2:1]   |CAPMOD0_1 |Select PWM_RCAPDAT0/1 or PWM_FCAPDAT0/1 to Do PDMA Transfer
S     * |        |          |00 = Reserved.
S     * |        |          |01 = PWM_RCAPDAT0/1 register.
S     * |        |          |10 = PWM_FCAPDAT0/1 register.
S     * |        |          |11 = Both PWM_RCAPDAT0/1 and PWM_FCAPDAT0/1 registers.
S     * |[3]     |CAPORD0_1 |Capture Channel 0/1 Rising/Falling Order
S     * |        |          |Set this bit to determine whether the PWM_RCAPDAT0/1 or PWM_FCAPDAT0/1 register is the first captured data transferred to memory through PDMA when CAPMOD0_1 bits are set to = 0x3.
S     * |        |          |0 = PWM_FCAPDAT0/1 register is the first captured data to memory.
S     * |        |          |1 = PWM_RCAPDAT0/1 register is the first captured data to memory.
S     * |[4]     |CHSEL0_1  |Select Channel 0/1 to Do PDMA Transfer
S     * |        |          |0 = Channel0.
S     * |        |          |1 = Channel1.
S     * |[8]     |CHEN2_3   |Channel 2/3 PDMA Enable
S     * |        |          |0 = Channel 2/3 PDMA function Disabled.
S     * |        |          |1 = Channel 2/3 PDMA function Enabled for the channel 2/3 captured data and transfer to memory.
S     * |[10:9]  |CAPMOD2_3 |Select PWM_RCAPDAT2/3 or PWM_FCAODAT2/3 to Do PDMA Transfer
S     * |        |          |00 = Reserved.
S     * |        |          |01 = PWM_RCAPDAT2/3 register.
S     * |        |          |10 = PWM_FCAPDAT2/3 register.
S     * |        |          |11 = Both PWM_RCAPDAT2/3 and PWM_FCAPDAT2/3 registers.
S     * |[11]    |CAPORD2_3 |Capture Channel 2/3 Rising/Falling Order
S     * |        |          |Set this bit to determine whether the PWM_RCAPDAT2/3 or PWM_FCAPDAT2/3 register is the first captured data transferred to memory through PDMA when CAPMOD2_3 bits are set to =0x3.
S     * |        |          |0 = PWM_FCAPDAT2/3 register is the first captured data to memory.
S     * |        |          |1 = PWM_RCAPDAT2/3 register is the first captured data to memory.
S     * |[12]    |CHSEL2_3  |Select Channel 2/3 to Do PDMA Transfer
S     * |        |          |0 = Channel2.
S     * |        |          |1 = Channel3.
S     * |[16]    |CHEN4_5   |Channel 4/5 PDMA Enable
S     * |        |          |0 = Channel 4/5 PDMA function Disabled.
S     * |        |          |1 = Channel 4/5 PDMA function Enabled for the channel 4/5 captured data and transfer to memory.
S     * |[18:17] |CAPMOD4_5 |Select PWM_RCAPDAT4/5 or PWM_FCAPDAT4/5 to Do PDMA Transfer
S     * |        |          |00 = Reserved.
S     * |        |          |01 = PWM_RCAPDAT4/5 register.
S     * |        |          |10 = PWM_FCAPDAT4/5 register.
S     * |        |          |11 = Both PWM_RCAPDAT4/5 and PWM_FCAPDAT4/5 registers.
S     * |[19]    |CAPORD4_5 |Capture Channel 4/5 Rising/Falling Order
S     * |        |          |Set this bit to determine whether the PWM_RCAPDAT4/5 or PWM_FCAPDAT4/5 register is the first captured data transferred to memory through PDMA when CAPMOD4_5 bits =are set to 0x3.
S     * |        |          |0 = PWM_FCAPDAT4/5 register is the first captured data to memory.
S     * |        |          |1 = PWM_RCAPDAT4/5 register is the first captured data to memory.
S     * |[20]    |CHSEL4_5  |Select Channel 4/5 to Do PDMA Transfer
S     * |        |          |0 = Channel4.
S     * |        |          |1 = Channel5.
S     * @var PWM_T::PDMACAP0_1
S     * Offset: 0x240  PWM Capture Channel 0/1 PDMA Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CAPBUF    |PWM Capture PDMA Register (Read Only)
S     * |        |          |This register is use as a buffer to transfer PWM capture rising or falling data to memory by PDMA.
S     * @var PWM_T::PDMACAP2_3
S     * Offset: 0x244  PWM Capture Channel 2/3 PDMA Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CAPBUF    |PWM Capture PDMA Register (Read Only)
S     * |        |          |This register is use as a buffer to transfer PWM capture rising or falling data to memory by PDMA.
S     * @var PWM_T::PDMACAP4_5
S     * Offset: 0x248  PWM Capture Channel 4/5 PDMA Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CAPBUF    |PWM Capture PDMA Register (Read Only)
S     * |        |          |This register is use as a buffer to transfer PWM capture rising or falling data to memory by PDMA.
S     * @var PWM_T::CAPIEN
S     * Offset: 0x250  PWM Capture Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CAPRIEN0  |PWM Capture Rising Latch Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture rising edge latch interrupt Disabled.
S     * |        |          |1 = Capture rising edge latch interrupt Enabled.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPRIENn bit must be disabled.
S     * |[1]     |CAPRIEN1  |PWM Capture Rising Latch Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture rising edge latch interrupt Disabled.
S     * |        |          |1 = Capture rising edge latch interrupt Enabled.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPRIENn bit must be disabled.
S     * |[2]     |CAPRIEN2  |PWM Capture Rising Latch Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture rising edge latch interrupt Disabled.
S     * |        |          |1 = Capture rising edge latch interrupt Enabled.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPRIENn bit must be disabled.
S     * |[3]     |CAPRIEN3  |PWM Capture Rising Latch Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture rising edge latch interrupt Disabled.
S     * |        |          |1 = Capture rising edge latch interrupt Enabled.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPRIENn bit must be disabled.
S     * |[4]     |CAPRIEN4  |PWM Capture Rising Latch Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture rising edge latch interrupt Disabled.
S     * |        |          |1 = Capture rising edge latch interrupt Enabled.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPRIENn bit must be disabled.
S     * |[5]     |CAPRIEN5  |PWM Capture Rising Latch Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture rising edge latch interrupt Disabled.
S     * |        |          |1 = Capture rising edge latch interrupt Enabled.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPRIENn bit must be disabled.
S     * |[8]     |CAPFIEN0  |PWM Capture Falling Latch Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture falling edge latch interrupt Disabled.
S     * |        |          |1 = Capture falling edge latch interrupt Enabled.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPFIENn bit must be disabled.
S     * |[9]     |CAPFIEN1  |PWM Capture Falling Latch Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture falling edge latch interrupt Disabled.
S     * |        |          |1 = Capture falling edge latch interrupt Enabled.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPFIENn bit must be disabled.
S     * |[10]    |CAPFIEN2  |PWM Capture Falling Latch Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture falling edge latch interrupt Disabled.
S     * |        |          |1 = Capture falling edge latch interrupt Enabled.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPFIENn bit must be disabled.
S     * |[11]    |CAPFIEN3  |PWM Capture Falling Latch Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture falling edge latch interrupt Disabled.
S     * |        |          |1 = Capture falling edge latch interrupt Enabled.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPFIENn bit must be disabled.
S     * |[12]    |CAPFIEN4  |PWM Capture Falling Latch Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture falling edge latch interrupt Disabled.
S     * |        |          |1 = Capture falling edge latch interrupt Enabled.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPFIENn bit must be disabled.
S     * |[13]    |CAPFIEN5  |PWM Capture Falling Latch Interrupt Enable Bits
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture falling edge latch interrupt Disabled.
S     * |        |          |1 = Capture falling edge latch interrupt Enabled.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CAPFIENn bit must be disabled.
S     * @var PWM_T::CAPIF
S     * Offset: 0x254  PWM Capture Interrupt Flag Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CRLIF0    |PWM Capture Rising Latch Interrupt Flag
S     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No capture rising latch condition happened.
S     * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CRLIFn bit will cleared by hardware after PDMA transfer data.
S     * |[1]     |CRLIF1    |PWM Capture Rising Latch Interrupt Flag
S     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No capture rising latch condition happened.
S     * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CRLIFn bit will cleared by hardware after PDMA transfer data.
S     * |[2]     |CRLIF2    |PWM Capture Rising Latch Interrupt Flag
S     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No capture rising latch condition happened.
S     * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CRLIFn bit will cleared by hardware after PDMA transfer data.
S     * |[3]     |CRLIF3    |PWM Capture Rising Latch Interrupt Flag
S     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No capture rising latch condition happened.
S     * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CRLIFn bit will cleared by hardware after PDMA transfer data.
S     * |[4]     |CRLIF4    |PWM Capture Rising Latch Interrupt Flag
S     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No capture rising latch condition happened.
S     * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CRLIFn bit will cleared by hardware after PDMA transfer data.
S     * |[5]     |CRLIF5    |PWM Capture Rising Latch Interrupt Flag
S     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No capture rising latch condition happened.
S     * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CRLIFn bit will cleared by hardware after PDMA transfer data.
S     * |[8]     |CFLIF0    |PWM Capture Falling Latch Interrupt Flag
S     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No capture falling latch condition happened.
S     * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CFLIFn bit will cleared by hardware after PDMA transfer data.
S     * |[9]     |CFLIF1    |PWM Capture Falling Latch Interrupt Flag
S     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No capture falling latch condition happened.
S     * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CFLIFn bit will cleared by hardware after PDMA transfer data.
S     * |[10]    |CFLIF2    |PWM Capture Falling Latch Interrupt Flag
S     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No capture falling latch condition happened.
S     * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CFLIFn bit will cleared by hardware after PDMA transfer data.
S     * |[11]    |CFLIF3    |PWM Capture Falling Latch Interrupt Flag
S     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No capture falling latch condition happened.
S     * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CFLIFn bit will cleared by hardware after PDMA transfer data.
S     * |[12]    |CFLIF4    |PWM Capture Falling Latch Interrupt Flag
S     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No capture falling latch condition happened.
S     * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CFLIFn bit will cleared by hardware after PDMA transfer data.
S     * |[13]    |CFLIF5    |PWM Capture Falling Latch Interrupt Flag
S     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No capture falling latch condition happened.
S     * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
S     * |        |          |Note: When Capture with PDMA operating, corresponding channel CFLIFn bit will cleared by hardware after PDMA transfer data.
S     * @var PWM_T::PBUF
S     * Offset: 0x304/0x308/0x30C/0x310/0x314/0x318  PWM PERIOD0/PERIOD1/PERIOD2/PERIOD3/PERIOD4/PERIOD5 Buffer
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |PBUF      |PWM Period Register Buffer (Read Only)
S     * |        |          |Used as PERIOD active register.
S     * @var PWM_T::CMPBUF
S     * Offset: 0x31C/0x320/0x324/0x328/0x32C/0x330  PWM CMPDAT0/CMPDAT1/CMPDAT2/CMPDAT3/CMPDAT4/CMPDAT5 Buffer
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CMPBUF    |PWM Comparator Register Buffer (Read Only)
S     * |        |          |Used as CMPDAT active register.
S     * @var PWM_T::CPSCBUF0_1
S     * Offset: 0x334  PWM CLKPSC0_1 Buffer
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |CPSCBUF   |PWM Counter Clock Pre-scale Buffer
S     * |        |          |Use as PWM counter clock pre-scare active register.
S     * @var PWM_T::CPSCBUF2_3
S     * Offset: 0x338  PWM CLKPSC2_3 Buffer
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |CPSCBUF   |PWM Counter Clock Pre-scale Buffer
S     * |        |          |Use as PWM counter clock pre-scare active register.
S     * @var PWM_T::CPSCBUF4_5
S     * Offset: 0x33C  PWM CLKPSC4_5 Buffer
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |CPSCBUF   |PWM Counter Clock Pre-scale Buffer
S     * |        |          |Use as PWM counter clock pre-scare active register.
S     * @var PWM_T::FTCBUF0_1
S     * Offset: 0x340  PWM FTCMPDAT0_1 Buffer
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FTCMPBUF  |PWM FTCMPDAT Buffer (Read Only)
S     * |        |          |Used as FTCMPDAT active register.
S     * @var PWM_T::FTCBUF2_3
S     * Offset: 0x344  PWM FTCMPDAT2_3 Buffer
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FTCMPBUF  |PWM FTCMPDAT Buffer (Read Only)
S     * |        |          |Used as FTCMPDAT active register.
S     * @var PWM_T::FTCBUF4_5
S     * Offset: 0x348  PWM FTCMPDAT4_5 Buffer
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FTCMPBUF  |PWM FTCMPDAT Buffer (Read Only)
S     * |        |          |Used as FTCMPDAT active register.
S     * @var PWM_T::FTCI
S     * Offset: 0x34C  PWM FTCMPDAT Indicator Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |FTCMU0    |PWM FTCMPDAT Up Indicator
S     * |        |          |Indicator will be set to high when FTCMPDATn(PWM_CTCMPDATn[15:0]) bits equal to PERIOD(PWM_PERIODn[15:0]) bitsn and DIRF(PWM_CNTn[16])= bit is 1, software can write 1 to clear this bit.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |[1]     |FTCMU2    |PWM FTCMPDAT Up Indicator
S     * |        |          |Indicator will be set to high when FTCMPDATn(PWM_CTCMPDATn[15:0]) bits equal to PERIOD(PWM_PERIODn[15:0]) bitsn and DIRF(PWM_CNTn[16])= bit is 1, software can write 1 to clear this bit.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |[2]     |FTCMU4    |PWM FTCMPDAT Up Indicator
S     * |        |          |Indicator will be set to high when FTCMPDATn(PWM_CTCMPDATn[15:0]) bits equal to PERIOD(PWM_PERIODn[15:0]) bitsn and DIRF(PWM_CNTn[16])= bit is 1, software can write 1 to clear this bit.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |[8]     |FTCMD0    |PWM FTCMPDAT Down Indicator
S     * |        |          |Indicator will be set to high when FTCMPDATn(PWM_FTCMPDATn[15:0]) bits equal to PERIODn(PWM_PERIODn[15:0]) bits and DIRF(PWM_CNTn[16]) bit= is 0, software can write 1 to clear this bit.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |[9]     |FTCMD2    |PWM FTCMPDAT Down Indicator
S     * |        |          |Indicator will be set to high when FTCMPDATn(PWM_FTCMPDATn[15:0]) bits equal to PERIODn(PWM_PERIODn[15:0]) bits and DIRF(PWM_CNTn[16]) bit= is 0, software can write 1 to clear this bit.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |[10]    |FTCMD4    |PWM FTCMPDAT Down Indicator
S     * |        |          |Indicator will be set to high when FTCMPDATn(PWM_FTCMPDATn[15:0]) bits equal to PERIODn(PWM_PERIODn[15:0]) bits and DIRF(PWM_CNTn[16]) bit= is 0, software can write 1 to clear this bit.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     */
S
S    __IO uint32_t CTL0;                  /*!< [0x0000] PWM Control Register 0                                           */
S    __IO uint32_t CTL1;                  /*!< [0x0004] PWM Control Register 1                                           */
S    __IO uint32_t SYNC;                  /*!< [0x0008] PWM Synchronization Register                                     */
S    __IO uint32_t SWSYNC;                /*!< [0x000c] PWM Software Control Synchronization Register                    */
S    __IO uint32_t CLKSRC;                /*!< [0x0010] PWM Clock Source Register                                        */
S    __IO uint32_t CLKPSC0_1;             /*!< [0x0014] PWM Clock Pre-scale Register 0/1                                 */
S    __IO uint32_t CLKPSC2_3;             /*!< [0x0018] PWM Clock Pre-scale Register 2/3                                 */
S    __IO uint32_t CLKPSC4_5;             /*!< [0x001c] PWM Clock Pre-scale Register 4/5                                 */
S    __IO uint32_t CNTEN;                 /*!< [0x0020] PWM Counter Enable Register                                      */
S    __IO uint32_t CNTCLR;                /*!< [0x0024] PWM Clear Counter Register                                       */
S    __IO uint32_t LOAD;                  /*!< [0x0028] PWM Load Register                                                */
S    __I  uint32_t RESERVE0[1];
S    __IO uint32_t PERIOD[6];             /*!< [0x0030~0x0044]  PWM Period Register 0~5                                  */
S    __I  uint32_t RESERVE1[2];
S    __IO uint32_t CMPDAT[6];             /*!< [0x0050~0x0064]  PWM Comparator Register 0~5                              */
S    __I  uint32_t RESERVE2[2];
S    __IO uint32_t DTCTL0_1;              /*!< [0x0070] PWM Dead-Time Control Register 0/1                               */
S    __IO uint32_t DTCTL2_3;              /*!< [0x0074] PWM Dead-Time Control Register 2/3                               */
S    __IO uint32_t DTCTL4_5;              /*!< [0x0078] PWM Dead-Time Control Register 4/5                               */
S    __I  uint32_t RESERVE3[1];
S    __IO uint32_t PHS0_1;                /*!< [0x0080] PWM Counter Phase Register 0/1                                   */
S    __IO uint32_t PHS2_3;                /*!< [0x0084] PWM Counter Phase Register 2/3                                   */
S    __IO uint32_t PHS4_5;                /*!< [0x0088] PWM Counter Phase Register 4/5                                   */
S    __I  uint32_t RESERVE4[1];
S    __I  uint32_t CNT[6];                /*!< [0x0090~0x00A4  PWM Counter Register 0~5                                  */
S    __I  uint32_t RESERVE5[2];
S    __IO uint32_t WGCTL0;                /*!< [0x00b0] PWM Generation Register 0                                        */
S    __IO uint32_t WGCTL1;                /*!< [0x00b4] PWM Generation Register 1                                        */
S    __IO uint32_t MSKEN;                 /*!< [0x00b8] PWM Mask Enable Register                                         */
S    __IO uint32_t MSK;                   /*!< [0x00bc] PWM Mask Data Register                                           */
S    __IO uint32_t BNF;                   /*!< [0x00c0] PWM Brake Noise Filter Register                                  */
S    __IO uint32_t FAILBRK;               /*!< [0x00c4] PWM System Fail Brake Control Register                           */
S    __IO uint32_t BRKCTL0_1;             /*!< [0x00c8] PWM Brake Edge Detect Control Register 0/1                       */
S    __IO uint32_t BRKCTL2_3;             /*!< [0x00cc] PWM Brake Edge Detect Control Register 2/3                       */
S    __IO uint32_t BRKCTL4_5;             /*!< [0x00d0] PWM Brake Edge Detect Control Register 4/5                       */
S    __IO uint32_t POLCTL;                /*!< [0x00d4] PWM Pin Polar Inverse Register                                   */
S    __IO uint32_t POEN;                  /*!< [0x00d8] PWM Output Enable Register                                       */
S    __O  uint32_t SWBRK;                 /*!< [0x00dc] PWM Software Brake Control Register                              */
S    __IO uint32_t INTEN0;                /*!< [0x00e0] PWM Interrupt Enable Register 0                                  */
S    __IO uint32_t INTEN1;                /*!< [0x00e4] PWM Interrupt Enable Register 1                                  */
S    __IO uint32_t INTSTS0;               /*!< [0x00e8] PWM Interrupt Flag Register 0                                    */
S    __IO uint32_t INTSTS1;               /*!< [0x00ec] PWM Interrupt Flag Register 1                                    */
S    __IO uint32_t IFA;                   /*!< [0x00f0] PWM Interrupt Flag Accumulator Register                          */
S    __I  uint32_t RESERVE6[1];
S    __IO uint32_t ADCTS0;                /*!< [0x00f8] PWM Trigger ADC Source Select Register 0                         */
S    __IO uint32_t ADCTS1;                /*!< [0x00fc] PWM Trigger ADC Source Select Register 1                         */
S    __IO uint32_t FTCMPDAT0_1;           /*!< [0x0100] PWM Free Trigger Compare Register 0/1                            */
S    __IO uint32_t FTCMPDAT2_3;           /*!< [0x0104] PWM Free Trigger Compare Register 2/3                            */
S    __IO uint32_t FTCMPDAT4_5;           /*!< [0x0108] PWM Free Trigger Compare Register 4/5                            */
S    __I  uint32_t RESERVE7[1];
S    __IO uint32_t SSCTL;                 /*!< [0x0110] PWM Synchronous Start Control Register                           */
S    __O  uint32_t SSTRG;                 /*!< [0x0114] PWM Synchronous Start Trigger Register                           */
S    __IO uint32_t LEBCTL;                /*!< [0x0118] PWM Leading Edge Blanking Control Register                       */
S    __IO uint32_t LEBCNT;                /*!< [0x011c] PWM Leading Edge Blanking Counter Register                       */
S    __IO uint32_t STATUS;                /*!< [0x0120] PWM Status Register                                              */
S    __I  uint32_t RESERVE8[55];
S    __IO uint32_t CAPINEN;               /*!< [0x0200] PWM Capture Input Enable Register                                */
S    __IO uint32_t CAPCTL;                /*!< [0x0204] PWM Capture Control Register                                     */
S    __I  uint32_t CAPSTS;                /*!< [0x0208] PWM Capture Status Register                                      */
S    __I  uint32_t RCAPDAT0;              /*!< [0x020c] PWM Rising Capture Data Register 0                               */
S    __I  uint32_t FCAPDAT0;              /*!< [0x0210] PWM Falling Capture Data Register 0                              */
S    __I  uint32_t RCAPDAT1;              /*!< [0x0214] PWM Rising Capture Data Register 1                               */
S    __I  uint32_t FCAPDAT1;              /*!< [0x0218] PWM Falling Capture Data Register 1                              */
S    __I  uint32_t RCAPDAT2;              /*!< [0x021c] PWM Rising Capture Data Register 2                               */
S    __I  uint32_t FCAPDAT2;              /*!< [0x0220] PWM Falling Capture Data Register 2                              */
S    __I  uint32_t RCAPDAT3;              /*!< [0x0224] PWM Rising Capture Data Register 3                               */
S    __I  uint32_t FCAPDAT3;              /*!< [0x0228] PWM Falling Capture Data Register 3                              */
S    __I  uint32_t RCAPDAT4;              /*!< [0x022c] PWM Rising Capture Data Register 4                               */
S    __I  uint32_t FCAPDAT4;              /*!< [0x0230] PWM Falling Capture Data Register 4                              */
S    __I  uint32_t RCAPDAT5;              /*!< [0x0234] PWM Rising Capture Data Register 5                               */
S    __I  uint32_t FCAPDAT5;              /*!< [0x0238] PWM Falling Capture Data Register 5                              */
S    __IO uint32_t PDMACTL;               /*!< [0x023c] PWM PDMA Control Register                                        */
S    __I  uint32_t PDMACAP0_1;            /*!< [0x0240] PWM Capture Channel 0/1 PDMA Register                            */
S    __I  uint32_t PDMACAP2_3;            /*!< [0x0244] PWM Capture Channel 2/3 PDMA Register                            */
S    __I  uint32_t PDMACAP4_5;            /*!< [0x0248] PWM Capture Channel 4/5 PDMA Register                            */
S    __I  uint32_t RESERVE9[1];
S    __IO uint32_t CAPIEN;                /*!< [0x0250] PWM Capture Interrupt Enable Register                            */
S    __IO uint32_t CAPIF;                 /*!< [0x0254] PWM Capture Interrupt Flag Register                              */
S    __I  uint32_t RESERVE10[43];
S    __I  uint32_t PBUF[6];               /*!< [0x0304~0x0318  PWM PERIOD0~5 Buffer                                      */
S    __I  uint32_t CMPBUF[6];             /*!< [0x031C~0x0330  PWM CMPDAT0~5 Buffer                                      */
S    __I  uint32_t CPSCBUF0_1;            /*!< [0x0334] PWM CLKPSC0_1 Buffer                                             */
S    __I  uint32_t CPSCBUF2_3;            /*!< [0x0338] PWM CLKPSC2_3 Buffer                                             */
S    __I  uint32_t CPSCBUF4_5;            /*!< [0x033c] PWM CLKPSC4_5 Buffer                                             */
S    __I  uint32_t FTCBUF0_1;             /*!< [0x0340] PWM FTCMPDAT0_1 Buffer                                           */
S    __I  uint32_t FTCBUF2_3;             /*!< [0x0344] PWM FTCMPDAT2_3 Buffer                                           */
S    __I  uint32_t FTCBUF4_5;             /*!< [0x0348] PWM FTCMPDAT4_5 Buffer                                           */
S    __IO uint32_t FTCI;                  /*!< [0x034c] PWM FTCMPDAT Indicator Register                                  */
S
S
S} PWM_T;
S
S/**
S    @addtogroup PWM_CONST PWM Bit Field Definition
S    Constant Definitions for PWM Controller
S@{ */
S
S#define PWM_CTL0_CTRLD0_Pos              (0)                                               /*!< PWM_T::CTL0: CTRLD0 Position           */
S#define PWM_CTL0_CTRLD0_Msk              (0x1ul << PWM_CTL0_CTRLD0_Pos)                    /*!< PWM_T::CTL0: CTRLD0 Mask               */
S
S#define PWM_CTL0_CTRLD1_Pos              (1)                                               /*!< PWM_T::CTL0: CTRLD1 Position           */
S#define PWM_CTL0_CTRLD1_Msk              (0x1ul << PWM_CTL0_CTRLD1_Pos)                    /*!< PWM_T::CTL0: CTRLD1 Mask               */
S
S#define PWM_CTL0_CTRLD2_Pos              (2)                                               /*!< PWM_T::CTL0: CTRLD2 Position           */
S#define PWM_CTL0_CTRLD2_Msk              (0x1ul << PWM_CTL0_CTRLD2_Pos)                    /*!< PWM_T::CTL0: CTRLD2 Mask               */
S
S#define PWM_CTL0_CTRLD3_Pos              (3)                                               /*!< PWM_T::CTL0: CTRLD3 Position           */
S#define PWM_CTL0_CTRLD3_Msk              (0x1ul << PWM_CTL0_CTRLD3_Pos)                    /*!< PWM_T::CTL0: CTRLD3 Mask               */
S
S#define PWM_CTL0_CTRLD4_Pos              (4)                                               /*!< PWM_T::CTL0: CTRLD4 Position           */
S#define PWM_CTL0_CTRLD4_Msk              (0x1ul << PWM_CTL0_CTRLD4_Pos)                    /*!< PWM_T::CTL0: CTRLD4 Mask               */
S
S#define PWM_CTL0_CTRLD5_Pos              (5)                                               /*!< PWM_T::CTL0: CTRLD5 Position           */
S#define PWM_CTL0_CTRLD5_Msk              (0x1ul << PWM_CTL0_CTRLD5_Pos)                    /*!< PWM_T::CTL0: CTRLD5 Mask               */
S
S#define PWM_CTL0_WINLDEN0_Pos            (8)                                               /*!< PWM_T::CTL0: WINLDEN0 Position         */
S#define PWM_CTL0_WINLDEN0_Msk            (0x1ul << PWM_CTL0_WINLDEN0_Pos)                  /*!< PWM_T::CTL0: WINLDEN0 Mask             */
S
S#define PWM_CTL0_WINLDEN1_Pos            (9)                                               /*!< PWM_T::CTL0: WINLDEN1 Position         */
S#define PWM_CTL0_WINLDEN1_Msk            (0x1ul << PWM_CTL0_WINLDEN1_Pos)                  /*!< PWM_T::CTL0: WINLDEN1 Mask             */
S
S#define PWM_CTL0_WINLDEN2_Pos            (10)                                              /*!< PWM_T::CTL0: WINLDEN2 Position         */
S#define PWM_CTL0_WINLDEN2_Msk            (0x1ul << PWM_CTL0_WINLDEN2_Pos)                  /*!< PWM_T::CTL0: WINLDEN2 Mask             */
S
S#define PWM_CTL0_WINLDEN3_Pos            (11)                                              /*!< PWM_T::CTL0: WINLDEN3 Position         */
S#define PWM_CTL0_WINLDEN3_Msk            (0x1ul << PWM_CTL0_WINLDEN3_Pos)                  /*!< PWM_T::CTL0: WINLDEN3 Mask             */
S
S#define PWM_CTL0_WINLDEN4_Pos            (12)                                              /*!< PWM_T::CTL0: WINLDEN4 Position         */
S#define PWM_CTL0_WINLDEN4_Msk            (0x1ul << PWM_CTL0_WINLDEN4_Pos)                  /*!< PWM_T::CTL0: WINLDEN4 Mask             */
S
S#define PWM_CTL0_WINLDEN5_Pos            (13)                                              /*!< PWM_T::CTL0: WINLDEN5 Position         */
S#define PWM_CTL0_WINLDEN5_Msk            (0x1ul << PWM_CTL0_WINLDEN5_Pos)                  /*!< PWM_T::CTL0: WINLDEN5 Mask             */
S
S#define PWM_CTL0_IMMLDEN0_Pos            (16)                                              /*!< PWM_T::CTL0: IMMLDEN0 Position         */
S#define PWM_CTL0_IMMLDEN0_Msk            (0x1ul << PWM_CTL0_IMMLDEN0_Pos)                  /*!< PWM_T::CTL0: IMMLDEN0 Mask             */
S
S#define PWM_CTL0_IMMLDEN1_Pos            (17)                                              /*!< PWM_T::CTL0: IMMLDEN1 Position         */
S#define PWM_CTL0_IMMLDEN1_Msk            (0x1ul << PWM_CTL0_IMMLDEN1_Pos)                  /*!< PWM_T::CTL0: IMMLDEN1 Mask             */
S
S#define PWM_CTL0_IMMLDEN2_Pos            (18)                                              /*!< PWM_T::CTL0: IMMLDEN2 Position         */
S#define PWM_CTL0_IMMLDEN2_Msk            (0x1ul << PWM_CTL0_IMMLDEN2_Pos)                  /*!< PWM_T::CTL0: IMMLDEN2 Mask             */
S
S#define PWM_CTL0_IMMLDEN3_Pos            (19)                                              /*!< PWM_T::CTL0: IMMLDEN3 Position         */
S#define PWM_CTL0_IMMLDEN3_Msk            (0x1ul << PWM_CTL0_IMMLDEN3_Pos)                  /*!< PWM_T::CTL0: IMMLDEN3 Mask             */
S
S#define PWM_CTL0_IMMLDEN4_Pos            (20)                                              /*!< PWM_T::CTL0: IMMLDEN4 Position         */
S#define PWM_CTL0_IMMLDEN4_Msk            (0x1ul << PWM_CTL0_IMMLDEN4_Pos)                  /*!< PWM_T::CTL0: IMMLDEN4 Mask             */
S
S#define PWM_CTL0_IMMLDEN5_Pos            (21)                                              /*!< PWM_T::CTL0: IMMLDEN5 Position         */
S#define PWM_CTL0_IMMLDEN5_Msk            (0x1ul << PWM_CTL0_IMMLDEN5_Pos)                  /*!< PWM_T::CTL0: IMMLDEN5 Mask             */
S
S#define PWM_CTL0_GROUPEN_Pos             (24)                                              /*!< PWM_T::CTL0: GROUPEN Position          */
S#define PWM_CTL0_GROUPEN_Msk             (0x1ul << PWM_CTL0_GROUPEN_Pos)                   /*!< PWM_T::CTL0: GROUPEN Mask              */
S
S#define PWM_CTL0_DBGHALT_Pos             (30)                                              /*!< PWM_T::CTL0: DBGHALT Position          */
S#define PWM_CTL0_DBGHALT_Msk             (0x1ul << PWM_CTL0_DBGHALT_Pos)                   /*!< PWM_T::CTL0: DBGHALT Mask              */
S
S#define PWM_CTL0_DBGTRIOFF_Pos           (31)                                              /*!< PWM_T::CTL0: DBGTRIOFF Position        */
S#define PWM_CTL0_DBGTRIOFF_Msk           (0x1ul << PWM_CTL0_DBGTRIOFF_Pos)                 /*!< PWM_T::CTL0: DBGTRIOFF Mask            */
S
S#define PWM_CTL1_CNTTYPE0_Pos            (0)                                               /*!< PWM_T::CTL1: CNTTYPE0 Position         */
S#define PWM_CTL1_CNTTYPE0_Msk            (0x3ul << PWM_CTL1_CNTTYPE0_Pos)                  /*!< PWM_T::CTL1: CNTTYPE0 Mask             */
S
S#define PWM_CTL1_CNTTYPE1_Pos            (2)                                               /*!< PWM_T::CTL1: CNTTYPE1 Position         */
S#define PWM_CTL1_CNTTYPE1_Msk            (0x3ul << PWM_CTL1_CNTTYPE1_Pos)                  /*!< PWM_T::CTL1: CNTTYPE1 Mask             */
S
S#define PWM_CTL1_CNTTYPE2_Pos            (4)                                               /*!< PWM_T::CTL1: CNTTYPE2 Position         */
S#define PWM_CTL1_CNTTYPE2_Msk            (0x3ul << PWM_CTL1_CNTTYPE2_Pos)                  /*!< PWM_T::CTL1: CNTTYPE2 Mask             */
S
S#define PWM_CTL1_CNTTYPE3_Pos            (6)                                               /*!< PWM_T::CTL1: CNTTYPE3 Position         */
S#define PWM_CTL1_CNTTYPE3_Msk            (0x3ul << PWM_CTL1_CNTTYPE3_Pos)                  /*!< PWM_T::CTL1: CNTTYPE3 Mask             */
S
S#define PWM_CTL1_CNTTYPE4_Pos            (8)                                               /*!< PWM_T::CTL1: CNTTYPE4 Position         */
S#define PWM_CTL1_CNTTYPE4_Msk            (0x3ul << PWM_CTL1_CNTTYPE4_Pos)                  /*!< PWM_T::CTL1: CNTTYPE4 Mask             */
S
S#define PWM_CTL1_CNTTYPE5_Pos            (10)                                              /*!< PWM_T::CTL1: CNTTYPE5 Position         */
S#define PWM_CTL1_CNTTYPE5_Msk            (0x3ul << PWM_CTL1_CNTTYPE5_Pos)                  /*!< PWM_T::CTL1: CNTTYPE5 Mask             */
S
S#define PWM_CTL1_CNTMODE0_Pos            (16)                                              /*!< PWM_T::CTL1: CNTMODE0 Position         */
S#define PWM_CTL1_CNTMODE0_Msk            (0x1ul << PWM_CTL1_CNTMODE0_Pos)                  /*!< PWM_T::CTL1: CNTMODE0 Mask             */
S
S#define PWM_CTL1_CNTMODE1_Pos            (17)                                              /*!< PWM_T::CTL1: CNTMODE1 Position         */
S#define PWM_CTL1_CNTMODE1_Msk            (0x1ul << PWM_CTL1_CNTMODE1_Pos)                  /*!< PWM_T::CTL1: CNTMODE1 Mask             */
S
S#define PWM_CTL1_CNTMODE2_Pos            (18)                                              /*!< PWM_T::CTL1: CNTMODE2 Position         */
S#define PWM_CTL1_CNTMODE2_Msk            (0x1ul << PWM_CTL1_CNTMODE2_Pos)                  /*!< PWM_T::CTL1: CNTMODE2 Mask             */
S
S#define PWM_CTL1_CNTMODE3_Pos            (19)                                              /*!< PWM_T::CTL1: CNTMODE3 Position         */
S#define PWM_CTL1_CNTMODE3_Msk            (0x1ul << PWM_CTL1_CNTMODE3_Pos)                  /*!< PWM_T::CTL1: CNTMODE3 Mask             */
S
S#define PWM_CTL1_CNTMODE4_Pos            (20)                                              /*!< PWM_T::CTL1: CNTMODE4 Position         */
S#define PWM_CTL1_CNTMODE4_Msk            (0x1ul << PWM_CTL1_CNTMODE4_Pos)                  /*!< PWM_T::CTL1: CNTMODE4 Mask             */
S
S#define PWM_CTL1_CNTMODE5_Pos            (21)                                              /*!< PWM_T::CTL1: CNTMODE5 Position         */
S#define PWM_CTL1_CNTMODE5_Msk            (0x1ul << PWM_CTL1_CNTMODE5_Pos)                  /*!< PWM_T::CTL1: CNTMODE5 Mask             */
S
S#define PWM_CTL1_OUTMODE0_Pos            (24)                                              /*!< PWM_T::CTL1: OUTMODE0 Position         */
S#define PWM_CTL1_OUTMODE0_Msk            (0x1ul << PWM_CTL1_OUTMODE0_Pos)                  /*!< PWM_T::CTL1: OUTMODE0 Mask             */
S
S#define PWM_CTL1_OUTMODE2_Pos            (25)                                              /*!< PWM_T::CTL1: OUTMODE2 Position         */
S#define PWM_CTL1_OUTMODE2_Msk            (0x1ul << PWM_CTL1_OUTMODE2_Pos)                  /*!< PWM_T::CTL1: OUTMODE2 Mask             */
S
S#define PWM_CTL1_OUTMODE4_Pos            (26)                                              /*!< PWM_T::CTL1: OUTMODE4 Position         */
S#define PWM_CTL1_OUTMODE4_Msk            (0x1ul << PWM_CTL1_OUTMODE4_Pos)                  /*!< PWM_T::CTL1: OUTMODE4 Mask             */
S
S#define PWM_SYNC_PHSEN0_Pos              (0)                                               /*!< PWM_T::SYNC: PHSEN0 Position           */
S#define PWM_SYNC_PHSEN0_Msk              (0x1ul << PWM_SYNC_PHSEN0_Pos)                    /*!< PWM_T::SYNC: PHSEN0 Mask               */
S
S#define PWM_SYNC_PHSEN2_Pos              (1)                                               /*!< PWM_T::SYNC: PHSEN2 Position           */
S#define PWM_SYNC_PHSEN2_Msk              (0x1ul << PWM_SYNC_PHSEN2_Pos)                    /*!< PWM_T::SYNC: PHSEN2 Mask               */
S
S#define PWM_SYNC_PHSEN4_Pos              (2)                                               /*!< PWM_T::SYNC: PHSEN4 Position           */
S#define PWM_SYNC_PHSEN4_Msk              (0x1ul << PWM_SYNC_PHSEN4_Pos)                    /*!< PWM_T::SYNC: PHSEN4 Mask               */
S
S#define PWM_SYNC_SINSRC0_Pos             (8)                                               /*!< PWM_T::SYNC: SINSRC0 Position          */
S#define PWM_SYNC_SINSRC0_Msk             (0x3ul << PWM_SYNC_SINSRC0_Pos)                   /*!< PWM_T::SYNC: SINSRC0 Mask              */
S
S#define PWM_SYNC_SINSRC2_Pos             (10)                                              /*!< PWM_T::SYNC: SINSRC2 Position          */
S#define PWM_SYNC_SINSRC2_Msk             (0x3ul << PWM_SYNC_SINSRC2_Pos)                   /*!< PWM_T::SYNC: SINSRC2 Mask              */
S
S#define PWM_SYNC_SINSRC4_Pos             (12)                                              /*!< PWM_T::SYNC: SINSRC4 Position          */
S#define PWM_SYNC_SINSRC4_Msk             (0x3ul << PWM_SYNC_SINSRC4_Pos)                   /*!< PWM_T::SYNC: SINSRC4 Mask              */
S
S#define PWM_SYNC_SNFLTEN_Pos             (16)                                              /*!< PWM_T::SYNC: SNFLTEN Position          */
S#define PWM_SYNC_SNFLTEN_Msk             (0x1ul << PWM_SYNC_SNFLTEN_Pos)                   /*!< PWM_T::SYNC: SNFLTEN Mask              */
S
S#define PWM_SYNC_SFLTCSEL_Pos            (17)                                              /*!< PWM_T::SYNC: SFLTCSEL Position         */
S#define PWM_SYNC_SFLTCSEL_Msk            (0x7ul << PWM_SYNC_SFLTCSEL_Pos)                  /*!< PWM_T::SYNC: SFLTCSEL Mask             */
S
S#define PWM_SYNC_SFLTCNT_Pos             (20)                                              /*!< PWM_T::SYNC: SFLTCNT Position          */
S#define PWM_SYNC_SFLTCNT_Msk             (0x7ul << PWM_SYNC_SFLTCNT_Pos)                   /*!< PWM_T::SYNC: SFLTCNT Mask              */
S
S#define PWM_SYNC_SINPINV_Pos             (23)                                              /*!< PWM_T::SYNC: SINPINV Position          */
S#define PWM_SYNC_SINPINV_Msk             (0x1ul << PWM_SYNC_SINPINV_Pos)                   /*!< PWM_T::SYNC: SINPINV Mask              */
S
S#define PWM_SYNC_PHSDIR0_Pos             (24)                                              /*!< PWM_T::SYNC: PHSDIR0 Position          */
S#define PWM_SYNC_PHSDIR0_Msk             (0x1ul << PWM_SYNC_PHSDIR0_Pos)                   /*!< PWM_T::SYNC: PHSDIR0 Mask              */
S
S#define PWM_SYNC_PHSDIR2_Pos             (25)                                              /*!< PWM_T::SYNC: PHSDIR2 Position          */
S#define PWM_SYNC_PHSDIR2_Msk             (0x1ul << PWM_SYNC_PHSDIR2_Pos)                   /*!< PWM_T::SYNC: PHSDIR2 Mask              */
S
S#define PWM_SYNC_PHSDIR4_Pos             (26)                                              /*!< PWM_T::SYNC: PHSDIR4 Position          */
S#define PWM_SYNC_PHSDIR4_Msk             (0x1ul << PWM_SYNC_PHSDIR4_Pos)                   /*!< PWM_T::SYNC: PHSDIR4 Mask              */
S
S#define PWM_SWSYNC_SWSYNC0_Pos           (0)                                               /*!< PWM_T::SWSYNC: SWSYNC0 Position        */
S#define PWM_SWSYNC_SWSYNC0_Msk           (0x1ul << PWM_SWSYNC_SWSYNC0_Pos)                 /*!< PWM_T::SWSYNC: SWSYNC0 Mask            */
S
S#define PWM_SWSYNC_SWSYNC2_Pos           (1)                                               /*!< PWM_T::SWSYNC: SWSYNC2 Position        */
S#define PWM_SWSYNC_SWSYNC2_Msk           (0x1ul << PWM_SWSYNC_SWSYNC2_Pos)                 /*!< PWM_T::SWSYNC: SWSYNC2 Mask            */
S
S#define PWM_SWSYNC_SWSYNC4_Pos           (2)                                               /*!< PWM_T::SWSYNC: SWSYNC4 Position        */
S#define PWM_SWSYNC_SWSYNC4_Msk           (0x1ul << PWM_SWSYNC_SWSYNC4_Pos)                 /*!< PWM_T::SWSYNC: SWSYNC4 Mask            */
S
S#define PWM_CLKSRC_ECLKSRC0_Pos          (0)                                               /*!< PWM_T::CLKSRC: ECLKSRC0 Position       */
S#define PWM_CLKSRC_ECLKSRC0_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC0_Pos)                /*!< PWM_T::CLKSRC: ECLKSRC0 Mask           */
S
S#define PWM_CLKSRC_ECLKSRC2_Pos          (8)                                               /*!< PWM_T::CLKSRC: ECLKSRC2 Position       */
S#define PWM_CLKSRC_ECLKSRC2_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC2_Pos)                /*!< PWM_T::CLKSRC: ECLKSRC2 Mask           */
S
S#define PWM_CLKSRC_ECLKSRC4_Pos          (16)                                              /*!< PWM_T::CLKSRC: ECLKSRC4 Position       */
S#define PWM_CLKSRC_ECLKSRC4_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC4_Pos)                /*!< PWM_T::CLKSRC: ECLKSRC4 Mask           */
S
S#define PWM_CLKPSC0_1_CLKPSC_Pos         (0)                                               /*!< PWM_T::CLKPSC0_1: CLKPSC Position      */
S#define PWM_CLKPSC0_1_CLKPSC_Msk         (0xffful << PWM_CLKPSC0_1_CLKPSC_Pos)             /*!< PWM_T::CLKPSC0_1: CLKPSC Mask          */
S
S#define PWM_CLKPSC2_3_CLKPSC_Pos         (0)                                               /*!< PWM_T::CLKPSC2_3: CLKPSC Position      */
S#define PWM_CLKPSC2_3_CLKPSC_Msk         (0xffful << PWM_CLKPSC2_3_CLKPSC_Pos)             /*!< PWM_T::CLKPSC2_3: CLKPSC Mask          */
S
S#define PWM_CLKPSC4_5_CLKPSC_Pos         (0)                                               /*!< PWM_T::CLKPSC4_5: CLKPSC Position      */
S#define PWM_CLKPSC4_5_CLKPSC_Msk         (0xffful << PWM_CLKPSC4_5_CLKPSC_Pos)             /*!< PWM_T::CLKPSC4_5: CLKPSC Mask          */
S
S#define PWM_CNTEN_CNTEN0_Pos             (0)                                               /*!< PWM_T::CNTEN: CNTEN0 Position          */
S#define PWM_CNTEN_CNTEN0_Msk             (0x1ul << PWM_CNTEN_CNTEN0_Pos)                   /*!< PWM_T::CNTEN: CNTEN0 Mask              */
S
S#define PWM_CNTEN_CNTEN1_Pos             (1)                                               /*!< PWM_T::CNTEN: CNTEN1 Position          */
S#define PWM_CNTEN_CNTEN1_Msk             (0x1ul << PWM_CNTEN_CNTEN1_Pos)                   /*!< PWM_T::CNTEN: CNTEN1 Mask              */
S
S#define PWM_CNTEN_CNTEN2_Pos             (2)                                               /*!< PWM_T::CNTEN: CNTEN2 Position          */
S#define PWM_CNTEN_CNTEN2_Msk             (0x1ul << PWM_CNTEN_CNTEN2_Pos)                   /*!< PWM_T::CNTEN: CNTEN2 Mask              */
S
S#define PWM_CNTEN_CNTEN3_Pos             (3)                                               /*!< PWM_T::CNTEN: CNTEN3 Position          */
S#define PWM_CNTEN_CNTEN3_Msk             (0x1ul << PWM_CNTEN_CNTEN3_Pos)                   /*!< PWM_T::CNTEN: CNTEN3 Mask              */
S
S#define PWM_CNTEN_CNTEN4_Pos             (4)                                               /*!< PWM_T::CNTEN: CNTEN4 Position          */
S#define PWM_CNTEN_CNTEN4_Msk             (0x1ul << PWM_CNTEN_CNTEN4_Pos)                   /*!< PWM_T::CNTEN: CNTEN4 Mask              */
S
S#define PWM_CNTEN_CNTEN5_Pos             (5)                                               /*!< PWM_T::CNTEN: CNTEN5 Position          */
S#define PWM_CNTEN_CNTEN5_Msk             (0x1ul << PWM_CNTEN_CNTEN5_Pos)                   /*!< PWM_T::CNTEN: CNTEN5 Mask              */
S
S#define PWM_CNTCLR_CNTCLR0_Pos           (0)                                               /*!< PWM_T::CNTCLR: CNTCLR0 Position        */
S#define PWM_CNTCLR_CNTCLR0_Msk           (0x1ul << PWM_CNTCLR_CNTCLR0_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR0 Mask            */
S
S#define PWM_CNTCLR_CNTCLR1_Pos           (1)                                               /*!< PWM_T::CNTCLR: CNTCLR1 Position        */
S#define PWM_CNTCLR_CNTCLR1_Msk           (0x1ul << PWM_CNTCLR_CNTCLR1_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR1 Mask            */
S
S#define PWM_CNTCLR_CNTCLR2_Pos           (2)                                               /*!< PWM_T::CNTCLR: CNTCLR2 Position        */
S#define PWM_CNTCLR_CNTCLR2_Msk           (0x1ul << PWM_CNTCLR_CNTCLR2_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR2 Mask            */
S
S#define PWM_CNTCLR_CNTCLR3_Pos           (3)                                               /*!< PWM_T::CNTCLR: CNTCLR3 Position        */
S#define PWM_CNTCLR_CNTCLR3_Msk           (0x1ul << PWM_CNTCLR_CNTCLR3_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR3 Mask            */
S
S#define PWM_CNTCLR_CNTCLR4_Pos           (4)                                               /*!< PWM_T::CNTCLR: CNTCLR4 Position        */
S#define PWM_CNTCLR_CNTCLR4_Msk           (0x1ul << PWM_CNTCLR_CNTCLR4_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR4 Mask            */
S
S#define PWM_CNTCLR_CNTCLR5_Pos           (5)                                               /*!< PWM_T::CNTCLR: CNTCLR5 Position        */
S#define PWM_CNTCLR_CNTCLR5_Msk           (0x1ul << PWM_CNTCLR_CNTCLR5_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR5 Mask            */
S
S#define PWM_LOAD_LOAD0_Pos               (0)                                               /*!< PWM_T::LOAD: LOAD0 Position            */
S#define PWM_LOAD_LOAD0_Msk               (0x1ul << PWM_LOAD_LOAD0_Pos)                     /*!< PWM_T::LOAD: LOAD0 Mask                */
S
S#define PWM_LOAD_LOAD1_Pos               (1)                                               /*!< PWM_T::LOAD: LOAD1 Position            */
S#define PWM_LOAD_LOAD1_Msk               (0x1ul << PWM_LOAD_LOAD1_Pos)                     /*!< PWM_T::LOAD: LOAD1 Mask                */
S
S#define PWM_LOAD_LOAD2_Pos               (2)                                               /*!< PWM_T::LOAD: LOAD2 Position            */
S#define PWM_LOAD_LOAD2_Msk               (0x1ul << PWM_LOAD_LOAD2_Pos)                     /*!< PWM_T::LOAD: LOAD2 Mask                */
S
S#define PWM_LOAD_LOAD3_Pos               (3)                                               /*!< PWM_T::LOAD: LOAD3 Position            */
S#define PWM_LOAD_LOAD3_Msk               (0x1ul << PWM_LOAD_LOAD3_Pos)                     /*!< PWM_T::LOAD: LOAD3 Mask                */
S
S#define PWM_LOAD_LOAD4_Pos               (4)                                               /*!< PWM_T::LOAD: LOAD4 Position            */
S#define PWM_LOAD_LOAD4_Msk               (0x1ul << PWM_LOAD_LOAD4_Pos)                     /*!< PWM_T::LOAD: LOAD4 Mask                */
S
S#define PWM_LOAD_LOAD5_Pos               (5)                                               /*!< PWM_T::LOAD: LOAD5 Position            */
S#define PWM_LOAD_LOAD5_Msk               (0x1ul << PWM_LOAD_LOAD5_Pos)                     /*!< PWM_T::LOAD: LOAD5 Mask                */
S
S#define PWM_PERIOD_PERIOD_Pos            (0)                                               /*!< PWM_T::PERIOD: PERIOD Position         */
S#define PWM_PERIOD_PERIOD_Msk            (0xfffful << PWM_PERIOD_PERIOD_Pos)               /*!< PWM_T::PERIOD: PERIOD Mask             */
S
S#define PWM_CMPDAT_CMP_Pos               (0)                                               /*!< PWM_T::CMPDAT: CMP Position            */
S#define PWM_CMPDAT_CMP_Msk               (0xfffful << PWM_CMPDAT_CMP_Pos)                  /*!< PWM_T::CMPDAT: CMP Mask                */
S
S#define PWM_DTCTL0_1_DTCNT_Pos           (0)                                               /*!< PWM_T::DTCTL0_1: DTCNT Position        */
S#define PWM_DTCTL0_1_DTCNT_Msk           (0xffful << PWM_DTCTL0_1_DTCNT_Pos)               /*!< PWM_T::DTCTL0_1: DTCNT Mask            */
S
S#define PWM_DTCTL0_1_DTEN_Pos            (16)                                              /*!< PWM_T::DTCTL0_1: DTEN Position         */
S#define PWM_DTCTL0_1_DTEN_Msk            (0x1ul << PWM_DTCTL0_1_DTEN_Pos)                  /*!< PWM_T::DTCTL0_1: DTEN Mask             */
S
S#define PWM_DTCTL0_1_DTCKSEL_Pos         (24)                                              /*!< PWM_T::DTCTL0_1: DTCKSEL Position      */
S#define PWM_DTCTL0_1_DTCKSEL_Msk         (0x1ul << PWM_DTCTL0_1_DTCKSEL_Pos)               /*!< PWM_T::DTCTL0_1: DTCKSEL Mask          */
S
S#define PWM_DTCTL2_3_DTCNT_Pos           (0)                                               /*!< PWM_T::DTCTL2_3: DTCNT Position        */
S#define PWM_DTCTL2_3_DTCNT_Msk           (0xffful << PWM_DTCTL2_3_DTCNT_Pos)               /*!< PWM_T::DTCTL2_3: DTCNT Mask            */
S
S#define PWM_DTCTL2_3_DTEN_Pos            (16)                                              /*!< PWM_T::DTCTL2_3: DTEN Position         */
S#define PWM_DTCTL2_3_DTEN_Msk            (0x1ul << PWM_DTCTL2_3_DTEN_Pos)                  /*!< PWM_T::DTCTL2_3: DTEN Mask             */
S
S#define PWM_DTCTL2_3_DTCKSEL_Pos         (24)                                              /*!< PWM_T::DTCTL2_3: DTCKSEL Position      */
S#define PWM_DTCTL2_3_DTCKSEL_Msk         (0x1ul << PWM_DTCTL2_3_DTCKSEL_Pos)               /*!< PWM_T::DTCTL2_3: DTCKSEL Mask          */
S
S#define PWM_DTCTL4_5_DTCNT_Pos           (0)                                               /*!< PWM_T::DTCTL4_5: DTCNT Position        */
S#define PWM_DTCTL4_5_DTCNT_Msk           (0xffful << PWM_DTCTL4_5_DTCNT_Pos)               /*!< PWM_T::DTCTL4_5: DTCNT Mask            */
S
S#define PWM_DTCTL4_5_DTEN_Pos            (16)                                              /*!< PWM_T::DTCTL4_5: DTEN Position         */
S#define PWM_DTCTL4_5_DTEN_Msk            (0x1ul << PWM_DTCTL4_5_DTEN_Pos)                  /*!< PWM_T::DTCTL4_5: DTEN Mask             */
S
S#define PWM_DTCTL4_5_DTCKSEL_Pos         (24)                                              /*!< PWM_T::DTCTL4_5: DTCKSEL Position      */
S#define PWM_DTCTL4_5_DTCKSEL_Msk         (0x1ul << PWM_DTCTL4_5_DTCKSEL_Pos)               /*!< PWM_T::DTCTL4_5: DTCKSEL Mask          */
S
S#define PWM_PHS0_1_PHS_Pos               (0)                                               /*!< PWM_T::PHS0_1: PHS Position            */
S#define PWM_PHS0_1_PHS_Msk               (0xfffful << PWM_PHS0_1_PHS_Pos)                  /*!< PWM_T::PHS0_1: PHS Mask                */
S
S#define PWM_PHS2_3_PHS_Pos               (0)                                               /*!< PWM_T::PHS2_3: PHS Position            */
S#define PWM_PHS2_3_PHS_Msk               (0xfffful << PWM_PHS2_3_PHS_Pos)                  /*!< PWM_T::PHS2_3: PHS Mask                */
S
S#define PWM_PHS4_5_PHS_Pos               (0)                                               /*!< PWM_T::PHS4_5: PHS Position            */
S#define PWM_PHS4_5_PHS_Msk               (0xfffful << PWM_PHS4_5_PHS_Pos)                  /*!< PWM_T::PHS4_5: PHS Mask                */
S
S#define PWM_CNT_CNT_Pos                  (0)                                               /*!< PWM_T::CNT: CNT Position               */
S#define PWM_CNT_CNT_Msk                  (0xfffful << PWM_CNT_CNT_Pos)                     /*!< PWM_T::CNT: CNT Mask                   */
S
S#define PWM_CNT_DIRF_Pos                 (16)                                              /*!< PWM_T::CNT: DIRF Position              */
S#define PWM_CNT_DIRF_Msk                 (0x1ul << PWM_CNT_DIRF_Pos)                       /*!< PWM_T::CNT: DIRF Mask                  */
S
S#define PWM_WGCTL0_ZPCTL0_Pos            (0)                                               /*!< PWM_T::WGCTL0: ZPCTL0 Position         */
S#define PWM_WGCTL0_ZPCTL0_Msk            (0x3ul << PWM_WGCTL0_ZPCTL0_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL0 Mask             */
S
S#define PWM_WGCTL0_ZPCTL1_Pos            (2)                                               /*!< PWM_T::WGCTL0: ZPCTL1 Position         */
S#define PWM_WGCTL0_ZPCTL1_Msk            (0x3ul << PWM_WGCTL0_ZPCTL1_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL1 Mask             */
S
S#define PWM_WGCTL0_ZPCTL2_Pos            (4)                                               /*!< PWM_T::WGCTL0: ZPCTL2 Position         */
S#define PWM_WGCTL0_ZPCTL2_Msk            (0x3ul << PWM_WGCTL0_ZPCTL2_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL2 Mask             */
S
S#define PWM_WGCTL0_ZPCTL3_Pos            (6)                                               /*!< PWM_T::WGCTL0: ZPCTL3 Position         */
S#define PWM_WGCTL0_ZPCTL3_Msk            (0x3ul << PWM_WGCTL0_ZPCTL3_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL3 Mask             */
S
S#define PWM_WGCTL0_ZPCTL4_Pos            (8)                                               /*!< PWM_T::WGCTL0: ZPCTL4 Position         */
S#define PWM_WGCTL0_ZPCTL4_Msk            (0x3ul << PWM_WGCTL0_ZPCTL4_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL4 Mask             */
S
S#define PWM_WGCTL0_ZPCTL5_Pos            (10)                                              /*!< PWM_T::WGCTL0: ZPCTL5 Position         */
S#define PWM_WGCTL0_ZPCTL5_Msk            (0x3ul << PWM_WGCTL0_ZPCTL5_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL5 Mask             */
S
S#define PWM_WGCTL0_PRDPCTL0_Pos          (16)                                              /*!< PWM_T::WGCTL0: PRDPCTL0 Position       */
S#define PWM_WGCTL0_PRDPCTL0_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL0_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL0 Mask           */
S
S#define PWM_WGCTL0_PRDPCTL1_Pos          (18)                                              /*!< PWM_T::WGCTL0: PRDPCTL1 Position       */
S#define PWM_WGCTL0_PRDPCTL1_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL1_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL1 Mask           */
S
S#define PWM_WGCTL0_PRDPCTL2_Pos          (20)                                              /*!< PWM_T::WGCTL0: PRDPCTL2 Position       */
S#define PWM_WGCTL0_PRDPCTL2_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL2_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL2 Mask           */
S
S#define PWM_WGCTL0_PRDPCTL3_Pos          (22)                                              /*!< PWM_T::WGCTL0: PRDPCTL3 Position       */
S#define PWM_WGCTL0_PRDPCTL3_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL3_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL3 Mask           */
S
S#define PWM_WGCTL0_PRDPCTL4_Pos          (24)                                              /*!< PWM_T::WGCTL0: PRDPCTL4 Position       */
S#define PWM_WGCTL0_PRDPCTL4_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL4_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL4 Mask           */
S
S#define PWM_WGCTL0_PRDPCTL5_Pos          (26)                                              /*!< PWM_T::WGCTL0: PRDPCTL5 Position       */
S#define PWM_WGCTL0_PRDPCTL5_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL5_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL5 Mask           */
S
S#define PWM_WGCTL1_CMPUCTL0_Pos          (0)                                               /*!< PWM_T::WGCTL1: CMPUCTL0 Position       */
S#define PWM_WGCTL1_CMPUCTL0_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL0_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL0 Mask           */
S
S#define PWM_WGCTL1_CMPUCTL1_Pos          (2)                                               /*!< PWM_T::WGCTL1: CMPUCTL1 Position       */
S#define PWM_WGCTL1_CMPUCTL1_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL1_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL1 Mask           */
S
S#define PWM_WGCTL1_CMPUCTL2_Pos          (4)                                               /*!< PWM_T::WGCTL1: CMPUCTL2 Position       */
S#define PWM_WGCTL1_CMPUCTL2_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL2_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL2 Mask           */
S
S#define PWM_WGCTL1_CMPUCTL3_Pos          (6)                                               /*!< PWM_T::WGCTL1: CMPUCTL3 Position       */
S#define PWM_WGCTL1_CMPUCTL3_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL3_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL3 Mask           */
S
S#define PWM_WGCTL1_CMPUCTL4_Pos          (8)                                               /*!< PWM_T::WGCTL1: CMPUCTL4 Position       */
S#define PWM_WGCTL1_CMPUCTL4_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL4_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL4 Mask           */
S
S#define PWM_WGCTL1_CMPUCTL5_Pos          (10)                                              /*!< PWM_T::WGCTL1: CMPUCTL5 Position       */
S#define PWM_WGCTL1_CMPUCTL5_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL5_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL5 Mask           */
S
S#define PWM_WGCTL1_CMPDCTL0_Pos          (16)                                              /*!< PWM_T::WGCTL1: CMPDCTL0 Position       */
S#define PWM_WGCTL1_CMPDCTL0_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL0_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL0 Mask           */
S
S#define PWM_WGCTL1_CMPDCTL1_Pos          (18)                                              /*!< PWM_T::WGCTL1: CMPDCTL1 Position       */
S#define PWM_WGCTL1_CMPDCTL1_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL1_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL1 Mask           */
S
S#define PWM_WGCTL1_CMPDCTL2_Pos          (20)                                              /*!< PWM_T::WGCTL1: CMPDCTL2 Position       */
S#define PWM_WGCTL1_CMPDCTL2_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL2_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL2 Mask           */
S
S#define PWM_WGCTL1_CMPDCTL3_Pos          (22)                                              /*!< PWM_T::WGCTL1: CMPDCTL3 Position       */
S#define PWM_WGCTL1_CMPDCTL3_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL3_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL3 Mask           */
S
S#define PWM_WGCTL1_CMPDCTL4_Pos          (24)                                              /*!< PWM_T::WGCTL1: CMPDCTL4 Position       */
S#define PWM_WGCTL1_CMPDCTL4_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL4_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL4 Mask           */
S
S#define PWM_WGCTL1_CMPDCTL5_Pos          (26)                                              /*!< PWM_T::WGCTL1: CMPDCTL5 Position       */
S#define PWM_WGCTL1_CMPDCTL5_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL5_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL5 Mask           */
S
S#define PWM_MSKEN_MSKEN0_Pos             (0)                                               /*!< PWM_T::MSKEN: MSKEN0 Position          */
S#define PWM_MSKEN_MSKEN0_Msk             (0x1ul << PWM_MSKEN_MSKEN0_Pos)                   /*!< PWM_T::MSKEN: MSKEN0 Mask              */
S
S#define PWM_MSKEN_MSKEN1_Pos             (1)                                               /*!< PWM_T::MSKEN: MSKEN1 Position          */
S#define PWM_MSKEN_MSKEN1_Msk             (0x1ul << PWM_MSKEN_MSKEN1_Pos)                   /*!< PWM_T::MSKEN: MSKEN1 Mask              */
S
S#define PWM_MSKEN_MSKEN2_Pos             (2)                                               /*!< PWM_T::MSKEN: MSKEN2 Position          */
S#define PWM_MSKEN_MSKEN2_Msk             (0x1ul << PWM_MSKEN_MSKEN2_Pos)                   /*!< PWM_T::MSKEN: MSKEN2 Mask              */
S
S#define PWM_MSKEN_MSKEN3_Pos             (3)                                               /*!< PWM_T::MSKEN: MSKEN3 Position          */
S#define PWM_MSKEN_MSKEN3_Msk             (0x1ul << PWM_MSKEN_MSKEN3_Pos)                   /*!< PWM_T::MSKEN: MSKEN3 Mask              */
S
S#define PWM_MSKEN_MSKEN4_Pos             (4)                                               /*!< PWM_T::MSKEN: MSKEN4 Position          */
S#define PWM_MSKEN_MSKEN4_Msk             (0x1ul << PWM_MSKEN_MSKEN4_Pos)                   /*!< PWM_T::MSKEN: MSKEN4 Mask              */
S
S#define PWM_MSKEN_MSKEN5_Pos             (5)                                               /*!< PWM_T::MSKEN: MSKEN5 Position          */
S#define PWM_MSKEN_MSKEN5_Msk             (0x1ul << PWM_MSKEN_MSKEN5_Pos)                   /*!< PWM_T::MSKEN: MSKEN5 Mask              */
S
S#define PWM_MSK_MSKDAT0_Pos              (0)                                               /*!< PWM_T::MSK: MSKDAT0 Position           */
S#define PWM_MSK_MSKDAT0_Msk              (0x1ul << PWM_MSK_MSKDAT0_Pos)                    /*!< PWM_T::MSK: MSKDAT0 Mask               */
S
S#define PWM_MSK_MSKDAT1_Pos              (1)                                               /*!< PWM_T::MSK: MSKDAT1 Position           */
S#define PWM_MSK_MSKDAT1_Msk              (0x1ul << PWM_MSK_MSKDAT1_Pos)                    /*!< PWM_T::MSK: MSKDAT1 Mask               */
S
S#define PWM_MSK_MSKDAT2_Pos              (2)                                               /*!< PWM_T::MSK: MSKDAT2 Position           */
S#define PWM_MSK_MSKDAT2_Msk              (0x1ul << PWM_MSK_MSKDAT2_Pos)                    /*!< PWM_T::MSK: MSKDAT2 Mask               */
S
S#define PWM_MSK_MSKDAT3_Pos              (3)                                               /*!< PWM_T::MSK: MSKDAT3 Position           */
S#define PWM_MSK_MSKDAT3_Msk              (0x1ul << PWM_MSK_MSKDAT3_Pos)                    /*!< PWM_T::MSK: MSKDAT3 Mask               */
S
S#define PWM_MSK_MSKDAT4_Pos              (4)                                               /*!< PWM_T::MSK: MSKDAT4 Position           */
S#define PWM_MSK_MSKDAT4_Msk              (0x1ul << PWM_MSK_MSKDAT4_Pos)                    /*!< PWM_T::MSK: MSKDAT4 Mask               */
S
S#define PWM_MSK_MSKDAT5_Pos              (5)                                               /*!< PWM_T::MSK: MSKDAT5 Position           */
S#define PWM_MSK_MSKDAT5_Msk              (0x1ul << PWM_MSK_MSKDAT5_Pos)                    /*!< PWM_T::MSK: MSKDAT5 Mask               */
S
S#define PWM_BNF_BRK0NFEN_Pos             (0)                                               /*!< PWM_T::BNF: BRK0NFEN Position          */
S#define PWM_BNF_BRK0NFEN_Msk             (0x1ul << PWM_BNF_BRK0NFEN_Pos)                   /*!< PWM_T::BNF: BRK0NFEN Mask              */
S
S#define PWM_BNF_BRK0NFSEL_Pos            (1)                                               /*!< PWM_T::BNF: BRK0NFSEL Position         */
S#define PWM_BNF_BRK0NFSEL_Msk            (0x7ul << PWM_BNF_BRK0NFSEL_Pos)                  /*!< PWM_T::BNF: BRK0NFSEL Mask             */
S
S#define PWM_BNF_BRK0FCNT_Pos             (4)                                               /*!< PWM_T::BNF: BRK0FCNT Position          */
S#define PWM_BNF_BRK0FCNT_Msk             (0x7ul << PWM_BNF_BRK0FCNT_Pos)                   /*!< PWM_T::BNF: BRK0FCNT Mask              */
S
S#define PWM_BNF_BRK0PINV_Pos             (7)                                               /*!< PWM_T::BNF: BRK0PINV Position          */
S#define PWM_BNF_BRK0PINV_Msk             (0x1ul << PWM_BNF_BRK0PINV_Pos)                   /*!< PWM_T::BNF: BRK0PINV Mask              */
S
S#define PWM_BNF_BRK1NFEN_Pos             (8)                                               /*!< PWM_T::BNF: BRK1NFEN Position          */
S#define PWM_BNF_BRK1NFEN_Msk             (0x1ul << PWM_BNF_BRK1NFEN_Pos)                   /*!< PWM_T::BNF: BRK1NFEN Mask              */
S
S#define PWM_BNF_BRK1NFSEL_Pos            (9)                                               /*!< PWM_T::BNF: BRK1NFSEL Position         */
S#define PWM_BNF_BRK1NFSEL_Msk            (0x7ul << PWM_BNF_BRK1NFSEL_Pos)                  /*!< PWM_T::BNF: BRK1NFSEL Mask             */
S
S#define PWM_BNF_BRK1FCNT_Pos             (12)                                              /*!< PWM_T::BNF: BRK1FCNT Position          */
S#define PWM_BNF_BRK1FCNT_Msk             (0x7ul << PWM_BNF_BRK1FCNT_Pos)                   /*!< PWM_T::BNF: BRK1FCNT Mask              */
S
S#define PWM_BNF_BRK1PINV_Pos             (15)                                              /*!< PWM_T::BNF: BRK1PINV Position          */
S#define PWM_BNF_BRK1PINV_Msk             (0x1ul << PWM_BNF_BRK1PINV_Pos)                   /*!< PWM_T::BNF: BRK1PINV Mask              */
S
S#define PWM_BNF_BK0SRC_Pos               (16)                                              /*!< PWM_T::BNF: BK0SRC Position            */
S#define PWM_BNF_BK0SRC_Msk               (0x1ul << PWM_BNF_BK0SRC_Pos)                     /*!< PWM_T::BNF: BK0SRC Mask                */
S
S#define PWM_BNF_BK1SRC_Pos               (24)                                              /*!< PWM_T::BNF: BK1SRC Position            */
S#define PWM_BNF_BK1SRC_Msk               (0x1ul << PWM_BNF_BK1SRC_Pos)                     /*!< PWM_T::BNF: BK1SRC Mask                */
S
S#define PWM_FAILBRK_CSSBRKEN_Pos         (0)                                               /*!< PWM_T::FAILBRK: CSSBRKEN Position      */
S#define PWM_FAILBRK_CSSBRKEN_Msk         (0x1ul << PWM_FAILBRK_CSSBRKEN_Pos)               /*!< PWM_T::FAILBRK: CSSBRKEN Mask          */
S
S#define PWM_FAILBRK_BODBRKEN_Pos         (1)                                               /*!< PWM_T::FAILBRK: BODBRKEN Position      */
S#define PWM_FAILBRK_BODBRKEN_Msk         (0x1ul << PWM_FAILBRK_BODBRKEN_Pos)               /*!< PWM_T::FAILBRK: BODBRKEN Mask          */
S
S#define PWM_FAILBRK_CORBRKEN_Pos         (3)                                               /*!< PWM_T::FAILBRK: CORBRKEN Position      */
S#define PWM_FAILBRK_CORBRKEN_Msk         (0x1ul << PWM_FAILBRK_CORBRKEN_Pos)               /*!< PWM_T::FAILBRK: CORBRKEN Mask          */
S
S#define PWM_BRKCTL0_1_CPO0EBEN_Pos       (0)                                               /*!< PWM_T::BRKCTL0_1: CPO0EBEN Position    */
S#define PWM_BRKCTL0_1_CPO0EBEN_Msk       (0x1ul << PWM_BRKCTL0_1_CPO0EBEN_Pos)             /*!< PWM_T::BRKCTL0_1: CPO0EBEN Mask        */
S
S#define PWM_BRKCTL0_1_CPO1EBEN_Pos       (1)                                               /*!< PWM_T::BRKCTL0_1: CPO1EBEN Position    */
S#define PWM_BRKCTL0_1_CPO1EBEN_Msk       (0x1ul << PWM_BRKCTL0_1_CPO1EBEN_Pos)             /*!< PWM_T::BRKCTL0_1: CPO1EBEN Mask        */
S
S#define PWM_BRKCTL0_1_BRKP0EEN_Pos       (4)                                               /*!< PWM_T::BRKCTL0_1: BRKP0EEN Position    */
S#define PWM_BRKCTL0_1_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP0EEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP0EEN Mask        */
S
S#define PWM_BRKCTL0_1_BRKP1EEN_Pos       (5)                                               /*!< PWM_T::BRKCTL0_1: BRKP1EEN Position    */
S#define PWM_BRKCTL0_1_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP1EEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP1EEN Mask        */
S
S#define PWM_BRKCTL0_1_SYSEBEN_Pos        (7)                                               /*!< PWM_T::BRKCTL0_1: SYSEBEN Position     */
S#define PWM_BRKCTL0_1_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL0_1_SYSEBEN_Pos)              /*!< PWM_T::BRKCTL0_1: SYSEBEN Mask         */
S
S#define PWM_BRKCTL0_1_CPO0LBEN_Pos       (8)                                               /*!< PWM_T::BRKCTL0_1: CPO0LBEN Position    */
S#define PWM_BRKCTL0_1_CPO0LBEN_Msk       (0x1ul << PWM_BRKCTL0_1_CPO0LBEN_Pos)             /*!< PWM_T::BRKCTL0_1: CPO0LBEN Mask        */
S
S#define PWM_BRKCTL0_1_CPO1LBEN_Pos       (9)                                               /*!< PWM_T::BRKCTL0_1: CPO1LBEN Position    */
S#define PWM_BRKCTL0_1_CPO1LBEN_Msk       (0x1ul << PWM_BRKCTL0_1_CPO1LBEN_Pos)             /*!< PWM_T::BRKCTL0_1: CPO1LBEN Mask        */
S
S#define PWM_BRKCTL0_1_BRKP0LEN_Pos       (12)                                              /*!< PWM_T::BRKCTL0_1: BRKP0LEN Position    */
S#define PWM_BRKCTL0_1_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP0LEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP0LEN Mask        */
S
S#define PWM_BRKCTL0_1_BRKP1LEN_Pos       (13)                                              /*!< PWM_T::BRKCTL0_1: BRKP1LEN Position    */
S#define PWM_BRKCTL0_1_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP1LEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP1LEN Mask        */
S
S#define PWM_BRKCTL0_1_SYSLBEN_Pos        (15)                                              /*!< PWM_T::BRKCTL0_1: SYSLBEN Position     */
S#define PWM_BRKCTL0_1_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL0_1_SYSLBEN_Pos)              /*!< PWM_T::BRKCTL0_1: SYSLBEN Mask         */
S
S#define PWM_BRKCTL0_1_BRKAEVEN_Pos       (16)                                              /*!< PWM_T::BRKCTL0_1: BRKAEVEN Position    */
S#define PWM_BRKCTL0_1_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL0_1_BRKAEVEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKAEVEN Mask        */
S
S#define PWM_BRKCTL0_1_BRKAODD_Pos        (18)                                              /*!< PWM_T::BRKCTL0_1: BRKAODD Position     */
S#define PWM_BRKCTL0_1_BRKAODD_Msk        (0x3ul << PWM_BRKCTL0_1_BRKAODD_Pos)              /*!< PWM_T::BRKCTL0_1: BRKAODD Mask         */
S
S#define PWM_BRKCTL0_1_ADCEBEN_Pos        (20)                                              /*!< PWM_T::BRKCTL0_1: ADCEBEN Position     */
S#define PWM_BRKCTL0_1_ADCEBEN_Msk        (0x1ul << PWM_BRKCTL0_1_ADCEBEN_Pos)              /*!< PWM_T::BRKCTL0_1: ADCEBEN Mask         */
S
S#define PWM_BRKCTL0_1_ADCLBEN_Pos        (28)                                              /*!< PWM_T::BRKCTL0_1: ADCLBEN Position     */
S#define PWM_BRKCTL0_1_ADCLBEN_Msk        (0x1ul << PWM_BRKCTL0_1_ADCLBEN_Pos)              /*!< PWM_T::BRKCTL0_1: ADCLBEN Mask         */
S
S#define PWM_BRKCTL2_3_CPO0EBEN_Pos       (0)                                               /*!< PWM_T::BRKCTL2_3: CPO0EBEN Position    */
S#define PWM_BRKCTL2_3_CPO0EBEN_Msk       (0x1ul << PWM_BRKCTL2_3_CPO0EBEN_Pos)             /*!< PWM_T::BRKCTL2_3: CPO0EBEN Mask        */
S
S#define PWM_BRKCTL2_3_CPO1EBEN_Pos       (1)                                               /*!< PWM_T::BRKCTL2_3: CPO1EBEN Position    */
S#define PWM_BRKCTL2_3_CPO1EBEN_Msk       (0x1ul << PWM_BRKCTL2_3_CPO1EBEN_Pos)             /*!< PWM_T::BRKCTL2_3: CPO1EBEN Mask        */
S
S#define PWM_BRKCTL2_3_BRKP0EEN_Pos       (4)                                               /*!< PWM_T::BRKCTL2_3: BRKP0EEN Position    */
S#define PWM_BRKCTL2_3_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP0EEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP0EEN Mask        */
S
S#define PWM_BRKCTL2_3_BRKP1EEN_Pos       (5)                                               /*!< PWM_T::BRKCTL2_3: BRKP1EEN Position    */
S#define PWM_BRKCTL2_3_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP1EEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP1EEN Mask        */
S
S#define PWM_BRKCTL2_3_SYSEBEN_Pos        (7)                                               /*!< PWM_T::BRKCTL2_3: SYSEBEN Position     */
S#define PWM_BRKCTL2_3_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL2_3_SYSEBEN_Pos)              /*!< PWM_T::BRKCTL2_3: SYSEBEN Mask         */
S
S#define PWM_BRKCTL2_3_CPO0LBEN_Pos       (8)                                               /*!< PWM_T::BRKCTL2_3: CPO0LBEN Position    */
S#define PWM_BRKCTL2_3_CPO0LBEN_Msk       (0x1ul << PWM_BRKCTL2_3_CPO0LBEN_Pos)             /*!< PWM_T::BRKCTL2_3: CPO0LBEN Mask        */
S
S#define PWM_BRKCTL2_3_CPO1LBEN_Pos       (9)                                               /*!< PWM_T::BRKCTL2_3: CPO1LBEN Position    */
S#define PWM_BRKCTL2_3_CPO1LBEN_Msk       (0x1ul << PWM_BRKCTL2_3_CPO1LBEN_Pos)             /*!< PWM_T::BRKCTL2_3: CPO1LBEN Mask        */
S
S#define PWM_BRKCTL2_3_BRKP0LEN_Pos       (12)                                              /*!< PWM_T::BRKCTL2_3: BRKP0LEN Position    */
S#define PWM_BRKCTL2_3_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP0LEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP0LEN Mask        */
S
S#define PWM_BRKCTL2_3_BRKP1LEN_Pos       (13)                                              /*!< PWM_T::BRKCTL2_3: BRKP1LEN Position    */
S#define PWM_BRKCTL2_3_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP1LEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP1LEN Mask        */
S
S#define PWM_BRKCTL2_3_SYSLBEN_Pos        (15)                                              /*!< PWM_T::BRKCTL2_3: SYSLBEN Position     */
S#define PWM_BRKCTL2_3_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL2_3_SYSLBEN_Pos)              /*!< PWM_T::BRKCTL2_3: SYSLBEN Mask         */
S
S#define PWM_BRKCTL2_3_BRKAEVEN_Pos       (16)                                              /*!< PWM_T::BRKCTL2_3: BRKAEVEN Position    */
S#define PWM_BRKCTL2_3_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL2_3_BRKAEVEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKAEVEN Mask        */
S
S#define PWM_BRKCTL2_3_BRKAODD_Pos        (18)                                              /*!< PWM_T::BRKCTL2_3: BRKAODD Position     */
S#define PWM_BRKCTL2_3_BRKAODD_Msk        (0x3ul << PWM_BRKCTL2_3_BRKAODD_Pos)              /*!< PWM_T::BRKCTL2_3: BRKAODD Mask         */
S
S#define PWM_BRKCTL2_3_ADCEBEN_Pos        (20)                                              /*!< PWM_T::BRKCTL2_3: ADCEBEN Position     */
S#define PWM_BRKCTL2_3_ADCEBEN_Msk        (0x1ul << PWM_BRKCTL2_3_ADCEBEN_Pos)              /*!< PWM_T::BRKCTL2_3: ADCEBEN Mask         */
S
S#define PWM_BRKCTL2_3_ADCLBEN_Pos        (28)                                              /*!< PWM_T::BRKCTL2_3: ADCLBEN Position     */
S#define PWM_BRKCTL2_3_ADCLBEN_Msk        (0x1ul << PWM_BRKCTL2_3_ADCLBEN_Pos)              /*!< PWM_T::BRKCTL2_3: ADCLBEN Mask         */
S
S#define PWM_BRKCTL4_5_CPO0EBEN_Pos       (0)                                               /*!< PWM_T::BRKCTL4_5: CPO0EBEN Position    */
S#define PWM_BRKCTL4_5_CPO0EBEN_Msk       (0x1ul << PWM_BRKCTL4_5_CPO0EBEN_Pos)             /*!< PWM_T::BRKCTL4_5: CPO0EBEN Mask        */
S
S#define PWM_BRKCTL4_5_CPO1EBEN_Pos       (1)                                               /*!< PWM_T::BRKCTL4_5: CPO1EBEN Position    */
S#define PWM_BRKCTL4_5_CPO1EBEN_Msk       (0x1ul << PWM_BRKCTL4_5_CPO1EBEN_Pos)             /*!< PWM_T::BRKCTL4_5: CPO1EBEN Mask        */
S
S#define PWM_BRKCTL4_5_BRKP0EEN_Pos       (4)                                               /*!< PWM_T::BRKCTL4_5: BRKP0EEN Position    */
S#define PWM_BRKCTL4_5_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP0EEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP0EEN Mask        */
S
S#define PWM_BRKCTL4_5_BRKP1EEN_Pos       (5)                                               /*!< PWM_T::BRKCTL4_5: BRKP1EEN Position    */
S#define PWM_BRKCTL4_5_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP1EEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP1EEN Mask        */
S
S#define PWM_BRKCTL4_5_SYSEBEN_Pos        (7)                                               /*!< PWM_T::BRKCTL4_5: SYSEBEN Position     */
S#define PWM_BRKCTL4_5_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL4_5_SYSEBEN_Pos)              /*!< PWM_T::BRKCTL4_5: SYSEBEN Mask         */
S
S#define PWM_BRKCTL4_5_CPO0LBEN_Pos       (8)                                               /*!< PWM_T::BRKCTL4_5: CPO0LBEN Position    */
S#define PWM_BRKCTL4_5_CPO0LBEN_Msk       (0x1ul << PWM_BRKCTL4_5_CPO0LBEN_Pos)             /*!< PWM_T::BRKCTL4_5: CPO0LBEN Mask        */
S
S#define PWM_BRKCTL4_5_CPO1LBEN_Pos       (9)                                               /*!< PWM_T::BRKCTL4_5: CPO1LBEN Position    */
S#define PWM_BRKCTL4_5_CPO1LBEN_Msk       (0x1ul << PWM_BRKCTL4_5_CPO1LBEN_Pos)             /*!< PWM_T::BRKCTL4_5: CPO1LBEN Mask        */
S
S#define PWM_BRKCTL4_5_BRKP0LEN_Pos       (12)                                              /*!< PWM_T::BRKCTL4_5: BRKP0LEN Position    */
S#define PWM_BRKCTL4_5_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP0LEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP0LEN Mask        */
S
S#define PWM_BRKCTL4_5_BRKP1LEN_Pos       (13)                                              /*!< PWM_T::BRKCTL4_5: BRKP1LEN Position    */
S#define PWM_BRKCTL4_5_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP1LEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP1LEN Mask        */
S
S#define PWM_BRKCTL4_5_SYSLBEN_Pos        (15)                                              /*!< PWM_T::BRKCTL4_5: SYSLBEN Position     */
S#define PWM_BRKCTL4_5_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL4_5_SYSLBEN_Pos)              /*!< PWM_T::BRKCTL4_5: SYSLBEN Mask         */
S
S#define PWM_BRKCTL4_5_BRKAEVEN_Pos       (16)                                              /*!< PWM_T::BRKCTL4_5: BRKAEVEN Position    */
S#define PWM_BRKCTL4_5_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL4_5_BRKAEVEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKAEVEN Mask        */
S
S#define PWM_BRKCTL4_5_BRKAODD_Pos        (18)                                              /*!< PWM_T::BRKCTL4_5: BRKAODD Position     */
S#define PWM_BRKCTL4_5_BRKAODD_Msk        (0x3ul << PWM_BRKCTL4_5_BRKAODD_Pos)              /*!< PWM_T::BRKCTL4_5: BRKAODD Mask         */
S
S#define PWM_BRKCTL4_5_ADCEBEN_Pos        (20)                                              /*!< PWM_T::BRKCTL4_5: ADCEBEN Position     */
S#define PWM_BRKCTL4_5_ADCEBEN_Msk        (0x1ul << PWM_BRKCTL4_5_ADCEBEN_Pos)              /*!< PWM_T::BRKCTL4_5: ADCEBEN Mask         */
S
S#define PWM_BRKCTL4_5_ADCLBEN_Pos        (28)                                              /*!< PWM_T::BRKCTL4_5: ADCLBEN Position     */
S#define PWM_BRKCTL4_5_ADCLBEN_Msk        (0x1ul << PWM_BRKCTL4_5_ADCLBEN_Pos)              /*!< PWM_T::BRKCTL4_5: ADCLBEN Mask         */
S
S#define PWM_POLCTL_PINV0_Pos             (0)                                               /*!< PWM_T::POLCTL: PINV0 Position          */
S#define PWM_POLCTL_PINV0_Msk             (0x1ul << PWM_POLCTL_PINV0_Pos)                   /*!< PWM_T::POLCTL: PINV0 Mask              */
S
S#define PWM_POLCTL_PINV1_Pos             (1)                                               /*!< PWM_T::POLCTL: PINV1 Position          */
S#define PWM_POLCTL_PINV1_Msk             (0x1ul << PWM_POLCTL_PINV1_Pos)                   /*!< PWM_T::POLCTL: PINV1 Mask              */
S
S#define PWM_POLCTL_PINV2_Pos             (2)                                               /*!< PWM_T::POLCTL: PINV2 Position          */
S#define PWM_POLCTL_PINV2_Msk             (0x1ul << PWM_POLCTL_PINV2_Pos)                   /*!< PWM_T::POLCTL: PINV2 Mask              */
S
S#define PWM_POLCTL_PINV3_Pos             (3)                                               /*!< PWM_T::POLCTL: PINV3 Position          */
S#define PWM_POLCTL_PINV3_Msk             (0x1ul << PWM_POLCTL_PINV3_Pos)                   /*!< PWM_T::POLCTL: PINV3 Mask              */
S
S#define PWM_POLCTL_PINV4_Pos             (4)                                               /*!< PWM_T::POLCTL: PINV4 Position          */
S#define PWM_POLCTL_PINV4_Msk             (0x1ul << PWM_POLCTL_PINV4_Pos)                   /*!< PWM_T::POLCTL: PINV4 Mask              */
S
S#define PWM_POLCTL_PINV5_Pos             (5)                                               /*!< PWM_T::POLCTL: PINV5 Position          */
S#define PWM_POLCTL_PINV5_Msk             (0x1ul << PWM_POLCTL_PINV5_Pos)                   /*!< PWM_T::POLCTL: PINV5 Mask              */
S
S#define PWM_POEN_POEN0_Pos               (0)                                               /*!< PWM_T::POEN: POEN0 Position            */
S#define PWM_POEN_POEN0_Msk               (0x1ul << PWM_POEN_POEN0_Pos)                     /*!< PWM_T::POEN: POEN0 Mask                */
S
S#define PWM_POEN_POEN1_Pos               (1)                                               /*!< PWM_T::POEN: POEN1 Position            */
S#define PWM_POEN_POEN1_Msk               (0x1ul << PWM_POEN_POEN1_Pos)                     /*!< PWM_T::POEN: POEN1 Mask                */
S
S#define PWM_POEN_POEN2_Pos               (2)                                               /*!< PWM_T::POEN: POEN2 Position            */
S#define PWM_POEN_POEN2_Msk               (0x1ul << PWM_POEN_POEN2_Pos)                     /*!< PWM_T::POEN: POEN2 Mask                */
S
S#define PWM_POEN_POEN3_Pos               (3)                                               /*!< PWM_T::POEN: POEN3 Position            */
S#define PWM_POEN_POEN3_Msk               (0x1ul << PWM_POEN_POEN3_Pos)                     /*!< PWM_T::POEN: POEN3 Mask                */
S
S#define PWM_POEN_POEN4_Pos               (4)                                               /*!< PWM_T::POEN: POEN4 Position            */
S#define PWM_POEN_POEN4_Msk               (0x1ul << PWM_POEN_POEN4_Pos)                     /*!< PWM_T::POEN: POEN4 Mask                */
S
S#define PWM_POEN_POEN5_Pos               (5)                                               /*!< PWM_T::POEN: POEN5 Position            */
S#define PWM_POEN_POEN5_Msk               (0x1ul << PWM_POEN_POEN5_Pos)                     /*!< PWM_T::POEN: POEN5 Mask                */
S
S#define PWM_SWBRK_BRKETRG0_Pos           (0)                                               /*!< PWM_T::SWBRK: BRKETRG0 Position        */
S#define PWM_SWBRK_BRKETRG0_Msk           (0x1ul << PWM_SWBRK_BRKETRG0_Pos)                 /*!< PWM_T::SWBRK: BRKETRG0 Mask            */
S
S#define PWM_SWBRK_BRKETRG2_Pos           (1)                                               /*!< PWM_T::SWBRK: BRKETRG2 Position        */
S#define PWM_SWBRK_BRKETRG2_Msk           (0x1ul << PWM_SWBRK_BRKETRG2_Pos)                 /*!< PWM_T::SWBRK: BRKETRG2 Mask            */
S
S#define PWM_SWBRK_BRKETRG4_Pos           (2)                                               /*!< PWM_T::SWBRK: BRKETRG4 Position        */
S#define PWM_SWBRK_BRKETRG4_Msk           (0x1ul << PWM_SWBRK_BRKETRG4_Pos)                 /*!< PWM_T::SWBRK: BRKETRG4 Mask            */
S
S#define PWM_SWBRK_BRKLTRG0_Pos           (8)                                               /*!< PWM_T::SWBRK: BRKLTRG0 Position        */
S#define PWM_SWBRK_BRKLTRG0_Msk           (0x1ul << PWM_SWBRK_BRKLTRG0_Pos)                 /*!< PWM_T::SWBRK: BRKLTRG0 Mask            */
S
S#define PWM_SWBRK_BRKLTRG2_Pos           (9)                                               /*!< PWM_T::SWBRK: BRKLTRG2 Position        */
S#define PWM_SWBRK_BRKLTRG2_Msk           (0x1ul << PWM_SWBRK_BRKLTRG2_Pos)                 /*!< PWM_T::SWBRK: BRKLTRG2 Mask            */
S
S#define PWM_SWBRK_BRKLTRG4_Pos           (10)                                              /*!< PWM_T::SWBRK: BRKLTRG4 Position        */
S#define PWM_SWBRK_BRKLTRG4_Msk           (0x1ul << PWM_SWBRK_BRKLTRG4_Pos)                 /*!< PWM_T::SWBRK: BRKLTRG4 Mask            */
S
S#define PWM_INTEN0_ZIEN0_Pos             (0)                                               /*!< PWM_T::INTEN0: ZIEN0 Position          */
S#define PWM_INTEN0_ZIEN0_Msk             (0x1ul << PWM_INTEN0_ZIEN0_Pos)                   /*!< PWM_T::INTEN0: ZIEN0 Mask              */
S
S#define PWM_INTEN0_ZIEN1_Pos             (1)                                               /*!< PWM_T::INTEN0: ZIEN1 Position          */
S#define PWM_INTEN0_ZIEN1_Msk             (0x1ul << PWM_INTEN0_ZIEN1_Pos)                   /*!< PWM_T::INTEN0: ZIEN1 Mask              */
S
S#define PWM_INTEN0_ZIEN2_Pos             (2)                                               /*!< PWM_T::INTEN0: ZIEN2 Position          */
S#define PWM_INTEN0_ZIEN2_Msk             (0x1ul << PWM_INTEN0_ZIEN2_Pos)                   /*!< PWM_T::INTEN0: ZIEN2 Mask              */
S
S#define PWM_INTEN0_ZIEN3_Pos             (3)                                               /*!< PWM_T::INTEN0: ZIEN3 Position          */
S#define PWM_INTEN0_ZIEN3_Msk             (0x1ul << PWM_INTEN0_ZIEN3_Pos)                   /*!< PWM_T::INTEN0: ZIEN3 Mask              */
S
S#define PWM_INTEN0_ZIEN4_Pos             (4)                                               /*!< PWM_T::INTEN0: ZIEN4 Position          */
S#define PWM_INTEN0_ZIEN4_Msk             (0x1ul << PWM_INTEN0_ZIEN4_Pos)                   /*!< PWM_T::INTEN0: ZIEN4 Mask              */
S
S#define PWM_INTEN0_ZIEN5_Pos             (5)                                               /*!< PWM_T::INTEN0: ZIEN5 Position          */
S#define PWM_INTEN0_ZIEN5_Msk             (0x1ul << PWM_INTEN0_ZIEN5_Pos)                   /*!< PWM_T::INTEN0: ZIEN5 Mask              */
S
S#define PWM_INTEN0_IFAIEN0_1_Pos         (7)                                               /*!< PWM_T::INTEN0: IFAIEN0_1 Position      */
S#define PWM_INTEN0_IFAIEN0_1_Msk         (0x1ul << PWM_INTEN0_IFAIEN0_1_Pos)               /*!< PWM_T::INTEN0: IFAIEN0_1 Mask          */
S
S#define PWM_INTEN0_PIEN0_Pos             (8)                                               /*!< PWM_T::INTEN0: PIEN0 Position          */
S#define PWM_INTEN0_PIEN0_Msk             (0x1ul << PWM_INTEN0_PIEN0_Pos)                   /*!< PWM_T::INTEN0: PIEN0 Mask              */
S
S#define PWM_INTEN0_PIEN1_Pos             (9)                                               /*!< PWM_T::INTEN0: PIEN1 Position          */
S#define PWM_INTEN0_PIEN1_Msk             (0x1ul << PWM_INTEN0_PIEN1_Pos)                   /*!< PWM_T::INTEN0: PIEN1 Mask              */
S
S#define PWM_INTEN0_PIEN2_Pos             (10)                                              /*!< PWM_T::INTEN0: PIEN2 Position          */
S#define PWM_INTEN0_PIEN2_Msk             (0x1ul << PWM_INTEN0_PIEN2_Pos)                   /*!< PWM_T::INTEN0: PIEN2 Mask              */
S
S#define PWM_INTEN0_PIEN3_Pos             (11)                                              /*!< PWM_T::INTEN0: PIEN3 Position          */
S#define PWM_INTEN0_PIEN3_Msk             (0x1ul << PWM_INTEN0_PIEN3_Pos)                   /*!< PWM_T::INTEN0: PIEN3 Mask              */
S
S#define PWM_INTEN0_PIEN4_Pos             (12)                                              /*!< PWM_T::INTEN0: PIEN4 Position          */
S#define PWM_INTEN0_PIEN4_Msk             (0x1ul << PWM_INTEN0_PIEN4_Pos)                   /*!< PWM_T::INTEN0: PIEN4 Mask              */
S
S#define PWM_INTEN0_PIEN5_Pos             (13)                                              /*!< PWM_T::INTEN0: PIEN5 Position          */
S#define PWM_INTEN0_PIEN5_Msk             (0x1ul << PWM_INTEN0_PIEN5_Pos)                   /*!< PWM_T::INTEN0: PIEN5 Mask              */
S
S#define PWM_INTEN0_IFAIEN2_3_Pos         (15)                                              /*!< PWM_T::INTEN0: IFAIEN2_3 Position      */
S#define PWM_INTEN0_IFAIEN2_3_Msk         (0x1ul << PWM_INTEN0_IFAIEN2_3_Pos)               /*!< PWM_T::INTEN0: IFAIEN2_3 Mask          */
S
S#define PWM_INTEN0_CMPUIEN0_Pos          (16)                                              /*!< PWM_T::INTEN0: CMPUIEN0 Position       */
S#define PWM_INTEN0_CMPUIEN0_Msk          (0x1ul << PWM_INTEN0_CMPUIEN0_Pos)                /*!< PWM_T::INTEN0: CMPUIEN0 Mask           */
S
S#define PWM_INTEN0_CMPUIEN1_Pos          (17)                                              /*!< PWM_T::INTEN0: CMPUIEN1 Position       */
S#define PWM_INTEN0_CMPUIEN1_Msk          (0x1ul << PWM_INTEN0_CMPUIEN1_Pos)                /*!< PWM_T::INTEN0: CMPUIEN1 Mask           */
S
S#define PWM_INTEN0_CMPUIEN2_Pos          (18)                                              /*!< PWM_T::INTEN0: CMPUIEN2 Position       */
S#define PWM_INTEN0_CMPUIEN2_Msk          (0x1ul << PWM_INTEN0_CMPUIEN2_Pos)                /*!< PWM_T::INTEN0: CMPUIEN2 Mask           */
S
S#define PWM_INTEN0_CMPUIEN3_Pos          (19)                                              /*!< PWM_T::INTEN0: CMPUIEN3 Position       */
S#define PWM_INTEN0_CMPUIEN3_Msk          (0x1ul << PWM_INTEN0_CMPUIEN3_Pos)                /*!< PWM_T::INTEN0: CMPUIEN3 Mask           */
S
S#define PWM_INTEN0_CMPUIEN4_Pos          (20)                                              /*!< PWM_T::INTEN0: CMPUIEN4 Position       */
S#define PWM_INTEN0_CMPUIEN4_Msk          (0x1ul << PWM_INTEN0_CMPUIEN4_Pos)                /*!< PWM_T::INTEN0: CMPUIEN4 Mask           */
S
S#define PWM_INTEN0_CMPUIEN5_Pos          (21)                                              /*!< PWM_T::INTEN0: CMPUIEN5 Position       */
S#define PWM_INTEN0_CMPUIEN5_Msk          (0x1ul << PWM_INTEN0_CMPUIEN5_Pos)                /*!< PWM_T::INTEN0: CMPUIEN5 Mask           */
S
S#define PWM_INTEN0_IFAIEN4_5_Pos         (23)                                              /*!< PWM_T::INTEN0: IFAIEN4_5 Position      */
S#define PWM_INTEN0_IFAIEN4_5_Msk         (0x1ul << PWM_INTEN0_IFAIEN4_5_Pos)               /*!< PWM_T::INTEN0: IFAIEN4_5 Mask          */
S
S#define PWM_INTEN0_CMPDIEN0_Pos          (24)                                              /*!< PWM_T::INTEN0: CMPDIEN0 Position       */
S#define PWM_INTEN0_CMPDIEN0_Msk          (0x1ul << PWM_INTEN0_CMPDIEN0_Pos)                /*!< PWM_T::INTEN0: CMPDIEN0 Mask           */
S
S#define PWM_INTEN0_CMPDIEN1_Pos          (25)                                              /*!< PWM_T::INTEN0: CMPDIEN1 Position       */
S#define PWM_INTEN0_CMPDIEN1_Msk          (0x1ul << PWM_INTEN0_CMPDIEN1_Pos)                /*!< PWM_T::INTEN0: CMPDIEN1 Mask           */
S
S#define PWM_INTEN0_CMPDIEN2_Pos          (26)                                              /*!< PWM_T::INTEN0: CMPDIEN2 Position       */
S#define PWM_INTEN0_CMPDIEN2_Msk          (0x1ul << PWM_INTEN0_CMPDIEN2_Pos)                /*!< PWM_T::INTEN0: CMPDIEN2 Mask           */
S
S#define PWM_INTEN0_CMPDIEN3_Pos          (27)                                              /*!< PWM_T::INTEN0: CMPDIEN3 Position       */
S#define PWM_INTEN0_CMPDIEN3_Msk          (0x1ul << PWM_INTEN0_CMPDIEN3_Pos)                /*!< PWM_T::INTEN0: CMPDIEN3 Mask           */
S
S#define PWM_INTEN0_CMPDIEN4_Pos          (28)                                              /*!< PWM_T::INTEN0: CMPDIEN4 Position       */
S#define PWM_INTEN0_CMPDIEN4_Msk          (0x1ul << PWM_INTEN0_CMPDIEN4_Pos)                /*!< PWM_T::INTEN0: CMPDIEN4 Mask           */
S
S#define PWM_INTEN0_CMPDIEN5_Pos          (29)                                              /*!< PWM_T::INTEN0: CMPDIEN5 Position       */
S#define PWM_INTEN0_CMPDIEN5_Msk          (0x1ul << PWM_INTEN0_CMPDIEN5_Pos)                /*!< PWM_T::INTEN0: CMPDIEN5 Mask           */
S
S#define PWM_INTEN1_BRKEIEN0_1_Pos        (0)                                               /*!< PWM_T::INTEN1: BRKEIEN0_1 Position     */
S#define PWM_INTEN1_BRKEIEN0_1_Msk        (0x1ul << PWM_INTEN1_BRKEIEN0_1_Pos)              /*!< PWM_T::INTEN1: BRKEIEN0_1 Mask         */
S
S#define PWM_INTEN1_BRKEIEN2_3_Pos        (1)                                               /*!< PWM_T::INTEN1: BRKEIEN2_3 Position     */
S#define PWM_INTEN1_BRKEIEN2_3_Msk        (0x1ul << PWM_INTEN1_BRKEIEN2_3_Pos)              /*!< PWM_T::INTEN1: BRKEIEN2_3 Mask         */
S
S#define PWM_INTEN1_BRKEIEN4_5_Pos        (2)                                               /*!< PWM_T::INTEN1: BRKEIEN4_5 Position     */
S#define PWM_INTEN1_BRKEIEN4_5_Msk        (0x1ul << PWM_INTEN1_BRKEIEN4_5_Pos)              /*!< PWM_T::INTEN1: BRKEIEN4_5 Mask         */
S
S#define PWM_INTEN1_BRKLIEN0_1_Pos        (8)                                               /*!< PWM_T::INTEN1: BRKLIEN0_1 Position     */
S#define PWM_INTEN1_BRKLIEN0_1_Msk        (0x1ul << PWM_INTEN1_BRKLIEN0_1_Pos)              /*!< PWM_T::INTEN1: BRKLIEN0_1 Mask         */
S
S#define PWM_INTEN1_BRKLIEN2_3_Pos        (9)                                               /*!< PWM_T::INTEN1: BRKLIEN2_3 Position     */
S#define PWM_INTEN1_BRKLIEN2_3_Msk        (0x1ul << PWM_INTEN1_BRKLIEN2_3_Pos)              /*!< PWM_T::INTEN1: BRKLIEN2_3 Mask         */
S
S#define PWM_INTEN1_BRKLIEN4_5_Pos        (10)                                              /*!< PWM_T::INTEN1: BRKLIEN4_5 Position     */
S#define PWM_INTEN1_BRKLIEN4_5_Msk        (0x1ul << PWM_INTEN1_BRKLIEN4_5_Pos)              /*!< PWM_T::INTEN1: BRKLIEN4_5 Mask         */
S
S#define PWM_INTSTS0_ZIF0_Pos             (0)                                               /*!< PWM_T::INTSTS0: ZIF0 Position          */
S#define PWM_INTSTS0_ZIF0_Msk             (0x1ul << PWM_INTSTS0_ZIF0_Pos)                   /*!< PWM_T::INTSTS0: ZIF0 Mask              */
S
S#define PWM_INTSTS0_ZIF1_Pos             (1)                                               /*!< PWM_T::INTSTS0: ZIF1 Position          */
S#define PWM_INTSTS0_ZIF1_Msk             (0x1ul << PWM_INTSTS0_ZIF1_Pos)                   /*!< PWM_T::INTSTS0: ZIF1 Mask              */
S
S#define PWM_INTSTS0_ZIF2_Pos             (2)                                               /*!< PWM_T::INTSTS0: ZIF2 Position          */
S#define PWM_INTSTS0_ZIF2_Msk             (0x1ul << PWM_INTSTS0_ZIF2_Pos)                   /*!< PWM_T::INTSTS0: ZIF2 Mask              */
S
S#define PWM_INTSTS0_ZIF3_Pos             (3)                                               /*!< PWM_T::INTSTS0: ZIF3 Position          */
S#define PWM_INTSTS0_ZIF3_Msk             (0x1ul << PWM_INTSTS0_ZIF3_Pos)                   /*!< PWM_T::INTSTS0: ZIF3 Mask              */
S
S#define PWM_INTSTS0_ZIF4_Pos             (4)                                               /*!< PWM_T::INTSTS0: ZIF4 Position          */
S#define PWM_INTSTS0_ZIF4_Msk             (0x1ul << PWM_INTSTS0_ZIF4_Pos)                   /*!< PWM_T::INTSTS0: ZIF4 Mask              */
S
S#define PWM_INTSTS0_ZIF5_Pos             (5)                                               /*!< PWM_T::INTSTS0: ZIF5 Position          */
S#define PWM_INTSTS0_ZIF5_Msk             (0x1ul << PWM_INTSTS0_ZIF5_Pos)                   /*!< PWM_T::INTSTS0: ZIF5 Mask              */
S
S#define PWM_INTSTS0_IFAIF0_1_Pos         (7)                                               /*!< PWM_T::INTSTS0: IFAIF0_1 Position      */
S#define PWM_INTSTS0_IFAIF0_1_Msk         (0x1ul << PWM_INTSTS0_IFAIF0_1_Pos)               /*!< PWM_T::INTSTS0: IFAIF0_1 Mask          */
S
S#define PWM_INTSTS0_PIF0_Pos             (8)                                               /*!< PWM_T::INTSTS0: PIF0 Position          */
S#define PWM_INTSTS0_PIF0_Msk             (0x1ul << PWM_INTSTS0_PIF0_Pos)                   /*!< PWM_T::INTSTS0: PIF0 Mask              */
S
S#define PWM_INTSTS0_PIF1_Pos             (9)                                               /*!< PWM_T::INTSTS0: PIF1 Position          */
S#define PWM_INTSTS0_PIF1_Msk             (0x1ul << PWM_INTSTS0_PIF1_Pos)                   /*!< PWM_T::INTSTS0: PIF1 Mask              */
S
S#define PWM_INTSTS0_PIF2_Pos             (10)                                              /*!< PWM_T::INTSTS0: PIF2 Position          */
S#define PWM_INTSTS0_PIF2_Msk             (0x1ul << PWM_INTSTS0_PIF2_Pos)                   /*!< PWM_T::INTSTS0: PIF2 Mask              */
S
S#define PWM_INTSTS0_PIF3_Pos             (11)                                              /*!< PWM_T::INTSTS0: PIF3 Position          */
S#define PWM_INTSTS0_PIF3_Msk             (0x1ul << PWM_INTSTS0_PIF3_Pos)                   /*!< PWM_T::INTSTS0: PIF3 Mask              */
S
S#define PWM_INTSTS0_PIF4_Pos             (12)                                              /*!< PWM_T::INTSTS0: PIF4 Position          */
S#define PWM_INTSTS0_PIF4_Msk             (0x1ul << PWM_INTSTS0_PIF4_Pos)                   /*!< PWM_T::INTSTS0: PIF4 Mask              */
S
S#define PWM_INTSTS0_PIF5_Pos             (13)                                              /*!< PWM_T::INTSTS0: PIF5 Position          */
S#define PWM_INTSTS0_PIF5_Msk             (0x1ul << PWM_INTSTS0_PIF5_Pos)                   /*!< PWM_T::INTSTS0: PIF5 Mask              */
S
S#define PWM_INTSTS0_IFAIF2_3_Pos         (15)                                              /*!< PWM_T::INTSTS0: IFAIF2_3 Position      */
S#define PWM_INTSTS0_IFAIF2_3_Msk         (0x1ul << PWM_INTSTS0_IFAIF2_3_Pos)               /*!< PWM_T::INTSTS0: IFAIF2_3 Mask          */
S
S#define PWM_INTSTS0_CMPUIF0_Pos          (16)                                              /*!< PWM_T::INTSTS0: CMPUIF0 Position       */
S#define PWM_INTSTS0_CMPUIF0_Msk          (0x1ul << PWM_INTSTS0_CMPUIF0_Pos)                /*!< PWM_T::INTSTS0: CMPUIF0 Mask           */
S
S#define PWM_INTSTS0_CMPUIF1_Pos          (17)                                              /*!< PWM_T::INTSTS0: CMPUIF1 Position       */
S#define PWM_INTSTS0_CMPUIF1_Msk          (0x1ul << PWM_INTSTS0_CMPUIF1_Pos)                /*!< PWM_T::INTSTS0: CMPUIF1 Mask           */
S
S#define PWM_INTSTS0_CMPUIF2_Pos          (18)                                              /*!< PWM_T::INTSTS0: CMPUIF2 Position       */
S#define PWM_INTSTS0_CMPUIF2_Msk          (0x1ul << PWM_INTSTS0_CMPUIF2_Pos)                /*!< PWM_T::INTSTS0: CMPUIF2 Mask           */
S
S#define PWM_INTSTS0_CMPUIF3_Pos          (19)                                              /*!< PWM_T::INTSTS0: CMPUIF3 Position       */
S#define PWM_INTSTS0_CMPUIF3_Msk          (0x1ul << PWM_INTSTS0_CMPUIF3_Pos)                /*!< PWM_T::INTSTS0: CMPUIF3 Mask           */
S
S#define PWM_INTSTS0_CMPUIF4_Pos          (20)                                              /*!< PWM_T::INTSTS0: CMPUIF4 Position       */
S#define PWM_INTSTS0_CMPUIF4_Msk          (0x1ul << PWM_INTSTS0_CMPUIF4_Pos)                /*!< PWM_T::INTSTS0: CMPUIF4 Mask           */
S
S#define PWM_INTSTS0_CMPUIF5_Pos          (21)                                              /*!< PWM_T::INTSTS0: CMPUIF5 Position       */
S#define PWM_INTSTS0_CMPUIF5_Msk          (0x1ul << PWM_INTSTS0_CMPUIF5_Pos)                /*!< PWM_T::INTSTS0: CMPUIF5 Mask           */
S
S#define PWM_INTSTS0_IFAIF4_5_Pos         (23)                                              /*!< PWM_T::INTSTS0: IFAIF4_5 Position      */
S#define PWM_INTSTS0_IFAIF4_5_Msk         (0x1ul << PWM_INTSTS0_IFAIF4_5_Pos)               /*!< PWM_T::INTSTS0: IFAIF4_5 Mask          */
S
S#define PWM_INTSTS0_CMPDIF0_Pos          (24)                                              /*!< PWM_T::INTSTS0: CMPDIF0 Position       */
S#define PWM_INTSTS0_CMPDIF0_Msk          (0x1ul << PWM_INTSTS0_CMPDIF0_Pos)                /*!< PWM_T::INTSTS0: CMPDIF0 Mask           */
S
S#define PWM_INTSTS0_CMPDIF1_Pos          (25)                                              /*!< PWM_T::INTSTS0: CMPDIF1 Position       */
S#define PWM_INTSTS0_CMPDIF1_Msk          (0x1ul << PWM_INTSTS0_CMPDIF1_Pos)                /*!< PWM_T::INTSTS0: CMPDIF1 Mask           */
S
S#define PWM_INTSTS0_CMPDIF2_Pos          (26)                                              /*!< PWM_T::INTSTS0: CMPDIF2 Position       */
S#define PWM_INTSTS0_CMPDIF2_Msk          (0x1ul << PWM_INTSTS0_CMPDIF2_Pos)                /*!< PWM_T::INTSTS0: CMPDIF2 Mask           */
S
S#define PWM_INTSTS0_CMPDIF3_Pos          (27)                                              /*!< PWM_T::INTSTS0: CMPDIF3 Position       */
S#define PWM_INTSTS0_CMPDIF3_Msk          (0x1ul << PWM_INTSTS0_CMPDIF3_Pos)                /*!< PWM_T::INTSTS0: CMPDIF3 Mask           */
S
S#define PWM_INTSTS0_CMPDIF4_Pos          (28)                                              /*!< PWM_T::INTSTS0: CMPDIF4 Position       */
S#define PWM_INTSTS0_CMPDIF4_Msk          (0x1ul << PWM_INTSTS0_CMPDIF4_Pos)                /*!< PWM_T::INTSTS0: CMPDIF4 Mask           */
S
S#define PWM_INTSTS0_CMPDIF5_Pos          (29)                                              /*!< PWM_T::INTSTS0: CMPDIF5 Position       */
S#define PWM_INTSTS0_CMPDIF5_Msk          (0x1ul << PWM_INTSTS0_CMPDIF5_Pos)                /*!< PWM_T::INTSTS0: CMPDIF5 Mask           */
S
S#define PWM_INTSTS1_BRKEIF0_Pos          (0)                                               /*!< PWM_T::INTSTS1: BRKEIF0 Position       */
S#define PWM_INTSTS1_BRKEIF0_Msk          (0x1ul << PWM_INTSTS1_BRKEIF0_Pos)                /*!< PWM_T::INTSTS1: BRKEIF0 Mask           */
S
S#define PWM_INTSTS1_BRKEIF1_Pos          (1)                                               /*!< PWM_T::INTSTS1: BRKEIF1 Position       */
S#define PWM_INTSTS1_BRKEIF1_Msk          (0x1ul << PWM_INTSTS1_BRKEIF1_Pos)                /*!< PWM_T::INTSTS1: BRKEIF1 Mask           */
S
S#define PWM_INTSTS1_BRKEIF2_Pos          (2)                                               /*!< PWM_T::INTSTS1: BRKEIF2 Position       */
S#define PWM_INTSTS1_BRKEIF2_Msk          (0x1ul << PWM_INTSTS1_BRKEIF2_Pos)                /*!< PWM_T::INTSTS1: BRKEIF2 Mask           */
S
S#define PWM_INTSTS1_BRKEIF3_Pos          (3)                                               /*!< PWM_T::INTSTS1: BRKEIF3 Position       */
S#define PWM_INTSTS1_BRKEIF3_Msk          (0x1ul << PWM_INTSTS1_BRKEIF3_Pos)                /*!< PWM_T::INTSTS1: BRKEIF3 Mask           */
S
S#define PWM_INTSTS1_BRKEIF4_Pos          (4)                                               /*!< PWM_T::INTSTS1: BRKEIF4 Position       */
S#define PWM_INTSTS1_BRKEIF4_Msk          (0x1ul << PWM_INTSTS1_BRKEIF4_Pos)                /*!< PWM_T::INTSTS1: BRKEIF4 Mask           */
S
S#define PWM_INTSTS1_BRKEIF5_Pos          (5)                                               /*!< PWM_T::INTSTS1: BRKEIF5 Position       */
S#define PWM_INTSTS1_BRKEIF5_Msk          (0x1ul << PWM_INTSTS1_BRKEIF5_Pos)                /*!< PWM_T::INTSTS1: BRKEIF5 Mask           */
S
S#define PWM_INTSTS1_BRKLIFn_Pos          (8)                                               /*!< PWM_T::INTSTS1: BRKLIFn Position       */
S#define PWM_INTSTS1_BRKLIFn_Msk          (0x1ul << PWM_INTSTS1_BRKLIFn_Pos)                /*!< PWM_T::INTSTS1: BRKLIFn Mask           */
S
S#define PWM_INTSTS1_BRKESTS0_Pos         (16)                                              /*!< PWM_T::INTSTS1: BRKESTS0 Position      */
S#define PWM_INTSTS1_BRKESTS0_Msk         (0x1ul << PWM_INTSTS1_BRKESTS0_Pos)               /*!< PWM_T::INTSTS1: BRKESTS0 Mask          */
S
S#define PWM_INTSTS1_BRKESTS1_Pos         (17)                                              /*!< PWM_T::INTSTS1: BRKESTS1 Position      */
S#define PWM_INTSTS1_BRKESTS1_Msk         (0x1ul << PWM_INTSTS1_BRKESTS1_Pos)               /*!< PWM_T::INTSTS1: BRKESTS1 Mask          */
S
S#define PWM_INTSTS1_BRKESTS2_Pos         (18)                                              /*!< PWM_T::INTSTS1: BRKESTS2 Position      */
S#define PWM_INTSTS1_BRKESTS2_Msk         (0x1ul << PWM_INTSTS1_BRKESTS2_Pos)               /*!< PWM_T::INTSTS1: BRKESTS2 Mask          */
S
S#define PWM_INTSTS1_BRKESTS3_Pos         (19)                                              /*!< PWM_T::INTSTS1: BRKESTS3 Position      */
S#define PWM_INTSTS1_BRKESTS3_Msk         (0x1ul << PWM_INTSTS1_BRKESTS3_Pos)               /*!< PWM_T::INTSTS1: BRKESTS3 Mask          */
S
S#define PWM_INTSTS1_BRKESTS4_Pos         (20)                                              /*!< PWM_T::INTSTS1: BRKESTS4 Position      */
S#define PWM_INTSTS1_BRKESTS4_Msk         (0x1ul << PWM_INTSTS1_BRKESTS4_Pos)               /*!< PWM_T::INTSTS1: BRKESTS4 Mask          */
S
S#define PWM_INTSTS1_BRKESTS5_Pos         (21)                                              /*!< PWM_T::INTSTS1: BRKESTS5 Position      */
S#define PWM_INTSTS1_BRKESTS5_Msk         (0x1ul << PWM_INTSTS1_BRKESTS5_Pos)               /*!< PWM_T::INTSTS1: BRKESTS5 Mask          */
S
S#define PWM_INTSTS1_BRKLSTS0_Pos         (24)                                              /*!< PWM_T::INTSTS1: BRKLSTS0 Position      */
S#define PWM_INTSTS1_BRKLSTS0_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS0_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS0 Mask          */
S
S#define PWM_INTSTS1_BRKLSTS1_Pos         (25)                                              /*!< PWM_T::INTSTS1: BRKLSTS1 Position      */
S#define PWM_INTSTS1_BRKLSTS1_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS1_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS1 Mask          */
S
S#define PWM_INTSTS1_BRKLSTS2_Pos         (26)                                              /*!< PWM_T::INTSTS1: BRKLSTS2 Position      */
S#define PWM_INTSTS1_BRKLSTS2_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS2_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS2 Mask          */
S
S#define PWM_INTSTS1_BRKLSTS3_Pos         (27)                                              /*!< PWM_T::INTSTS1: BRKLSTS3 Position      */
S#define PWM_INTSTS1_BRKLSTS3_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS3_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS3 Mask          */
S
S#define PWM_INTSTS1_BRKLSTS4_Pos         (28)                                              /*!< PWM_T::INTSTS1: BRKLSTS4 Position      */
S#define PWM_INTSTS1_BRKLSTS4_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS4_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS4 Mask          */
S
S#define PWM_INTSTS1_BRKLSTS5_Pos         (29)                                              /*!< PWM_T::INTSTS1: BRKLSTS5 Position      */
S#define PWM_INTSTS1_BRKLSTS5_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS5_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS5 Mask          */
S
S#define PWM_IFA_IFCNT0_1_Pos             (0)                                               /*!< PWM_T::IFA: IFCNT0_1 Position          */
S#define PWM_IFA_IFCNT0_1_Msk             (0xful << PWM_IFA_IFCNT0_1_Pos)                   /*!< PWM_T::IFA: IFCNT0_1 Mask              */
S
S#define PWM_IFA_IFSEL0_1_Pos             (4)                                               /*!< PWM_T::IFA: IFSEL0_1 Position          */
S#define PWM_IFA_IFSEL0_1_Msk             (0x7ul << PWM_IFA_IFSEL0_1_Pos)                   /*!< PWM_T::IFA: IFSEL0_1 Mask              */
S
S#define PWM_IFA_IFAEN0_1_Pos             (7)                                               /*!< PWM_T::IFA: IFAEN0_1 Position          */
S#define PWM_IFA_IFAEN0_1_Msk             (0x1ul << PWM_IFA_IFAEN0_1_Pos)                   /*!< PWM_T::IFA: IFAEN0_1 Mask              */
S
S#define PWM_IFA_IFCNT2_3_Pos             (8)                                               /*!< PWM_T::IFA: IFCNT2_3 Position          */
S#define PWM_IFA_IFCNT2_3_Msk             (0xful << PWM_IFA_IFCNT2_3_Pos)                   /*!< PWM_T::IFA: IFCNT2_3 Mask              */
S
S#define PWM_IFA_IFSEL2_3_Pos             (12)                                              /*!< PWM_T::IFA: IFSEL2_3 Position          */
S#define PWM_IFA_IFSEL2_3_Msk             (0x7ul << PWM_IFA_IFSEL2_3_Pos)                   /*!< PWM_T::IFA: IFSEL2_3 Mask              */
S
S#define PWM_IFA_IFAEN2_3_Pos             (15)                                              /*!< PWM_T::IFA: IFAEN2_3 Position          */
S#define PWM_IFA_IFAEN2_3_Msk             (0x1ul << PWM_IFA_IFAEN2_3_Pos)                   /*!< PWM_T::IFA: IFAEN2_3 Mask              */
S
S#define PWM_IFA_IFCNT4_5_Pos             (16)                                              /*!< PWM_T::IFA: IFCNT4_5 Position          */
S#define PWM_IFA_IFCNT4_5_Msk             (0xful << PWM_IFA_IFCNT4_5_Pos)                   /*!< PWM_T::IFA: IFCNT4_5 Mask              */
S
S#define PWM_IFA_IFSEL4_5_Pos             (20)                                              /*!< PWM_T::IFA: IFSEL4_5 Position          */
S#define PWM_IFA_IFSEL4_5_Msk             (0x7ul << PWM_IFA_IFSEL4_5_Pos)                   /*!< PWM_T::IFA: IFSEL4_5 Mask              */
S
S#define PWM_IFA_IFAEN4_5_Pos             (23)                                              /*!< PWM_T::IFA: IFAEN4_5 Position          */
S#define PWM_IFA_IFAEN4_5_Msk             (0x1ul << PWM_IFA_IFAEN4_5_Pos)                   /*!< PWM_T::IFA: IFAEN4_5 Mask              */
S
S#define PWM_ADCTS0_TRGSEL0_Pos           (0)                                               /*!< PWM_T::ADCTS0: TRGSEL0 Position        */
S#define PWM_ADCTS0_TRGSEL0_Msk           (0xful << PWM_ADCTS0_TRGSEL0_Pos)                 /*!< PWM_T::ADCTS0: TRGSEL0 Mask            */
S
S#define PWM_ADCTS0_TRGEN0_Pos            (7)                                               /*!< PWM_T::ADCTS0: TRGEN0 Position         */
S#define PWM_ADCTS0_TRGEN0_Msk            (0x1ul << PWM_ADCTS0_TRGEN0_Pos)                  /*!< PWM_T::ADCTS0: TRGEN0 Mask             */
S
S#define PWM_ADCTS0_TRGSEL1_Pos           (8)                                               /*!< PWM_T::ADCTS0: TRGSEL1 Position        */
S#define PWM_ADCTS0_TRGSEL1_Msk           (0xful << PWM_ADCTS0_TRGSEL1_Pos)                 /*!< PWM_T::ADCTS0: TRGSEL1 Mask            */
S
S#define PWM_ADCTS0_TRGEN1_Pos            (15)                                              /*!< PWM_T::ADCTS0: TRGEN1 Position         */
S#define PWM_ADCTS0_TRGEN1_Msk            (0x1ul << PWM_ADCTS0_TRGEN1_Pos)                  /*!< PWM_T::ADCTS0: TRGEN1 Mask             */
S
S#define PWM_ADCTS0_TRGSEL2_Pos           (16)                                              /*!< PWM_T::ADCTS0: TRGSEL2 Position        */
S#define PWM_ADCTS0_TRGSEL2_Msk           (0xful << PWM_ADCTS0_TRGSEL2_Pos)                 /*!< PWM_T::ADCTS0: TRGSEL2 Mask            */
S
S#define PWM_ADCTS0_TRGEN2_Pos            (23)                                              /*!< PWM_T::ADCTS0: TRGEN2 Position         */
S#define PWM_ADCTS0_TRGEN2_Msk            (0x1ul << PWM_ADCTS0_TRGEN2_Pos)                  /*!< PWM_T::ADCTS0: TRGEN2 Mask             */
S
S#define PWM_ADCTS0_TRGSEL3_Pos           (24)                                              /*!< PWM_T::ADCTS0: TRGSEL3 Position        */
S#define PWM_ADCTS0_TRGSEL3_Msk           (0xful << PWM_ADCTS0_TRGSEL3_Pos)                 /*!< PWM_T::ADCTS0: TRGSEL3 Mask            */
S
S#define PWM_ADCTS0_TRGEN3_Pos            (31)                                              /*!< PWM_T::ADCTS0: TRGEN3 Position         */
S#define PWM_ADCTS0_TRGEN3_Msk            (0x1ul << PWM_ADCTS0_TRGEN3_Pos)                  /*!< PWM_T::ADCTS0: TRGEN3 Mask             */
S
S#define PWM_ADCTS1_TRGSEL4_Pos           (0)                                               /*!< PWM_T::ADCTS1: TRGSEL4 Position        */
S#define PWM_ADCTS1_TRGSEL4_Msk           (0xful << PWM_ADCTS1_TRGSEL4_Pos)                 /*!< PWM_T::ADCTS1: TRGSEL4 Mask            */
S
S#define PWM_ADCTS1_TRGEN4_Pos            (7)                                               /*!< PWM_T::ADCTS1: TRGEN4 Position         */
S#define PWM_ADCTS1_TRGEN4_Msk            (0x1ul << PWM_ADCTS1_TRGEN4_Pos)                  /*!< PWM_T::ADCTS1: TRGEN4 Mask             */
S
S#define PWM_ADCTS1_TRGSEL5_Pos           (8)                                               /*!< PWM_T::ADCTS1: TRGSEL5 Position        */
S#define PWM_ADCTS1_TRGSEL5_Msk           (0xful << PWM_ADCTS1_TRGSEL5_Pos)                 /*!< PWM_T::ADCTS1: TRGSEL5 Mask            */
S
S#define PWM_ADCTS1_TRGEN5_Pos            (15)                                              /*!< PWM_T::ADCTS1: TRGEN5 Position         */
S#define PWM_ADCTS1_TRGEN5_Msk            (0x1ul << PWM_ADCTS1_TRGEN5_Pos)                  /*!< PWM_T::ADCTS1: TRGEN5 Mask             */
S
S#define PWM_FTCMPDAT0_1_FTCMP_Pos        (0)                                               /*!< PWM_T::FTCMPDAT0_1: FTCMP Position     */
S#define PWM_FTCMPDAT0_1_FTCMP_Msk        (0xfffful << PWM_FTCMPDAT0_1_FTCMP_Pos)           /*!< PWM_T::FTCMPDAT0_1: FTCMP Mask         */
S
S#define PWM_FTCMPDAT2_3_FTCMP_Pos        (0)                                               /*!< PWM_T::FTCMPDAT2_3: FTCMP Position     */
S#define PWM_FTCMPDAT2_3_FTCMP_Msk        (0xfffful << PWM_FTCMPDAT2_3_FTCMP_Pos)           /*!< PWM_T::FTCMPDAT2_3: FTCMP Mask         */
S
S#define PWM_FTCMPDAT4_5_FTCMP_Pos        (0)                                               /*!< PWM_T::FTCMPDAT4_5: FTCMP Position     */
S#define PWM_FTCMPDAT4_5_FTCMP_Msk        (0xfffful << PWM_FTCMPDAT4_5_FTCMP_Pos)           /*!< PWM_T::FTCMPDAT4_5: FTCMP Mask         */
S
S#define PWM_SSCTL_SSEN0_Pos              (0)                                               /*!< PWM_T::SSCTL: SSEN0 Position           */
S#define PWM_SSCTL_SSEN0_Msk              (0x1ul << PWM_SSCTL_SSEN0_Pos)                    /*!< PWM_T::SSCTL: SSEN0 Mask               */
S
S#define PWM_SSCTL_SSEN1_Pos              (1)                                               /*!< PWM_T::SSCTL: SSEN1 Position           */
S#define PWM_SSCTL_SSEN1_Msk              (0x1ul << PWM_SSCTL_SSEN1_Pos)                    /*!< PWM_T::SSCTL: SSEN1 Mask               */
S
S#define PWM_SSCTL_SSEN2_Pos              (2)                                               /*!< PWM_T::SSCTL: SSEN2 Position           */
S#define PWM_SSCTL_SSEN2_Msk              (0x1ul << PWM_SSCTL_SSEN2_Pos)                    /*!< PWM_T::SSCTL: SSEN2 Mask               */
S
S#define PWM_SSCTL_SSEN3_Pos              (3)                                               /*!< PWM_T::SSCTL: SSEN3 Position           */
S#define PWM_SSCTL_SSEN3_Msk              (0x1ul << PWM_SSCTL_SSEN3_Pos)                    /*!< PWM_T::SSCTL: SSEN3 Mask               */
S
S#define PWM_SSCTL_SSEN4_Pos              (4)                                               /*!< PWM_T::SSCTL: SSEN4 Position           */
S#define PWM_SSCTL_SSEN4_Msk              (0x1ul << PWM_SSCTL_SSEN4_Pos)                    /*!< PWM_T::SSCTL: SSEN4 Mask               */
S
S#define PWM_SSCTL_SSEN5_Pos              (5)                                               /*!< PWM_T::SSCTL: SSEN5 Position           */
S#define PWM_SSCTL_SSEN5_Msk              (0x1ul << PWM_SSCTL_SSEN5_Pos)                    /*!< PWM_T::SSCTL: SSEN5 Mask               */
S
S#define PWM_SSCTL_SSRC_Pos               (8)                                               /*!< PWM_T::SSCTL: SSRC Position            */
S#define PWM_SSCTL_SSRC_Msk               (0x1ul << PWM_SSCTL_SSRC_Pos)                     /*!< PWM_T::SSCTL: SSRC Mask                */
S
S#define PWM_SSTRG_CNTSEN_Pos             (0)                                               /*!< PWM_T::SSTRG: CNTSEN Position          */
S#define PWM_SSTRG_CNTSEN_Msk             (0x1ul << PWM_SSTRG_CNTSEN_Pos)                   /*!< PWM_T::SSTRG: CNTSEN Mask              */
S
S#define PWM_LEBCTL_LEBEN_Pos             (0)                                               /*!< PWM_T::LEBCTL: LEBEN Position          */
S#define PWM_LEBCTL_LEBEN_Msk             (0x1ul << PWM_LEBCTL_LEBEN_Pos)                   /*!< PWM_T::LEBCTL: LEBEN Mask              */
S
S#define PWM_LEBCTL_SRCEN0_Pos            (8)                                               /*!< PWM_T::LEBCTL: SRCEN0 Position         */
S#define PWM_LEBCTL_SRCEN0_Msk            (0x1ul << PWM_LEBCTL_SRCEN0_Pos)                  /*!< PWM_T::LEBCTL: SRCEN0 Mask             */
S
S#define PWM_LEBCTL_SRCEN2_Pos            (9)                                               /*!< PWM_T::LEBCTL: SRCEN2 Position         */
S#define PWM_LEBCTL_SRCEN2_Msk            (0x1ul << PWM_LEBCTL_SRCEN2_Pos)                  /*!< PWM_T::LEBCTL: SRCEN2 Mask             */
S
S#define PWM_LEBCTL_SRCEN4_Pos            (10)                                              /*!< PWM_T::LEBCTL: SRCEN4 Position         */
S#define PWM_LEBCTL_SRCEN4_Msk            (0x1ul << PWM_LEBCTL_SRCEN4_Pos)                  /*!< PWM_T::LEBCTL: SRCEN4 Mask             */
S
S#define PWM_LEBCTL_TRGTYPE_Pos           (16)                                              /*!< PWM_T::LEBCTL: TRGTYPE Position        */
S#define PWM_LEBCTL_TRGTYPE_Msk           (0x3ul << PWM_LEBCTL_TRGTYPE_Pos)                 /*!< PWM_T::LEBCTL: TRGTYPE Mask            */
S
S#define PWM_LEBCNT_LEBCNT_Pos            (0)                                               /*!< PWM_T::LEBCNT: LEBCNT Position         */
S#define PWM_LEBCNT_LEBCNT_Msk            (0x1fful << PWM_LEBCNT_LEBCNT_Pos)                /*!< PWM_T::LEBCNT: LEBCNT Mask             */
S
S#define PWM_STATUS_CNTMAXF0_Pos          (0)                                               /*!< PWM_T::STATUS: CNTMAXF0 Position       */
S#define PWM_STATUS_CNTMAXF0_Msk          (0x1ul << PWM_STATUS_CNTMAXF0_Pos)                /*!< PWM_T::STATUS: CNTMAXF0 Mask           */
S
S#define PWM_STATUS_CNTMAXF1_Pos          (1)                                               /*!< PWM_T::STATUS: CNTMAXF1 Position       */
S#define PWM_STATUS_CNTMAXF1_Msk          (0x1ul << PWM_STATUS_CNTMAXF1_Pos)                /*!< PWM_T::STATUS: CNTMAXF1 Mask           */
S
S#define PWM_STATUS_CNTMAXF2_Pos          (2)                                               /*!< PWM_T::STATUS: CNTMAXF2 Position       */
S#define PWM_STATUS_CNTMAXF2_Msk          (0x1ul << PWM_STATUS_CNTMAXF2_Pos)                /*!< PWM_T::STATUS: CNTMAXF2 Mask           */
S
S#define PWM_STATUS_CNTMAXF3_Pos          (3)                                               /*!< PWM_T::STATUS: CNTMAXF3 Position       */
S#define PWM_STATUS_CNTMAXF3_Msk          (0x1ul << PWM_STATUS_CNTMAXF3_Pos)                /*!< PWM_T::STATUS: CNTMAXF3 Mask           */
S
S#define PWM_STATUS_CNTMAXF4_Pos          (4)                                               /*!< PWM_T::STATUS: CNTMAXF4 Position       */
S#define PWM_STATUS_CNTMAXF4_Msk          (0x1ul << PWM_STATUS_CNTMAXF4_Pos)                /*!< PWM_T::STATUS: CNTMAXF4 Mask           */
S
S#define PWM_STATUS_CNTMAXF5_Pos          (5)                                               /*!< PWM_T::STATUS: CNTMAXF5 Position       */
S#define PWM_STATUS_CNTMAXF5_Msk          (0x1ul << PWM_STATUS_CNTMAXF5_Pos)                /*!< PWM_T::STATUS: CNTMAXF5 Mask           */
S
S#define PWM_STATUS_SYNCINF0_Pos          (8)                                               /*!< PWM_T::STATUS: SYNCINF0 Position       */
S#define PWM_STATUS_SYNCINF0_Msk          (0x1ul << PWM_STATUS_SYNCINF0_Pos)                /*!< PWM_T::STATUS: SYNCINF0 Mask           */
S
S#define PWM_STATUS_SYNCINF2_Pos          (9)                                               /*!< PWM_T::STATUS: SYNCINF2 Position       */
S#define PWM_STATUS_SYNCINF2_Msk          (0x1ul << PWM_STATUS_SYNCINF2_Pos)                /*!< PWM_T::STATUS: SYNCINF2 Mask           */
S
S#define PWM_STATUS_SYNCINF4_Pos          (10)                                              /*!< PWM_T::STATUS: SYNCINF4 Position       */
S#define PWM_STATUS_SYNCINF4_Msk          (0x1ul << PWM_STATUS_SYNCINF4_Pos)                /*!< PWM_T::STATUS: SYNCINF4 Mask           */
S
S#define PWM_STATUS_ADCTRGF0_Pos          (16)                                              /*!< PWM_T::STATUS: ADCTRGF0 Position       */
S#define PWM_STATUS_ADCTRGF0_Msk          (0x1ul << PWM_STATUS_ADCTRGF0_Pos)                /*!< PWM_T::STATUS: ADCTRGF0 Mask           */
S
S#define PWM_STATUS_ADCTRGF1_Pos          (17)                                              /*!< PWM_T::STATUS: ADCTRGF1 Position       */
S#define PWM_STATUS_ADCTRGF1_Msk          (0x1ul << PWM_STATUS_ADCTRGF1_Pos)                /*!< PWM_T::STATUS: ADCTRGF1 Mask           */
S
S#define PWM_STATUS_ADCTRGF2_Pos          (18)                                              /*!< PWM_T::STATUS: ADCTRGF2 Position       */
S#define PWM_STATUS_ADCTRGF2_Msk          (0x1ul << PWM_STATUS_ADCTRGF2_Pos)                /*!< PWM_T::STATUS: ADCTRGF2 Mask           */
S
S#define PWM_STATUS_ADCTRGF3_Pos          (19)                                              /*!< PWM_T::STATUS: ADCTRGF3 Position       */
S#define PWM_STATUS_ADCTRGF3_Msk          (0x1ul << PWM_STATUS_ADCTRGF3_Pos)                /*!< PWM_T::STATUS: ADCTRGF3 Mask           */
S
S#define PWM_STATUS_ADCTRGF4_Pos          (20)                                              /*!< PWM_T::STATUS: ADCTRGF4 Position       */
S#define PWM_STATUS_ADCTRGF4_Msk          (0x1ul << PWM_STATUS_ADCTRGF4_Pos)                /*!< PWM_T::STATUS: ADCTRGF4 Mask           */
S
S#define PWM_STATUS_ADCTRGF5_Pos          (21)                                              /*!< PWM_T::STATUS: ADCTRGF5 Position       */
S#define PWM_STATUS_ADCTRGF5_Msk          (0x1ul << PWM_STATUS_ADCTRGF5_Pos)                /*!< PWM_T::STATUS: ADCTRGF5 Mask           */
S
S#define PWM_CAPINEN_CAPINEN0_Pos         (0)                                               /*!< PWM_T::CAPINEN: CAPINEN0 Position      */
S#define PWM_CAPINEN_CAPINEN0_Msk         (0x1ul << PWM_CAPINEN_CAPINEN0_Pos)               /*!< PWM_T::CAPINEN: CAPINEN0 Mask          */
S
S#define PWM_CAPINEN_CAPINEN1_Pos         (1)                                               /*!< PWM_T::CAPINEN: CAPINEN1 Position      */
S#define PWM_CAPINEN_CAPINEN1_Msk         (0x1ul << PWM_CAPINEN_CAPINEN1_Pos)               /*!< PWM_T::CAPINEN: CAPINEN1 Mask          */
S
S#define PWM_CAPINEN_CAPINEN2_Pos         (2)                                               /*!< PWM_T::CAPINEN: CAPINEN2 Position      */
S#define PWM_CAPINEN_CAPINEN2_Msk         (0x1ul << PWM_CAPINEN_CAPINEN2_Pos)               /*!< PWM_T::CAPINEN: CAPINEN2 Mask          */
S
S#define PWM_CAPINEN_CAPINEN3_Pos         (3)                                               /*!< PWM_T::CAPINEN: CAPINEN3 Position      */
S#define PWM_CAPINEN_CAPINEN3_Msk         (0x1ul << PWM_CAPINEN_CAPINEN3_Pos)               /*!< PWM_T::CAPINEN: CAPINEN3 Mask          */
S
S#define PWM_CAPINEN_CAPINEN4_Pos         (4)                                               /*!< PWM_T::CAPINEN: CAPINEN4 Position      */
S#define PWM_CAPINEN_CAPINEN4_Msk         (0x1ul << PWM_CAPINEN_CAPINEN4_Pos)               /*!< PWM_T::CAPINEN: CAPINEN4 Mask          */
S
S#define PWM_CAPINEN_CAPINEN5_Pos         (5)                                               /*!< PWM_T::CAPINEN: CAPINEN5 Position      */
S#define PWM_CAPINEN_CAPINEN5_Msk         (0x1ul << PWM_CAPINEN_CAPINEN5_Pos)               /*!< PWM_T::CAPINEN: CAPINEN5 Mask          */
S
S#define PWM_CAPCTL_CAPEN0_Pos            (0)                                               /*!< PWM_T::CAPCTL: CAPEN0 Position         */
S#define PWM_CAPCTL_CAPEN0_Msk            (0x1ul << PWM_CAPCTL_CAPEN0_Pos)                  /*!< PWM_T::CAPCTL: CAPEN0 Mask             */
S
S#define PWM_CAPCTL_CAPEN1_Pos            (1)                                               /*!< PWM_T::CAPCTL: CAPEN1 Position         */
S#define PWM_CAPCTL_CAPEN1_Msk            (0x1ul << PWM_CAPCTL_CAPEN1_Pos)                  /*!< PWM_T::CAPCTL: CAPEN1 Mask             */
S
S#define PWM_CAPCTL_CAPEN2_Pos            (2)                                               /*!< PWM_T::CAPCTL: CAPEN2 Position         */
S#define PWM_CAPCTL_CAPEN2_Msk            (0x1ul << PWM_CAPCTL_CAPEN2_Pos)                  /*!< PWM_T::CAPCTL: CAPEN2 Mask             */
S
S#define PWM_CAPCTL_CAPEN3_Pos            (3)                                               /*!< PWM_T::CAPCTL: CAPEN3 Position         */
S#define PWM_CAPCTL_CAPEN3_Msk            (0x1ul << PWM_CAPCTL_CAPEN3_Pos)                  /*!< PWM_T::CAPCTL: CAPEN3 Mask             */
S
S#define PWM_CAPCTL_CAPEN4_Pos            (4)                                               /*!< PWM_T::CAPCTL: CAPEN4 Position         */
S#define PWM_CAPCTL_CAPEN4_Msk            (0x1ul << PWM_CAPCTL_CAPEN4_Pos)                  /*!< PWM_T::CAPCTL: CAPEN4 Mask             */
S
S#define PWM_CAPCTL_CAPEN5_Pos            (5)                                               /*!< PWM_T::CAPCTL: CAPEN5 Position         */
S#define PWM_CAPCTL_CAPEN5_Msk            (0x1ul << PWM_CAPCTL_CAPEN5_Pos)                  /*!< PWM_T::CAPCTL: CAPEN5 Mask             */
S
S#define PWM_CAPCTL_CAPINV0_Pos           (8)                                               /*!< PWM_T::CAPCTL: CAPINV0 Position        */
S#define PWM_CAPCTL_CAPINV0_Msk           (0x1ul << PWM_CAPCTL_CAPINV0_Pos)                 /*!< PWM_T::CAPCTL: CAPINV0 Mask            */
S
S#define PWM_CAPCTL_CAPINV1_Pos           (9)                                               /*!< PWM_T::CAPCTL: CAPINV1 Position        */
S#define PWM_CAPCTL_CAPINV1_Msk           (0x1ul << PWM_CAPCTL_CAPINV1_Pos)                 /*!< PWM_T::CAPCTL: CAPINV1 Mask            */
S
S#define PWM_CAPCTL_CAPINV2_Pos           (10)                                              /*!< PWM_T::CAPCTL: CAPINV2 Position        */
S#define PWM_CAPCTL_CAPINV2_Msk           (0x1ul << PWM_CAPCTL_CAPINV2_Pos)                 /*!< PWM_T::CAPCTL: CAPINV2 Mask            */
S
S#define PWM_CAPCTL_CAPINV3_Pos           (11)                                              /*!< PWM_T::CAPCTL: CAPINV3 Position        */
S#define PWM_CAPCTL_CAPINV3_Msk           (0x1ul << PWM_CAPCTL_CAPINV3_Pos)                 /*!< PWM_T::CAPCTL: CAPINV3 Mask            */
S
S#define PWM_CAPCTL_CAPINV4_Pos           (12)                                              /*!< PWM_T::CAPCTL: CAPINV4 Position        */
S#define PWM_CAPCTL_CAPINV4_Msk           (0x1ul << PWM_CAPCTL_CAPINV4_Pos)                 /*!< PWM_T::CAPCTL: CAPINV4 Mask            */
S
S#define PWM_CAPCTL_CAPINV5_Pos           (13)                                              /*!< PWM_T::CAPCTL: CAPINV5 Position        */
S#define PWM_CAPCTL_CAPINV5_Msk           (0x1ul << PWM_CAPCTL_CAPINV5_Pos)                 /*!< PWM_T::CAPCTL: CAPINV5 Mask            */
S
S#define PWM_CAPCTL_RCRLDEN0_Pos          (16)                                              /*!< PWM_T::CAPCTL: RCRLDEN0 Position       */
S#define PWM_CAPCTL_RCRLDEN0_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN0_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN0 Mask           */
S
S#define PWM_CAPCTL_RCRLDEN1_Pos          (17)                                              /*!< PWM_T::CAPCTL: RCRLDEN1 Position       */
S#define PWM_CAPCTL_RCRLDEN1_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN1_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN1 Mask           */
S
S#define PWM_CAPCTL_RCRLDEN2_Pos          (18)                                              /*!< PWM_T::CAPCTL: RCRLDEN2 Position       */
S#define PWM_CAPCTL_RCRLDEN2_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN2_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN2 Mask           */
S
S#define PWM_CAPCTL_RCRLDEN3_Pos          (19)                                              /*!< PWM_T::CAPCTL: RCRLDEN3 Position       */
S#define PWM_CAPCTL_RCRLDEN3_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN3_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN3 Mask           */
S
S#define PWM_CAPCTL_RCRLDEN4_Pos          (20)                                              /*!< PWM_T::CAPCTL: RCRLDEN4 Position       */
S#define PWM_CAPCTL_RCRLDEN4_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN4_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN4 Mask           */
S
S#define PWM_CAPCTL_RCRLDEN5_Pos          (21)                                              /*!< PWM_T::CAPCTL: RCRLDEN5 Position       */
S#define PWM_CAPCTL_RCRLDEN5_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN5_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN5 Mask           */
S
S#define PWM_CAPCTL_FCRLDEN0_Pos          (24)                                              /*!< PWM_T::CAPCTL: FCRLDEN0 Position       */
S#define PWM_CAPCTL_FCRLDEN0_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN0_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN0 Mask           */
S
S#define PWM_CAPCTL_FCRLDEN1_Pos          (25)                                              /*!< PWM_T::CAPCTL: FCRLDEN1 Position       */
S#define PWM_CAPCTL_FCRLDEN1_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN1_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN1 Mask           */
S
S#define PWM_CAPCTL_FCRLDEN2_Pos          (26)                                              /*!< PWM_T::CAPCTL: FCRLDEN2 Position       */
S#define PWM_CAPCTL_FCRLDEN2_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN2_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN2 Mask           */
S
S#define PWM_CAPCTL_FCRLDEN3_Pos          (27)                                              /*!< PWM_T::CAPCTL: FCRLDEN3 Position       */
S#define PWM_CAPCTL_FCRLDEN3_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN3_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN3 Mask           */
S
S#define PWM_CAPCTL_FCRLDEN4_Pos          (28)                                              /*!< PWM_T::CAPCTL: FCRLDEN4 Position       */
S#define PWM_CAPCTL_FCRLDEN4_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN4_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN4 Mask           */
S
S#define PWM_CAPCTL_FCRLDEN5_Pos          (29)                                              /*!< PWM_T::CAPCTL: FCRLDEN5 Position       */
S#define PWM_CAPCTL_FCRLDEN5_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN5_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN5 Mask           */
S
S#define PWM_CAPSTS_CRLIFOV0_Pos          (0)                                               /*!< PWM_T::CAPSTS: CRLIFOV0 Position       */
S#define PWM_CAPSTS_CRLIFOV0_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV0_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV0 Mask           */
S
S#define PWM_CAPSTS_CRLIFOV1_Pos          (1)                                               /*!< PWM_T::CAPSTS: CRLIFOV1 Position       */
S#define PWM_CAPSTS_CRLIFOV1_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV1_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV1 Mask           */
S
S#define PWM_CAPSTS_CRLIFOV2_Pos          (2)                                               /*!< PWM_T::CAPSTS: CRLIFOV2 Position       */
S#define PWM_CAPSTS_CRLIFOV2_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV2_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV2 Mask           */
S
S#define PWM_CAPSTS_CRLIFOV3_Pos          (3)                                               /*!< PWM_T::CAPSTS: CRLIFOV3 Position       */
S#define PWM_CAPSTS_CRLIFOV3_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV3_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV3 Mask           */
S
S#define PWM_CAPSTS_CRLIFOV4_Pos          (4)                                               /*!< PWM_T::CAPSTS: CRLIFOV4 Position       */
S#define PWM_CAPSTS_CRLIFOV4_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV4_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV4 Mask           */
S
S#define PWM_CAPSTS_CRLIFOV5_Pos          (5)                                               /*!< PWM_T::CAPSTS: CRLIFOV5 Position       */
S#define PWM_CAPSTS_CRLIFOV5_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV5_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV5 Mask           */
S
S#define PWM_CAPSTS_CFLIFOV0_Pos          (8)                                               /*!< PWM_T::CAPSTS: CFLIFOV0 Position       */
S#define PWM_CAPSTS_CFLIFOV0_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV0_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV0 Mask           */
S
S#define PWM_CAPSTS_CFLIFOV1_Pos          (9)                                               /*!< PWM_T::CAPSTS: CFLIFOV1 Position       */
S#define PWM_CAPSTS_CFLIFOV1_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV1_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV1 Mask           */
S
S#define PWM_CAPSTS_CFLIFOV2_Pos          (10)                                              /*!< PWM_T::CAPSTS: CFLIFOV2 Position       */
S#define PWM_CAPSTS_CFLIFOV2_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV2_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV2 Mask           */
S
S#define PWM_CAPSTS_CFLIFOV3_Pos          (11)                                              /*!< PWM_T::CAPSTS: CFLIFOV3 Position       */
S#define PWM_CAPSTS_CFLIFOV3_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV3_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV3 Mask           */
S
S#define PWM_CAPSTS_CFLIFOV4_Pos          (12)                                              /*!< PWM_T::CAPSTS: CFLIFOV4 Position       */
S#define PWM_CAPSTS_CFLIFOV4_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV4_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV4 Mask           */
S
S#define PWM_CAPSTS_CFLIFOV5_Pos          (13)                                              /*!< PWM_T::CAPSTS: CFLIFOV5 Position       */
S#define PWM_CAPSTS_CFLIFOV5_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV5_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV5 Mask           */
S
S#define PWM_RCAPDAT0_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT0: RCAPDAT Position      */
S#define PWM_RCAPDAT0_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT0_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT0: RCAPDAT Mask          */
S
S#define PWM_FCAPDAT0_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT0: FCAPDAT Position      */
S#define PWM_FCAPDAT0_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT0_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT0: FCAPDAT Mask          */
S
S#define PWM_RCAPDAT1_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT1: RCAPDAT Position      */
S#define PWM_RCAPDAT1_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT1_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT1: RCAPDAT Mask          */
S
S#define PWM_FCAPDAT1_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT1: FCAPDAT Position      */
S#define PWM_FCAPDAT1_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT1_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT1: FCAPDAT Mask          */
S
S#define PWM_RCAPDAT2_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT2: RCAPDAT Position      */
S#define PWM_RCAPDAT2_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT2_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT2: RCAPDAT Mask          */
S
S#define PWM_FCAPDAT2_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT2: FCAPDAT Position      */
S#define PWM_FCAPDAT2_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT2_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT2: FCAPDAT Mask          */
S
S#define PWM_RCAPDAT3_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT3: RCAPDAT Position      */
S#define PWM_RCAPDAT3_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT3_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT3: RCAPDAT Mask          */
S
S#define PWM_FCAPDAT3_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT3: FCAPDAT Position      */
S#define PWM_FCAPDAT3_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT3_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT3: FCAPDAT Mask          */
S
S#define PWM_RCAPDAT4_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT4: RCAPDAT Position      */
S#define PWM_RCAPDAT4_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT4_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT4: RCAPDAT Mask          */
S
S#define PWM_FCAPDAT4_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT4: FCAPDAT Position      */
S#define PWM_FCAPDAT4_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT4_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT4: FCAPDAT Mask          */
S
S#define PWM_RCAPDAT5_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT5: RCAPDAT Position      */
S#define PWM_RCAPDAT5_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT5_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT5: RCAPDAT Mask          */
S
S#define PWM_FCAPDAT5_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT5: FCAPDAT Position      */
S#define PWM_FCAPDAT5_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT5_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT5: FCAPDAT Mask          */
S
S#define PWM_PDMACTL_CHEN0_1_Pos          (0)                                               /*!< PWM_T::PDMACTL: CHEN0_1 Position       */
S#define PWM_PDMACTL_CHEN0_1_Msk          (0x1ul << PWM_PDMACTL_CHEN0_1_Pos)                /*!< PWM_T::PDMACTL: CHEN0_1 Mask           */
S
S#define PWM_PDMACTL_CAPMOD0_1_Pos        (1)                                               /*!< PWM_T::PDMACTL: CAPMOD0_1 Position     */
S#define PWM_PDMACTL_CAPMOD0_1_Msk        (0x3ul << PWM_PDMACTL_CAPMOD0_1_Pos)              /*!< PWM_T::PDMACTL: CAPMOD0_1 Mask         */
S
S#define PWM_PDMACTL_CAPORD0_1_Pos        (3)                                               /*!< PWM_T::PDMACTL: CAPORD0_1 Position     */
S#define PWM_PDMACTL_CAPORD0_1_Msk        (0x1ul << PWM_PDMACTL_CAPORD0_1_Pos)              /*!< PWM_T::PDMACTL: CAPORD0_1 Mask         */
S
S#define PWM_PDMACTL_CHSEL0_1_Pos         (4)                                               /*!< PWM_T::PDMACTL: CHSEL0_1 Position      */
S#define PWM_PDMACTL_CHSEL0_1_Msk         (0x1ul << PWM_PDMACTL_CHSEL0_1_Pos)               /*!< PWM_T::PDMACTL: CHSEL0_1 Mask          */
S
S#define PWM_PDMACTL_CHEN2_3_Pos          (8)                                               /*!< PWM_T::PDMACTL: CHEN2_3 Position       */
S#define PWM_PDMACTL_CHEN2_3_Msk          (0x1ul << PWM_PDMACTL_CHEN2_3_Pos)                /*!< PWM_T::PDMACTL: CHEN2_3 Mask           */
S
S#define PWM_PDMACTL_CAPMOD2_3_Pos        (9)                                               /*!< PWM_T::PDMACTL: CAPMOD2_3 Position     */
S#define PWM_PDMACTL_CAPMOD2_3_Msk        (0x3ul << PWM_PDMACTL_CAPMOD2_3_Pos)              /*!< PWM_T::PDMACTL: CAPMOD2_3 Mask         */
S
S#define PWM_PDMACTL_CAPORD2_3_Pos        (11)                                              /*!< PWM_T::PDMACTL: CAPORD2_3 Position     */
S#define PWM_PDMACTL_CAPORD2_3_Msk        (0x1ul << PWM_PDMACTL_CAPORD2_3_Pos)              /*!< PWM_T::PDMACTL: CAPORD2_3 Mask         */
S
S#define PWM_PDMACTL_CHSEL2_3_Pos         (12)                                              /*!< PWM_T::PDMACTL: CHSEL2_3 Position      */
S#define PWM_PDMACTL_CHSEL2_3_Msk         (0x1ul << PWM_PDMACTL_CHSEL2_3_Pos)               /*!< PWM_T::PDMACTL: CHSEL2_3 Mask          */
S
S#define PWM_PDMACTL_CHEN4_5_Pos          (16)                                              /*!< PWM_T::PDMACTL: CHEN4_5 Position       */
S#define PWM_PDMACTL_CHEN4_5_Msk          (0x1ul << PWM_PDMACTL_CHEN4_5_Pos)                /*!< PWM_T::PDMACTL: CHEN4_5 Mask           */
S
S#define PWM_PDMACTL_CAPMOD4_5_Pos        (17)                                              /*!< PWM_T::PDMACTL: CAPMOD4_5 Position     */
S#define PWM_PDMACTL_CAPMOD4_5_Msk        (0x3ul << PWM_PDMACTL_CAPMOD4_5_Pos)              /*!< PWM_T::PDMACTL: CAPMOD4_5 Mask         */
S
S#define PWM_PDMACTL_CAPORD4_5_Pos        (19)                                              /*!< PWM_T::PDMACTL: CAPORD4_5 Position     */
S#define PWM_PDMACTL_CAPORD4_5_Msk        (0x1ul << PWM_PDMACTL_CAPORD4_5_Pos)              /*!< PWM_T::PDMACTL: CAPORD4_5 Mask         */
S
S#define PWM_PDMACTL_CHSEL4_5_Pos         (20)                                              /*!< PWM_T::PDMACTL: CHSEL4_5 Position      */
S#define PWM_PDMACTL_CHSEL4_5_Msk         (0x1ul << PWM_PDMACTL_CHSEL4_5_Pos)               /*!< PWM_T::PDMACTL: CHSEL4_5 Mask          */
S
S#define PWM_PDMACAP0_1_CAPBUF_Pos        (0)                                               /*!< PWM_T::PDMACAP0_1: CAPBUF Position     */
S#define PWM_PDMACAP0_1_CAPBUF_Msk        (0xfffful << PWM_PDMACAP0_1_CAPBUF_Pos)           /*!< PWM_T::PDMACAP0_1: CAPBUF Mask         */
S
S#define PWM_PDMACAP2_3_CAPBUF_Pos        (0)                                               /*!< PWM_T::PDMACAP2_3: CAPBUF Position     */
S#define PWM_PDMACAP2_3_CAPBUF_Msk        (0xfffful << PWM_PDMACAP2_3_CAPBUF_Pos)           /*!< PWM_T::PDMACAP2_3: CAPBUF Mask         */
S
S#define PWM_PDMACAP4_5_CAPBUF_Pos        (0)                                               /*!< PWM_T::PDMACAP4_5: CAPBUF Position     */
S#define PWM_PDMACAP4_5_CAPBUF_Msk        (0xfffful << PWM_PDMACAP4_5_CAPBUF_Pos)           /*!< PWM_T::PDMACAP4_5: CAPBUF Mask         */
S
S#define PWM_CAPIEN_CAPRIEN0_Pos          (0)                                               /*!< PWM_T::CAPIEN: CAPRIEN0 Position       */
S#define PWM_CAPIEN_CAPRIEN0_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN0_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN0 Mask           */
S
S#define PWM_CAPIEN_CAPRIEN1_Pos          (1)                                               /*!< PWM_T::CAPIEN: CAPRIEN1 Position       */
S#define PWM_CAPIEN_CAPRIEN1_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN1_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN1 Mask           */
S
S#define PWM_CAPIEN_CAPRIEN2_Pos          (2)                                               /*!< PWM_T::CAPIEN: CAPRIEN2 Position       */
S#define PWM_CAPIEN_CAPRIEN2_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN2_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN2 Mask           */
S
S#define PWM_CAPIEN_CAPRIEN3_Pos          (3)                                               /*!< PWM_T::CAPIEN: CAPRIEN3 Position       */
S#define PWM_CAPIEN_CAPRIEN3_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN3_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN3 Mask           */
S
S#define PWM_CAPIEN_CAPRIEN4_Pos          (4)                                               /*!< PWM_T::CAPIEN: CAPRIEN4 Position       */
S#define PWM_CAPIEN_CAPRIEN4_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN4_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN4 Mask           */
S
S#define PWM_CAPIEN_CAPRIEN5_Pos          (5)                                               /*!< PWM_T::CAPIEN: CAPRIEN5 Position       */
S#define PWM_CAPIEN_CAPRIEN5_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN5_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN5 Mask           */
S
S#define PWM_CAPIEN_CAPFIEN0_Pos          (8)                                               /*!< PWM_T::CAPIEN: CAPFIEN0 Position       */
S#define PWM_CAPIEN_CAPFIEN0_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN0_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN0 Mask           */
S
S#define PWM_CAPIEN_CAPFIEN1_Pos          (9)                                               /*!< PWM_T::CAPIEN: CAPFIEN1 Position       */
S#define PWM_CAPIEN_CAPFIEN1_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN1_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN1 Mask           */
S
S#define PWM_CAPIEN_CAPFIEN2_Pos          (10)                                              /*!< PWM_T::CAPIEN: CAPFIEN2 Position       */
S#define PWM_CAPIEN_CAPFIEN2_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN2_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN2 Mask           */
S
S#define PWM_CAPIEN_CAPFIEN3_Pos          (11)                                              /*!< PWM_T::CAPIEN: CAPFIEN3 Position       */
S#define PWM_CAPIEN_CAPFIEN3_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN3_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN3 Mask           */
S
S#define PWM_CAPIEN_CAPFIEN4_Pos          (12)                                              /*!< PWM_T::CAPIEN: CAPFIEN4 Position       */
S#define PWM_CAPIEN_CAPFIEN4_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN4_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN4 Mask           */
S
S#define PWM_CAPIEN_CAPFIEN5_Pos          (13)                                              /*!< PWM_T::CAPIEN: CAPFIEN5 Position       */
S#define PWM_CAPIEN_CAPFIEN5_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN5_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN5 Mask           */
S
S#define PWM_CAPIF_CRLIF0_Pos             (0)                                               /*!< PWM_T::CAPIF: CRLIF0 Position          */
S#define PWM_CAPIF_CRLIF0_Msk             (0x1ul << PWM_CAPIF_CRLIF0_Pos)                   /*!< PWM_T::CAPIF: CRLIF0 Mask              */
S
S#define PWM_CAPIF_CRLIF1_Pos             (1)                                               /*!< PWM_T::CAPIF: CRLIF1 Position          */
S#define PWM_CAPIF_CRLIF1_Msk             (0x1ul << PWM_CAPIF_CRLIF1_Pos)                   /*!< PWM_T::CAPIF: CRLIF1 Mask              */
S
S#define PWM_CAPIF_CRLIF2_Pos             (2)                                               /*!< PWM_T::CAPIF: CRLIF2 Position          */
S#define PWM_CAPIF_CRLIF2_Msk             (0x1ul << PWM_CAPIF_CRLIF2_Pos)                   /*!< PWM_T::CAPIF: CRLIF2 Mask              */
S
S#define PWM_CAPIF_CRLIF3_Pos             (3)                                               /*!< PWM_T::CAPIF: CRLIF3 Position          */
S#define PWM_CAPIF_CRLIF3_Msk             (0x1ul << PWM_CAPIF_CRLIF3_Pos)                   /*!< PWM_T::CAPIF: CRLIF3 Mask              */
S
S#define PWM_CAPIF_CRLIF4_Pos             (4)                                               /*!< PWM_T::CAPIF: CRLIF4 Position          */
S#define PWM_CAPIF_CRLIF4_Msk             (0x1ul << PWM_CAPIF_CRLIF4_Pos)                   /*!< PWM_T::CAPIF: CRLIF4 Mask              */
S
S#define PWM_CAPIF_CRLIF5_Pos             (5)                                               /*!< PWM_T::CAPIF: CRLIF5 Position          */
S#define PWM_CAPIF_CRLIF5_Msk             (0x1ul << PWM_CAPIF_CRLIF5_Pos)                   /*!< PWM_T::CAPIF: CRLIF5 Mask              */
S
S#define PWM_CAPIF_CFLIF0_Pos             (8)                                               /*!< PWM_T::CAPIF: CFLIF0 Position          */
S#define PWM_CAPIF_CFLIF0_Msk             (0x1ul << PWM_CAPIF_CFLIF0_Pos)                   /*!< PWM_T::CAPIF: CFLIF0 Mask              */
S
S#define PWM_CAPIF_CFLIF1_Pos             (9)                                               /*!< PWM_T::CAPIF: CFLIF1 Position          */
S#define PWM_CAPIF_CFLIF1_Msk             (0x1ul << PWM_CAPIF_CFLIF1_Pos)                   /*!< PWM_T::CAPIF: CFLIF1 Mask              */
S
S#define PWM_CAPIF_CFLIF2_Pos             (10)                                              /*!< PWM_T::CAPIF: CFLIF2 Position          */
S#define PWM_CAPIF_CFLIF2_Msk             (0x1ul << PWM_CAPIF_CFLIF2_Pos)                   /*!< PWM_T::CAPIF: CFLIF2 Mask              */
S
S#define PWM_CAPIF_CFLIF3_Pos             (11)                                              /*!< PWM_T::CAPIF: CFLIF3 Position          */
S#define PWM_CAPIF_CFLIF3_Msk             (0x1ul << PWM_CAPIF_CFLIF3_Pos)                   /*!< PWM_T::CAPIF: CFLIF3 Mask              */
S
S#define PWM_CAPIF_CFLIF4_Pos             (12)                                              /*!< PWM_T::CAPIF: CFLIF4 Position          */
S#define PWM_CAPIF_CFLIF4_Msk             (0x1ul << PWM_CAPIF_CFLIF4_Pos)                   /*!< PWM_T::CAPIF: CFLIF4 Mask              */
S
S#define PWM_CAPIF_CFLIF5_Pos             (13)                                              /*!< PWM_T::CAPIF: CFLIF5 Position          */
S#define PWM_CAPIF_CFLIF5_Msk             (0x1ul << PWM_CAPIF_CFLIF5_Pos)                   /*!< PWM_T::CAPIF: CFLIF5 Mask              */
S
S#define PWM_PBUF_PBUF_Pos                (0)                                               /*!< PWM_T::PBUF: PBUF Position             */
S#define PWM_PBUF_PBUF_Msk                (0xfffful << PWM_PBUF_PBUF_Pos)                   /*!< PWM_T::PBUF: PBUF Mask                 */
S
S#define PWM_CMPBUF_CMPBUF_Pos            (0)                                               /*!< PWM_T::CMPBUF: CMPBUF Position         */
S#define PWM_CMPBUF_CMPBUF_Msk            (0xfffful << PWM_CMPBUF_CMPBUF_Pos)               /*!< PWM_T::CMPBUF: CMPBUF Mask             */
S
S#define PWM_CPSCBUF0_1_CPSCBUF_Pos       (0)                                               /*!< PWM_T::CPSCBUF0_1: CPSCBUF Position    */
S#define PWM_CPSCBUF0_1_CPSCBUF_Msk       (0xffful << PWM_CPSCBUF0_1_CPSCBUF_Pos)           /*!< PWM_T::CPSCBUF0_1: CPSCBUF Mask        */
S
S#define PWM_CPSCBUF2_3_CPSCBUF_Pos       (0)                                               /*!< PWM_T::CPSCBUF2_3: CPSCBUF Position    */
S#define PWM_CPSCBUF2_3_CPSCBUF_Msk       (0xffful << PWM_CPSCBUF2_3_CPSCBUF_Pos)           /*!< PWM_T::CPSCBUF2_3: CPSCBUF Mask        */
S
S#define PWM_CPSCBUF4_5_CPSCBUF_Pos       (0)                                               /*!< PWM_T::CPSCBUF4_5: CPSCBUF Position    */
S#define PWM_CPSCBUF4_5_CPSCBUF_Msk       (0xffful << PWM_CPSCBUF4_5_CPSCBUF_Pos)           /*!< PWM_T::CPSCBUF4_5: CPSCBUF Mask        */
S
S#define PWM_FTCBUF0_1_FTCMPBUF_Pos       (0)                                               /*!< PWM_T::FTCBUF0_1: FTCMPBUF Position    */
S#define PWM_FTCBUF0_1_FTCMPBUF_Msk       (0xfffful << PWM_FTCBUF0_1_FTCMPBUF_Pos)          /*!< PWM_T::FTCBUF0_1: FTCMPBUF Mask        */
S
S#define PWM_FTCBUF2_3_FTCMPBUF_Pos       (0)                                               /*!< PWM_T::FTCBUF2_3: FTCMPBUF Position    */
S#define PWM_FTCBUF2_3_FTCMPBUF_Msk       (0xfffful << PWM_FTCBUF2_3_FTCMPBUF_Pos)          /*!< PWM_T::FTCBUF2_3: FTCMPBUF Mask        */
S
S#define PWM_FTCBUF4_5_FTCMPBUF_Pos       (0)                                               /*!< PWM_T::FTCBUF4_5: FTCMPBUF Position    */
S#define PWM_FTCBUF4_5_FTCMPBUF_Msk       (0xfffful << PWM_FTCBUF4_5_FTCMPBUF_Pos)          /*!< PWM_T::FTCBUF4_5: FTCMPBUF Mask        */
S
S#define PWM_FTCI_FTCMU0_Pos              (0)                                               /*!< PWM_T::FTCI: FTCMU0 Position           */
S#define PWM_FTCI_FTCMU0_Msk              (0x1ul << PWM_FTCI_FTCMU0_Pos)                    /*!< PWM_T::FTCI: FTCMU0 Mask               */
S
S#define PWM_FTCI_FTCMU2_Pos              (1)                                               /*!< PWM_T::FTCI: FTCMU2 Position           */
S#define PWM_FTCI_FTCMU2_Msk              (0x1ul << PWM_FTCI_FTCMU2_Pos)                    /*!< PWM_T::FTCI: FTCMU2 Mask               */
S
S#define PWM_FTCI_FTCMU4_Pos              (2)                                               /*!< PWM_T::FTCI: FTCMU4 Position           */
S#define PWM_FTCI_FTCMU4_Msk              (0x1ul << PWM_FTCI_FTCMU4_Pos)                    /*!< PWM_T::FTCI: FTCMU4 Mask               */
S
S#define PWM_FTCI_FTCMD0_Pos              (8)                                               /*!< PWM_T::FTCI: FTCMD0 Position           */
S#define PWM_FTCI_FTCMD0_Msk              (0x1ul << PWM_FTCI_FTCMD0_Pos)                    /*!< PWM_T::FTCI: FTCMD0 Mask               */
S
S#define PWM_FTCI_FTCMD2_Pos              (9)                                               /*!< PWM_T::FTCI: FTCMD2 Position           */
S#define PWM_FTCI_FTCMD2_Msk              (0x1ul << PWM_FTCI_FTCMD2_Pos)                    /*!< PWM_T::FTCI: FTCMD2 Mask               */
S
S#define PWM_FTCI_FTCMD4_Pos              (10)                                              /*!< PWM_T::FTCI: FTCMD4 Position           */
S#define PWM_FTCI_FTCMD4_Msk              (0x1ul << PWM_FTCI_FTCMD4_Pos)                    /*!< PWM_T::FTCI: FTCMD4 Mask               */
S
S/**@}*/ /* PWM_CONST */
S/**@}*/ /* end of PWM register group */
S
S
S/*---------------------- Real Time Clock Controller -------------------------*/
S/**
S    @addtogroup RTC Real Time Clock Controller(RTC)
S    Memory Mapped Structure for RTC Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var RTC_T::INIT
S     * Offset: 0x00  RTC Initiation Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |INIT_ACTIVE|RTC Active Status (Read Only)
S     * |        |          |0 = RTC is at reset state.
S     * |        |          |1 = RTC is at normal active state.
S     * |[31:1]  |INIT      |RTC Initiation
S     * |        |          |When RTC block is first powered on, RTC is at reset state
S     * |        |          |User has to write a special number (0xA5EB13570x a5eb1357) to INIT to make RTC leaving reset state
S     * |        |          |Once the INIT is written as 0xa5eb13570xA5EB1357, the RTC will be in un-resetat normal active state permanently.
S     * |        |          |The INIT[31:1] is a write-only field and read value will be always 0.
S     * @var RTC_T::RWEN
S     * Offset: 0x04  RTC Access Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RWEN      |RTC Register Access Enable Password (Write Only)
S     * |        |          |Writing 0xA965 to this field register will enable RTC register access period and keep 1024 RTC clocks.
S     * |        |          |Note: Writing others vaule will clear RWENF and disable RTC register access function immediately.
S     * |[16]    |RWENF     |RTC Register Access Enable Flag (Read Only)
S     * |        |          |0 = RTC register read/write Disabled.
S     * |        |          |1 = RTC register read/write Enabled.
S     * |        |          |This bit will be set after RWEN RTC_RWEN[15:0] register is load a 0xA965, and be cleared automatically after 1024 RTC clocks expired.
S     * |        |          |Note: RWENF will be mask to u201C0u201D during RTCBUSY is= 1, and first turn on RTCCKEN (CLK_APBCLK[1]) also.
S     * |[24]    |RTCBUSY   |RTC Write Busy Flag
S     * |        |          |This bit indicates RTC registers are writable or not.
S     * |        |          |0: RTC register write canu2019t writeaccess enable .
S     * |        |          |1: RTC register are writablewrite access disable , RTC under Busy Status..
S     * |        |          |Note: RTCBUSY falg will be set when execute write RTC register command exceed 6 times within By Exceed RTC IP Prcessing Write Counter Capacity ( 6 counts Per 1 1120 PCLK cycles.).
S     * @var RTC_T::FREQADJ
S     * Offset: 0x08  RTC Frequency Compensation Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[21:0]  |FREQADJ   |Frequency Compensation RegisterValue
S     * |        |          |User must to get actual clock freqency of LXT, LXT frequency.
S     * |        |          |When CLK_CLKSEL2[18] = 0.
S     * |        |          |FCR = 0x200000 * (32768 / LXT freqency period).
S     * |        |          |LXT Note: This formula is suitable only when RTCSEL (CLK_CLKSEL2[18]) is 0, RTC clock source is from LXT.period: the clock period (Hz) of LXT.
S     * |        |          |uLIRC period: the clock period (Hz) of LIRC.
S     * |        |          |Note : LIRC can measure by softwaremethod.
S     * @var RTC_T::TIME
S     * Offset: 0x0C  RTC Time Loading Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |SEC       |1-Sec Time Digit (0~9)
S     * |[6:4]   |TENSEC    |10-Sec Time Digit (0~5)
S     * |[11:8]  |MIN       |1-Min Time Digit (0~9)
S     * |[14:12] |TENMIN    |10-Min Time Digit (0~5)
S     * |[19:16] |HR        |1-Hour Time Digit (0~9)
S     * |[21:20] |TENHR     |10-Hour Time Digit (0~2)
S     * |        |          |Note: When RTC runs as 12-hour time scale mode, RTC_TIME[21] (the high bit of TENHR[1:0]) means AM/PM indication, RTC_TIME[21] is 0 means AM hour and RTC_TIME[21] is 1 means PM hour (If RTC_TIME[21] is 1, it indicates PM time message.).
S     * @var RTC_T::CAL
S     * Offset: 0x10  RTC Calendar Loading Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |DAY       |1-Day Calendar Digit (0~9)
S     * |[5:4]   |TENDAY    |10-Day Calendar Digit (0~3)
S     * |[11:8]  |MON       |1-Month Calendar Digit (0~9)
S     * |[12]    |TENMON    |10-Month Calendar Digit (0~1)
S     * |[19:16] |YEAR      |1-Year Calendar Digit (0~9)
S     * |[23:20] |TENYEAR   |10-Year Calendar Digit (0~9)
S     * @var RTC_T::CLKFMT
S     * Offset: 0x14  RTC Time Scale Selection Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |24HEN     |24-hour / 12-hour Time Scale Selection
S     * |        |          |Indicates that RTC_TIME and RTC_TALM register are in 24-hour time scale or 12-hour time scale
S     * |        |          |0 = 12-hour time scale with AM and PM indication selected.
S     * |        |          |1 = 24-hour time scale selected.
S     * @var RTC_T::WEEKDAY
S     * Offset: 0x18  RTC Day of the Week Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2:0]   |WEEKDAY   |Day of the Week Register
S     * |        |          |000 = Sunday.
S     * |        |          |001 = Monday.
S     * |        |          |010 = Tuesday.
S     * |        |          |011 = Wednesday.
S     * |        |          |100 = Thursday.
S     * |        |          |101 = Friday.
S     * |        |          |110 = Saturday.
S     * |        |          |111 = Reserved.
S     * |        |          |Note: RTC will not check WEEKDAY setting with RTC_CAL is reasonable or not.
S     * @var RTC_T::TALM
S     * Offset: 0x1C  RTC Time Alarm Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |SEC       |1-Sec Time Digit of Alarm Setting (0~9)
S     * |[6:4]   |TENSEC    |10-Sec Time Digit of Alarm Setting (0~5)
S     * |[11:8]  |MIN       |1-Min Time Digit of Alarm Setting (0~9)
S     * |[14:12] |TENMIN    |10-Min Time Digit of Alarm Setting (0~5)
S     * |[19:16] |HR        |1-Hour Time Digit of Alarm Setting (0~9)
S     * |[21:20] |TENHR     |10-Hour Time Digit of Alarm Setting (0~2) When RTC runs as 12-hour time scale mode, RTC_TIME[21] (the high bit of TENHR[1:0]) means AM/PM indication (If RTC_TIME[21] is 1, it indicates PM time message.)
S     * @var RTC_T::CALM
S     * Offset: 0x20  RTC Calendar Alarm Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |DAY       |1-Day Calendar Digit of Alarm Setting (0~9)
S     * |[5:4]   |TENDAY    |10-Day Calendar Digit of Alarm Setting (0~3)
S     * |[11:8]  |MON       |1-Month Calendar Digit of Alarm Setting (0~9)
S     * |[12]    |TENMON    |10-Month Calendar Digit of Alarm Setting (0~1)
S     * |[19:16] |YEAR      |1-Year Calendar Digit of Alarm Setting (0~9)
S     * |[23:20] |TENYEAR   |10-Year Calendar Digit of Alarm Setting (0~9)
S     * @var RTC_T::LEAPYEAR
S     * Offset: 0x24  RTC Leap Year Indicaton Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |LEAPYEAR  |Leap Year Indication Register (Read Only)
S     * |        |          |0 = This year is not a leap year.
S     * |        |          |1 = This year is leap year.
S     * @var RTC_T::INTEN
S     * Offset: 0x28  RTC Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ALMIEN    |Alarm Interrupt Enable Bit
S     * |        |          |0 = RTC aAlarm interrupt Disabled.
S     * |        |          |1 = RTC aAlarm interrupt Enabled.
S     * |[1]     |TICKIEN   |Time Tick Interrupt Enable Bit
S     * |        |          |0 = RTC tTime tTick interrupt Disabled.
S     * |        |          |1 = RTC tTime tTick interrupt Enabled.
S     * @var RTC_T::INTSTS
S     * Offset: 0x2C  RTC Interrupt Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ALMIF     |RTC Alarm Interrupt Flag
S     * |        |          |When RTC current RTC counter in time counters RTC_TIME and RTC_CAL are matched the alarm setting time registers RTC alarm settings in RTC_TALM and RTC_CALM, ALMIFthis bit will be set to 1 and an alarm interrupt signal will be generated if RTC Alarm Interrupt enabled ALMIEN (RTC_INTEN[0]) is enabledset to 1.
S     * |        |          |Chip will also be waken up if RTC Alarm when alarm interrupt signal occurred Interrupt if chip is running at Power-down modeis enabled when chip is at Power-down mode.
S     * |        |          |0 = Alarm condition is not matched.
S     * |        |          |1 = Alarm condition is matched.
S     * |        |          |Note: Write Writing 1 to clear this bit.
S     * |[1]     |TICKIF    |RTC Time Tick Interrupt Flag
S     * |        |          |When RTC time tick event happened, this bit TICKIF will be set to 1 and an time tick interrupt signal will be generated if RTC Tick Interrupt enabled TICKIEN (RTC_INTEN[1]) is enabledset to 1
S     * |        |          |Chip will also be waken up when time tick interrupt signal occurred if RTC Tick Interrupt is enabled and this bit is set to 1 ifwhen chip is running at Power-down mode.
S     * |        |          |0 = Tick condition does not occur.
S     * |        |          |1 = Tick condition occurred.
S     * |        |          |Note: Writing Write 1 to clear to clear this bit.
S     * @var RTC_T::TICK
S     * Offset: 0x30  RTC Time Tick Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2:0]   |TICK      |Time Tick Register
S     * |        |          |These bits are used to select RTC time tick period for pPeriodic tTime tTick iInterrupt request.
S     * |        |          |000 = Time tick is 1 second.
S     * |        |          |001 = Time tick is 1/2 second.
S     * |        |          |010 = Time tick is 1/4 second.
S     * |        |          |011 = Time tick is 1/8 second.
S     * |        |          |100 = Time tick is 1/16 second.
S     * |        |          |101 = Time tick is 1/32 second.
S     * |        |          |110 = Time tick is 1/64 second.
S     * |        |          |111 = Time tick is 1/128 second.
S     * |        |          |Note: This register can be read back after the RTC register access enable bit RWENF (RTC_RWEN[16]) is active.
S     * @var RTC_T::TAMSK
S     * Offset: 0x34  RTC Time Alarm Mask Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |MSEC      |Mask 1-Sec Time Digit of aAlarm sSetting (0~9)
S     * |[1]     |MTENSEC   |Mask 10-Sec Time Digit of aAlarm sSetting (0~5)
S     * |[2]     |MMIN      |Mask 1-Min Time Digit of aAlarm sSetting (0~9)
S     * |[3]     |MTENMIN   |Mask 10-Min Time Digit of aAlarm sSetting (0~5)
S     * |[4]     |MHR       |Mask 1-Hour Time Digit of aAlarm sSetting (0~9)
S     * |        |          |Note: MHR function is only for 24-hour time scale mode.
S     * |[5]     |MTENHR    |Mask 10-Hour Time Digit of aAlarm sSetting (0~2)
S     * |        |          |Note: MTENHR function is only for 24-hour time scale mode.
S     * @var RTC_T::CAMSK
S     * Offset: 0x38  RTC Calendar Alarm Mask Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |MDAY      |Mask 1-Day Calendar Digit of Alarm alarm Setting setting (0~9)
S     * |[1]     |MTENDAY   |Mask 10-Day Calendar Digit of Alarm alarm Setting setting (0~3)
S     * |[2]     |MMON      |Mask 1-Month Calendar Digit of Alarm alarm Setting setting (0~9)
S     * |[3]     |MTENMON   |Mask 10-Month Calendar Digit of A alarm Setting setting (0~1)
S     * |[4]     |MYEAR     |Mask 1-Year Calendar Digit of Alarm alarm Setting setting (0~9)
S     * |[5]     |MTENYEAR  |Mask 10-Year Calendar Digit of A alarm Setting setting (0~9)
S     * @var RTC_T::LXTCTL
S     * Offset: 0x100  RTC 32 kHz Oscillator Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:1]   |GAIN      |Oscillator Gain Option
S     * |        |          |User can select oscillator gain according to crystal external loading and operating temperature range
S     * |        |          |The larger gain value corresponding to stronger driving capability and higher power consumption.
S     * |        |          |000 = L0 mode.
S     * |        |          |001 = L1 mode.
S     * |        |          |010 = L2 mode.
S     * |        |          |011 = L3 mode.
S     * |        |          |100 = L4 mode.
S     * |        |          |101 = L5 mode.
S     * |        |          |110 = L6 mode.
S     * |        |          |111 = L7 mode (Default).
S     * @var RTC_T::LXTOCTL
S     * Offset: 0x104  RTC X32KO Pin Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |OPMODE    |GPF0 IO Pin Operation Mode
S     * |        |          |00 = X32KO (P5.0) is in Iinput only mode, without pull-up resistor.
S     * |        |          |01 = X32KO (P5.0) is in output pPush- pull output mode.
S     * |        |          |10 = X32KO (P5.0) is in Oopen- drain output mode.
S     * |        |          |11 = X32KO (P5.0) is in Quasi-bidirectional modeinput only mode with internal pull up.
S     * |[2]     |DOUT      |IO Pin Output Data
S     * |        |          |0 = X32KO (P5.0) will driver output low in output mode.
S     * |        |          |1 = X32KO (P5.0) will driver high in output mode output high.
S     * |[3]     |CTLSEL    |IO Pin State Backup Selection
S     * |        |          |When low speed 32 kHz oscillator (LXT) is disabled, X32KO (P5.0) pin can be used as GPIO P5.0 function
S     * |        |          |User can program CTLSEL bit to decide X32KO (P5.0) I/O function is controlled by system power domain GPIO module or VBAT power domain RTC_LXTOCTL control register.
S     * |        |          |0 = X32KO (P5.0) pin I/O function is controlled by GPIO module
S     * |        |          |Hardware auto becomes CTLSEL =1 when system power is turned off..
S     * |        |          |1 = X32KO (P5.0) pin I/O function is controlled by OPMODE and DOUT in RTC_LXTOCT at VBAT power domain, X32KO (P5.0) pin function and I/O status are controlled by OPMODE[1:0] and DOUT after CTLSEL it set to 1.
S     * |        |          |Note: CTLSEL (this bit) will automatically be set to 1 automatically by hardware to 1 when system power is turned off andoff RTC is at normal active state, ACTIVE (RTC_INIT[0]) is 1 and RTC Active Status = 1.
S     * @var RTC_T::LXTICTL
S     * Offset: 0x108  RTC X32KI Pin Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |OPMODE    |IO Pin Operation Mode
S     * |        |          |00 = X32KI (P5.1) is in Input mode without pull-up resistor.
S     * |        |          |01 = X32KI (P5.1) is in Push-pull output mode.
S     * |        |          |10 = X32KI (P5.1) is in Open-drain output mode.
S     * |        |          |11 = X32KI (P5.1) is in Quasi-bidirectional mode.00 = X32KI (P5.1) is input only mode, without pull-up resistor.
S     * |        |          |01 = X32KI (P5.1) is output push pull mode.
S     * |        |          |10 = X32KI (P5.1) is open drain mode.
S     * |        |          |11 = X32KI (P5.1) is input only mode with internal pull up.
S     * |[2]     |DOUT      |IO Pin Output Data
S     * |        |          |0 = X32KI (P5.1) will driver low in output mode.
S     * |        |          |1 = X32KI (P5.1) will driver high in output mode.0 = X32KI (P5.1) output low.
S     * |        |          |1 = X32KI (P5.1) output high.
S     * |[3]     |CTLSEL    |IO Pin State Backup Selection
S     * |        |          |When low speed 32 kHz oscillator (LXT) is disabled, X32KO pin can be used as GPIO P5.1 function
S     * |        |          |User can program CTLSEL to decide X32KI (P5.1) I/O function is controlled by system power domain GPIO module or VBAT power domain RTC_LXTICTL register.
S     * |        |          |0 = X32KI (P5.1) pin I/O function is controlled by GPIO module.
S     * |        |          |1 = X32KI (P5.1) pin I/O function is controlled by OPMODE and DOUT in RTC_LXTICTL at VBAT power domain.
S     * |        |          |Note: CTLSEL will be set to 1 automatically by hardware when system power is turned off and RTC is at normal active state, ACTIVE (RTC_INIT[0]) is 1.When low speed 32 kHz oscillator is disabled, X32KI (P5.1) pin can be used as GPIO function
S     * |        |          |User can program CTLSEL bit to decide X32KI (P5.1) I/O function is controlled by system power domain GPIO module or VBAT power domain RTC_LXTICTL control register.
S     * |        |          |0 = X32KI (P5.1) pin I/O function is controlled by GPIO module
S     * |        |          |Hardware auto becomes CTLSEL =1 when system power is turned off.
S     * |        |          |1 = X32KI (P5.1) pin I/O function is controlled by VBAT power domain, X32KI (P5.1) pin function and I/O status are controlled by OPMODE[1:0] and DOUT after CTLSEL it set to 1.
S     * |        |          |Note:CTLSEL (this bit) will automatically be set by hardware to 1 when system power is off and RTC Active Status = 1.
S     * @var RTC_T::P52CTL
S     * Offset: 0x10C  RTC P52 Pin Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |OPMODE    |IO Pin Operation Mode
S     * |        |          |00 = P5.2 is in Input mode without pull-up resistor.
S     * |        |          |01 = P5.2 is in Push-pull output mode.
S     * |        |          |10 = P5.2 is in Open-drain output mode.
S     * |        |          |11 = P5.2 is in Quasi-bidirectional mode.00 = GPIO(P5.2) is input only mode, without pull-up resistor.
S     * |        |          |01 = GPIO(P5.2) is output push pull mode.
S     * |        |          |10 = GPIO(P5.2) is open drain mode.
S     * |        |          |11 = GPIO(P5.2) is input only mode with internal pull up.
S     * |[2]     |DOUT      |IO Pin Output Data
S     * |        |          |0 = GPIO P5.2 will driver low in output mode.
S     * |        |          |1 = GPIO P5.2 will driver high in output mode.0 = GPIO(P5.2) output low.
S     * |        |          |1 = GPIO (P5.2) output high.
S     * |[3]     |CTLSEL    |IO Pin State Backup Selection
S     * |        |          |User can program CTLSEL to decide GPIO P5.2 I/O function is controlled by system power domain GPIO module or VBAT power domain RTC_LXTICTL register.
S     * |        |          |0 = GPIO P5.2 pin I/O function is controlled by GPIO module.
S     * |        |          |1 = GPIO P5.2 pin I/O function is controlled by OPMODE and DOUT in RTC_P52CTL at VBAT power domain.
S     * |        |          |Note: CTLSEL will be set to 1 automatically by hardware when system power is turned off and RTC is at normal active state, ACTIVE (RTC_INIT[0]) is 1.User can program CTLSEL bit to decide GPIO (P5.2) I/O function is controlled by system power domain GPIO module or VBAT power domain RTC_GPIOCTL control register.
S     * |        |          |0 = GPIO (P5.2) pin I/O function is controlled by GPIO module
S     * |        |          |Hardware auto becomes CTLSEL =1 when system power is turned off.
S     * |        |          |1 = GPIO (P5.2) pin I/O function is controlled by VBAT power domain, GPIO (P5.2) pin function and I/O status are controlled by OPMODE[1:0] and DOUT after CTLSEL it set to 1.
S     * |        |          |Note:CTLSEL (this bit) will automatically be set by hardware to 1 when system power is off and RTC Active Status = 1.
S     * @var RTC_T::DSTCTL
S     * Offset: 0x110  RTC Daylight Saving Time Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ADDHR     |Add 1 Hour
S     * |        |          |0 = No effect.
S     * |        |          |1 = Indicates RTC hour digit has been addedAdds 1 one hour for summer time change.
S     * |[1]     |SUBHR     |Subtract 1 Hour
S     * |        |          |0 = No effect.
S     * |        |          |1 = Indicates RTC hour digit has been sSubtractsed one1 hour for winter time change.
S     * |        |          |Note: Writing this bit has no effect when RTC_TIME[21:16] is 0x00 in 24-hour time scale mode and RTC_TIME[21:16] is 0x12 in 12-hour time scale mode.
S     * |[2]     |DSBAK     |Daylight Saving Back
S     * |        |          |0= Daylight Saving Time function isChange is not performed.
S     * |        |          |1= Daylight Saving Time function Change is performed.
S     */
S
S    __IO uint32_t INIT;                  /*!< [0x0000] RTC Initiation Register                                          */
S    __IO uint32_t RWEN;                  /*!< [0x0004] RTC Access Enable Register                                       */
S    __IO uint32_t FREQADJ;               /*!< [0x0008] RTC Frequency Compensation Register                              */
S    __IO uint32_t TIME;                  /*!< [0x000c] RTC Time Loading Register                                        */
S    __IO uint32_t CAL;                   /*!< [0x0010] RTC Calendar Loading Register                                    */
S    __IO uint32_t CLKFMT;                /*!< [0x0014] RTC Time Scale Selection Register                                */
S    __IO uint32_t WEEKDAY;               /*!< [0x0018] RTC Day of the Week Register                                     */
S    __IO uint32_t TALM;                  /*!< [0x001c] RTC Time Alarm Register                                          */
S    __IO uint32_t CALM;                  /*!< [0x0020] RTC Calendar Alarm Register                                      */
S    __I  uint32_t LEAPYEAR;              /*!< [0x0024] RTC Leap Year Indicaton Register                                 */
S    __IO uint32_t INTEN;                 /*!< [0x0028] RTC Interrupt Enable Register                                    */
S    __IO uint32_t INTSTS;                /*!< [0x002c] RTC Interrupt Status Register                                    */
S    __IO uint32_t TICK;                  /*!< [0x0030] RTC Time Tick Register                                           */
S    __IO uint32_t TAMSK;                 /*!< [0x0034] RTC Time Alarm Mask Register                                     */
S    __IO uint32_t CAMSK;                 /*!< [0x0038] RTC Calendar Alarm Mask Register                                 */
S    __I  uint32_t RESERVE0[49];
S    __IO uint32_t LXTCTL;                /*!< [0x0100] RTC 32 kHz Oscillator Control Register                           */
S    __IO uint32_t LXTOCTL;               /*!< [0x0104] RTC X32KO Pin Control Register                                   */
S    __IO uint32_t LXTICTL;               /*!< [0x0108] RTC X32KI Pin Control Register                                   */
S    __IO uint32_t P52CTL;                /*!< [0x010c] RTC P52 Pin Control Register                                     */
S    __IO uint32_t DSTCTL;                /*!< [0x0110] RTC Daylight Saving Time Control Register                        */
S
S} RTC_T;
S
S/**
S    @addtogroup RTC_CONST RTC Bit Field Definition
S    Constant Definitions for RTC Controller
S@{ */
S
S#define RTC_INIT_ACTIVE_Pos              (0)                                               /*!< RTC_T::INIT: ACTIVE Position           */
S#define RTC_INIT_ACTIVE_Msk              (0x1ul << RTC_INIT_ACTIVE_Pos)                    /*!< RTC_T::INIT: ACTIVE Mask               */
S
S#define RTC_INIT_INIT_Pos                (1)                                               /*!< RTC_T::INIT: INIT Position             */
S#define RTC_INIT_INIT_Msk                (0x7ffffffful << RTC_INIT_INIT_Pos)               /*!< RTC_T::INIT: INIT Mask                 */
S
S#define RTC_RWEN_RWEN_Pos                (0)                                               /*!< RTC_T::RWEN: RWEN Position             */
S#define RTC_RWEN_RWEN_Msk                (0xfffful << RTC_RWEN_RWEN_Pos)                   /*!< RTC_T::RWEN: RWEN Mask                 */
S
S#define RTC_RWEN_RWENF_Pos               (16)                                              /*!< RTC_T::RWEN: RWENF Position            */
S#define RTC_RWEN_RWENF_Msk               (0x1ul << RTC_RWEN_RWENF_Pos)                     /*!< RTC_T::RWEN: RWENF Mask                */
S
S#define RTC_RWEN_RTCBUSY_Pos             (24)                                              /*!< RTC_T::RWEN: RTCBUSY Position          */
S#define RTC_RWEN_RTCBUSY_Msk             (0x1ul << RTC_RWEN_RTCBUSY_Pos)                   /*!< RTC_T::RWEN: RTCBUSY Mask              */
S
S#define RTC_FREQADJ_FREQADJ_Pos          (0)                                               /*!< RTC_T::FREQADJ: FREQADJ Position       */
S#define RTC_FREQADJ_FREQADJ_Msk          (0x3ffffful << RTC_FREQADJ_FREQADJ_Pos)           /*!< RTC_T::FREQADJ: FREQADJ Mask           */
S
S#define RTC_TIME_SEC_Pos                 (0)                                               /*!< RTC_T::TIME: SEC Position              */
S#define RTC_TIME_SEC_Msk                 (0xful << RTC_TIME_SEC_Pos)                       /*!< RTC_T::TIME: SEC Mask                  */
S
S#define RTC_TIME_TENSEC_Pos              (4)                                               /*!< RTC_T::TIME: TENSEC Position           */
S#define RTC_TIME_TENSEC_Msk              (0x7ul << RTC_TIME_TENSEC_Pos)                    /*!< RTC_T::TIME: TENSEC Mask               */
S
S#define RTC_TIME_MIN_Pos                 (8)                                               /*!< RTC_T::TIME: MIN Position              */
S#define RTC_TIME_MIN_Msk                 (0xful << RTC_TIME_MIN_Pos)                       /*!< RTC_T::TIME: MIN Mask                  */
S
S#define RTC_TIME_TENMIN_Pos              (12)                                              /*!< RTC_T::TIME: TENMIN Position           */
S#define RTC_TIME_TENMIN_Msk              (0x7ul << RTC_TIME_TENMIN_Pos)                    /*!< RTC_T::TIME: TENMIN Mask               */
S
S#define RTC_TIME_HR_Pos                  (16)                                              /*!< RTC_T::TIME: HR Position               */
S#define RTC_TIME_HR_Msk                  (0xful << RTC_TIME_HR_Pos)                        /*!< RTC_T::TIME: HR Mask                   */
S
S#define RTC_TIME_TENHR_Pos               (20)                                              /*!< RTC_T::TIME: TENHR Position            */
S#define RTC_TIME_TENHR_Msk               (0x3ul << RTC_TIME_TENHR_Pos)                     /*!< RTC_T::TIME: TENHR Mask                */
S
S#define RTC_CAL_DAY_Pos                  (0)                                               /*!< RTC_T::CAL: DAY Position               */
S#define RTC_CAL_DAY_Msk                  (0xful << RTC_CAL_DAY_Pos)                        /*!< RTC_T::CAL: DAY Mask                   */
S
S#define RTC_CAL_TENDAY_Pos               (4)                                               /*!< RTC_T::CAL: TENDAY Position            */
S#define RTC_CAL_TENDAY_Msk               (0x3ul << RTC_CAL_TENDAY_Pos)                     /*!< RTC_T::CAL: TENDAY Mask                */
S
S#define RTC_CAL_MON_Pos                  (8)                                               /*!< RTC_T::CAL: MON Position               */
S#define RTC_CAL_MON_Msk                  (0xful << RTC_CAL_MON_Pos)                        /*!< RTC_T::CAL: MON Mask                   */
S
S#define RTC_CAL_TENMON_Pos               (12)                                              /*!< RTC_T::CAL: TENMON Position            */
S#define RTC_CAL_TENMON_Msk               (0x1ul << RTC_CAL_TENMON_Pos)                     /*!< RTC_T::CAL: TENMON Mask                */
S
S#define RTC_CAL_YEAR_Pos                 (16)                                              /*!< RTC_T::CAL: YEAR Position              */
S#define RTC_CAL_YEAR_Msk                 (0xful << RTC_CAL_YEAR_Pos)                       /*!< RTC_T::CAL: YEAR Mask                  */
S
S#define RTC_CAL_TENYEAR_Pos              (20)                                              /*!< RTC_T::CAL: TENYEAR Position           */
S#define RTC_CAL_TENYEAR_Msk              (0xful << RTC_CAL_TENYEAR_Pos)                    /*!< RTC_T::CAL: TENYEAR Mask               */
S
S#define RTC_CLKFMT_24HEN_Pos             (0)                                               /*!< RTC_T::CLKFMT: 24HEN Position          */
S#define RTC_CLKFMT_24HEN_Msk             (0x1ul << RTC_CLKFMT_24HEN_Pos)                   /*!< RTC_T::CLKFMT: 24HEN Mask              */
S
S#define RTC_WEEKDAY_WEEKDAY_Pos          (0)                                               /*!< RTC_T::WEEKDAY: WEEKDAY Position       */
S#define RTC_WEEKDAY_WEEKDAY_Msk          (0x7ul << RTC_WEEKDAY_WEEKDAY_Pos)                /*!< RTC_T::WEEKDAY: WEEKDAY Mask           */
S
S#define RTC_TALM_SEC_Pos                 (0)                                               /*!< RTC_T::TALM: SEC Position              */
S#define RTC_TALM_SEC_Msk                 (0xful << RTC_TALM_SEC_Pos)                       /*!< RTC_T::TALM: SEC Mask                  */
S
S#define RTC_TALM_TENSEC_Pos              (4)                                               /*!< RTC_T::TALM: TENSEC Position           */
S#define RTC_TALM_TENSEC_Msk              (0x7ul << RTC_TALM_TENSEC_Pos)                    /*!< RTC_T::TALM: TENSEC Mask               */
S
S#define RTC_TALM_MIN_Pos                 (8)                                               /*!< RTC_T::TALM: MIN Position              */
S#define RTC_TALM_MIN_Msk                 (0xful << RTC_TALM_MIN_Pos)                       /*!< RTC_T::TALM: MIN Mask                  */
S
S#define RTC_TALM_TENMIN_Pos              (12)                                              /*!< RTC_T::TALM: TENMIN Position           */
S#define RTC_TALM_TENMIN_Msk              (0x7ul << RTC_TALM_TENMIN_Pos)                    /*!< RTC_T::TALM: TENMIN Mask               */
S
S#define RTC_TALM_HR_Pos                  (16)                                              /*!< RTC_T::TALM: HR Position               */
S#define RTC_TALM_HR_Msk                  (0xful << RTC_TALM_HR_Pos)                        /*!< RTC_T::TALM: HR Mask                   */
S
S#define RTC_TALM_TENHR_Pos               (20)                                              /*!< RTC_T::TALM: TENHR Position            */
S#define RTC_TALM_TENHR_Msk               (0x3ul << RTC_TALM_TENHR_Pos)                     /*!< RTC_T::TALM: TENHR Mask                */
S
S#define RTC_CALM_DAY_Pos                 (0)                                               /*!< RTC_T::CALM: DAY Position              */
S#define RTC_CALM_DAY_Msk                 (0xful << RTC_CALM_DAY_Pos)                       /*!< RTC_T::CALM: DAY Mask                  */
S
S#define RTC_CALM_TENDAY_Pos              (4)                                               /*!< RTC_T::CALM: TENDAY Position           */
S#define RTC_CALM_TENDAY_Msk              (0x3ul << RTC_CALM_TENDAY_Pos)                    /*!< RTC_T::CALM: TENDAY Mask               */
S
S#define RTC_CALM_MON_Pos                 (8)                                               /*!< RTC_T::CALM: MON Position              */
S#define RTC_CALM_MON_Msk                 (0xful << RTC_CALM_MON_Pos)                       /*!< RTC_T::CALM: MON Mask                  */
S
S#define RTC_CALM_TENMON_Pos              (12)                                              /*!< RTC_T::CALM: TENMON Position           */
S#define RTC_CALM_TENMON_Msk              (0x1ul << RTC_CALM_TENMON_Pos)                    /*!< RTC_T::CALM: TENMON Mask               */
S
S#define RTC_CALM_YEAR_Pos                (16)                                              /*!< RTC_T::CALM: YEAR Position             */
S#define RTC_CALM_YEAR_Msk                (0xful << RTC_CALM_YEAR_Pos)                      /*!< RTC_T::CALM: YEAR Mask                 */
S
S#define RTC_CALM_TENYEAR_Pos             (20)                                              /*!< RTC_T::CALM: TENYEAR Position          */
S#define RTC_CALM_TENYEAR_Msk             (0xful << RTC_CALM_TENYEAR_Pos)                   /*!< RTC_T::CALM: TENYEAR Mask              */
S
S#define RTC_LEAPYEAR_LEAPYEAR_Pos        (0)                                               /*!< RTC_T::LEAPYEAR: LEAPYEAR Position     */
S#define RTC_LEAPYEAR_LEAPYEAR_Msk        (0x1ul << RTC_LEAPYEAR_LEAPYEAR_Pos)              /*!< RTC_T::LEAPYEAR: LEAPYEAR Mask         */
S
S#define RTC_INTEN_ALMIEN_Pos             (0)                                               /*!< RTC_T::INTEN: ALMIEN Position          */
S#define RTC_INTEN_ALMIEN_Msk             (0x1ul << RTC_INTEN_ALMIEN_Pos)                   /*!< RTC_T::INTEN: ALMIEN Mask              */
S
S#define RTC_INTEN_TICKIEN_Pos            (1)                                               /*!< RTC_T::INTEN: TICKIEN Position         */
S#define RTC_INTEN_TICKIEN_Msk            (0x1ul << RTC_INTEN_TICKIEN_Pos)                  /*!< RTC_T::INTEN: TICKIEN Mask             */
S
S#define RTC_INTSTS_ALMIF_Pos             (0)                                               /*!< RTC_T::INTSTS: ALMIF Position          */
S#define RTC_INTSTS_ALMIF_Msk             (0x1ul << RTC_INTSTS_ALMIF_Pos)                   /*!< RTC_T::INTSTS: ALMIF Mask              */
S
S#define RTC_INTSTS_TICKIF_Pos            (1)                                               /*!< RTC_T::INTSTS: TICKIF Position         */
S#define RTC_INTSTS_TICKIF_Msk            (0x1ul << RTC_INTSTS_TICKIF_Pos)                  /*!< RTC_T::INTSTS: TICKIF Mask             */
S
S#define RTC_TICK_TICK_Pos                (0)                                               /*!< RTC_T::TICK: TICK Position             */
S#define RTC_TICK_TICK_Msk                (0x7ul << RTC_TICK_TICK_Pos)                      /*!< RTC_T::TICK: TICK Mask                 */
S
S#define RTC_TAMSK_MSEC_Pos               (0)                                               /*!< RTC_T::TAMSK: MSEC Position            */
S#define RTC_TAMSK_MSEC_Msk               (0x1ul << RTC_TAMSK_MSEC_Pos)                     /*!< RTC_T::TAMSK: MSEC Mask                */
S
S#define RTC_TAMSK_MTENSEC_Pos            (1)                                               /*!< RTC_T::TAMSK: MTENSEC Position         */
S#define RTC_TAMSK_MTENSEC_Msk            (0x1ul << RTC_TAMSK_MTENSEC_Pos)                  /*!< RTC_T::TAMSK: MTENSEC Mask             */
S
S#define RTC_TAMSK_MMIN_Pos               (2)                                               /*!< RTC_T::TAMSK: MMIN Position            */
S#define RTC_TAMSK_MMIN_Msk               (0x1ul << RTC_TAMSK_MMIN_Pos)                     /*!< RTC_T::TAMSK: MMIN Mask                */
S
S#define RTC_TAMSK_MTENMIN_Pos            (3)                                               /*!< RTC_T::TAMSK: MTENMIN Position         */
S#define RTC_TAMSK_MTENMIN_Msk            (0x1ul << RTC_TAMSK_MTENMIN_Pos)                  /*!< RTC_T::TAMSK: MTENMIN Mask             */
S
S#define RTC_TAMSK_MHR_Pos                (4)                                               /*!< RTC_T::TAMSK: MHR Position             */
S#define RTC_TAMSK_MHR_Msk                (0x1ul << RTC_TAMSK_MHR_Pos)                      /*!< RTC_T::TAMSK: MHR Mask                 */
S
S#define RTC_TAMSK_MTENHR_Pos             (5)                                               /*!< RTC_T::TAMSK: MTENHR Position          */
S#define RTC_TAMSK_MTENHR_Msk             (0x1ul << RTC_TAMSK_MTENHR_Pos)                   /*!< RTC_T::TAMSK: MTENHR Mask              */
S
S#define RTC_CAMSK_MDAY_Pos               (0)                                               /*!< RTC_T::CAMSK: MDAY Position            */
S#define RTC_CAMSK_MDAY_Msk               (0x1ul << RTC_CAMSK_MDAY_Pos)                     /*!< RTC_T::CAMSK: MDAY Mask                */
S
S#define RTC_CAMSK_MTENDAY_Pos            (1)                                               /*!< RTC_T::CAMSK: MTENDAY Position         */
S#define RTC_CAMSK_MTENDAY_Msk            (0x1ul << RTC_CAMSK_MTENDAY_Pos)                  /*!< RTC_T::CAMSK: MTENDAY Mask             */
S
S#define RTC_CAMSK_MMON_Pos               (2)                                               /*!< RTC_T::CAMSK: MMON Position            */
S#define RTC_CAMSK_MMON_Msk               (0x1ul << RTC_CAMSK_MMON_Pos)                     /*!< RTC_T::CAMSK: MMON Mask                */
S
S#define RTC_CAMSK_MTENMON_Pos            (3)                                               /*!< RTC_T::CAMSK: MTENMON Position         */
S#define RTC_CAMSK_MTENMON_Msk            (0x1ul << RTC_CAMSK_MTENMON_Pos)                  /*!< RTC_T::CAMSK: MTENMON Mask             */
S
S#define RTC_CAMSK_MYEAR_Pos              (4)                                               /*!< RTC_T::CAMSK: MYEAR Position           */
S#define RTC_CAMSK_MYEAR_Msk              (0x1ul << RTC_CAMSK_MYEAR_Pos)                    /*!< RTC_T::CAMSK: MYEAR Mask               */
S
S#define RTC_CAMSK_MTENYEAR_Pos           (5)                                               /*!< RTC_T::CAMSK: MTENYEAR Position        */
S#define RTC_CAMSK_MTENYEAR_Msk           (0x1ul << RTC_CAMSK_MTENYEAR_Pos)                 /*!< RTC_T::CAMSK: MTENYEAR Mask            */
S
S#define RTC_LXTCTL_GAIN_Pos              (1)                                               /*!< RTC_T::LXTCTL: GAIN Position           */
S#define RTC_LXTCTL_GAIN_Msk              (0x7ul << RTC_LXTCTL_GAIN_Pos)                    /*!< RTC_T::LXTCTL: GAIN Mask               */
S
S#define RTC_LXTOCTL_OPMODE_Pos           (0)                                               /*!< RTC_T::LXTOCTL: OPMODE Position        */
S#define RTC_LXTOCTL_OPMODE_Msk           (0x3ul << RTC_LXTOCTL_OPMODE_Pos)                 /*!< RTC_T::LXTOCTL: OPMODE Mask            */
S
S#define RTC_LXTOCTL_DOUT_Pos             (2)                                               /*!< RTC_T::LXTOCTL: DOUT Position          */
S#define RTC_LXTOCTL_DOUT_Msk             (0x1ul << RTC_LXTOCTL_DOUT_Pos)                   /*!< RTC_T::LXTOCTL: DOUT Mask              */
S
S#define RTC_LXTOCTL_CTLSEL_Pos           (3)                                               /*!< RTC_T::LXTOCTL: CTLSEL Position        */
S#define RTC_LXTOCTL_CTLSEL_Msk           (0x1ul << RTC_LXTOCTL_CTLSEL_Pos)                 /*!< RTC_T::LXTOCTL: CTLSEL Mask            */
S
S#define RTC_LXTICTL_OPMODE_Pos           (0)                                               /*!< RTC_T::LXTICTL: OPMODE Position        */
S#define RTC_LXTICTL_OPMODE_Msk           (0x3ul << RTC_LXTICTL_OPMODE_Pos)                 /*!< RTC_T::LXTICTL: OPMODE Mask            */
S
S#define RTC_LXTICTL_DOUT_Pos             (2)                                               /*!< RTC_T::LXTICTL: DOUT Position          */
S#define RTC_LXTICTL_DOUT_Msk             (0x1ul << RTC_LXTICTL_DOUT_Pos)                   /*!< RTC_T::LXTICTL: DOUT Mask              */
S
S#define RTC_LXTICTL_CTLSEL_Pos           (3)                                               /*!< RTC_T::LXTICTL: CTLSEL Position        */
S#define RTC_LXTICTL_CTLSEL_Msk           (0x1ul << RTC_LXTICTL_CTLSEL_Pos)                 /*!< RTC_T::LXTICTL: CTLSEL Mask            */
S
S#define RTC_P52CTL_OPMODE_Pos            (0)                                               /*!< RTC_T::P52CTL: OPMODE Position         */
S#define RTC_P52CTL_OPMODE_Msk            (0x3ul << RTC_P52CTL_OPMODE_Pos)                  /*!< RTC_T::P52CTL: OPMODE Mask             */
S
S#define RTC_P52CTL_DOUT_Pos              (2)                                               /*!< RTC_T::P52CTL: DOUT Position           */
S#define RTC_P52CTL_DOUT_Msk              (0x1ul << RTC_P52CTL_DOUT_Pos)                    /*!< RTC_T::P52CTL: DOUT Mask               */
S
S#define RTC_P52CTL_CTLSEL_Pos            (3)                                               /*!< RTC_T::P52CTL: CTLSEL Position         */
S#define RTC_P52CTL_CTLSEL_Msk            (0x1ul << RTC_P52CTL_CTLSEL_Pos)                  /*!< RTC_T::P52CTL: CTLSEL Mask             */
S
S#define RTC_DSTCTL_ADDHR_Pos             (0)                                               /*!< RTC_T::DSTCTL: ADDHR Position          */
S#define RTC_DSTCTL_ADDHR_Msk             (0x1ul << RTC_DSTCTL_ADDHR_Pos)                   /*!< RTC_T::DSTCTL: ADDHR Mask              */
S
S#define RTC_DSTCTL_SUBHR_Pos             (1)                                               /*!< RTC_T::DSTCTL: SUBHR Position          */
S#define RTC_DSTCTL_SUBHR_Msk             (0x1ul << RTC_DSTCTL_SUBHR_Pos)                   /*!< RTC_T::DSTCTL: SUBHR Mask              */
S
S#define RTC_DSTCTL_DSBAK_Pos             (2)                                               /*!< RTC_T::DSTCTL: DSBAK Position          */
S#define RTC_DSTCTL_DSBAK_Msk             (0x1ul << RTC_DSTCTL_DSBAK_Pos)                   /*!< RTC_T::DSTCTL: DSBAK Mask              */
S
S/**@}*/ /* RTC_CONST */
S/**@}*/ /* end of RTC register group */
S
S
S/*---------------------- Smart Card Host Interface Controller -------------------------*/
S/**
S    @addtogroup SC Smart Card Host Interface Controller(SC)
S    Memory Mapped Structure for SC Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var SC_T::DAT
S     * Offset: 0x00  SC Receive/Transmit Holding Buffer Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |DAT       |Receive/Transmit Holding Buffer
S     * |        |          |Write Operation:
S     * |        |          |By writing data to DAT, the SC will send out an 8-bit data.
S     * |        |          |Note: If SCEN (SC_SCn_CTL[0]) is not enabled, DAT cannot be programmed.
S     * |        |          |Read Operation:
S     * |        |          |By reading DAT, the SC will return an 8-bit received data.[WH1]
S     * |        |          |Note: If SCEN (SC_CTL[0]) is not enabled, DAT cannot be programmed.
S     * |        |          |[WH1]Tag59
S     * @var SC_T::CTL
S     * Offset: 0x04  SC Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SCEN      |SC Controller Enable Bit
S     * |        |          |Set this bit to 1 to enable SC operation function. If this bit is cleared,
S     * |        |          |0 = SC will force all transition to IDLE state.
S     * |        |          |1 = SC controller is enabled and all function can work correctly.
S     * |        |          |Note1: SCEN must be set to 1 before filling in other SC registers, or smart card will not work properly.[WH1]
S     * |        |          |[WH1]Tag66
S     * |[1]     |RXOFF     |RX Transition Disable Control Bit
S     * |        |          |This bit is used for disable Rx receive transition function.
S     * |        |          |0 = The receiver Enabled.
S     * |        |          |1 = The receiver Disabled.
S     * |        |          |Note1: If AUTOCEN (SC_SCn_CTL[3]) is enabled, this field is ignored.[WH1]
S     * |        |          |[WH1]Tag65
S     * |[2]     |TXOFF     |TX Transition Disable Control Bit
S     * |        |          |This bit is used for disable Tx transmit ftransition function.
S     * |        |          |0 = The transceiver Enabled.
S     * |        |          |1 = The transceiver Disabled.[WH1]
S     * |        |          |[WH1]Tag64
S     * |[3]     |AUTOCEN   |Auto Convention Enable Bit
S     * |        |          |This bit is used for enable auto convention function.
S     * |        |          |0 = Auto-convention Disabled.
S     * |        |          |1 = Auto-convention Enabled.
S     * |        |          |If user enables auto convention function, the setting step must be done before Answer to Reset (ATR) state and the first data must be 0x3B or 0x3F
S     * |        |          |After hardware received first data and stored it at buffer, hardware will decided the convention and change the CONSEL (SC_SCn_CTL[5:4]) bits automatically when received first data is 0x3B or 0x3F
S     * |        |          |If received first byte is 0x3B, TS is direct convention, CONSEL (SC_SCn_CTL[5:4]) will be set to 00 automatically, otherwise the TS is inverse convention, and CONSEL (SC_SCn_CTL[5:4]) will be set to 11.
S     * |        |          |If the first data is not 0x3B or 0x3F, hardware will set ACERRIF (SC_SCn_INTSTS[10]) and generate an interrupt signal to inform CPU when ACERRIEN (SC_SCn_INTEN[10]) is enabled.[WH1]
S     * |        |          |[WH1]Tag10, 33, 34, 35
S     * |[5:4]   |CONSEL    |Convention Selection
S     * |        |          |00 = Direct convention.
S     * |        |          |01 = Reserved.
S     * |        |          |10 = Reserved.
S     * |        |          |11 = Inverse convention.
S     * |        |          |Note: If AUTOCEN (SC_SCn_CTL[3]) is enabled, this field is ignored.[WH1]
S     * |        |          |[WH1]Tag10, 33, 34, 35
S     * |[7:6]   |RXTRGLV   |Rx Buffer Trigger Level
S     * |        |          |When the number of bytes in the receiving buffer equals the RXTRGLV, the RDAIF (SC_INTSTS[0]) will be set
S     * |        |          |If RDAIEN (SC_SCn_INTEN[0]) is enabled, an interrupt signal will be generated to inform CPU.
S     * |        |          |00 = Rx Buffer Trigger Level with 01 bytes.
S     * |        |          |01 = Rx Buffer Trigger Level with 02 bytes.
S     * |        |          |10 = Rx Buffer Trigger Level with 03 bytes.
S     * |        |          |11 = Reserved. [WH1]
S     * |        |          |[WH1]Tag7
S     * |[12:8]  |BGT       |Block Guard Time (BGT)
S     * |        |          |Block guard time means the minimum interval between the leading edges of two consecutive characters between different transfer directions
S     * |        |          |This field indicates the counter for the bit length of block guard time
S     * |        |          |According to ISO7816-3, in T = 0 mode, user must fill 15 (real block guard time = 16.5) to this field; in T = 1 mode, user must fill 21 (real block guard time = 22.5) to it.
S     * |        |          |Note: The real block guard time is BGT + 1.[WH1]
S     * |        |          |[WH1]Tag8
S     * |[14:13] |TMRSEL    |Timer Channel Selection
S     * |        |          |00 = All internal timer function Disabled.[WH1]
S     * |        |          |.
S     * |        |          |11 = Internal 24- bit Timer0timer and two 8- bit Timer0 and Timer1 are etimers Enabled
S     * |        |          |User can configure them by setting SC_SCn_TMRCTL0[23:0], SC_SCn_TMRCTL1[7:0] and SC_SCn_TMRCTL2[7:0].
S     * |        |          |Other configurations are reserved[WH2]
S     * |        |          |[WH1]Tag9
S     * |        |          |[WH2]Tag9
S     * |[15]    |NSB       |Stop Bit Length
S     * |        |          |This field indicates the length of stop bit.
S     * |        |          |0 = The stop bit length is 2 ETU.
S     * |        |          |1 = The stop bit length is 1 ETU.
S     * |        |          |Note1: The default stop bit length is 2. SC and UART adopts NSB to program the stop bit length.
S     * |        |          |Note2: In UART mode, RX can receive the data sequence in 1 stop bit or 2 stop bits with NSB is set to 0.[WH1]
S     * |        |          |[WH1]Tag22
S     * |[18:16] |RXRTY     |RX Error Retry Count Number
S     * |        |          |This field indicates the maximum number of receiver retries that are allowed when parity error has occurred
S     * |        |          |Note1: The real retry number is RXRTY + 1, so 8 is the maximum retry number.
S     * |        |          |Note2: This field cannot be changed when RXRTYEN enabled
S     * |        |          |The change flow is to disable RXRTYEN first and then fill in new retry value.[WH1]
S     * |        |          |[WH1]Tag11
S     * |[19]    |RXRTYEN   |RX Error Retry Enable Bit
S     * |        |          |This bit enables receiver retry function when parity error has occurred.
S     * |        |          |0 = RX error retry function Disabled.
S     * |        |          |1 = RX error retry function Enabled.
S     * |        |          |Note: User must fill in the RXRTY value before enabling this bit.
S     * |[22:20] |TXRTY     |TX Error Retry Count Number
S     * |        |          |This field indicates the maximum number of transmitter retries that are allowed when parity error has occurred.
S     * |        |          |Note1: The real retry number is TXRTY + 1, so 8 is the maximum retry number.
S     * |        |          |Note2: This field cannot be changed when TXRTYEN enabled
S     * |        |          |The change flow is to disable TXRTYEN first and then fill in new retry value.[WH1]
S     * |        |          |[WH1]Tag11
S     * |[23]    |TXRTYEN   |TX Error Retry Enable Bit
S     * |        |          |This bit enables transmitter retry function when parity error has occurred.
S     * |        |          |0 = TX error retry function Disabled.
S     * |        |          |1 = TX error retry function Enabled.
S     * |[25:24] |CDDBSEL   |Card Detect De-bounce Selection
S     * |        |          |This field indicates the card detect de-bounce selection.
S     * |        |          |00 = De-bounce sample card insert once per 384 (128 * 3) SC modue clocks and de-bounce sample card removal once per 128 SC modue clocks.[WH1]
S     * |        |          |Other configurations are reserved.[WH2]
S     * |        |          |[WH1]Tag63
S     * |        |          |[WH2]Tag63
S     * |[26]    |CDLV      |Card Detect Level Selection
S     * |        |          |0 = When hardware detects the card detect pin (SC_SCn_CD) from high to low, it indicates a card is detected.
S     * |        |          |1 = When hardware detects the card detect pin (SC_SCn_CD) from low to high, it indicates a card is detected.
S     * |        |          |Note: User must select card detect level before Smart Card controller enabled. [WH1]
S     * |        |          |[WH1]Tag2
S     * |[30]    |SYNC      |SYNC Flag Indicator (Read Only)
S     * |        |          |Due to synchronization, user should check this bit before writing a new value to RXRTY and TXRTY fields.
S     * |        |          |0 = Synchronizing is completion, user can write new data to RXRTY and TXRTY.
S     * |        |          |1 = Last value is synchronizing. [WH1]
S     * |        |          |[WH1]Tag62
S     * @var SC_T::ALTCTL
S     * Offset: 0x08  SC Alternate Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TXRST     |TX Software Reset
S     * |        |          |When TXRST is set, all the bytes in the transmit buffer and TX Tx internal state machine will be cleared.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset the TX Tx internal state machine and pointers.
S     * |        |          |Note: This bit will be auto cleared after reset is complete.[WH1]
S     * |        |          |[WH1]Tag71
S     * |[1]     |RXRST     |Rx RX Software Reset
S     * |        |          |When RXRST is set, all the bytes in the receive buffer and Rx internal state machine will be cleared.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset the Rx internal state machine and pointers.
S     * |        |          |Note: This bit will be auto cleared after reset is complete.[WH1]
S     * |        |          |[WH1]Tag70
S     * |[2]     |DACTEN    |Deactivation Sequence Generator Enable Bit
S     * |        |          |This bit enables SC controller to initiate the card by deactivation sequence.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Deactivation sequence generator Enabled.
S     * |        |          |Note1: When the deactivation sequence completed, this bit will be cleared automatically and the INITIF (SC_SCn_INTSTS[8]) will be set to 1.
S     * |        |          |Note2: This field will be cleared by setT TXRST (SC_SCn_ALTCTL[0]) and or RXRST (SC_SCn_ALTCTL[1])
S     * |        |          |Thus, do not fill in this bit DACTEN, TXRST and or RXRST at the same time.
S     * |        |          |Note3: If SCEN (SC_SCn_CTL[0]) is not enabled, this filed cannot be programmed.[WH1]
S     * |        |          |[WH1]Tag14, 65
S     * |[3]     |ACTEN     |Activation Sequence Generator Enable Bit
S     * |        |          |This bit enables SC controller to initiate the card by activation sequence.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Activation sequence generator Enabled.
S     * |        |          |Note1: When the activation sequence completed, this bit will be cleared automatically and the INITIF (SC_SCn_INTSTS[8]) will be set to 1.
S     * |        |          |Note2: This field will be cleared by set TXRST (SC_SCn_ALTCTL[0]) and or RXRST (SC_SCn_ALTCTL[1])
S     * |        |          |Thus, do not fill in this bit ACTEN, TXRST and or RXRST at the same time.
S     * |        |          |Note3: If SCEN (SC_SCn_CTL[0]) is not enabled, this filed cannot be programmed.[WH1]
S     * |        |          |[WH1]Tag12, 65
S     * |[4]     |WARSTEN   |Warm Reset Sequence Generator Enable Bit
S     * |        |          |This bit enables SC controller to initiate the card by warm reset sequence.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Warm reset sequence generator Enabled.
S     * |        |          |Note1: When the warm reset sequence completed, this bit will be cleared automatically and the INITIF (SC_SCn_INTSTS[8]) will be set to 1.
S     * |        |          |Note2: This field will be cleared by set TXRST (SC_SCn_ALTCTL[0]) and or RXRST (SC_SCn_ALTCTL[1])
S     * |        |          |Thus, do not fill in this bit WARSTEN, TXRST and or RXRST at the same time.
S     * |        |          |Note3: If SCEN (SC_SCn_CTL[0]) is not enabled, this filed cannot be programmed.[WH1]
S     * |        |          |[WH1]Tag13, 65
S     * |[5]     |CNTEN0    |Internal Timer0 Start Enable Bit
S     * |        |          |This bit enables Timer 0 to start counting
S     * |        |          |User can fill 0 to stop count it and set 1 to reload and start count
S     * |        |          |The counter unit is ETU base.
S     * |        |          |0 = Stops counting.
S     * |        |          |1 = Start counting.
S     * |        |          |Note1: This field is used for internal 24- bit timer when TMRSEL (SC_SCn_CTL[14:13]) is 11 only
S     * |        |          |Do not fill CNTEN0 when TMRSEL (SC_CTL[14:13]) is not equale to 11.
S     * |        |          |Note2: If the operation mode is not in auto-reload mode (SC_SCn_TMRCTL0[26] = 0), this bit will be auto-cleared by hardware.
S     * |        |          |Note3: If SCEN (SC_SCn_CTL[0]) is not enabled, this filed cannot be programmed.[WH1]
S     * |        |          |[WH1]Tag37
S     * |[6]     |CNTEN1    |Internal Timer1 Start Enable Bit
S     * |        |          |This bit enables Timer 1 to start counting
S     * |        |          |User can fill 0 to stop count it and set 1 to reload and start count
S     * |        |          |The counter unit is ETU base.
S     * |        |          |0 = Stops counting.
S     * |        |          |1 = Start counting.
S     * |        |          |Note1: This field is used for internal 8- bit timer when TMRSEL (SC_SCn_CTL[14:13]) is 11 only
S     * |        |          |Do not fill CNTEN1 when TMRSEL (SC_SCn_CTL[14:13]) is not equale to 11.
S     * |        |          |Note2: If the operation mode is not in auto-reload mode (SC_SCn_TMRCTL1[26] = 0), this bit will be auto-cleared by hardware.
S     * |        |          |Note3: If SCEN (SC_SCn_CTL[0]) is not enabled, this filed cannot be programmed.
S     * |[7]     |CNTEN2    |Internal Timer2 Start Enable Bit
S     * |        |          |This bit enables Timer 2 to start counting
S     * |        |          |User can fill 0 to stop it count and set 1 to reload and start count
S     * |        |          |The counter unit is ETU base.
S     * |        |          |0 = Stops counting.
S     * |        |          |1 = Start counting.
S     * |        |          |Note1: This field is used for internal 8- bit timer when TMRSEL (SC_SCn_CTL[14:13]) is 11 only
S     * |        |          |Do not fill in CNTEN2 when TMRSEL (SC_SCn_CTL[14:13]) is not equale to 11.
S     * |        |          |Note2: If the operation mode is not in auto-reload mode (SC_SCn_TMRCTL2[26] = = 0), this bit will be auto-cleared by hardware.
S     * |        |          |Note3: If SCEN (SC_SCn_CTL[0]) is not enabled, this filed cannot be programmed.
S     * |[9:8]   |INITSEL   |Initial Timing Selection
S     * |        |          |This fields indicates the initial timing of hardware activation, warm-reset or deactivation.
S     * |        |          |The unit of initial timing is SC module clock.
S     * |        |          |Activation: refer to SC Activation Sequence in Figure 1.1-4 Figure 1.1-4.
S     * |        |          |Warm-reset: refer to Warm-Reset Sequence in Figure 1.1-5 Figure 1.1-5.
S     * |        |          |Deactivation: refer to Deactivation Sequence in Figure 1.1-6 Figure 1.1-6.
S     * |        |          |Note: When set activation and warm reset in Timer0 operation mode 0011, it may have deviation at most 128 SC module clock cycles.[WH1]
S     * |        |          |[WH1]Tag12~15
S     * |[11]    |ADACEN    |Auto Deactivation When Card Removal
S     * |        |          |This bit is usde for enable hardware auto deactivation when smart card is removed.
S     * |        |          |0 = Auto deactivation Disabled.
S     * |        |          |1 = Auto deactivation Enabled.
S     * |        |          |Note: When the card is removed, hardware will stop any process and then do deactivation sequence if this bit is set
S     * |        |          |If auto deactivation process completes, hardware will set INITIF (SC_SCn_INTSTS[8]) also.[WH1]
S     * |        |          |[WH1]Tag15
S     * |[12]    |RXBGTEN   |Receiver Block Guard Time Function Enable Bit
S     * |        |          |This bit enables the receiver block guard time function.
S     * |        |          |0 = Receiver block guard time function Disabled.
S     * |        |          |1 = Receiver block guard time function Enabled.[WH1]
S     * |        |          |[WH1]Tag69
S     * |[13]    |ACTSTS0   |Internal Timer0 Active Status (Read Only)
S     * |        |          |This bit indicates the timer counter status of timer0.
S     * |        |          |0 = Timer0 is not active.
S     * |        |          |1 = Timer0 is active.
S     * |        |          |Note: Timer0 is active does not always mean timer0 is counting the CNT (SC_SCn_TMRCTL0[23:0]).[WH1]
S     * |        |          |[WH1]Tag68
S     * |[14]    |ACTSTS1   |Internal Timer1 Active Status (Read Only)
S     * |        |          |This bit indicates the timer counter status of timer1.
S     * |        |          |0 = Timer1 is not active.
S     * |        |          |1 = Timer1 is active.
S     * |        |          |Note: Timer1 is active does not always mean timer1 is counting the CNT (SC_SCn_TMRCTL1[7:0]).
S     * |[15]    |ACTSTS2   |Internal Timer2 Active Status (Read Only)
S     * |        |          |This bit indicates the timer counter status of timer2.
S     * |        |          |0 = Timer2 is not active.
S     * |        |          |1 = Timer2 is active.
S     * |        |          |Note: Timer2 is active does not always mean timer2 is counting the CNT (SC_SCn_TMRCTL2[7:0]).
S     * |[31]    |SYNC      |SYNC Flag Indicator (Read Only)
S     * |        |          |Due to synchronization, user should check this bit when writing a new value to SC_SCn_ALTCTL register.
S     * |        |          |0 = Synchronizing is completion, user can write new data to SC_SCn_ALTCTL register.
S     * |        |          |1 = Last value is synchronizing. [WH1]
S     * |        |          |[WH1]Tag67
S     * @var SC_T::EGT
S     * Offset: 0x0C  SC Extra Guard Time Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |EGT       |Extra Guard Time
S     * |        |          |This field indicates the extra guard time value.
S     * |        |          |Note: The extra guard time unit is ETU base.[WH1]
S     * |        |          |[WH1]Tag53
S     * @var SC_T::RXTOUT
S     * Offset: 0x10  SC Receive Buffer Time-out Counter Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[8:0]   |RFTM      |SC Receiver FIFO Time-out Counter
S     * |        |          |The time-out down counter resets and starts counting whenever the RX Rx buffer received a new data
S     * |        |          |Once the counter decrease to 1 and no new data is received or CPU does not read data by reading SC_SCn_DAT (SC_DAT[7:0]), a receiver time-out flag RBXTOIF (SC_SCn_INTSTS[9]) will be set, and hardware will generate an interrupt signal to inform CPU when RXBTOIEN (SC_SCn_INTEN[9]) is enabled.
S     * |        |          |Note1: The counter unit is ETU based and the interval of time-out is (RFTM + 0.5) ETU time.
S     * |        |          |Note2: Filling in all 0 to this field indicates willto disable this function.[WH1]
S     * |        |          |[WH1]Tag72
S     * @var SC_T::ETUCTL
S     * Offset: 0x14  SC Element Time Unit Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |ETURDIV   |ETU Rate Divider
S     * |        |          |The field is used for define ETU time unit.clock rate divider.
S     * |        |          |The real ETU time unit is (ETURDIV + 1) * SC clock time.[WH1]
S     * |        |          |Note: User can configure this field, but this field must be greater than 0x004.[WH2]
S     * |        |          |[WH1]Tag6
S     * |        |          |[WH2]Tag74
S     * @var SC_T::INTEN
S     * Offset: 0x18  SC Interrupt Enable Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RDAIEN    |Receive Data Reach Interrupt Enable Bit
S     * |        |          |This field is used to enable received data bytes in Rx buffer reaching trigger level RXTRGLV (SC_SCn_CTL[7:6]) interrupt.
S     * |        |          |0 = Received data bytes in Rx buffer reach trigger level interrupt Disabled.
S     * |        |          |1 = Received data bytes in Rx buffer reach trigger level interrupt Enabled.[WH1]
S     * |        |          |[WH1]Tag7
S     * |[1]     |TXEIEN    |Transmit Buffer Empty Interrupt Enable Bit
S     * |        |          |This field is used to enable transmit buffer empty interrupt.
S     * |        |          |0 = Transmit buffer empty interrupt Disabled.
S     * |        |          |1 = Transmit buffer empty interrupt Enabled.[WH1]
S     * |        |          |[WH1]Tag64, 71
S     * |[2]     |TERRIEN   |Transfer Error Interrupt Enable Bit
S     * |        |          |This field is used to enable transfer error interrupt
S     * |        |          |The transfer error status states is at SC_SCn_STATUS register which includes receiver break error BEF (SC_SCn_STATUS[6]), frame error FEF (SC_SCn_STATUS[5]), parity error PEF (SC_SCn_STATUS[4]), receive buffer overflow error RXOV (SC_SCn_STATUS[0]), transmit buffer overflow error TXOV (SC_SCn_STATUS[8]), receiver retry over limit error RXOVERR (SC_SCn_STATUS[22]) and or transmitter retry over limit error TXOVERR (SC_SCn_STATUS[30]).
S     * |        |          |0 = Transfer error interrupt Disabled.
S     * |        |          |1 = Transfer error interrupt Enabled.[WH1]
S     * |        |          |[WH1]Tag11, 36
S     * |[3]     |TMR0IEN   |Timer0 Interrupt Enable Bit
S     * |        |          |This field is used to enable Timer0 interrupt function.
S     * |        |          |0 = Timer0 interrupt Disabled.
S     * |        |          |1 = Timer0 interrupt Enabled.[WH1]
S     * |        |          |[WH1]Tag76
S     * |[4]     |TMR1IEN   |Timer1 Interrupt Enable Bit
S     * |        |          |This field is used to enable the Timer1 interrupt function.
S     * |        |          |0 = Timer1 interrupt Disabled.
S     * |        |          |1 = Timer1 interrupt Enabled.
S     * |[5]     |TMR2IEN   |Timer2 Interrupt Enable Bit
S     * |        |          |This field is used to enable Timer2 interrupt function.
S     * |        |          |0 = Timer2 interrupt Disabled.
S     * |        |          |1 = Timer2 interrupt Enabled.
S     * |[6]     |BGTIEN    |Block Guard Time Interrupt Enable Bit
S     * |        |          |This field is used to enable block guard time interrupt in recevive direction.
S     * |        |          |0 = Block guard time interrupt Disabled.
S     * |        |          |1 = Block guard time interrupt Enabled.
S     * |        |          |Note: This bit is valid only for recvive receive direction block guard time.[WH1]
S     * |        |          |[WH1]Tag8, 50~53
S     * |[7]     |CDIEN     |Card Detect Interrupt Enable Bit
S     * |        |          |This field is used to enable card detect interrupt
S     * |        |          |The card detect status is CDPINSTS (SC_SCn_STATUS[13]).
S     * |        |          |0 = Card detect interrupt Disabled.
S     * |        |          |1 = Card detect interrupt Enabled.[WH1]
S     * |        |          |Note: Either cared insert or card remove event will generate crad detect event.
S     * |        |          |[WH1]Tag75
S     * |[8]     |INITIEN   |Initial End Interrupt Enable Bit
S     * |        |          |This field is used to enable activation (ACTEN (SC_SCn_ALTCTL[3] = 1)), deactivation (DACTEN (SC_SCn_ALTCTL[2] = 1)) and warm reset (WARSTEN (SC_SCn_ALTCTL [4])) sequence complete interrupt.
S     * |        |          |0 = Initial end interrupt Disabled.
S     * |        |          |1 = Initial end interrupt Enabled.[WH1]
S     * |        |          |[WH1]Tag12~15
S     * |[9]     |RXTOIEN   |Receiver Buffer Time-out Interrupt Enable Bit
S     * |        |          |This field is used to enable receiver buffer time-out interrupt.
S     * |        |          |0 = Receiver buffer time-out interrupt Disabled.
S     * |        |          |1 = Receiver buffer time-out interrupt Enabled.[WH1]
S     * |        |          |[WH1]Tag72
S     * |[10]    |ACERRIEN  |Auto Convention Error Interrupt Enable Bit
S     * |        |          |This field is used to enable auto-convention error interrupt.
S     * |        |          |0 = Auto-convention error interrupt Disabled.
S     * |        |          |1 = Auto-convention error interrupt Enabled.[WH1]
S     * |        |          |[WH1]Tag10
S     * @var SC_T::INTSTS
S     * Offset: 0x1C  SC Interrupt Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RDAIF     |Receive Data Reach Interrupt Status Flag (Read Only)
S     * |        |          |This field is used for received data bytes in Rx buffer reaching trigger level RXTRGLV (SC_SCn_CTL[7:6]) interrupt status flag.
S     * |        |          |0 = Number of receive buffer is less than RXTRGLV setting.
S     * |        |          |1 = Number of receive buffer data equals the RXTRGLV setting.
S     * |        |          |Note: This bit is read only
S     * |        |          |If user reads data from DAT (SC_SCn_DAT[7:0]) and remains receiver buffer data byte number is less than RXTRGLV, this bit will be cleared automatically.[WH1]
S     * |        |          |[WH1]Tag7
S     * |[1]     |TXEIF     |Transmit Buffer Empty Interrupt Status Flag (Read Only)
S     * |        |          |This field is used for transmit buffer empty interrupt status flag.
S     * |        |          |0 = Transmit buffer is not empty.
S     * |        |          |1 = Transmit buffer is empty.
S     * |        |          |Note: This bit is read only
S     * |        |          |If user wants to clear this bit, user must write data to DAT (SC_SCn_DAT[7:0]) and then this bit will be cleared automatically.[WH1]
S     * |        |          |[WH1]Tag64, 71
S     * |[2]     |TERRIF    |Transfer Error Interrupt Status Flag
S     * |        |          |This field is used for indicate transfer error interrupt status flag
S     * |        |          |The transfer error states status is at SC_SCn_STATUS register which includes receiver break error BEF (SC_SCn_STATUS[6]), frame error FEF (SC_SCn_STATUS[5]), parity error PEF (SC_SCn_STATUS[4]), and receive buffer overflow error RXOV (SC_SCn_STATUS[0]), transmit buffer overflow error TXOV (SC_SCn_STATUS[8]), receiver retry over limit error RXOVERR (SC_SCn_STATUS[22]) or transmitter retry over limit error TXOVERR (SC_SCn_STATUS[30]).
S     * |        |          |0 = Transfer error interrupt did not occur.
S     * |        |          |1 = Transfer error interrupt occurred.
S     * |        |          |Note1: This field is the status flag of BEF, FEF, PEF, RXOV, TXOV, RXOVERR or TXOVERR.
S     * |        |          |Note2: This bit can be cleared by writing 1 to it.[WH1]
S     * |        |          |[WH1]Tag11, 36
S     * |[3]     |TMR0IF    |Timer0 Interrupt Status Flag
S     * |        |          |This field is used for Timer0 interrupt status flag.
S     * |        |          |0 = Timer0 interrupt did not occur.
S     * |        |          |1 = Timer0 interrupt occurred.
S     * |        |          |Note: This bit can be cleared by writing 1 to it.[WH1]
S     * |        |          |[WH1]Tag76
S     * |[4]     |TMR1IF    |Timer1 Interrupt Status Flag
S     * |        |          |This field is used for Timer1 interrupt status flag.
S     * |        |          |0 = Timer1 interrupt did not occur.
S     * |        |          |1 = Timer1 interrupt occurred.
S     * |        |          |Note: This bit can be cleared by writing 1 to it.
S     * |[5]     |TMR2IF    |Timer2 Interrupt Status Flag
S     * |        |          |This field is used for Timer2 interrupt status flag.
S     * |        |          |0 = Timer2 interrupt did not occur.
S     * |        |          |1 = Timer2 interrupt occurred.
S     * |        |          |Note: This bit can be cleared by writing 1 to it.
S     * |[6]     |BGTIF     |Block   Guard Time Interrupt Status Flag
S     * |        |          |This field is   used for indicate block guard time interrupt status flag in recvive receive direction.
S     * |        |          |0 = Block   guard time interrupt did not occur.
S     * |        |          |1 = Block   guard time interrupt occurred.
S     * |        |          |Note1: This bit is valid only when RXBGTEN (SC_SCn_ALTCTL[12])   is enabled.
S     * |        |          |Note2: This bit can be cleared by writing 1 to   it.
S     * |[7]     |CDIF      |Card Detect Interrupt Status Flag (Read Only)
S     * |        |          |This field is used for card detect interrupt status flag
S     * |        |          |The actual card detect status is in CINSERT (SC_SCn_STATUS[12]) and CREMOVE (SC_SCn_STATUS[11]).
S     * |        |          |0 = Card detect event did not occur.
S     * |        |          |1 = Card detect event occurred.
S     * |        |          |Note1: This bit is read only, and will be cleared after user must to clear CINSERT or CREMOVE [WH1]status has been clearedto clear it.
S     * |        |          |Note2: Either cared insert or card remove event will generate crad detect event.
S     * |        |          |[WH1]Tag75
S     * |[8]     |INITIF    |Initial End Interrupt Status Flag
S     * |        |          |This field is used for activation (ACTEN (SC_SCn_ALTCTL[3])), deactivation (DACTEN (SC_SCn_ALTCTL[2])) and warm reset (WARSTEN (SC_SCn_ALTCTL[4])) sequence interrupt status flag.
S     * |        |          |0 = Initial sequence is not complete.
S     * |        |          |1 = Initial sequence is completed.
S     * |        |          |Note: This bit can be cleared by writing 1 to it.[WH1]
S     * |        |          |[WH1]Tag12~15
S     * |[9]     |RXTOIF    |Receive Buffer Time-out Interrupt Status Flag (Read Only)
S     * |        |          |This field is used for indicate receive buffer time-out interrupt status flag.
S     * |        |          |0 = Receive buffer time-out interrupt did not occur.
S     * |        |          |1 = Receive buffer time-out interrupt occurred.
S     * |        |          |Note: This bit is read only, user must read all receive buffer remaining data by reading SC_SCn_DAT (SC_DAT[7:0])register to clear it.[WH1]
S     * |        |          |[WH1]Tag72
S     * |[10]    |ACERRIF   |Auto Convention Error Interrupt Status Flag
S     * |        |          |This field indicates auto convention sequence error.
S     * |        |          |0 = Received TS at ATR state is 0x3B or 0x3F.
S     * |        |          |1 = Received TS at ATR state is neither 0x3B nor 0x3F.
S     * |        |          |Note: This bit can be cleared by writing 1 to it.[WH1]
S     * |        |          |[WH1]Tag10
S     * @var SC_T::STATUS
S     * Offset: 0x20  SC Transfer Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RXOV      |Receive Overflow Error Status Flag
S     * |        |          |This bit is set when Rx buffer overflow.
S     * |        |          |0 = Rx buffer is not overflow.
S     * |        |          |1 = Rx buffer is overflow when the number of received bytes is greater than Rx buffer size (4 bytes).
S     * |        |          |Note: This bit can be cleared by writing 1 to it.[WH1]
S     * |        |          |[WH1]Tag5
S     * |[1]     |RXEMPTY   |Receive Buffer Empty Status Flag (Read Only)
S     * |        |          |This bit indicates Rx buffer is empty or not.
S     * |        |          |0 = Rx buffer is not empty.
S     * |        |          |1 = Rx buffer is empty, it means the last byte of in Rx buffer has been read from DAT (SC_SCn_DAT[7:0]) by CPU.
S     * |[2]     |RXFULL    |Receive Buffer Full Status Flag (Read Only)
S     * |        |          |This bit indicates Rx buffer is full or not.
S     * |        |          |0 = Rx buffer count is less than 4.
S     * |        |          |1 = Rx buffer count equals to 4.
S     * |[4]     |PEF       |Receiver Parity Error Status Flag
S     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid u201Cparity bitu201D.
S     * |        |          |0 = Receiver parity error flag did not occur.
S     * |        |          |1 = Receiver parity error flag occurred.
S     * |        |          |Note1: This bit can be cleared by writing 1 to it.
S     * |        |          |Note2: If user CPU sets receiver retries function by setting RXRTYEN (SC_SCn_CTL[19]), hardware will not set this flag.[WH1]
S     * |        |          |[WH1]Tag80
S     * |[5]     |FEF       |Receiver Frame Error Status Flag
S     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid u201Cstop bitu201D (that is, the stop bit following the last data bit or parity bit is detected as logic 0).
S     * |        |          |0 = Receiver frame error flag did not occur.
S     * |        |          |1 = Receiver frame error flag occurred.
S     * |        |          |Note1: This bit can be cleared by writing 1 to it.
S     * |        |          |Note2: If user CPU sets receiver retries function by setting RXRTYEN (SC_SCn_CTL[19]), hardware will not set this flag.[WH1]
S     * |        |          |[WH1]Tag79
S     * |[6]     |BEF       |Receiver Break Error Status Flag
S     * |        |          |This bit is set to logic 1 whenever the received data input (Rx) held in the u201Cspacing stateu201D (logic 0) is longer than a full word transmission time (that is, the total time of u201Cstart bitu201D + u201Cdata bitsu201D + u201Cparity bitu201D + u201Cstop bitsu201D).
S     * |        |          |0 = Receiver break error flag did not occur.
S     * |        |          |1 = Receiver break error flag occurred.
S     * |        |          |Note1: This bit can be cleared by writing 1 to it.
S     * |        |          |Note2: If CPU user sets receiver retries function by setting RXRTYEN (SC_SCn_CTL[19]), hardware will not set this flag.[WH1]
S     * |        |          |[WH1]Tag78
S     * |[8]     |TXOV      |Transmit Overflow Error Interrupt Status Flag
S     * |        |          |This bit is set when Tx buffer overflow.
S     * |        |          |0 = Tx buffer is not overflow.
S     * |        |          |1 = Tx buffer is overflow, it means when Tx buffer is full and an additional write operation to DAT (SC_SCn_DAT[7:0]) when Tx buffer is already full.
S     * |        |          |Note: This bit can be cleared by writing 1 to it.[WH1]
S     * |        |          |[WH1]Tag5
S     * |[9]     |TXEMPTY   |Transmit Buffer Empty Status Flag (Read Only)
S     * |        |          |This bit indicates TX buffer is empty or not.
S     * |        |          |0 = Tx buffer is not empty.
S     * |        |          |1 = Tx buffer is empty, it means the last byte of Tx buffer has been transferred to Transmitter Shift Register.
S     * |        |          |Note: This bit will be cleared when writing data into DAT (SC_SCn_DAT[7:0]).
S     * |[10]    |TXFULL    |Transmit Buffer Full Status Flag (Read Only)
S     * |        |          |This bit indicates Tx buffer is full or not.
S     * |        |          |0 = Tx buffer count is less than 4.
S     * |        |          |1 = Tx buffer count equals to 4.
S     * |[11]    |CREMOVE   |Card Removal Status of SC_SCn_CD Pin
S     * |        |          |This bit is set whenever card has been removal.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Card removed.
S     * |        |          |Note1: This bit can be cleared by writing u201C1u201D to it.
S     * |        |          |Note2: Card detect function will start after SCEN (SC_SCn_CTL[0]) is set.[WH1]
S     * |        |          |[WH1]Tag2
S     * |[12]    |CINSERT   |Card Insert Status of SC_SCn_CD Pin
S     * |        |          |This bit is set whenever card has been inserted.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Card insert.
S     * |        |          |Note1: This bit can be cleared by writing u201C1u201D to it.
S     * |        |          |Note2: The card detect function will start after SCEN (SC_SCn_CTL[0]) setis set.
S     * |[13]    |CDPINSTS  |Card Detect Pin Status (Read Only)
S     * |        |          |This bit is the pin status of SC_SCn_CD.
S     * |        |          |0 = The SC_SCn_CD pin state at low.
S     * |        |          |1 = The SC_SCn_CD pin state at high.
S     * |[18:16] |RXPOINT   |Receive Buffer Pointer Status (Read Only)
S     * |        |          |This field indicates the Rx buffer pointer status
S     * |        |          |When SC controller receives one byte from external device, RXPOINT increases one
S     * |        |          |When one byte of in Rx buffer is read by CPUreading DAT (SC_DAT[7:0]), RXPOINT decreases one.[WH1]
S     * |        |          |[WH1]Tag5
S     * |[21]    |RXRTYERR  |Receiver Retry ErrorRetry Error
S     * |        |          |This bit is used for indicate receiver error retry error retry and set by hardware.
S     * |        |          |0 = No Rx retry transfer.
S     * |        |          |1 = Rx has any error and retries transfer.
S     * |        |          |Note1: This bit can be cleared by writing 1 to it.
S     * |        |          |Note2: This bit is a flag and cannot generate any interrupt signal to CPU.
S     * |        |          |Note3: If CPU user enables receiver retries function by setting RXRTYEN (SC_SCn_CTL[19]), the PEF (SC_STATUS[4]) bit hardware will not set this flag.[WH1]
S     * |        |          |[WH1]Tag11
S     * |[22]    |RXOVERR   |Receiver Oover Retry Error
S     * |        |          |This bit is used for indicate receiver retry counts over than retry number limitation.
S     * |        |          |0 = Receiver retries counts is not over than RXRTY (SC_SCn_CTL[18:16]) + 1.
S     * |        |          |1 = Receiver retries counts over than RXRTY (SC_SCn_CTL[18:16]) + 1.
S     * |        |          |Note1: This bit can be cleared by writing 1 to it.
S     * |        |          |Note2: If CPU user enables receiver retries function by setting RXRTYEN (SC_SCn_CTL[19]), the PEF (SC_STATUS[4]) bit will not set hardware will not set this flag.
S     * |[23]    |RXACT     |Receiver in Active Status Flag (Read Only)
S     * |        |          |This bit indicates Rx transfer status.
S     * |        |          |0 = This bit is cleared automatically when Rx transfer is finished.
S     * |        |          |1 = This bit is set by hardware when Rx transfer is in active.
S     * |        |          |Note: This bit is read only.[WH1]
S     * |        |          |[WH1]Tag78
S     * |[26:24] |TXPOINT   |Transmit Buffer Pointer Status (Read Only)
S     * |        |          |This field indicates the Tx buffer pointer status
S     * |        |          |When CPU writes data into DAT (SC_SCn_DAT[7:0]), TXPOINT increases one
S     * |        |          |When one byte of Tx buffer is transferred to Transmitter Shift Registertransmitter shift register, TXPOINT decreases one.[WH1]
S     * |        |          |[WH1]Tag5
S     * |[29]    |TXRTYERR  |Transmitter Retry ErrorRetry Error
S     * |        |          |This bit is used for indicate transmitter error retry and set by hardware..
S     * |        |          |0 = No Tx retry transfer.
S     * |        |          |1 = Tx has any error and retries transfer.
S     * |        |          |Note1: This bit can be cleared by writing 1 to it.
S     * |        |          |Note2: This bit is a flag and cannot generate any interrupt signal to CPU.[WH1]
S     * |        |          |[WH1]Tag11
S     * |[30]    |TXOVERR   |Transmitter Oover Retry Error
S     * |        |          |This bit is used for transmitter retry counts over than retry number limitation.
S     * |        |          |0 = Transmitter retries counts is not over than TXRTY (SC_SCn_CTL[22:20]) + 1.
S     * |        |          |1 = Transmitter retries counts over than TXRTY (SC_SCn_CTL[22:20]) + 1.
S     * |        |          |Note: This bit can be cleared by writing 1 to it.
S     * |[31]    |TXACT     |Transmit in Active Status Flag (Read Only)
S     * |        |          |This bit indicates Tx transmit status.
S     * |        |          |0 = This bit is cleared automatically when Tx transfer is finished or the last byte transmission has completed.
S     * |        |          |1 = Transmit is active or the STOP bit of last byte has not been transmitted when Tx transfer is in active.and this bit is set by hardware when Tx transfer is in active and the STOP bit of the last byte has not been transmitted.
S     * |        |          |Note: This bit is read only.[WH1]
S     * |        |          |[WH1]Tag77
S     * @var SC_T::PINCTL
S     * Offset: 0x24  SC Pin Control State Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PWREN     |SC_SCn_PWR Pin Signal
S     * |        |          |User can set PWRINV (SC_SCn_PINCTL[11]) and PWREN (SC_SCn_PINCTL[0]) to decide SC_SCn_PWR pin is in high or low level.
S     * |        |          |Write this field bit can to drive SC_SCn_PWR pin
S     * |        |          |Refer PWRINV (SC_SCn_PINCTL[11]) description for programming SC_SCn_PWR pin voltage level.
S     * |        |          |Read this field bit to get SC_SCn_PWR signal status.
S     * |        |          |0 = SC_SCn_PWR signal status is low.
S     * |        |          |1 = SC_SCn_PWR signal status is high.
S     * |        |          |Note: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically
S     * |        |          |Thus, do not fill in this field when operating in these modes.[WH1]
S     * |        |          |[WH1]Tag84
S     * |[1]     |SCRST     |SC_SCn_RST Pin Signal
S     * |        |          |This bit is the signal status of SC_SCn_RST but user can drive SC_SCn_RST pin to high or low by setting control this bit.
S     * |        |          |Write this bit can field to drive SC_SCn_RST pin.
S     * |        |          |0 = Drive SC_SCn_RST pin to low.
S     * |        |          |1 = Drive SC_SCn_RST pin to high.
S     * |        |          |Read this bit field to get SC_SCn_RST signal status.
S     * |        |          |0 = SC_SCn_RST signal status is low.
S     * |        |          |1 = SC_SCn_RST signal status is high.
S     * |        |          |Note: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically
S     * |        |          |Thus, do not fill in this field when operating in these modes.[WH1]
S     * |        |          |[WH1]Tag84
S     * |[6]     |CLKKEEP   |SC Clock Enable Bit
S     * |        |          |0 = SC clock generation Disabled.
S     * |        |          |1 = SC clock always keeps free running.
S     * |        |          |Note: When operating in activation, warm reset or deactivation mode, this bit will be changed automatically
S     * |        |          |Thus, do not fill in this field when operating in these modes.[WH1]
S     * |        |          |[WH1]Tag66
S     * |[9]     |SCDATA    |SC_SCn_DATA Pin Signal
S     * |        |          |This bit is the signal status of SC_SCn_DATA but user can also drive SC_SCn_DATA pin to high or low by control this setting this bit.
S     * |        |          |Write this bit can drive SC_RST pin.
S     * |        |          |0 = Drive SC_SCn_DATA pin to low.
S     * |        |          |1 = Drive SC_SCn_DATA pin to high.
S     * |        |          |Read this bit field to get SC_SCn_DATA signal status.
S     * |        |          |0 = SC_SCn_DATA signal status is low.
S     * |        |          |1 = SC_SCn_DATA signal status is high.
S     * |        |          |Note: When SC is at activation, warm reset or deactivation mode, this bit will be changed automatically
S     * |        |          |Thus, do not fill in this field when SC is in these modes.[WH1]
S     * |        |          |[WH1]Tag85
S     * |[11]    |PWRINV    |SC_SCn_PWR Pin Inverse
S     * |        |          |This bit is used for inverse the SC_SCn_PWR pin.
S     * |        |          |There are four kinds of combination for SC_SCn_PWR pin setting by PWRINV (SC_SCn_PINCTL[11]) and PWREN (SC_SCn_PINCTL[0])
S     * |        |          |A
S     * |        |          |PWRINV (SC_SCn_PINCTL[11]) is bit 1 and PWREN (SC_SCn_PINCTL[0]) is bit 0 and all conditions as below list.,
S     * |        |          |00 = SC_SCn_PWR pin is 0.
S     * |        |          |01 = SC_SCn_PWR pin is 1.
S     * |        |          |10 = SC_SCn_PWR pin is 1.
S     * |        |          |11 = SC_SCn_PWR pin is 0.
S     * |        |          |Note: User must select PWRINV (SC_SCn_PINCTL[11]) before smart card is enabled by SCEN (SC_SCn_CTL[0]).[WH1]
S     * |        |          |[WH1]Tag84
S     * |[16]    |DATSTS    |SC_SCn_DATA Pin Status (Read Only)
S     * |        |          |This bit is the pin status of SC_SCn_DATA.
S     * |        |          |0 = The SC_SCn_DATA pin status is low.
S     * |        |          |1 = The SC_SCn_DATA pin status is high.
S     * |[17]    |PWRSTS    |SCn_PWR Pin Status (Read Only)
S     * |        |          |This bit is the pin status of SC_SCn_PWR.
S     * |        |          |0 = SC_SCn_PWR pin to low.
S     * |        |          |1 = SC_SCn_PWR pin to high.[WH1]
S     * |        |          |[WH1]Tag84
S     * |[18]    |RSTSTS    |SC_SCn_RST Pin Status (Read Only)
S     * |        |          |This bit is the pin status of SC_SCn_RST.
S     * |        |          |0 = SC_SCn_RST pin is low.
S     * |        |          |1 = SC_SCn_RST pin is high. [WH1]
S     * |        |          |[WH1]Tag83
S     * |[30]    |SYNC      |SYNC Flag Indicator (Read Only)
S     * |        |          |Due to synchronization, user should check this bit when writing a new value to SC_SCn_PINCTL register.
S     * |        |          |0 = Synchronizing is completion, user can write new data to SC_SCn_PINCTL register.
S     * |        |          |1 = Last value is synchronizing. [WH1]
S     * |        |          |[WH1]Tag82
S     * @var SC_T::TMRCTL0
S     * Offset: 0x28  SC Timer0 Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[23:0]  |CNT       |Timer 0 Counter Value
S     * |        |          |This field indicates the internal Timer0 counter values.
S     * |        |          |Note: Unit of Timer01 counter is ETU base.[WH1]
S     * |        |          |[WH1]Tag9, 37~49
S     * |[27:24] |OPMODE    |Timer 0 Operation Mode Selection
S     * |        |          |This field indicates the internal 824-bit Timer0 operation selection.
S     * |        |          |Refer to Table 1.1-3 Table 1.1-3 for programming Timer0.[WH1]
S     * |        |          |[WH1]Tag9, 37~49
S     * |[31]    |SYNC      |SYNC Flag Indicator (Read Only)
S     * |        |          |Due to synchronization, softwareuser should check this bit when writing a new value to SCn_TMRCTL0 register.
S     * |        |          |0 = Synchronizing is completion, user can write new data to SCn_TMRCTL0 register.
S     * |        |          |1 = Last value is synchronizing. [WH1]
S     * |        |          |[WH1]Tag88
S     * @var SC_T::TMRCTL1
S     * Offset: 0x2C  SC Timer1 Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |CNT       |Timer 1 Counter Value
S     * |        |          |This field indicates the internal Timer1 counter values.
S     * |        |          |Note: Unit of Timer1 counter is ETU base.[WH1]
S     * |        |          |[WH1]Tag9, 37~49
S     * |[27:24] |OPMODE    |Timer 1 Operation Mode Selection
S     * |        |          |This field indicates the internal 8-bit Timer1 operation selection.
S     * |        |          |Refer to Table 1.1-3 Table 1.1-3 for programming Timer1.[WH1]
S     * |        |          |[WH1]Tag9, 37~49
S     * |[31]    |SYNC      |SYNC Flag Indicator (Read Only)
S     * |        |          |Due to synchronization, softwareuser should check this bit when writing a new value to SCn_TMRCTL1 register.
S     * |        |          |0 = Synchronizing is completion, user can write new data to SCn_TMRCTL1 register.
S     * |        |          |1 = Last value is synchronizing. [WH1]
S     * |        |          |[WH1]Tag88
S     * @var SC_T::TMRCTL2
S     * Offset: 0x30  SC Timer2 Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |CNT       |Timer 2 Counter Value
S     * |        |          |This field indicates the internal Timer2 counter values.
S     * |        |          |Note: Unit of Timer2 counter is ETU base.[WH1]
S     * |        |          |[WH1]Tag9, 37~49
S     * |[27:24] |OPMODE    |Timer 2 Operation Mode Selection
S     * |        |          |This field indicates the internal 8-bit Timer2 operation selection
S     * |        |          |Refer to Table 1.1-3 Table 1.1-3 for programming Timer2.[WH1]
S     * |        |          |[WH1]Tag9, 37~49
S     * |[31]    |SYNC      |SYNC Flag Indicator (Read Only)
S     * |        |          |Due to synchronization, user should check this bit when writing a new value to SCn_TMRCTL2 register.
S     * |        |          |0 = Synchronizing is completion, user can write new data to SCn_TMRCTL2 register.
S     * |        |          |1 = Last value is synchronizing. [WH1]
S     * |        |          |[WH1]Tag88
S     * @var SC_T::UARTCTL
S     * Offset: 0x34  SC UART Mode Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |UARTEN    |UART Mode Enable Bit
S     * |        |          |Sets this bit to enable UART mode function.
S     * |        |          |0 = Smart Card mode.
S     * |        |          |1 = UART mode.
S     * |        |          |Note1: When operating in UART mode, user must set CONSEL (SC_SCn_CTL[5:4]) = 00 and AUTOCEN (SC_SCn_CTL[3]) = 0.
S     * |        |          |Note2: When operating in Smart Card mode, user must set UARTEN (SC_SCn_UARTCTL[0]) = 0.
S     * |        |          |Note3: When UART mode is enabled, hardware will generate a reset SC event to reset FIFO and internal state machine.[WH1]
S     * |        |          |[WH1]Tag94
S     * |[5:4]   |WLS       |Word Length Selection
S     * |        |          |This field is used for select uart UART data transfer length.
S     * |        |          |00 = Word length is 8 bits.
S     * |        |          |01 = Word length is 7 bits.
S     * |        |          |10 = Word length is 6 bits.
S     * |        |          |11 = Word length is 5 bits.
S     * |        |          |Note: In smart card mode, this WLS field must be u201800u2019.[WH1]
S     * |        |          |[WH1]Tag93
S     * |[6]     |PBOFF     |Parity Bit Disable Control
S     * |        |          |Sets tThis bit is used for disable parity check function.
S     * |        |          |0 = Parity bit is generated or checked between the u201Clast data word bitu201D and u201Cstop bitu201D of the serial data.
S     * |        |          |1 = Parity bit is not generated (transmitting data) or checked (receiving data) during transfer.
S     * |        |          |Note: In smart card mode, this field bit must be u20180u2019 (default setting is with parity bit)[WH1].
S     * |        |          |[WH1]Tag21
S     * |[7]     |OPE       |Odd Parity Enable Bit
S     * |        |          |This is used for odd/even parity selection.
S     * |        |          |0 = Even number of logic 1u2019s are transmitted or check the data word and parity bits in receiving mode.
S     * |        |          |1 = Odd number of logic 1u2019s are transmitted or check the data word and parity bits in receiving mode.
S     * |        |          |Note: This bit has effect only when PBOFF bit is u20180u2019.
S     * @var SC_T::TMRDAT0
S     * Offset: 0x38  SC Timer0 Current Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[23:0]  |CNT0      |Timer0 Current Data Value (Read Only)
S     * |        |          |This field indicates the current counter values of Timer0.[WH1]
S     * |        |          |[WH1]Tag37
S     * @var SC_T::TMRDAT12
S     * Offset: 0x3C  SC Timer1/2 Current Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |CNT1      |Timer1 Current Data Value (Read Only)
S     * |        |          |This field indicates the current counter values of Timer1.[WH1]
S     * |        |          |[WH1]Tag37
S     * |[15:8]  |CNT2      |Timer2 Current Data Value (Read Only)
S     * |        |          |This field indicates the current counter values of Timer2.
S     * @var SC_T::ACTCTL
S     * Offset: 0x4C  SC Activation Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[4:0]   |T1EXT     |T1 Extend Time of Hardware Activation
S     * |        |          |This field provide the configurable cycles to extend the activation time T1 period.
S     * |        |          |Please refer to SC activation sequence in Figure 1.1-4.
S     * |        |          |The cycle scaling factor is 2048 and .
S     * |        |          |Extend cycles = (filled valueT1EXT * 2048) cycles.
S     * |        |          |Refer to SC activation sequence in Figure 1.1-4 SC Activation Sequence.
S     * |        |          |For example:,
S     * |        |          |If SCLK is= 4MHz, each clock cycle cyiscle = 0.25us.,.
S     * |        |          |Filled 20 to this T1EXT, thenfield
S     * |        |          |Extend time == 20 * 2048 * 0.25us = 10.24 ms.
S     * |        |          |Note: Setting 0 to this field conforms to the protocol ISO/IEC 7816-3[WH1].
S     * |        |          |[WH1]Tag98
S     */
S
S    __IO uint32_t DAT;                   /*!< [0x0000] SC Receive/Transmit Holding Buffer Register                      */
S    __IO uint32_t CTL;                   /*!< [0x0004] SC Control Register                                              */
S    __IO uint32_t ALTCTL;                /*!< [0x0008] SC Alternate Control Register                                    */
S    __IO uint32_t EGT;                   /*!< [0x000c] SC Extra Guard Time Register                                     */
S    __IO uint32_t RXTOUT;                /*!< [0x0010] SC Receive Buffer Time-out Counter Register                      */
S    __IO uint32_t ETUCTL;                /*!< [0x0014] SC Element Time Unit Control Register                            */
S    __IO uint32_t INTEN;                 /*!< [0x0018] SC Interrupt Enable Control Register                             */
S    __IO uint32_t INTSTS;                /*!< [0x001c] SC Interrupt Status Register                                     */
S    __IO uint32_t STATUS;                /*!< [0x0020] SC Transfer Status Register                                      */
S    __IO uint32_t PINCTL;                /*!< [0x0024] SC Pin Control State Register                                    */
S    __IO uint32_t TMRCTL0;               /*!< [0x0028] SC Timer0 Control Register                                       */
S    __IO uint32_t TMRCTL1;               /*!< [0x002c] SC Timer1 Control Register                                       */
S    __IO uint32_t TMRCTL2;               /*!< [0x0030] SC Timer2 Control Register                                       */
S    __IO uint32_t UARTCTL;               /*!< [0x0034] SC UART Mode Control Register                                    */
S    __I  uint32_t TMRDAT0;               /*!< [0x0038] SC Timer0 Current Data Register                                  */
S    __I  uint32_t TMRDAT12;              /*!< [0x003c] SC Timer1/2 Current Data Register                                */
S    __I  uint32_t RESERVE0[3];
S    __IO uint32_t ACTCTL;                /*!< [0x004c] SC Activation Control Register                                   */
S
S////    __IO uint32_t DAT;           /* Offset: 0x00  SC Receiving/Transmit Holding Buffer Register.                     */
S////    __IO uint32_t CTL;           /* Offset: 0x04  SC Control Register.                                               */
S////    __IO uint32_t ALTCTL;        /* Offset: 0x08  SC Alternate Control Register.                                     */
S////    __IO uint32_t EGT;           /* Offset: 0x0C  SC Extend Guard Time Register.                                     */
S////    __IO uint32_t RXTOUT;        /* Offset: 0x10  SC Receive buffer Time-out Register.                               */
S////    __IO uint32_t ETUCTL;        /* Offset: 0x14  SC ETU Control Register.                                           */
S////    __IO uint32_t INTEN;         /* Offset: 0x18  SC Interrupt Enable Control Register.                              */
S////    __IO uint32_t INTSTS;        /* Offset: 0x1C  SC Interrupt Status Register.                                      */
S////    __IO uint32_t STATUS;        /* Offset: 0x20  SC Status Register.                                                */
S////    __IO uint32_t PINCTL;        /* Offset: 0x24  SC Pin Control State Register.                                     */
S////    __IO uint32_t TMRCTL0;       /* Offset: 0x28  SC Internal Timer Control Register 0.                              */
S////    __IO uint32_t TMRCTL1;       /* Offset: 0x2C  SC Internal Timer Control Register 1.                              */
S////    __IO uint32_t TMRCTL2;       /* Offset: 0x30  SC Internal Timer Control Register 2.                              */
S////    __IO uint32_t UARTCTL;       /* Offset: 0x34  SC UART Mode Control Register.                                     */
S////    __I  uint32_t TMRDAT0;       /* Offset: 0x38  SC Timer0 Current Data Register.                                   */
S////    __I  uint32_t TMRDAT1_2;     /* Offset: 0x3C  SC Timer1/2 Current Data Register.                                 */
S//////    __I  uint32_t RESERVE[3];
S////        /* Not released in TRM */
S////        __IO  uint32_t  PETCTL; /*!< Offset: 0x0040  SC Parity Error Timing Setting Register                     */
S////        __IO  uint32_t  BGTEXT; /*!< Offset: 0x0044  SC Block Guard Timing Extent  Register                  */
S////        __IO  uint32_t  EGTADJ; /*!< Offset: 0x0048  SC Block Guard Timing Extent  Register                 */
S////    __IO uint32_t ACTCTL;        /* Offset: 0x4C  SC Activation Control Register.                                    */
S////
S
S} SC_T;
S
S/**
S    @addtogroup SC_CONST SC Bit Field Definition
S    Constant Definitions for SC Controller
S@{ */
S
S#define SC_DAT_DAT_Pos                   (0)                                               /*!< SC_T::DAT: DAT Position                */
S#define SC_DAT_DAT_Msk                   (0xfful << SC_DAT_DAT_Pos)                        /*!< SC_T::DAT: DAT Mask                    */
S
S#define SC_CTL_SCEN_Pos                  (0)                                               /*!< SC_T::CTL: SCEN Position               */
S#define SC_CTL_SCEN_Msk                  (0x1ul << SC_CTL_SCEN_Pos)                        /*!< SC_T::CTL: SCEN Mask                   */
S
S#define SC_CTL_RXOFF_Pos                 (1)                                               /*!< SC_T::CTL: RXOFF Position              */
S#define SC_CTL_RXOFF_Msk                 (0x1ul << SC_CTL_RXOFF_Pos)                       /*!< SC_T::CTL: RXOFF Mask                  */
S
S#define SC_CTL_TXOFF_Pos                 (2)                                               /*!< SC_T::CTL: TXOFF Position              */
S#define SC_CTL_TXOFF_Msk                 (0x1ul << SC_CTL_TXOFF_Pos)                       /*!< SC_T::CTL: TXOFF Mask                  */
S
S#define SC_CTL_AUTOCEN_Pos               (3)                                               /*!< SC_T::CTL: AUTOCEN Position            */
S#define SC_CTL_AUTOCEN_Msk               (0x1ul << SC_CTL_AUTOCEN_Pos)                     /*!< SC_T::CTL: AUTOCEN Mask                */
S
S#define SC_CTL_CONSEL_Pos                (4)                                               /*!< SC_T::CTL: CONSEL Position             */
S#define SC_CTL_CONSEL_Msk                (0x3ul << SC_CTL_CONSEL_Pos)                      /*!< SC_T::CTL: CONSEL Mask                 */
S
S#define SC_CTL_RXTRGLV_Pos               (6)                                               /*!< SC_T::CTL: RXTRGLV Position            */
S#define SC_CTL_RXTRGLV_Msk               (0x3ul << SC_CTL_RXTRGLV_Pos)                     /*!< SC_T::CTL: RXTRGLV Mask                */
S
S#define SC_CTL_BGT_Pos                   (8)                                               /*!< SC_T::CTL: BGT Position                */
S#define SC_CTL_BGT_Msk                   (0x1ful << SC_CTL_BGT_Pos)                        /*!< SC_T::CTL: BGT Mask                    */
S
S#define SC_CTL_TMRSEL_Pos                (13)                                              /*!< SC_T::CTL: TMRSEL Position             */
S#define SC_CTL_TMRSEL_Msk                (0x3ul << SC_CTL_TMRSEL_Pos)                      /*!< SC_T::CTL: TMRSEL Mask                 */
S
S#define SC_CTL_NSB_Pos                   (15)                                              /*!< SC_T::CTL: NSB Position                */
S#define SC_CTL_NSB_Msk                   (0x1ul << SC_CTL_NSB_Pos)                         /*!< SC_T::CTL: NSB Mask                    */
S
S#define SC_CTL_RXRTY_Pos                 (16)                                              /*!< SC_T::CTL: RXRTY Position              */
S#define SC_CTL_RXRTY_Msk                 (0x7ul << SC_CTL_RXRTY_Pos)                       /*!< SC_T::CTL: RXRTY Mask                  */
S
S#define SC_CTL_RXRTYEN_Pos               (19)                                              /*!< SC_T::CTL: RXRTYEN Position            */
S#define SC_CTL_RXRTYEN_Msk               (0x1ul << SC_CTL_RXRTYEN_Pos)                     /*!< SC_T::CTL: RXRTYEN Mask                */
S
S#define SC_CTL_TXRTY_Pos                 (20)                                              /*!< SC_T::CTL: TXRTY Position              */
S#define SC_CTL_TXRTY_Msk                 (0x7ul << SC_CTL_TXRTY_Pos)                       /*!< SC_T::CTL: TXRTY Mask                  */
S
S#define SC_CTL_TXRTYEN_Pos               (23)                                              /*!< SC_T::CTL: TXRTYEN Position            */
S#define SC_CTL_TXRTYEN_Msk               (0x1ul << SC_CTL_TXRTYEN_Pos)                     /*!< SC_T::CTL: TXRTYEN Mask                */
S
S#define SC_CTL_CDDBSEL_Pos               (24)                                              /*!< SC_T::CTL: CDDBSEL Position            */
S#define SC_CTL_CDDBSEL_Msk               (0x3ul << SC_CTL_CDDBSEL_Pos)                     /*!< SC_T::CTL: CDDBSEL Mask                */
S
S#define SC_CTL_CDLV_Pos                  (26)                                              /*!< SC_T::CTL: CDLV Position               */
S#define SC_CTL_CDLV_Msk                  (0x1ul << SC_CTL_CDLV_Pos)                        /*!< SC_T::CTL: CDLV Mask                   */
S
S#define SC_CTL_SYNC_Pos                  (30)                                              /*!< SC_T::CTL: SYNC Position               */
S#define SC_CTL_SYNC_Msk                  (0x1ul << SC_CTL_SYNC_Pos)                        /*!< SC_T::CTL: SYNC Mask                   */
S
S#define SC_ALTCTL_TXRST_Pos              (0)                                               /*!< SC_T::ALTCTL: TXRST Position           */
S#define SC_ALTCTL_TXRST_Msk              (0x1ul << SC_ALTCTL_TXRST_Pos)                    /*!< SC_T::ALTCTL: TXRST Mask               */
S
S#define SC_ALTCTL_RXRST_Pos              (1)                                               /*!< SC_T::ALTCTL: RXRST Position           */
S#define SC_ALTCTL_RXRST_Msk              (0x1ul << SC_ALTCTL_RXRST_Pos)                    /*!< SC_T::ALTCTL: RXRST Mask               */
S
S#define SC_ALTCTL_DACTEN_Pos             (2)                                               /*!< SC_T::ALTCTL: DACTEN Position          */
S#define SC_ALTCTL_DACTEN_Msk             (0x1ul << SC_ALTCTL_DACTEN_Pos)                   /*!< SC_T::ALTCTL: DACTEN Mask              */
S
S#define SC_ALTCTL_ACTEN_Pos              (3)                                               /*!< SC_T::ALTCTL: ACTEN Position           */
S#define SC_ALTCTL_ACTEN_Msk              (0x1ul << SC_ALTCTL_ACTEN_Pos)                    /*!< SC_T::ALTCTL: ACTEN Mask               */
S
S#define SC_ALTCTL_WARSTEN_Pos            (4)                                               /*!< SC_T::ALTCTL: WARSTEN Position         */
S#define SC_ALTCTL_WARSTEN_Msk            (0x1ul << SC_ALTCTL_WARSTEN_Pos)                  /*!< SC_T::ALTCTL: WARSTEN Mask             */
S
S#define SC_ALTCTL_CNTEN0_Pos             (5)                                               /*!< SC_T::ALTCTL: CNTEN0 Position          */
S#define SC_ALTCTL_CNTEN0_Msk             (0x1ul << SC_ALTCTL_CNTEN0_Pos)                   /*!< SC_T::ALTCTL: CNTEN0 Mask              */
S
S#define SC_ALTCTL_CNTEN1_Pos             (6)                                               /*!< SC_T::ALTCTL: CNTEN1 Position          */
S#define SC_ALTCTL_CNTEN1_Msk             (0x1ul << SC_ALTCTL_CNTEN1_Pos)                   /*!< SC_T::ALTCTL: CNTEN1 Mask              */
S
S#define SC_ALTCTL_CNTEN2_Pos             (7)                                               /*!< SC_T::ALTCTL: CNTEN2 Position          */
S#define SC_ALTCTL_CNTEN2_Msk             (0x1ul << SC_ALTCTL_CNTEN2_Pos)                   /*!< SC_T::ALTCTL: CNTEN2 Mask              */
S
S#define SC_ALTCTL_INITSEL_Pos            (8)                                               /*!< SC_T::ALTCTL: INITSEL Position         */
S#define SC_ALTCTL_INITSEL_Msk            (0x3ul << SC_ALTCTL_INITSEL_Pos)                  /*!< SC_T::ALTCTL: INITSEL Mask             */
S
S#define SC_ALTCTL_ADACEN_Pos             (11)                                              /*!< SC_T::ALTCTL: ADACEN Position          */
S#define SC_ALTCTL_ADACEN_Msk             (0x1ul << SC_ALTCTL_ADACEN_Pos)                   /*!< SC_T::ALTCTL: ADACEN Mask              */
S
S#define SC_ALTCTL_RXBGTEN_Pos            (12)                                              /*!< SC_T::ALTCTL: RXBGTEN Position         */
S#define SC_ALTCTL_RXBGTEN_Msk            (0x1ul << SC_ALTCTL_RXBGTEN_Pos)                  /*!< SC_T::ALTCTL: RXBGTEN Mask             */
S
S#define SC_ALTCTL_ACTSTS0_Pos            (13)                                              /*!< SC_T::ALTCTL: ACTSTS0 Position         */
S#define SC_ALTCTL_ACTSTS0_Msk            (0x1ul << SC_ALTCTL_ACTSTS0_Pos)                  /*!< SC_T::ALTCTL: ACTSTS0 Mask             */
S
S#define SC_ALTCTL_ACTSTS1_Pos            (14)                                              /*!< SC_T::ALTCTL: ACTSTS1 Position         */
S#define SC_ALTCTL_ACTSTS1_Msk            (0x1ul << SC_ALTCTL_ACTSTS1_Pos)                  /*!< SC_T::ALTCTL: ACTSTS1 Mask             */
S
S#define SC_ALTCTL_ACTSTS2_Pos            (15)                                              /*!< SC_T::ALTCTL: ACTSTS2 Position         */
S#define SC_ALTCTL_ACTSTS2_Msk            (0x1ul << SC_ALTCTL_ACTSTS2_Pos)                  /*!< SC_T::ALTCTL: ACTSTS2 Mask             */
S
S#define SC_ALTCTL_SYNC_Pos               (31)                                              /*!< SC_T::ALTCTL: SYNC Position            */
S#define SC_ALTCTL_SYNC_Msk               (0x1ul << SC_ALTCTL_SYNC_Pos)                     /*!< SC_T::ALTCTL: SYNC Mask                */
S
S#define SC_EGT_EGT_Pos                   (0)                                               /*!< SC_T::EGT: EGT Position                */
S#define SC_EGT_EGT_Msk                   (0xfful << SC_EGT_EGT_Pos)                        /*!< SC_T::EGT: EGT Mask                    */
S
S#define SC_RXTOUT_RFTM_Pos               (0)                                               /*!< SC_T::RXTOUT: RFTM Position            */
S#define SC_RXTOUT_RFTM_Msk               (0x1fful << SC_RXTOUT_RFTM_Pos)                   /*!< SC_T::RXTOUT: RFTM Mask                */
S
S#define SC_ETUCTL_ETURDIV_Pos            (0)                                               /*!< SC_T::ETUCTL: ETURDIV Position         */
S#define SC_ETUCTL_ETURDIV_Msk            (0xffful << SC_ETUCTL_ETURDIV_Pos)                /*!< SC_T::ETUCTL: ETURDIV Mask             */
S
S#define SC_INTEN_RDAIEN_Pos              (0)                                               /*!< SC_T::INTEN: RDAIEN Position           */
S#define SC_INTEN_RDAIEN_Msk              (0x1ul << SC_INTEN_RDAIEN_Pos)                    /*!< SC_T::INTEN: RDAIEN Mask               */
S
S#define SC_INTEN_TXEIEN_Pos              (1)                                               /*!< SC_T::INTEN: TXEIEN Position           */
S#define SC_INTEN_TXEIEN_Msk              (0x1ul << SC_INTEN_TXEIEN_Pos)                    /*!< SC_T::INTEN: TXEIEN Mask               */
S
S#define SC_INTEN_TERRIEN_Pos             (2)                                               /*!< SC_T::INTEN: TERRIEN Position          */
S#define SC_INTEN_TERRIEN_Msk             (0x1ul << SC_INTEN_TERRIEN_Pos)                   /*!< SC_T::INTEN: TERRIEN Mask              */
S
S#define SC_INTEN_TMR0IEN_Pos             (3)                                               /*!< SC_T::INTEN: TMR0IEN Position          */
S#define SC_INTEN_TMR0IEN_Msk             (0x1ul << SC_INTEN_TMR0IEN_Pos)                   /*!< SC_T::INTEN: TMR0IEN Mask              */
S
S#define SC_INTEN_TMR1IEN_Pos             (4)                                               /*!< SC_T::INTEN: TMR1IEN Position          */
S#define SC_INTEN_TMR1IEN_Msk             (0x1ul << SC_INTEN_TMR1IEN_Pos)                   /*!< SC_T::INTEN: TMR1IEN Mask              */
S
S#define SC_INTEN_TMR2IEN_Pos             (5)                                               /*!< SC_T::INTEN: TMR2IEN Position          */
S#define SC_INTEN_TMR2IEN_Msk             (0x1ul << SC_INTEN_TMR2IEN_Pos)                   /*!< SC_T::INTEN: TMR2IEN Mask              */
S
S#define SC_INTEN_BGTIEN_Pos              (6)                                               /*!< SC_T::INTEN: BGTIEN Position           */
S#define SC_INTEN_BGTIEN_Msk              (0x1ul << SC_INTEN_BGTIEN_Pos)                    /*!< SC_T::INTEN: BGTIEN Mask               */
S
S#define SC_INTEN_CDIEN_Pos               (7)                                               /*!< SC_T::INTEN: CDIEN Position            */
S#define SC_INTEN_CDIEN_Msk               (0x1ul << SC_INTEN_CDIEN_Pos)                     /*!< SC_T::INTEN: CDIEN Mask                */
S
S#define SC_INTEN_INITIEN_Pos             (8)                                               /*!< SC_T::INTEN: INITIEN Position          */
S#define SC_INTEN_INITIEN_Msk             (0x1ul << SC_INTEN_INITIEN_Pos)                   /*!< SC_T::INTEN: INITIEN Mask              */
S
S#define SC_INTEN_RXTOIEN_Pos             (9)                                               /*!< SC_T::INTEN: RXTOIEN Position          */
S#define SC_INTEN_RXTOIEN_Msk             (0x1ul << SC_INTEN_RXTOIEN_Pos)                   /*!< SC_T::INTEN: RXTOIEN Mask              */
S
S#define SC_INTEN_ACERRIEN_Pos            (10)                                              /*!< SC_T::INTEN: ACERRIEN Position         */
S#define SC_INTEN_ACERRIEN_Msk            (0x1ul << SC_INTEN_ACERRIEN_Pos)                  /*!< SC_T::INTEN: ACERRIEN Mask             */
S
S#define SC_INTSTS_RDAIF_Pos              (0)                                               /*!< SC_T::INTSTS: RDAIF Position           */
S#define SC_INTSTS_RDAIF_Msk              (0x1ul << SC_INTSTS_RDAIF_Pos)                    /*!< SC_T::INTSTS: RDAIF Mask               */
S
S#define SC_INTSTS_TXEIF_Pos              (1)                                               /*!< SC_T::INTSTS: TXEIF Position           */
S#define SC_INTSTS_TXEIF_Msk              (0x1ul << SC_INTSTS_TXEIF_Pos)                    /*!< SC_T::INTSTS: TXEIF Mask               */
S
S#define SC_INTSTS_TERRIF_Pos             (2)                                               /*!< SC_T::INTSTS: TERRIF Position          */
S#define SC_INTSTS_TERRIF_Msk             (0x1ul << SC_INTSTS_TERRIF_Pos)                   /*!< SC_T::INTSTS: TERRIF Mask              */
S
S#define SC_INTSTS_TMR0IF_Pos             (3)                                               /*!< SC_T::INTSTS: TMR0IF Position          */
S#define SC_INTSTS_TMR0IF_Msk             (0x1ul << SC_INTSTS_TMR0IF_Pos)                   /*!< SC_T::INTSTS: TMR0IF Mask              */
S
S#define SC_INTSTS_TMR1IF_Pos             (4)                                               /*!< SC_T::INTSTS: TMR1IF Position          */
S#define SC_INTSTS_TMR1IF_Msk             (0x1ul << SC_INTSTS_TMR1IF_Pos)                   /*!< SC_T::INTSTS: TMR1IF Mask              */
S
S#define SC_INTSTS_TMR2IF_Pos             (5)                                               /*!< SC_T::INTSTS: TMR2IF Position          */
S#define SC_INTSTS_TMR2IF_Msk             (0x1ul << SC_INTSTS_TMR2IF_Pos)                   /*!< SC_T::INTSTS: TMR2IF Mask              */
S
S#define SC_INTSTS_BGTIF_Pos              (6)                                               /*!< SC_T::INTSTS: BGTIF Position           */
S#define SC_INTSTS_BGTIF_Msk              (0x1ul << SC_INTSTS_BGTIF_Pos)                    /*!< SC_T::INTSTS: BGTIF Mask               */
S
S#define SC_INTSTS_CDIF_Pos               (7)                                               /*!< SC_T::INTSTS: CDIF Position            */
S#define SC_INTSTS_CDIF_Msk               (0x1ul << SC_INTSTS_CDIF_Pos)                     /*!< SC_T::INTSTS: CDIF Mask                */
S
S#define SC_INTSTS_INITIF_Pos             (8)                                               /*!< SC_T::INTSTS: INITIF Position          */
S#define SC_INTSTS_INITIF_Msk             (0x1ul << SC_INTSTS_INITIF_Pos)                   /*!< SC_T::INTSTS: INITIF Mask              */
S
S#define SC_INTSTS_RXTOIF_Pos             (9)                                               /*!< SC_T::INTSTS: RXTOIF Position          */
S#define SC_INTSTS_RXTOIF_Msk             (0x1ul << SC_INTSTS_RXTOIF_Pos)                   /*!< SC_T::INTSTS: RXTOIF Mask              */
S
S#define SC_INTSTS_ACERRIF_Pos            (10)                                              /*!< SC_T::INTSTS: ACERRIF Position         */
S#define SC_INTSTS_ACERRIF_Msk            (0x1ul << SC_INTSTS_ACERRIF_Pos)                  /*!< SC_T::INTSTS: ACERRIF Mask             */
S
S#define SC_STATUS_RXOV_Pos               (0)                                               /*!< SC_T::STATUS: RXOV Position            */
S#define SC_STATUS_RXOV_Msk               (0x1ul << SC_STATUS_RXOV_Pos)                     /*!< SC_T::STATUS: RXOV Mask                */
S
S#define SC_STATUS_RXEMPTY_Pos            (1)                                               /*!< SC_T::STATUS: RXEMPTY Position         */
S#define SC_STATUS_RXEMPTY_Msk            (0x1ul << SC_STATUS_RXEMPTY_Pos)                  /*!< SC_T::STATUS: RXEMPTY Mask             */
S
S#define SC_STATUS_RXFULL_Pos             (2)                                               /*!< SC_T::STATUS: RXFULL Position          */
S#define SC_STATUS_RXFULL_Msk             (0x1ul << SC_STATUS_RXFULL_Pos)                   /*!< SC_T::STATUS: RXFULL Mask              */
S
S#define SC_STATUS_PEF_Pos                (4)                                               /*!< SC_T::STATUS: PEF Position             */
S#define SC_STATUS_PEF_Msk                (0x1ul << SC_STATUS_PEF_Pos)                      /*!< SC_T::STATUS: PEF Mask                 */
S
S#define SC_STATUS_FEF_Pos                (5)                                               /*!< SC_T::STATUS: FEF Position             */
S#define SC_STATUS_FEF_Msk                (0x1ul << SC_STATUS_FEF_Pos)                      /*!< SC_T::STATUS: FEF Mask                 */
S
S#define SC_STATUS_BEF_Pos                (6)                                               /*!< SC_T::STATUS: BEF Position             */
S#define SC_STATUS_BEF_Msk                (0x1ul << SC_STATUS_BEF_Pos)                      /*!< SC_T::STATUS: BEF Mask                 */
S
S#define SC_STATUS_TXOV_Pos               (8)                                               /*!< SC_T::STATUS: TXOV Position            */
S#define SC_STATUS_TXOV_Msk               (0x1ul << SC_STATUS_TXOV_Pos)                     /*!< SC_T::STATUS: TXOV Mask                */
S
S#define SC_STATUS_TXEMPTY_Pos            (9)                                               /*!< SC_T::STATUS: TXEMPTY Position         */
S#define SC_STATUS_TXEMPTY_Msk            (0x1ul << SC_STATUS_TXEMPTY_Pos)                  /*!< SC_T::STATUS: TXEMPTY Mask             */
S
S#define SC_STATUS_TXFULL_Pos             (10)                                              /*!< SC_T::STATUS: TXFULL Position          */
S#define SC_STATUS_TXFULL_Msk             (0x1ul << SC_STATUS_TXFULL_Pos)                   /*!< SC_T::STATUS: TXFULL Mask              */
S
S#define SC_STATUS_CREMOVE_Pos            (11)                                              /*!< SC_T::STATUS: CREMOVE Position         */
S#define SC_STATUS_CREMOVE_Msk            (0x1ul << SC_STATUS_CREMOVE_Pos)                  /*!< SC_T::STATUS: CREMOVE Mask             */
S
S#define SC_STATUS_CINSERT_Pos            (12)                                              /*!< SC_T::STATUS: CINSERT Position         */
S#define SC_STATUS_CINSERT_Msk            (0x1ul << SC_STATUS_CINSERT_Pos)                  /*!< SC_T::STATUS: CINSERT Mask             */
S
S#define SC_STATUS_CDPINSTS_Pos           (13)                                              /*!< SC_T::STATUS: CDPINSTS Position        */
S#define SC_STATUS_CDPINSTS_Msk           (0x1ul << SC_STATUS_CDPINSTS_Pos)                 /*!< SC_T::STATUS: CDPINSTS Mask            */
S
S#define SC_STATUS_RXPOINT_Pos            (16)                                              /*!< SC_T::STATUS: RXPOINT Position         */
S#define SC_STATUS_RXPOINT_Msk            (0x7ul << SC_STATUS_RXPOINT_Pos)                  /*!< SC_T::STATUS: RXPOINT Mask             */
S
S#define SC_STATUS_RXRTYERR_Pos           (21)                                              /*!< SC_T::STATUS: RXRTYERR Position        */
S#define SC_STATUS_RXRTYERR_Msk           (0x1ul << SC_STATUS_RXRTYERR_Pos)                 /*!< SC_T::STATUS: RXRTYERR Mask            */
S
S#define SC_STATUS_RXOVERR_Pos            (22)                                              /*!< SC_T::STATUS: RXOVERR Position         */
S#define SC_STATUS_RXOVERR_Msk            (0x1ul << SC_STATUS_RXOVERR_Pos)                  /*!< SC_T::STATUS: RXOVERR Mask             */
S
S#define SC_STATUS_RXACT_Pos              (23)                                              /*!< SC_T::STATUS: RXACT Position           */
S#define SC_STATUS_RXACT_Msk              (0x1ul << SC_STATUS_RXACT_Pos)                    /*!< SC_T::STATUS: RXACT Mask               */
S
S#define SC_STATUS_TXPOINT_Pos            (24)                                              /*!< SC_T::STATUS: TXPOINT Position         */
S#define SC_STATUS_TXPOINT_Msk            (0x7ul << SC_STATUS_TXPOINT_Pos)                  /*!< SC_T::STATUS: TXPOINT Mask             */
S
S#define SC_STATUS_TXRTYERR_Pos           (29)                                              /*!< SC_T::STATUS: TXRTYERR Position        */
S#define SC_STATUS_TXRTYERR_Msk           (0x1ul << SC_STATUS_TXRTYERR_Pos)                 /*!< SC_T::STATUS: TXRTYERR Mask            */
S
S#define SC_STATUS_TXOVERR_Pos            (30)                                              /*!< SC_T::STATUS: TXOVERR Position         */
S#define SC_STATUS_TXOVERR_Msk            (0x1ul << SC_STATUS_TXOVERR_Pos)                  /*!< SC_T::STATUS: TXOVERR Mask             */
S
S#define SC_STATUS_TXACT_Pos              (31)                                              /*!< SC_T::STATUS: TXACT Position           */
S#define SC_STATUS_TXACT_Msk              (0x1ul << SC_STATUS_TXACT_Pos)                    /*!< SC_T::STATUS: TXACT Mask               */
S
S#define SC_PINCTL_PWREN_Pos              (0)                                               /*!< SC_T::PINCTL: PWREN Position           */
S#define SC_PINCTL_PWREN_Msk              (0x1ul << SC_PINCTL_PWREN_Pos)                    /*!< SC_T::PINCTL: PWREN Mask               */
S
S#define SC_PINCTL_SCRST_Pos              (1)                                               /*!< SC_T::PINCTL: SCRST Position           */
S#define SC_PINCTL_SCRST_Msk              (0x1ul << SC_PINCTL_SCRST_Pos)                    /*!< SC_T::PINCTL: SCRST Mask               */
S
S#define SC_PINCTL_CLKKEEP_Pos            (6)                                               /*!< SC_T::PINCTL: CLKKEEP Position         */
S#define SC_PINCTL_CLKKEEP_Msk            (0x1ul << SC_PINCTL_CLKKEEP_Pos)                  /*!< SC_T::PINCTL: CLKKEEP Mask             */
S
S#define SC_PINCTL_SCDATA_Pos             (9)                                               /*!< SC_T::PINCTL: SCDATA Position          */
S#define SC_PINCTL_SCDATA_Msk             (0x1ul << SC_PINCTL_SCDATA_Pos)                   /*!< SC_T::PINCTL: SCDATA Mask              */
S
S#define SC_PINCTL_PWRINV_Pos             (11)                                              /*!< SC_T::PINCTL: PWRINV Position          */
S#define SC_PINCTL_PWRINV_Msk             (0x1ul << SC_PINCTL_PWRINV_Pos)                   /*!< SC_T::PINCTL: PWRINV Mask              */
S
S#define SC_PINCTL_DATSTS_Pos             (16)                                              /*!< SC_T::PINCTL: DATSTS Position          */
S#define SC_PINCTL_DATSTS_Msk             (0x1ul << SC_PINCTL_DATSTS_Pos)                   /*!< SC_T::PINCTL: DATSTS Mask              */
S
S#define SC_PINCTL_PWRSTS_Pos             (17)                                              /*!< SC_T::PINCTL: PWRSTS Position          */
S#define SC_PINCTL_PWRSTS_Msk             (0x1ul << SC_PINCTL_PWRSTS_Pos)                   /*!< SC_T::PINCTL: PWRSTS Mask              */
S
S#define SC_PINCTL_RSTSTS_Pos             (18)                                              /*!< SC_T::PINCTL: RSTSTS Position          */
S#define SC_PINCTL_RSTSTS_Msk             (0x1ul << SC_PINCTL_RSTSTS_Pos)                   /*!< SC_T::PINCTL: RSTSTS Mask              */
S
S#define SC_PINCTL_SYNC_Pos               (30)                                              /*!< SC_T::PINCTL: SYNC Position            */
S#define SC_PINCTL_SYNC_Msk               (0x1ul << SC_PINCTL_SYNC_Pos)                     /*!< SC_T::PINCTL: SYNC Mask                */
S
S#define SC_TMRCTL0_CNT_Pos               (0)                                               /*!< SC_T::TMRCTL0: CNT Position            */
S#define SC_TMRCTL0_CNT_Msk               (0xfffffful << SC_TMRCTL0_CNT_Pos)                /*!< SC_T::TMRCTL0: CNT Mask                */
S
S#define SC_TMRCTL0_OPMODE_Pos            (24)                                              /*!< SC_T::TMRCTL0: OPMODE Position         */
S#define SC_TMRCTL0_OPMODE_Msk            (0xful << SC_TMRCTL0_OPMODE_Pos)                  /*!< SC_T::TMRCTL0: OPMODE Mask             */
S
S#define SC_TMRCTL0_SYNC_Pos              (31)                                              /*!< SC_T::TMRCTL0: SYNC Position           */
S#define SC_TMRCTL0_SYNC_Msk              (0x1ul << SC_TMRCTL0_SYNC_Pos)                    /*!< SC_T::TMRCTL0: SYNC Mask               */
S
S#define SC_TMRCTL1_CNT_Pos               (0)                                               /*!< SC_T::TMRCTL1: CNT Position            */
S#define SC_TMRCTL1_CNT_Msk               (0xfful << SC_TMRCTL1_CNT_Pos)                    /*!< SC_T::TMRCTL1: CNT Mask                */
S
S#define SC_TMRCTL1_OPMODE_Pos            (24)                                              /*!< SC_T::TMRCTL1: OPMODE Position         */
S#define SC_TMRCTL1_OPMODE_Msk            (0xful << SC_TMRCTL1_OPMODE_Pos)                  /*!< SC_T::TMRCTL1: OPMODE Mask             */
S
S#define SC_TMRCTL1_SYNC_Pos              (31)                                              /*!< SC_T::TMRCTL1: SYNC Position           */
S#define SC_TMRCTL1_SYNC_Msk              (0x1ul << SC_TMRCTL1_SYNC_Pos)                    /*!< SC_T::TMRCTL1: SYNC Mask               */
S
S#define SC_TMRCTL2_CNT_Pos               (0)                                               /*!< SC_T::TMRCTL2: CNT Position            */
S#define SC_TMRCTL2_CNT_Msk               (0xfful << SC_TMRCTL2_CNT_Pos)                    /*!< SC_T::TMRCTL2: CNT Mask                */
S
S#define SC_TMRCTL2_OPMODE_Pos            (24)                                              /*!< SC_T::TMRCTL2: OPMODE Position         */
S#define SC_TMRCTL2_OPMODE_Msk            (0xful << SC_TMRCTL2_OPMODE_Pos)                  /*!< SC_T::TMRCTL2: OPMODE Mask             */
S
S#define SC_TMRCTL2_SYNC_Pos              (31)                                              /*!< SC_T::TMRCTL2: SYNC Position           */
S#define SC_TMRCTL2_SYNC_Msk              (0x1ul << SC_TMRCTL2_SYNC_Pos)                    /*!< SC_T::TMRCTL2: SYNC Mask               */
S
S#define SC_UARTCTL_UARTEN_Pos            (0)                                               /*!< SC_T::UARTCTL: UARTEN Position         */
S#define SC_UARTCTL_UARTEN_Msk            (0x1ul << SC_UARTCTL_UARTEN_Pos)                  /*!< SC_T::UARTCTL: UARTEN Mask             */
S
S#define SC_UARTCTL_WLS_Pos               (4)                                               /*!< SC_T::UARTCTL: WLS Position            */
S#define SC_UARTCTL_WLS_Msk               (0x3ul << SC_UARTCTL_WLS_Pos)                     /*!< SC_T::UARTCTL: WLS Mask                */
S
S#define SC_UARTCTL_PBOFF_Pos             (6)                                               /*!< SC_T::UARTCTL: PBOFF Position          */
S#define SC_UARTCTL_PBOFF_Msk             (0x1ul << SC_UARTCTL_PBOFF_Pos)                   /*!< SC_T::UARTCTL: PBOFF Mask              */
S
S#define SC_UARTCTL_OPE_Pos               (7)                                               /*!< SC_T::UARTCTL: OPE Position            */
S#define SC_UARTCTL_OPE_Msk               (0x1ul << SC_UARTCTL_OPE_Pos)                     /*!< SC_T::UARTCTL: OPE Mask                */
S
S#define SC_TMRDAT0_CNT0_Pos              (0)                                               /*!< SC_T::TMRDAT0: CNT0 Position           */
S#define SC_TMRDAT0_CNT0_Msk              (0xfffffful << SC_TMRDAT0_CNT0_Pos)               /*!< SC_T::TMRDAT0: CNT0 Mask               */
S
S#define SC_TMRDAT12_CNT1_Pos             (0)                                               /*!< SC_T::TMRDAT12: CNT1 Position          */
S#define SC_TMRDAT12_CNT1_Msk             (0xfful << SC_TMRDAT12_CNT1_Pos)                  /*!< SC_T::TMRDAT12: CNT1 Mask              */
S
S#define SC_TMRDAT12_CNT2_Pos             (8)                                               /*!< SC_T::TMRDAT12: CNT2 Position          */
S#define SC_TMRDAT12_CNT2_Msk             (0xfful << SC_TMRDAT12_CNT2_Pos)                  /*!< SC_T::TMRDAT12: CNT2 Mask              */
S
S#define SC_ACTCTL_T1EXT_Pos              (0)                                               /*!< SC_T::ACTCTL: T1EXT Position           */
S#define SC_ACTCTL_T1EXT_Msk              (0x1ful << SC_ACTCTL_T1EXT_Pos)                   /*!< SC_T::ACTCTL: T1EXT Mask               */
S
S/**@}*/ /* SC_CONST */
S/**@}*/ /* end of SC register group */
S
S
S/*---------------------- Serial Peripheral Interface Controller -------------------------*/
S/**
S    @addtogroup SPI Serial Peripheral Interface Controller(SPI)
S    Memory Mapped Structure for SPI Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var SPI_T::CTL
S     * Offset: 0x00  SPI Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SPIEN     |SPI Transfer Control Enable Bit
S     * |        |          |In Master mode, the transfer will start when there is data in the FIFO buffer after this bit is set to 1
S     * |        |          |In Slave mode, this device is ready to receive data when this bit is set to 1.
S     * |        |          |0 = Transfer control Disabled.
S     * |        |          |1 = Transfer control Enabled.
S     * |        |          |Note: Before changing the configurations of SPIx_CTL, SPIx_CLKDIV, SPIx_SSCTL and SPIx_FIFOCTL registers, user shall clear the SPIEN (SPIx_CTL[0]) and confirm the SPIENSTS (SPIx_STATUS[15]) is 0.
S     * |[1]     |RXNEG     |Receive on Negative Edge
S     * |        |          |0 = Received data input signal is latched on the rising edge of SPI bus clock.
S     * |        |          |1 = Received data input signal is latched on the falling edge of SPI bus clock.
S     * |[2]     |TXNEG     |Transmit on Negative Edge
S     * |        |          |0 = Transmitted data output signal is changed on the rising edge of SPI bus clock.
S     * |        |          |1 = Transmitted data output signal is changed on the falling edge of SPI bus clock.
S     * |[3]     |CLKPOL    |Clock Polarity
S     * |        |          |0 = SPI bus clock is idle low.
S     * |        |          |1 = SPI bus clock is idle high.
S     * |[7:4]   |SUSPITV   |Suspend Interval (Master Only)
S     * |        |          |The four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer
S     * |        |          |The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word and the first clock edge of the following transaction word
S     * |        |          |The default value is 0x3
S     * |        |          |The period of the suspend interval is obtained according to the following equation.
S     * |        |          |(SUSPITV[3:0] + 0.5) * period of SPICLK clock cycle
S     * |        |          |Example:
S     * |        |          |SUSPITV = 0x0 u2026. 0.5 SPICLK clock cycle.
S     * |        |          |SUSPITV = 0x1 u2026. 1.5 SPICLK clock cycle.
S     * |        |          |u2026u2026
S     * |        |          |SUSPITV = 0xE u2026. 14.5 SPICLK clock cycle.
S     * |        |          |SUSPITV = 0xF u2026. 15.5 SPICLK clock cycle.
S     * |[12:8]  |DWIDTH    |Data Width
S     * |        |          |This field specifies how many bits can be transmitted / received in one transaction
S     * |        |          |The minimum bit length is 8 bits and can up to 32 bits.
S     * |        |          |DWIDTH = 0x08 u2026. 8 bits.
S     * |        |          |DWIDTH = 0x09 u2026. 9 bits.
S     * |        |          |u2026u2026
S     * |        |          |DWIDTH = 0x1F u2026. 31 bits.
S     * |        |          |DWIDTH = 0x00 u2026. 32 bits.
S     * |[13]    |LSB       |Send LSB First
S     * |        |          |0 = The MSB, which bit of transmit/receive register depends on the setting of DWIDTH, is transmitted/received first.
S     * |        |          |1 = The LSB, bit 0 of the SPI TX register, is sent first to the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the RX register (bit 0 of SPI_RX).
S     * |[14]    |HALFDPX   |SPI Half-duplex duplex TRANSMISSION Transfer Enable Bit
S     * |        |          |This bit is used to select full-duplex or half-duplex for SPI transmissiontransfer
S     * |        |          |The bit field DATDIR (SPIx_CTL[20]) can be used to set the data direction while in half-duplex transmissiontransfer.
S     * |        |          |0 = SPI operates in full-duplex transmissiontransfer.
S     * |        |          |1 = SPI operates in half-duplex transmissiontransfer.
S     * |[15]    |RXONLY    |Receive-only FUNCTION Mode Enable Bit (Master Only)
S     * |        |          |This bit field is only available in Master mode
S     * |        |          |In receive-only mode, SPI Master will generate SPI bus clock continuously for receiving data bit from SPI slave device and assert the BUSY status
S     * |        |          |If both AUTOSS (SPI_SSCTL[3]) and RXONLY are enabled, the output slave select signal will be activated.
S     * |        |          |0 = Receive-only function mode Disabled.
S     * |        |          |1 = Receive-only functionmode Enabled.
S     * |        |          |Note: We suggest users switch to receive-only mode when BUSY (SPI_STATUS[0]) is low.
S     * |[17]    |UNITIEN   |Unit Transfer Interrupt Enable Bit
S     * |        |          |0 = SPI unit transfer interrupt Disabled.
S     * |        |          |1 = SPI unit transfer interrupt Enabled.
S     * |[18]    |SLAVE     |Slave Mode Control
S     * |        |          |0 = Master mode.
S     * |        |          |1 = Slave mode.
S     * |[19]    |REORDER   |Byte Reorder Function Enable Bit
S     * |        |          |0 = Byte Reorder function Disabled.
S     * |        |          |1 = Byte Reorder function Enabled
S     * |        |          |A byte suspend interval will be inserted among each byte
S     * |        |          |The period of the byte suspend interval depends on the setting of SUSPITV.
S     * |        |          |Note:
S     * |        |          |Byte Reorder function is only available if DWIDTH is defined as 16, 24, and 32 bits.
S     * |        |          |Byte Reorder function is not supported when the Quad or Dual I/O mode is enabled.
S     * |[20]    |DATDIR    |Data Port Direction Control
S     * |        |          |This bit is used to select the data input/output direction while in half-duplex transfer.ransmission.
S     * |        |          |0 = SPI data is input direction.
S     * |        |          |1 = SPI data is output direction.
S     * @var SPI_T::CLKDIV
S     * Offset: 0x04  SPI Clock Divider Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |DIVIDER   |Clock Divider
S     * |        |          |The value in this field is the frequency divider for generating the peripheral clock, fspi_eclk, and the SPI bus clock of SPI Master
S     * |        |          |The frequency is obtained according to the following equation.
S     * |        |          |where
S     * |        |          |is the peripheral clock source, which is defined in the clock control register, CLK_CLKSEL2.
S     * |        |          |Note: Not supported in I2S mode.
S     * @var SPI_T::SSCTL
S     * Offset: 0x08  SPI Slave Select Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SS        |Slave Selection Control (Master Only)
S     * |        |          |If AUTOSS bit is cleared to 0,
S     * |        |          |0 = set the SPIx_SS line to inactive state.
S     * |        |          |1 = set the SPIx_SS line to active state.
S     * |        |          |If the AUTOSS bit is set to 1,
S     * |        |          |0 = Keep the SPIx_SS line at inactive state.
S     * |        |          |1 = SPIx_SS line will be automatically driven to active state for the duration of data transfer, and will be driven to inactive state for the rest of the time
S     * |        |          |The active state of SPIx_SS is specified in SSACTPOL (SPIx_SSCTL[2]).
S     * |[2]     |SSACTPOL  |Slave Selection Active Polarity
S     * |        |          |This bit defines the active polarity of slave selection signal (SPIx_SS).
S     * |        |          |0 = The slave selection signal SPIx_SS is active low.
S     * |        |          |1 = The slave selection signal SPIx_SS is active high.
S     * |[3]     |AUTOSS    |Automatic Slave Selection Function Enable Bit (Master Only)
S     * |        |          |0 = Automatic slave selection function Disabled
S     * |        |          |Slave selection signal will be asserted/de-asserted according to SS (SPIx_SSCTL[0]).
S     * |        |          |1 = Automatic slave selection function Enabled.
S     * |[8]     |SLVBEIEN  |Slave Mode Bit Count Error Interrupt Enable Bit
S     * |        |          |0 = Slave mode bit count error interrupt Disabled.
S     * |        |          |1 = Slave mode bit count error interrupt Enabled.
S     * |[9]     |SLVURIEN  |Slave Mode TX Under Run Interrupt Enable Bit
S     * |        |          |0 = Slave mode TX under run interrupt Disabled.
S     * |        |          |1 = Slave mode TX under run interrupt Enabled.
S     * |[12]    |SSACTIEN  |Slave Select Active Interrupt Enable Bit
S     * |        |          |0 = Slave select active interrupt Disabled.
S     * |        |          |1 = Slave select active interrupt Enabled.
S     * |[13]    |SSINAIEN  |Slave Select Inactive Interrupt Enable Bit
S     * |        |          |0 = Slave select inactive interrupt Disabled.
S     * |        |          |1 = Slave select inactive interrupt Enabled.
S     * @var SPI_T::PDMACTL
S     * Offset: 0x0C  SPI PDMA Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TXPDMAEN  |Transmit PDMA Enable Bit
S     * |        |          |0 = Transmit PDMA function Disabled.
S     * |        |          |1 = Transmit PDMA function Enabled.
S     * |        |          |Note: In SPI Master mode with full duplex transfer, if both TX and RX PDMA functions are enabled, RX PDMA function cannot be enabled prior to TX PDMA function
S     * |        |          |User can enable TX PDMA function firstly or enable both functions simultaneously.
S     * |[1]     |RXPDMAEN  |Receive PDMA Enable Bit
S     * |        |          |0 = Receiver PDMA function Disabled.
S     * |        |          |1 = Receiver PDMA function Enabled.
S     * |[2]     |PDMARST   |PDMA Reset
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset the PDMA control logic of the SPI controller. This bit will be automatically cleared to 0.
S     * @var SPI_T::FIFOCTL
S     * Offset: 0x10  SPI FIFO Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RXRST     |Receive Reset
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset receive FIFO pointer and receive circuit
S     * |        |          |The RXFULL bit will be cleared to 0 and the RXEMPTY bit will be set to 1
S     * |        |          |This bit will be cleared to 0 by hardware about 3 system clock cycles + 2 peripheral clock cycles after it is set to 1
S     * |        |          |User can read TXRXRST (SPIx_STATUS[23]) to check if reset is accomplished or not.
S     * |        |          |Note: If there is slave receive time-out event, the RXRST will be set 1 when the SLVTORST (SPI_SSCTL[6]) is enabled.
S     * |[1]     |TXRST     |Transmit Reset
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset transmit FIFO pointer and transmit circuit
S     * |        |          |The TXFULL bit will be cleared to 0 and the TXEMPTY bit will be set to 1
S     * |        |          |This bit will be cleared to 0 by hardware about 3 system clock cycles + 2 peripheral clock cycles after it is set to 1
S     * |        |          |User can read TXRXRST (SPIx_STATUS[23]) to check if reset is accomplished or not.
S     * |        |          |Note: If TX under-runflow event occurs in SPI Slave mode, this bit can be used to make SPI return to idle state.Note: If there is slave receive time-out event, the TXRST will be set to 1 when the SLVTORST (SPI_SSCTL[6]) is enabled.
S     * |[2]     |RXTHIEN   |Receive FIFO Threshold Interrupt Enable Bit
S     * |        |          |0 = RX FIFO threshold interrupt Disabled.
S     * |        |          |1 = RX FIFO threshold interrupt Enabled.
S     * |[3]     |TXTHIEN   |Transmit FIFO Threshold Interrupt Enable Bit
S     * |        |          |0 = TX FIFO threshold interrupt Disabled.
S     * |        |          |1 = TX FIFO threshold interrupt Enabled.
S     * |[4]     |RXTOIEN   |Slave Receive Time-out Interrupt Enable Bit
S     * |        |          |0 = Receive time-out interrupt Disabled.
S     * |        |          |1 = Receive time-out interrupt Enabled.
S     * |[5]     |RXOVIEN   |Receive FIFO Overrun Interrupt Enable Bit
S     * |        |          |0 = Receive FIFO overrun interrupt Disabled.
S     * |        |          |1 = Receive FIFO overrun interrupt Enabled.
S     * |[6]     |TXUFPOL   |TX Underflow Data Polarity
S     * |        |          |0 = The SPI data out is keep 0 if there is TX underflow event in Slave mode.
S     * |        |          |1 = The SPI data out is keep 1 if there is TX underflow event in Slave mode.
S     * |        |          |Note:
S     * |        |          |1
S     * |        |          |The TX underflow event occurs if there is not any data in TX FIFO when the slave selection signal is active.
S     * |        |          |2. This bit should be set as 0 in I2S mode.
S     * |        |          |3
S     * |        |          |When TX underflow event occurs, SPIx_MISO pin state will be determined by this setting even though TX FIFO is not empty afterward
S     * |        |          |Data stored in TX FIFO will be sent through SPIx_MISO pin in the next transfer frame.
S     * |[7]     |TXUFIEN   |TX Underflow Interrupt Enable Bit
S     * |        |          |0 = Slave TX underflow interrupt Disabled.
S     * |        |          |1 = Slave TX underflow interrupt Enabled.
S     * |[8]     |RXFBCLR   |Receive FIFO Buffer Clear
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear receive FIFO pointer
S     * |        |          |The RXFULL bit will be cleared to 0 and the RXEMPTY bit will be set to 1
S     * |        |          |This bit will be cleared to 0 by hardware about 1 system clock after it is set to 1.
S     * |        |          |Note: The RX shift register will not be cleared.
S     * |[9]     |TXFBCLR   |Transmit FIFO Buffer Clear
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear transmit FIFO pointer
S     * |        |          |The TXFULL bit will be cleared to 0 and the TXEMPTY bit will be set to 1
S     * |        |          |This bit will be cleared to 0 by hardware about 1 system clock after it is set to 1.
S     * |        |          |Note: The TX shift register will not be cleared.
S     * |[25:24] |RXTH      |Receive FIFO Threshold
S     * |        |          |If the valid data count of the receive FIFO buffer is larger than the RXTH setting, the RXTHIF bit will be set to 1, else the RXTHIF bit will be cleared to 0
S     * |[29:28] |TXTH      |Transmit FIFO Threshold
S     * |        |          |If the valid data count of the transmit FIFO buffer is less than or equal to the TXTH setting, the TXTHIF bit will be set to 1, else the TXTHIF bit will be cleared to 0.
S     * @var SPI_T::STATUS
S     * Offset: 0x14  SPI Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |BUSY      |Busy Status (Read Only)
S     * |        |          |0 = SPI controller is in idle state.
S     * |        |          |1 = SPI controller is in busy state.
S     * |        |          |The following listing are the bus busy conditions:
S     * |        |          |a. SPIx_CTL[0] = 1 and the TXEMPTY = 0.
S     * |        |          |b
S     * |        |          |For SPI Master mode, SPIx_CTL[0] = 1 and the TXEMPTY = 1 but the current transaction is not finished yet.
S     * |        |          |c. For SPI Master mode, SPIx_CTL[0] = 1 and RXONLY = 1.
S     * |        |          |d
S     * |        |          |For SPI Slave mode, the SPIx_CTL[0] = 1 and there is serial clock input into the SPI core logic when slave select is active.
S     * |        |          |For SPI Slave mode, the SPIx_CTL[0] = 1 and the transmit buffer or transmit shift register is not empty even if the slave select is inactive.
S     * |[1]     |UNITIF    |Unit Transfer Interrupt Flag
S     * |        |          |0 = No transaction has been finished since this bit was cleared to 0.
S     * |        |          |1 = SPI controller has finished one unit transfer.
S     * |        |          |Note: This bit will be cleared by writing 1 to it.
S     * |[2]     |SSACTIF   |Slave Select Active Interrupt Flag
S     * |        |          |0 = Slave select active interrupt was cleared or not occurred.
S     * |        |          |1 = Slave select active interrupt event occurred.
S     * |        |          |Note: Only available in Slave mode. This bit will be cleared by writing 1 to it.
S     * |[3]     |SSINAIF   |Slave Select Inactive Interrupt Flag
S     * |        |          |0 = Slave select inactive interrupt was cleared or not occurred.
S     * |        |          |1 = Slave select inactive interrupt event occurred.
S     * |        |          |Note: Only available in Slave mode. This bit will be cleared by writing 1 to it.
S     * |[4]     |SSLINE    |Slave Select Line Bus Status (Read Only)
S     * |        |          |0 = The slave select line status is 0.
S     * |        |          |1 = The slave select line status is 1.
S     * |        |          |Note: This bit is only available in Slave mode
S     * |        |          |If SSACTPOL (SPIx_SSCTL[2]) is set 0, and the SSLINE is 1, the SPI slave select is in inactive status.
S     * |[6]     |SLVBEIF   |Slave Mode Bit Count Error Interrupt Flag
S     * |        |          |In Slave mode, when the slave select line goes to inactive state, if bit counter is mismatch with DWIDTH, this interrupt flag will be set to 1.
S     * |        |          |0 = No Slave mode bit count error event.
S     * |        |          |1 = Slave mode bit count error event occurs.
S     * |        |          |Note: If the slave select active but there is no any bus clock input, the SLVBCEEIF also active when the slave select goes to inactive state
S     * |        |          |This bit will be cleared by writing 1 to it.
S     * |[7]     |SLVURIF   |Slave Mode TX Under Run Interrupt Flag
S     * |        |          |In Slave mode, if TX underflow event occurs and the slave select line goes to inactive state, this interrupt flag will be set to 1.
S     * |        |          |0 = No Slave TX under run event.
S     * |        |          |1 = Slave TX under run event occurs.
S     * |        |          |Note: This bit will be cleared by writing 1 to it.
S     * |[8]     |RXEMPTY   |Receive FIFO Buffer Empty Indicator (Read Only)
S     * |        |          |0 = Receive FIFO buffer is not empty.
S     * |        |          |1 = Receive FIFO buffer is empty.
S     * |[9]     |RXFULL    |Receive FIFO Buffer Full Indicator (Read Only)
S     * |        |          |0 = Receive FIFO buffer is not full.
S     * |        |          |1 = Receive FIFO buffer is full.
S     * |[10]    |RXTHIF    |Receive FIFO Threshold Interrupt Flag (Read Only)
S     * |        |          |0 = The valid data count within the RXreceive FIFO buffer is smaller than or equal to the setting value of RXTH.
S     * |        |          |1 = The valid data count within the receive FIFO buffer is larger than the setting value of RXTH.
S     * |[11]    |RXOVIF    |Receive FIFO Overrun Interrupt Flag
S     * |        |          |When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.
S     * |        |          |0 = No FIFO is over run.
S     * |        |          |1 = Receive FIFO is over run.
S     * |        |          |Note: This bit will be cleared by writing 1 to it.
S     * |[12]    |RXTOIF    |Receive Time-out Interrupt Flag
S     * |        |          |0 = No receive FIFO time-out event.
S     * |        |          |1 = Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI peripheral clock periods in Master mode or over 576 SPI peripheral clock periods in Slave mode
S     * |        |          |When the received FIFO buffer is read by software, the time-out status will be cleared automatically.
S     * |        |          |Note: This bit will be cleared by writing 1 to it.
S     * |[15]    |SPIENSTS  |SPI Enable Status (Read Only)
S     * |        |          |0 = The SPI controller is disabled.
S     * |        |          |1 = The SPI controller is enabled.
S     * |        |          |Note: The SPI peripheral clock is asynchronous with the system clock
S     * |        |          |In order to make sure the SPI control logic is disabled, this bit indicates the real status of SPI controller.
S     * |[16]    |TXEMPTY   |Transmit FIFO Buffer Empty Indicator (Read Only)
S     * |        |          |0 = Transmit FIFO buffer is not empty.
S     * |        |          |1 = Transmit FIFO buffer is empty.
S     * |[17]    |TXFULL    |Transmit FIFO Buffer Full Indicator (Read Only)
S     * |        |          |0 = Transmit FIFO buffer is not full.
S     * |        |          |1 = Transmit FIFO buffer is full.
S     * |[18]    |TXTHIF    |Transmit FIFO Threshold Interrupt Flag (Read Only)
S     * |        |          |0 = The valid data count within the transmit FIFO buffer is larger than the setting value of TXTH.
S     * |        |          |1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TXTH.
S     * |[19]    |TXUFIF    |TX Underflow Interrupt Flag
S     * |        |          |When the TX underflow event occurs, this bit will be set to 1, the state of data output pin depends on the setting of TXUFPOL.
S     * |        |          |0 = No effect.
S     * |        |          |1 = No data in Transmit FIFO and TX shift register when the slave selection signal is active.
S     * |        |          |Note 1: This bit will be cleared by writing 1 to it.
S     * |        |          |Note 2: If reset slaveu2019s transmission circuit when slave selection signal is active, this flag will be set to 1 after 2 peripheral clock cycles + 3 system clock cycles since the reset operation is done.
S     * |[23]    |TXRXRST   |TX or RX Reset Status (Read Only)
S     * |        |          |0 = The reset function of TXRST or RXRST is done.
S     * |        |          |1 = Doing the reset function of TXRST or RXRST.
S     * |        |          |Note: Both the reset operations of TXRST and RXRST need 3 system clock cycles + 2 peripheral clock cycles
S     * |        |          |User can check the status of this bit to monitor the reset function is doing or done.
S     * |[27:24] |RXCNT     |Receive FIFO Data Count (Read Only)
S     * |        |          |This bit field indicates the valid data count of receive FIFO buffer.
S     * |[31:28] |TXCNT     |Transmit FIFO Data Count (Read Only)
S     * |        |          |This bit field indicates the valid data count of transmit FIFO buffer.
S     * @var SPI_T::TX
S     * Offset: 0x20  SPI Data Transmit Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |TX        |Data Transmit Register
S     * |        |          |The data transmit registers pass through the transmitted data into the 4-level transmit FIFO buffers
S     * |        |          |The number of valid bits depends on the setting of DWIDTH (SPIx_CTL[12:8]) in SPI mode or WDWIDTH (SPIx_I2SCTL[5:4]) in I2S mode.
S     * |        |          |For exampleIn SPI mode, if DWIDTH is set to 0x08, the bits TX[7:0] will be transmitted
S     * |        |          |If DWIDTH is set to 0x00 , the SPI controller will perform a 32-bit transfer.
S     * |        |          |In I2S mode, if WDWIDTH (SPIx_I2SCTL[5:4]) is set to 0x2, the data width of audio channel is 24-bit and corresponding to TX[243:0]
S     * |        |          |If WDWIDTH is set as 0x0, 0x1, or 0x3, all bits of this field are valid and referred to the data arrangement in I2S mode FIFO operation section
S     * |        |          |Note: In Master mode, SPI controller will start to transfer the SPI bus clock after 1 APB clock and 6 peripheral clock cycles after user writes to this register.
S     * @var SPI_T::RX
S     * Offset: 0x30  SPI Data Receive Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |RX        |Data Receive Register
S     * |        |          |There are 8-/4-level FIFO buffers in this controller
S     * |        |          |The data receive register holds the data received from SPI data input pin
S     * |        |          |If the RXEMPTY (SPIx_STATUS[8] or SPIx_I2SSTS[8]) is not set to 1, the receive FIFO buffers can be accessed through software by reading this register
S     * |        |          |This is a read only register.
S     * @var SPI_T::I2SCTL
S     * Offset: 0x60  I2S Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |I2SEN     |I2S Controller Enable Bit
S     * |        |          |0 = Disabled I2S mode.
S     * |        |          |1 = Enabled I2S mode.
S     * |        |          |Note:
S     * |        |          |1. If enable this bit, I2Sx_BCLK will start to output in master Master mode.
S     * |        |          |2
S     * |        |          |Before changing the configurations of SPIx_I2SCTL, SPIx_I2SCLK, and SPIx_FIFOCTL registers, user shall clear the I2SEN (SPIx_I2SCTL[0]) and confirm the I2SENSTS (SPIx_I2SSTS[15]) is 0.
S     * |[1]     |TXEN      |Transmit Enable Bit
S     * |        |          |0 = Data transmit Disabled.
S     * |        |          |1 = Data transmit Enabled.
S     * |[2]     |RXEN      |Receive Enable Bit
S     * |        |          |0 = Data receiving receive Disabled.
S     * |        |          |1 = Data receiving receive Enabled.
S     * |[3]     |MUTE      |Transmit Mute Enable Bit
S     * |        |          |0 = Transmit data is shifted from buffer.
S     * |        |          |1 = Transmit channel zero.
S     * |[5:4]   |WDWIDTH   |Word Width
S     * |        |          |00 = data size is 8-bit.
S     * |        |          |01 = data size is 16-bit.
S     * |        |          |10 = data size is 24-bit.
S     * |        |          |11 = data size is 32-bit.
S     * |[6]     |MONO      |Monaural Data
S     * |        |          |0 = Data is stereo format.
S     * |        |          |1 = Data is monaural format.
S     * |[7]     |ORDER     |Stereo Data Order in FIFO
S     * |        |          |0 = Left channel data at high byte.
S     * |        |          |1 = Left channel data at low byte.
S     * |[8]     |SLAVE     |Slave Mode
S     * |        |          |I2S can operate as master or slave
S     * |        |          |For Master mode, I2Sx_BCLK and I2Sx_LRCLK pins are output mode and send bit clock from NuMicrou00AEu00E4 NUC200 NUC029xGE series to Audio audio CODEC chip
S     * |        |          |In Slave mode, I2Sx_BCLK and I2Sx_LRCLK pins are input mode and I2Sx_BCLK and I2Sx_LRCLK signals are received from outer Audio audio CODEC chip.
S     * |        |          |0 = Master mode.
S     * |        |          |1 = Slave mode.
S     * |[15]    |MCLKEN    |Master Clock Enable Bit
S     * |        |          |If MCLKEN is set to 1, I2S controller will generate master clock on SPIx_I2SMCLK pin for external audio devices.
S     * |        |          |0 = Master clock Disabled.
S     * |        |          |1 = Master clock Enabled.
S     * |[16]    |RZCEN     |Right Channel Zero Cross Detection Enable Bit
S     * |        |          |If this bit is set to 1, when right channel data sign bit change or next shift data bits are all 0 then RZCIF flag in SPIx_I2SSTS register is set to 1
S     * |        |          |This function is only available in transmit operation.
S     * |        |          |0 = Right channel zero cross detection Disabled.
S     * |        |          |1 = Right channel zero cross detection Enabled.
S     * |[17]    |LZCEN     |Left Channel Zero Cross Detection Enable Bit
S     * |        |          |If this bit is set to 1, when left channel data sign bit changes or next shift data bits are all 0 then LZCIF flag in SPIx_I2SSTS register is set to 1
S     * |        |          |This function is only available in transmit operation.
S     * |        |          |0 = Left channel zero cross detection Disabled.
S     * |        |          |1 = Left channel zero cross detection Enabled.
S     * |[23]    |RXLCH     |Receive Left Channel Enable Bit
S     * |        |          |When monaural format is selected (MONO = 1), I2S controller will receive right channel data if RXLCH is set to 0, and receive left channel data if RXLCH is set to 1.
S     * |        |          |0 = Receive right channel data in Mono mode.
S     * |        |          |1 = Receive left channel data in Mono mode.
S     * |[24]    |RZCIEN    |Right Channel Zero- CCross Interrupt Enable Bit
S     * |        |          |Interrupt occurs if this bit is set to 1 and right channel zero- cross event occurs.
S     * |        |          |0 = Interrupt Disabled.
S     * |        |          |1 = Interrupt Enabled.
S     * |[25]    |LZCIEN    |Left Channel Zero- CCross Interrupt Enable Bit
S     * |        |          |Interrupt occurs if this bit is set to 1 and left channel zero- cross event occurs.
S     * |        |          |0 = Interrupt Disabled.
S     * |        |          |1 = Interrupt Enabled.
S     * |[29:28] |FORMAT    |Data Format Selection
S     * |        |          |00 = I2S data format.
S     * |        |          |01 = MSB justified data format.
S     * |        |          |10 = PCM mode A.
S     * |        |          |11 = PCM mode B.
S     * @var SPI_T::I2SCLK
S     * Offset: 0x64  I2S Clock Divider Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |MCLKDIV   |Master Clock Divider
S     * |        |          |If MCLKEN is set to 1, I2S controller will generate master clock for external audio devices
S     * |        |          |The frequency of master clock rate, fMCLKF_MCLK, is determined by the following expressions:.
S     * |        |          |If MCLKDIV >= 1,. F_MCLK = F_I2SCLK/(2x(MCLKDIV)).
S     * |        |          |If MCLKDIV = 0,. F_MCLK = F_I2SCLK.
S     * |        |          |where
S     * |        |          |is the frequency of I2S peripheral clock source, which is defined in the clock control register CLK_CLKSEL2
S     * |        |          |F_I2SCLK is the frequency of I2S peripheral clock.
S     * |        |          |In general, the master clock rate is 256 times sampling clock rate.
S     * |[16:8]  |BCLKDIV   |Bit Clock Divider
S     * |        |          |The I2S controller will generate bit clock in Master mode
S     * |        |          |The bit clock rate frequency of bit clock , Ff_bclBCLKk, is determined by the following expression:.
S     * |        |          |F_BCLK = F_I2SCLK /(2x(BCLKDIV + 1)) ,
S     * |        |          |where
S     * |        |          |F_I2SCLK is the frequency of I2S peripheral clock source, which is defined in the clock control register CLK_CLKSEL2.
S     * |        |          |In I2S
S     * |        |          |Slave mode, this field is used to define the frequency of peripheral clock and itu2019s determined by .
S     * |        |          |The peripheral clock frequency in I2S Slave mode must be equal to or faster than 6 times of input bit clock.
S     * @var SPI_T::I2SSTS
S     * Offset: 0x68  I2S Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[4]     |RIGHT     |Right Channel (Read Only)
S     * |        |          |This bit indicates the current transmit data is belong to which channel.
S     * |        |          |0 = Left channel.
S     * |        |          |1 = Right channel.
S     * |[8]     |RXEMPTY   |Receive FIFO Buffer Empty Indicator (Read Only)
S     * |        |          |0 = Receive FIFO buffer is not empty.
S     * |        |          |1 = Receive FIFO buffer is empty.
S     * |[9]     |RXFULL    |Receive FIFO Buffer Full Indicator (Read Only)
S     * |        |          |0 = Receive FIFO buffer is not full.
S     * |        |          |1 = Receive FIFO buffer is full.
S     * |[10]    |RXTHIF    |Receive FIFO Threshold Interrupt Flag (Read Only)
S     * |        |          |0 = The valid data count within the Rxreceive FIFO buffer is smaller than or equal to the setting value of RXTH.
S     * |        |          |1 = The valid data count within the receive FIFO buffer is larger than the setting value of RXTH.
S     * |        |          |Note: If RXTHIEN = 1 and RXTHIF = 1, the SPI/I2S controller will generate a SPI interrupt request.
S     * |[11]    |RXOVIF    |Receive FIFO Overrun Interrupt Flag
S     * |        |          |When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.
S     * |        |          |Note: This bit will be cleared by writing 1 to it.
S     * |[12]    |RXTOIF    |Receive Time-out Interrupt Flag
S     * |        |          |0 = No receive FIFO time-out event.
S     * |        |          |1 = Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI peripheral clock period in Master mode or over 576 SPI peripheral clock period in Slave mode
S     * |        |          |When the received FIFO buffer is read by software, the time-out status will be cleared automatically.
S     * |        |          |Note: This bit will be cleared by writing 1 to it.
S     * |[15]    |I2SENSTS  |I2S Enable Status (Read Only)
S     * |        |          |0 = The SPI/I2S control logic is disabled.
S     * |        |          |1 = The SPI/I2S control logic is enabled.
S     * |        |          |Note: The SPI peripheral clock is asynchronous with the system clock
S     * |        |          |In order to make sure the SPI/I2S controller logic is disabled, this bit indicates the real status of SPI/I2S controller logic for user.
S     * |[16]    |TXEMPTY   |Transmit FIFO Buffer Empty Indicator (Read Only)
S     * |        |          |0 = Transmit FIFO buffer is not empty.
S     * |        |          |1 = Transmit FIFO buffer is empty.
S     * |[17]    |TXFULL    |Transmit FIFO Buffer Full Indicator (Read Only)
S     * |        |          |0 = Transmit FIFO buffer is not full.
S     * |        |          |1 = Transmit FIFO buffer is full.
S     * |[18]    |TXTHIF    |Transmit FIFO Threshold Interrupt Flag (Read Only)
S     * |        |          |0 = The valid data count within the transmit FIFO buffer is larger than the setting value of TXTH.
S     * |        |          |1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TXTH.
S     * |        |          |Note: If TXTHIEN = 1 and TXTHIF = 1, the SPI/I2S controller will generate a SPI interrupt request.
S     * |[19]    |TXUFIF    |Transmit FIFO Underflow Interrupt Flag
S     * |        |          |When the transmit FIFO buffer is empty and there is no datum written into the FIFO buffer, if there is more bus clock input, this bit will be set to 1.
S     * |        |          |Note: This bit will be cleared by writing 1 to it.
S     * |[20]    |RZCIF     |Right Channel Zero Cross Interrupt Flag
S     * |        |          |0 = No zero cross event occurred on right channel.
S     * |        |          |1 = Zero cross event occurred on right channel.
S     * |[21]    |LZCIF     |Left Channel Zero Cross Interrupt Flag
S     * |        |          |0 = No zero cross event occurred on left channel.
S     * |        |          |1 = Zero cross event occurred on left channel.
S     * |[23]    |TXRXRST   |TX or RX Reset Status (Read Only)
S     * |        |          |0 = The reset function of TXRST or RXRST is done.
S     * |        |          |1 = Doing the reset function of TXRST or RXRST.
S     * |        |          |Note: Both the reset operations of TXRST and RXRST need 3 system clock cycles + 2 peripheral clock cycles
S     * |        |          |User can check the status of this bit to monitor the reset function is doing or done.
S     * |[26:24] |RXCNT     |Receive FIFO Data Count (Read Only)
S     * |        |          |This bit field indicates the valid data count of receive FIFO buffer.
S     * |[30:28] |TXCNT     |Transmit FIFO Data Count (Read Only)
S     * |        |          |This bit field indicates the valid data count of transmit FIFO buffer.
S     */
S
S    __IO uint32_t CTL;                   /*!< [0x0000] SPI Control Register                                             */
S    __IO uint32_t CLKDIV;                /*!< [0x0004] SPI Clock Divider Register                                       */
S    __IO uint32_t SSCTL;                 /*!< [0x0008] SPI Slave Select Control Register                                */
S    __IO uint32_t PDMACTL;               /*!< [0x000c] SPI PDMA Control Register                                        */
S    __IO uint32_t FIFOCTL;               /*!< [0x0010] SPI FIFO Control Register                                        */
S    __IO uint32_t STATUS;                /*!< [0x0014] SPI Status Register                                              */
S    __I  uint32_t RESERVE0[2];
S    __O  uint32_t TX;                    /*!< [0x0020] SPI Data Transmit Register                                       */
S    __I  uint32_t RESERVE1[3];
S    __I  uint32_t RX;                    /*!< [0x0030] SPI Data Receive Register                                        */
S    __I  uint32_t RESERVE2[11];
S    __IO uint32_t I2SCTL;                /*!< [0x0060] I2S Control Register                                             */
S    __IO uint32_t I2SCLK;                /*!< [0x0064] I2S Clock Divider Control Register                               */
S    __IO uint32_t I2SSTS;                /*!< [0x0068] I2S Status Register                                              */
S
S} SPI_T;
S
S/**
S    @addtogroup SPI_CONST SPI Bit Field Definition
S    Constant Definitions for SPI Controller
S@{ */
S
S#define SPI_CTL_SPIEN_Pos                (0)                                               /*!< SPI_T::CTL: SPIEN Position             */
S#define SPI_CTL_SPIEN_Msk                (0x1ul << SPI_CTL_SPIEN_Pos)                      /*!< SPI_T::CTL: SPIEN Mask                 */
S
S#define SPI_CTL_RXNEG_Pos                (1)                                               /*!< SPI_T::CTL: RXNEG Position             */
S#define SPI_CTL_RXNEG_Msk                (0x1ul << SPI_CTL_RXNEG_Pos)                      /*!< SPI_T::CTL: RXNEG Mask                 */
S
S#define SPI_CTL_TXNEG_Pos                (2)                                               /*!< SPI_T::CTL: TXNEG Position             */
S#define SPI_CTL_TXNEG_Msk                (0x1ul << SPI_CTL_TXNEG_Pos)                      /*!< SPI_T::CTL: TXNEG Mask                 */
S
S#define SPI_CTL_CLKPOL_Pos               (3)                                               /*!< SPI_T::CTL: CLKPOL Position            */
S#define SPI_CTL_CLKPOL_Msk               (0x1ul << SPI_CTL_CLKPOL_Pos)                     /*!< SPI_T::CTL: CLKPOL Mask                */
S
S#define SPI_CTL_SUSPITV_Pos              (4)                                               /*!< SPI_T::CTL: SUSPITV Position           */
S#define SPI_CTL_SUSPITV_Msk              (0xful << SPI_CTL_SUSPITV_Pos)                    /*!< SPI_T::CTL: SUSPITV Mask               */
S
S#define SPI_CTL_DWIDTH_Pos               (8)                                               /*!< SPI_T::CTL: DWIDTH Position            */
S#define SPI_CTL_DWIDTH_Msk               (0x1ful << SPI_CTL_DWIDTH_Pos)                    /*!< SPI_T::CTL: DWIDTH Mask                */
S
S#define SPI_CTL_LSB_Pos                  (13)                                              /*!< SPI_T::CTL: LSB Position               */
S#define SPI_CTL_LSB_Msk                  (0x1ul << SPI_CTL_LSB_Pos)                        /*!< SPI_T::CTL: LSB Mask                   */
S
S#define SPI_CTL_HALFDPX_Pos              (14)                                              /*!< SPI_T::CTL: HALFDPX Position           */
S#define SPI_CTL_HALFDPX_Msk              (0x1ul << SPI_CTL_HALFDPX_Pos)                    /*!< SPI_T::CTL: HALFDPX Mask               */
S
S#define SPI_CTL_RXONLY_Pos               (15)                                              /*!< SPI_T::CTL: RXONLY Position            */
S#define SPI_CTL_RXONLY_Msk               (0x1ul << SPI_CTL_RXONLY_Pos)                     /*!< SPI_T::CTL: RXONLY Mask                */
S
S#define SPI_CTL_UNITIEN_Pos              (17)                                              /*!< SPI_T::CTL: UNITIEN Position           */
S#define SPI_CTL_UNITIEN_Msk              (0x1ul << SPI_CTL_UNITIEN_Pos)                    /*!< SPI_T::CTL: UNITIEN Mask               */
S
S#define SPI_CTL_SLAVE_Pos                (18)                                              /*!< SPI_T::CTL: SLAVE Position             */
S#define SPI_CTL_SLAVE_Msk                (0x1ul << SPI_CTL_SLAVE_Pos)                      /*!< SPI_T::CTL: SLAVE Mask                 */
S
S#define SPI_CTL_REORDER_Pos              (19)                                              /*!< SPI_T::CTL: REORDER Position           */
S#define SPI_CTL_REORDER_Msk              (0x1ul << SPI_CTL_REORDER_Pos)                    /*!< SPI_T::CTL: REORDER Mask               */
S
S#define SPI_CTL_DATDIR_Pos               (20)                                              /*!< SPI_T::CTL: DATDIR Position            */
S#define SPI_CTL_DATDIR_Msk               (0x1ul << SPI_CTL_DATDIR_Pos)                     /*!< SPI_T::CTL: DATDIR Mask                */
S
S#define SPI_CLKDIV_DIVIDER_Pos           (0)                                               /*!< SPI_T::CLKDIV: DIVIDER Position        */
S#define SPI_CLKDIV_DIVIDER_Msk           (0xfful << SPI_CLKDIV_DIVIDER_Pos)                /*!< SPI_T::CLKDIV: DIVIDER Mask            */
S
S#define SPI_SSCTL_SS_Pos                 (0)                                               /*!< SPI_T::SSCTL: SS Position              */
S#define SPI_SSCTL_SS_Msk                 (0x1ul << SPI_SSCTL_SS_Pos)                       /*!< SPI_T::SSCTL: SS Mask                  */
S
S#define SPI_SSCTL_SSACTPOL_Pos           (2)                                               /*!< SPI_T::SSCTL: SSACTPOL Position        */
S#define SPI_SSCTL_SSACTPOL_Msk           (0x1ul << SPI_SSCTL_SSACTPOL_Pos)                 /*!< SPI_T::SSCTL: SSACTPOL Mask            */
S
S#define SPI_SSCTL_AUTOSS_Pos             (3)                                               /*!< SPI_T::SSCTL: AUTOSS Position          */
S#define SPI_SSCTL_AUTOSS_Msk             (0x1ul << SPI_SSCTL_AUTOSS_Pos)                   /*!< SPI_T::SSCTL: AUTOSS Mask              */
S
S#define SPI_SSCTL_SLVBEIEN_Pos           (8)                                               /*!< SPI_T::SSCTL: SLVBEIEN Position        */
S#define SPI_SSCTL_SLVBEIEN_Msk           (0x1ul << SPI_SSCTL_SLVBEIEN_Pos)                 /*!< SPI_T::SSCTL: SLVBEIEN Mask            */
S
S#define SPI_SSCTL_SLVURIEN_Pos           (9)                                               /*!< SPI_T::SSCTL: SLVURIEN Position        */
S#define SPI_SSCTL_SLVURIEN_Msk           (0x1ul << SPI_SSCTL_SLVURIEN_Pos)                 /*!< SPI_T::SSCTL: SLVURIEN Mask            */
S
S#define SPI_SSCTL_SSACTIEN_Pos           (12)                                              /*!< SPI_T::SSCTL: SSACTIEN Position        */
S#define SPI_SSCTL_SSACTIEN_Msk           (0x1ul << SPI_SSCTL_SSACTIEN_Pos)                 /*!< SPI_T::SSCTL: SSACTIEN Mask            */
S
S#define SPI_SSCTL_SSINAIEN_Pos           (13)                                              /*!< SPI_T::SSCTL: SSINAIEN Position        */
S#define SPI_SSCTL_SSINAIEN_Msk           (0x1ul << SPI_SSCTL_SSINAIEN_Pos)                 /*!< SPI_T::SSCTL: SSINAIEN Mask            */
S
S#define SPI_PDMACTL_TXPDMAEN_Pos         (0)                                               /*!< SPI_T::PDMACTL: TXPDMAEN Position      */
S#define SPI_PDMACTL_TXPDMAEN_Msk         (0x1ul << SPI_PDMACTL_TXPDMAEN_Pos)               /*!< SPI_T::PDMACTL: TXPDMAEN Mask          */
S
S#define SPI_PDMACTL_RXPDMAEN_Pos         (1)                                               /*!< SPI_T::PDMACTL: RXPDMAEN Position      */
S#define SPI_PDMACTL_RXPDMAEN_Msk         (0x1ul << SPI_PDMACTL_RXPDMAEN_Pos)               /*!< SPI_T::PDMACTL: RXPDMAEN Mask          */
S
S#define SPI_PDMACTL_PDMARST_Pos          (2)                                               /*!< SPI_T::PDMACTL: PDMARST Position       */
S#define SPI_PDMACTL_PDMARST_Msk          (0x1ul << SPI_PDMACTL_PDMARST_Pos)                /*!< SPI_T::PDMACTL: PDMARST Mask           */
S
S#define SPI_FIFOCTL_RXRST_Pos            (0)                                               /*!< SPI_T::FIFOCTL: RXRST Position         */
S#define SPI_FIFOCTL_RXRST_Msk            (0x1ul << SPI_FIFOCTL_RXRST_Pos)                  /*!< SPI_T::FIFOCTL: RXRST Mask             */
S
S#define SPI_FIFOCTL_TXRST_Pos            (1)                                               /*!< SPI_T::FIFOCTL: TXRST Position         */
S#define SPI_FIFOCTL_TXRST_Msk            (0x1ul << SPI_FIFOCTL_TXRST_Pos)                  /*!< SPI_T::FIFOCTL: TXRST Mask             */
S
S#define SPI_FIFOCTL_RXTHIEN_Pos          (2)                                               /*!< SPI_T::FIFOCTL: RXTHIEN Position       */
S#define SPI_FIFOCTL_RXTHIEN_Msk          (0x1ul << SPI_FIFOCTL_RXTHIEN_Pos)                /*!< SPI_T::FIFOCTL: RXTHIEN Mask           */
S
S#define SPI_FIFOCTL_TXTHIEN_Pos          (3)                                               /*!< SPI_T::FIFOCTL: TXTHIEN Position       */
S#define SPI_FIFOCTL_TXTHIEN_Msk          (0x1ul << SPI_FIFOCTL_TXTHIEN_Pos)                /*!< SPI_T::FIFOCTL: TXTHIEN Mask           */
S
S#define SPI_FIFOCTL_RXTOIEN_Pos          (4)                                               /*!< SPI_T::FIFOCTL: RXTOIEN Position       */
S#define SPI_FIFOCTL_RXTOIEN_Msk          (0x1ul << SPI_FIFOCTL_RXTOIEN_Pos)                /*!< SPI_T::FIFOCTL: RXTOIEN Mask           */
S
S#define SPI_FIFOCTL_RXOVIEN_Pos          (5)                                               /*!< SPI_T::FIFOCTL: RXOVIEN Position       */
S#define SPI_FIFOCTL_RXOVIEN_Msk          (0x1ul << SPI_FIFOCTL_RXOVIEN_Pos)                /*!< SPI_T::FIFOCTL: RXOVIEN Mask           */
S
S#define SPI_FIFOCTL_TXUFPOL_Pos          (6)                                               /*!< SPI_T::FIFOCTL: TXUFPOL Position       */
S#define SPI_FIFOCTL_TXUFPOL_Msk          (0x1ul << SPI_FIFOCTL_TXUFPOL_Pos)                /*!< SPI_T::FIFOCTL: TXUFPOL Mask           */
S
S#define SPI_FIFOCTL_TXUFIEN_Pos          (7)                                               /*!< SPI_T::FIFOCTL: TXUFIEN Position       */
S#define SPI_FIFOCTL_TXUFIEN_Msk          (0x1ul << SPI_FIFOCTL_TXUFIEN_Pos)                /*!< SPI_T::FIFOCTL: TXUFIEN Mask           */
S
S#define SPI_FIFOCTL_RXFBCLR_Pos          (8)                                               /*!< SPI_T::FIFOCTL: RXFBCLR Position       */
S#define SPI_FIFOCTL_RXFBCLR_Msk          (0x1ul << SPI_FIFOCTL_RXFBCLR_Pos)                /*!< SPI_T::FIFOCTL: RXFBCLR Mask           */
S
S#define SPI_FIFOCTL_TXFBCLR_Pos          (9)                                               /*!< SPI_T::FIFOCTL: TXFBCLR Position       */
S#define SPI_FIFOCTL_TXFBCLR_Msk          (0x1ul << SPI_FIFOCTL_TXFBCLR_Pos)                /*!< SPI_T::FIFOCTL: TXFBCLR Mask           */
S
S#define SPI_FIFOCTL_RXTH_Pos             (24)                                              /*!< SPI_T::FIFOCTL: RXTH Position          */
S#define SPI_FIFOCTL_RXTH_Msk             (0x3ul << SPI_FIFOCTL_RXTH_Pos)                   /*!< SPI_T::FIFOCTL: RXTH Mask              */
S
S#define SPI_FIFOCTL_TXTH_Pos             (28)                                              /*!< SPI_T::FIFOCTL: TXTH Position          */
S#define SPI_FIFOCTL_TXTH_Msk             (0x3ul << SPI_FIFOCTL_TXTH_Pos)                   /*!< SPI_T::FIFOCTL: TXTH Mask              */
S
S#define SPI_STATUS_BUSY_Pos              (0)                                               /*!< SPI_T::STATUS: BUSY Position           */
S#define SPI_STATUS_BUSY_Msk              (0x1ul << SPI_STATUS_BUSY_Pos)                    /*!< SPI_T::STATUS: BUSY Mask               */
S
S#define SPI_STATUS_UNITIF_Pos            (1)                                               /*!< SPI_T::STATUS: UNITIF Position         */
S#define SPI_STATUS_UNITIF_Msk            (0x1ul << SPI_STATUS_UNITIF_Pos)                  /*!< SPI_T::STATUS: UNITIF Mask             */
S
S#define SPI_STATUS_SSACTIF_Pos           (2)                                               /*!< SPI_T::STATUS: SSACTIF Position        */
S#define SPI_STATUS_SSACTIF_Msk           (0x1ul << SPI_STATUS_SSACTIF_Pos)                 /*!< SPI_T::STATUS: SSACTIF Mask            */
S
S#define SPI_STATUS_SSINAIF_Pos           (3)                                               /*!< SPI_T::STATUS: SSINAIF Position        */
S#define SPI_STATUS_SSINAIF_Msk           (0x1ul << SPI_STATUS_SSINAIF_Pos)                 /*!< SPI_T::STATUS: SSINAIF Mask            */
S
S#define SPI_STATUS_SSLINE_Pos            (4)                                               /*!< SPI_T::STATUS: SSLINE Position         */
S#define SPI_STATUS_SSLINE_Msk            (0x1ul << SPI_STATUS_SSLINE_Pos)                  /*!< SPI_T::STATUS: SSLINE Mask             */
S
S#define SPI_STATUS_SLVBEIF_Pos           (6)                                               /*!< SPI_T::STATUS: SLVBEIF Position        */
S#define SPI_STATUS_SLVBEIF_Msk           (0x1ul << SPI_STATUS_SLVBEIF_Pos)                 /*!< SPI_T::STATUS: SLVBEIF Mask            */
S
S#define SPI_STATUS_SLVURIF_Pos           (7)                                               /*!< SPI_T::STATUS: SLVURIF Position        */
S#define SPI_STATUS_SLVURIF_Msk           (0x1ul << SPI_STATUS_SLVURIF_Pos)                 /*!< SPI_T::STATUS: SLVURIF Mask            */
S
S#define SPI_STATUS_RXEMPTY_Pos           (8)                                               /*!< SPI_T::STATUS: RXEMPTY Position        */
S#define SPI_STATUS_RXEMPTY_Msk           (0x1ul << SPI_STATUS_RXEMPTY_Pos)                 /*!< SPI_T::STATUS: RXEMPTY Mask            */
S
S#define SPI_STATUS_RXFULL_Pos            (9)                                               /*!< SPI_T::STATUS: RXFULL Position         */
S#define SPI_STATUS_RXFULL_Msk            (0x1ul << SPI_STATUS_RXFULL_Pos)                  /*!< SPI_T::STATUS: RXFULL Mask             */
S
S#define SPI_STATUS_RXTHIF_Pos            (10)                                              /*!< SPI_T::STATUS: RXTHIF Position         */
S#define SPI_STATUS_RXTHIF_Msk            (0x1ul << SPI_STATUS_RXTHIF_Pos)                  /*!< SPI_T::STATUS: RXTHIF Mask             */
S
S#define SPI_STATUS_RXOVIF_Pos            (11)                                              /*!< SPI_T::STATUS: RXOVIF Position         */
S#define SPI_STATUS_RXOVIF_Msk            (0x1ul << SPI_STATUS_RXOVIF_Pos)                  /*!< SPI_T::STATUS: RXOVIF Mask             */
S
S#define SPI_STATUS_RXTOIF_Pos            (12)                                              /*!< SPI_T::STATUS: RXTOIF Position         */
S#define SPI_STATUS_RXTOIF_Msk            (0x1ul << SPI_STATUS_RXTOIF_Pos)                  /*!< SPI_T::STATUS: RXTOIF Mask             */
S
S#define SPI_STATUS_SPIENSTS_Pos          (15)                                              /*!< SPI_T::STATUS: SPIENSTS Position       */
S#define SPI_STATUS_SPIENSTS_Msk          (0x1ul << SPI_STATUS_SPIENSTS_Pos)                /*!< SPI_T::STATUS: SPIENSTS Mask           */
S
S#define SPI_STATUS_TXEMPTY_Pos           (16)                                              /*!< SPI_T::STATUS: TXEMPTY Position        */
S#define SPI_STATUS_TXEMPTY_Msk           (0x1ul << SPI_STATUS_TXEMPTY_Pos)                 /*!< SPI_T::STATUS: TXEMPTY Mask            */
S
S#define SPI_STATUS_TXFULL_Pos            (17)                                              /*!< SPI_T::STATUS: TXFULL Position         */
S#define SPI_STATUS_TXFULL_Msk            (0x1ul << SPI_STATUS_TXFULL_Pos)                  /*!< SPI_T::STATUS: TXFULL Mask             */
S
S#define SPI_STATUS_TXTHIF_Pos            (18)                                              /*!< SPI_T::STATUS: TXTHIF Position         */
S#define SPI_STATUS_TXTHIF_Msk            (0x1ul << SPI_STATUS_TXTHIF_Pos)                  /*!< SPI_T::STATUS: TXTHIF Mask             */
S
S#define SPI_STATUS_TXUFIF_Pos            (19)                                              /*!< SPI_T::STATUS: TXUFIF Position         */
S#define SPI_STATUS_TXUFIF_Msk            (0x1ul << SPI_STATUS_TXUFIF_Pos)                  /*!< SPI_T::STATUS: TXUFIF Mask             */
S
S#define SPI_STATUS_TXRXRST_Pos           (23)                                              /*!< SPI_T::STATUS: TXRXRST Position        */
S#define SPI_STATUS_TXRXRST_Msk           (0x1ul << SPI_STATUS_TXRXRST_Pos)                 /*!< SPI_T::STATUS: TXRXRST Mask            */
S
S#define SPI_STATUS_RXCNT_Pos             (24)                                              /*!< SPI_T::STATUS: RXCNT Position          */
S#define SPI_STATUS_RXCNT_Msk             (0xful << SPI_STATUS_RXCNT_Pos)                   /*!< SPI_T::STATUS: RXCNT Mask              */
S
S#define SPI_STATUS_TXCNT_Pos             (28)                                              /*!< SPI_T::STATUS: TXCNT Position          */
S#define SPI_STATUS_TXCNT_Msk             (0xful << SPI_STATUS_TXCNT_Pos)                   /*!< SPI_T::STATUS: TXCNT Mask              */
S
S#define SPI_TX_TX_Pos                    (0)                                               /*!< SPI_T::TX: TX Position                 */
S#define SPI_TX_TX_Msk                    (0xfffffffful << SPI_TX_TX_Pos)                   /*!< SPI_T::TX: TX Mask                     */
S
S#define SPI_RX_RX_Pos                    (0)                                               /*!< SPI_T::RX: RX Position                 */
S#define SPI_RX_RX_Msk                    (0xfffffffful << SPI_RX_RX_Pos)                   /*!< SPI_T::RX: RX Mask                     */
S
S#define SPI_I2SCTL_I2SEN_Pos             (0)                                               /*!< SPI_T::I2SCTL: I2SEN Position          */
S#define SPI_I2SCTL_I2SEN_Msk             (0x1ul << SPI_I2SCTL_I2SEN_Pos)                   /*!< SPI_T::I2SCTL: I2SEN Mask              */
S
S#define SPI_I2SCTL_TXEN_Pos              (1)                                               /*!< SPI_T::I2SCTL: TXEN Position           */
S#define SPI_I2SCTL_TXEN_Msk              (0x1ul << SPI_I2SCTL_TXEN_Pos)                    /*!< SPI_T::I2SCTL: TXEN Mask               */
S
S#define SPI_I2SCTL_RXEN_Pos              (2)                                               /*!< SPI_T::I2SCTL: RXEN Position           */
S#define SPI_I2SCTL_RXEN_Msk              (0x1ul << SPI_I2SCTL_RXEN_Pos)                    /*!< SPI_T::I2SCTL: RXEN Mask               */
S
S#define SPI_I2SCTL_MUTE_Pos              (3)                                               /*!< SPI_T::I2SCTL: MUTE Position           */
S#define SPI_I2SCTL_MUTE_Msk              (0x1ul << SPI_I2SCTL_MUTE_Pos)                    /*!< SPI_T::I2SCTL: MUTE Mask               */
S
S#define SPI_I2SCTL_WDWIDTH_Pos           (4)                                               /*!< SPI_T::I2SCTL: WDWIDTH Position        */
S#define SPI_I2SCTL_WDWIDTH_Msk           (0x3ul << SPI_I2SCTL_WDWIDTH_Pos)                 /*!< SPI_T::I2SCTL: WDWIDTH Mask            */
S
S#define SPI_I2SCTL_MONO_Pos              (6)                                               /*!< SPI_T::I2SCTL: MONO Position           */
S#define SPI_I2SCTL_MONO_Msk              (0x1ul << SPI_I2SCTL_MONO_Pos)                    /*!< SPI_T::I2SCTL: MONO Mask               */
S
S#define SPI_I2SCTL_ORDER_Pos             (7)                                               /*!< SPI_T::I2SCTL: ORDER Position          */
S#define SPI_I2SCTL_ORDER_Msk             (0x1ul << SPI_I2SCTL_ORDER_Pos)                   /*!< SPI_T::I2SCTL: ORDER Mask              */
S
S#define SPI_I2SCTL_SLAVE_Pos             (8)                                               /*!< SPI_T::I2SCTL: SLAVE Position          */
S#define SPI_I2SCTL_SLAVE_Msk             (0x1ul << SPI_I2SCTL_SLAVE_Pos)                   /*!< SPI_T::I2SCTL: SLAVE Mask              */
S
S#define SPI_I2SCTL_MCLKEN_Pos            (15)                                              /*!< SPI_T::I2SCTL: MCLKEN Position         */
S#define SPI_I2SCTL_MCLKEN_Msk            (0x1ul << SPI_I2SCTL_MCLKEN_Pos)                  /*!< SPI_T::I2SCTL: MCLKEN Mask             */
S
S#define SPI_I2SCTL_RZCEN_Pos             (16)                                              /*!< SPI_T::I2SCTL: RZCEN Position          */
S#define SPI_I2SCTL_RZCEN_Msk             (0x1ul << SPI_I2SCTL_RZCEN_Pos)                   /*!< SPI_T::I2SCTL: RZCEN Mask              */
S
S#define SPI_I2SCTL_LZCEN_Pos             (17)                                              /*!< SPI_T::I2SCTL: LZCEN Position          */
S#define SPI_I2SCTL_LZCEN_Msk             (0x1ul << SPI_I2SCTL_LZCEN_Pos)                   /*!< SPI_T::I2SCTL: LZCEN Mask              */
S
S#define SPI_I2SCTL_RXLCH_Pos             (23)                                              /*!< SPI_T::I2SCTL: RXLCH Position          */
S#define SPI_I2SCTL_RXLCH_Msk             (0x1ul << SPI_I2SCTL_RXLCH_Pos)                   /*!< SPI_T::I2SCTL: RXLCH Mask              */
S
S#define SPI_I2SCTL_RZCIEN_Pos            (24)                                              /*!< SPI_T::I2SCTL: RZCIEN Position         */
S#define SPI_I2SCTL_RZCIEN_Msk            (0x1ul << SPI_I2SCTL_RZCIEN_Pos)                  /*!< SPI_T::I2SCTL: RZCIEN Mask             */
S
S#define SPI_I2SCTL_LZCIEN_Pos            (25)                                              /*!< SPI_T::I2SCTL: LZCIEN Position         */
S#define SPI_I2SCTL_LZCIEN_Msk            (0x1ul << SPI_I2SCTL_LZCIEN_Pos)                  /*!< SPI_T::I2SCTL: LZCIEN Mask             */
S
S#define SPI_I2SCTL_FORMAT_Pos            (28)                                              /*!< SPI_T::I2SCTL: FORMAT Position         */
S#define SPI_I2SCTL_FORMAT_Msk            (0x3ul << SPI_I2SCTL_FORMAT_Pos)                  /*!< SPI_T::I2SCTL: FORMAT Mask             */
S
S#define SPI_I2SCLK_MCLKDIV_Pos           (0)                                               /*!< SPI_T::I2SCLK: MCLKDIV Position        */
S#define SPI_I2SCLK_MCLKDIV_Msk           (0x3ful << SPI_I2SCLK_MCLKDIV_Pos)                /*!< SPI_T::I2SCLK: MCLKDIV Mask            */
S
S#define SPI_I2SCLK_BCLKDIV_Pos           (8)                                               /*!< SPI_T::I2SCLK: BCLKDIV Position        */
S#define SPI_I2SCLK_BCLKDIV_Msk           (0x1fful << SPI_I2SCLK_BCLKDIV_Pos)               /*!< SPI_T::I2SCLK: BCLKDIV Mask            */
S
S#define SPI_I2SSTS_RIGHT_Pos             (4)                                               /*!< SPI_T::I2SSTS: RIGHT Position          */
S#define SPI_I2SSTS_RIGHT_Msk             (0x1ul << SPI_I2SSTS_RIGHT_Pos)                   /*!< SPI_T::I2SSTS: RIGHT Mask              */
S
S#define SPI_I2SSTS_RXEMPTY_Pos           (8)                                               /*!< SPI_T::I2SSTS: RXEMPTY Position        */
S#define SPI_I2SSTS_RXEMPTY_Msk           (0x1ul << SPI_I2SSTS_RXEMPTY_Pos)                 /*!< SPI_T::I2SSTS: RXEMPTY Mask            */
S
S#define SPI_I2SSTS_RXFULL_Pos            (9)                                               /*!< SPI_T::I2SSTS: RXFULL Position         */
S#define SPI_I2SSTS_RXFULL_Msk            (0x1ul << SPI_I2SSTS_RXFULL_Pos)                  /*!< SPI_T::I2SSTS: RXFULL Mask             */
S
S#define SPI_I2SSTS_RXTHIF_Pos            (10)                                              /*!< SPI_T::I2SSTS: RXTHIF Position         */
S#define SPI_I2SSTS_RXTHIF_Msk            (0x1ul << SPI_I2SSTS_RXTHIF_Pos)                  /*!< SPI_T::I2SSTS: RXTHIF Mask             */
S
S#define SPI_I2SSTS_RXOVIF_Pos            (11)                                              /*!< SPI_T::I2SSTS: RXOVIF Position         */
S#define SPI_I2SSTS_RXOVIF_Msk            (0x1ul << SPI_I2SSTS_RXOVIF_Pos)                  /*!< SPI_T::I2SSTS: RXOVIF Mask             */
S
S#define SPI_I2SSTS_RXTOIF_Pos            (12)                                              /*!< SPI_T::I2SSTS: RXTOIF Position         */
S#define SPI_I2SSTS_RXTOIF_Msk            (0x1ul << SPI_I2SSTS_RXTOIF_Pos)                  /*!< SPI_T::I2SSTS: RXTOIF Mask             */
S
S#define SPI_I2SSTS_I2SENSTS_Pos          (15)                                              /*!< SPI_T::I2SSTS: I2SENSTS Position       */
S#define SPI_I2SSTS_I2SENSTS_Msk          (0x1ul << SPI_I2SSTS_I2SENSTS_Pos)                /*!< SPI_T::I2SSTS: I2SENSTS Mask           */
S
S#define SPI_I2SSTS_TXEMPTY_Pos           (16)                                              /*!< SPI_T::I2SSTS: TXEMPTY Position        */
S#define SPI_I2SSTS_TXEMPTY_Msk           (0x1ul << SPI_I2SSTS_TXEMPTY_Pos)                 /*!< SPI_T::I2SSTS: TXEMPTY Mask            */
S
S#define SPI_I2SSTS_TXFULL_Pos            (17)                                              /*!< SPI_T::I2SSTS: TXFULL Position         */
S#define SPI_I2SSTS_TXFULL_Msk            (0x1ul << SPI_I2SSTS_TXFULL_Pos)                  /*!< SPI_T::I2SSTS: TXFULL Mask             */
S
S#define SPI_I2SSTS_TXTHIF_Pos            (18)                                              /*!< SPI_T::I2SSTS: TXTHIF Position         */
S#define SPI_I2SSTS_TXTHIF_Msk            (0x1ul << SPI_I2SSTS_TXTHIF_Pos)                  /*!< SPI_T::I2SSTS: TXTHIF Mask             */
S
S#define SPI_I2SSTS_TXUFIF_Pos            (19)                                              /*!< SPI_T::I2SSTS: TXUFIF Position         */
S#define SPI_I2SSTS_TXUFIF_Msk            (0x1ul << SPI_I2SSTS_TXUFIF_Pos)                  /*!< SPI_T::I2SSTS: TXUFIF Mask             */
S
S#define SPI_I2SSTS_RZCIF_Pos             (20)                                              /*!< SPI_T::I2SSTS: RZCIF Position          */
S#define SPI_I2SSTS_RZCIF_Msk             (0x1ul << SPI_I2SSTS_RZCIF_Pos)                   /*!< SPI_T::I2SSTS: RZCIF Mask              */
S
S#define SPI_I2SSTS_LZCIF_Pos             (21)                                              /*!< SPI_T::I2SSTS: LZCIF Position          */
S#define SPI_I2SSTS_LZCIF_Msk             (0x1ul << SPI_I2SSTS_LZCIF_Pos)                   /*!< SPI_T::I2SSTS: LZCIF Mask              */
S
S#define SPI_I2SSTS_TXRXRST_Pos           (23)                                              /*!< SPI_T::I2SSTS: TXRXRST Position        */
S#define SPI_I2SSTS_TXRXRST_Msk           (0x1ul << SPI_I2SSTS_TXRXRST_Pos)                 /*!< SPI_T::I2SSTS: TXRXRST Mask            */
S
S#define SPI_I2SSTS_RXCNT_Pos             (24)                                              /*!< SPI_T::I2SSTS: RXCNT Position          */
S#define SPI_I2SSTS_RXCNT_Msk             (0x7ul << SPI_I2SSTS_RXCNT_Pos)                   /*!< SPI_T::I2SSTS: RXCNT Mask              */
S
S#define SPI_I2SSTS_TXCNT_Pos             (28)                                              /*!< SPI_T::I2SSTS: TXCNT Position          */
S#define SPI_I2SSTS_TXCNT_Msk             (0x7ul << SPI_I2SSTS_TXCNT_Pos)                   /*!< SPI_T::I2SSTS: TXCNT Mask              */
S
S/**@}*/ /* SPI_CONST */
S/**@}*/ /* end of SPI register group */
S
S
S/*---------------------- System Manger Controller -------------------------*/
S/**
S    @addtogroup SYS System Manger Controller(SYS)
S    Memory Mapped Structure for SYS Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var SYS_T::PDID
S     * Offset: 0x00  Part Device Identification Number Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |PDID      |Part Device Identification Number (Read Only)
S     * |        |          |This register reflects device part number code.
S     * |        |          |Software can read this register to identify which device is used.
S     * @var SYS_T::RSTSTS
S     * Offset: 0x04  System Reset Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PORF      |POR Reset Flag
S     * |        |          |The POR reset flag is set by the Reset Signal from the Power-on Reset (POR) Controller or bit CHIPRST (SYS_IPRST0[0]) to indicate the previous reset source.
S     * |        |          |0 = No reset from POR or CHIPRST.
S     * |        |          |1 = Power-on Reset (POR) or CHIPRST had issued the reset signal to reset the system.
S     * |        |          |Note: This bit can be cleared by software writing 1.
S     * |[1]     |PINRF     |nRESET Pin Reset Flag
S     * |        |          |The nRESET pin reset flag is set by the Reset Signal from the nRESET Pin to indicate the previous reset source.
S     * |        |          |0 = No reset from nRESET pin.
S     * |        |          |1 = Pin nRESET had issued the reset signal to reset the system.
S     * |        |          |Note: This bit can be cleared by software writing 1.
S     * |[2]     |WDTRF     |WDT Reset Flag
S     * |        |          |The WDT reset flag is set by the Reset Signal from the Watchdog Timer or Window Watchdog Timer to indicate the previous reset source.
S     * |        |          |0 = No reset from watchdog timer or window watchdog timer.
S     * |        |          |1 = The watchdog timer or window watchdog timer had issued the reset signal to reset the system.
S     * |        |          |Note1: This bit can be cleared by software writing 1.
S     * |        |          |Note2: Watchdog Timer register RSTF(WDT_CTL[2]) bit is set if the system has been reset by WDT time-out reset.
S     * |        |          |Window Watchdog Timer register WWDTRF(WWDT_STATUS[1]) bit is set if the system has been reset by WWDT time-out reset.
S     * |[3]     |LVRF      |LVR Reset Flag
S     * |        |          |The LVR reset flag is set by the Reset Signal from the Low Voltage Reset Controller to indicate the previous reset source.
S     * |        |          |0 = No reset from LVR.
S     * |        |          |1 = LVR controller had issued the reset signal to reset the system.
S     * |        |          |Note: This bit can be cleared by software writing 1.
S     * |[4]     |BODRF     |BOD Reset Flag
S     * |        |          |The BOD reset flag is set by the Reset Signal from the Brown-out Detector to indicate the previous reset source.
S     * |        |          |0 = No reset from BOD.
S     * |        |          |1 = The BOD had issued the reset signal to reset the system.
S     * |        |          |Note: This bit can be cleared by software writing 1.
S     * |[5]     |MCURF     |MCU Reset Flag
S     * |        |          |The MCU reset flag is set by the Reset Signal from the Cortex-M0 Core to indicate the previous reset source.
S     * |        |          |0 = No reset from Cortex-M0.
S     * |        |          |1 = The Cortex-M0 had issued the reset signal to reset the system by writing 1 to the bit SYSRESETREQ(AIRCR[2], Application Interrupt and Reset Control Register, address = 0xE000ED0C) in system control registers of Cortex-M0 core.
S     * |        |          |Note: This bit can be cleared by software writing 1.
S     * |[7]     |CPURF     |CPU Reset Flag
S     * |        |          |The CPU reset flag is set by hardware if software writes CPURST (SYS_IPRST0[1]) 1 to reset Cortex-M0 Core and Flash Memory Controller (FMC).
S     * |        |          |0 = No reset from CPU.
S     * |        |          |1 = The Cortex-M0 Core and FMC are reset by software setting CPURST to 1.
S     * |        |          |Note: This bit can be cleared by software writing 1.
S     * |[8]     |CPULKRF   |CPU Lockup Reset Flag
S     * |        |          |The CPU lockup reset flag is set by hardware if Cortex-M0 lockup happened.
S     * |        |          |0 = No reset from CPU lockup happened.
S     * |        |          |1 = The Cortex-M0 lockup happened and chip is reset.
S     * |        |          |Note: This bit can be cleared by software writing 1.
S     * @var SYS_T::IPRST0
S     * Offset: 0x08  Peripheral  Reset Control Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CHIPRST   |Chip One-shot Reset (Write Protect)
S     * |        |          |Setting this bit will reset the whole chip, including Processor core and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.
S     * |        |          |The CHIPRST is same as the POR reset, all the chip controllers is reset and the chip setting from flash are also reload.
S     * |        |          |0 = Chip normal operation.
S     * |        |          |1 = Chip one-shot reset.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[1]     |CPURST    |Processor Core One-shot Reset (Write Protect)
S     * |        |          |Setting this bit will only reset the processor core and Flash Memory Controller(FMC), and this bit will automatically return to 0 after the 2 clock cycles.
S     * |        |          |0 = Processor core normal operation.
S     * |        |          |1 = Processor core one-shot reset.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[2]     |PDMARST   |PDMA Controller Reset (Write Protect)
S     * |        |          |Setting this bit to 1 will generate a reset signal to the PDMA.
S     * |        |          |User needs to set this bit to 0 to release from reset state.
S     * |        |          |0 = PDMA controller normal operation.
S     * |        |          |1 = PDMA controller reset.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[3]     |EBIRST    |EBI Controller Reset (Write Protect)
S     * |        |          |Set this bit to 1 will generate a reset signal to the EBI.
S     * |        |          |User needs to set this bit to 0 to release from the reset state.
S     * |        |          |0 = EBI controller normal operation.
S     * |        |          |1 = EBI controller reset.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[4]     |HDIVRST   |HDIV Controller Reset (Write Protect)
S     * |        |          |Set this bit to 1 will generate a reset signal to the HDIV controller.
S     * |        |          |User needs to set this bit to 0 to release from the reset state.
S     * |        |          |0 = HDIV controller normal operation.
S     * |        |          |1 = HDIV controller reset.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[7]     |CRCRST    |CRC Calculation Controller Reset (Write Protect)
S     * |        |          |Set this bit to 1 will generate a reset signal to the CRC calculation controller.
S     * |        |          |User needs to set this bit to 0 to release from the reset state.
S     * |        |          |0 = CRC calculation controller normal operation.
S     * |        |          |1 = CRC calculation controller reset.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * @var SYS_T::IPRST1
S     * Offset: 0x0C  Peripheral Reset Control Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |GPIORST   |GPIO Controller Reset
S     * |        |          |0 = GPIO controller normal operation.
S     * |        |          |1 = GPIO controller reset.
S     * |[2]     |TMR0RST   |Timer0 Controller Reset
S     * |        |          |0 = Timer0 controller normal operation.
S     * |        |          |1 = Timer0 controller reset.
S     * |[3]     |TMR1RST   |Timer1 Controller Reset
S     * |        |          |0 = Timer1 controller normal operation.
S     * |        |          |1 = Timer1 controller reset.
S     * |[4]     |TMR2RST   |Timer2 Controller Reset
S     * |        |          |0 = Timer2 controller normal operation.
S     * |        |          |1 = Timer2 controller reset.
S     * |[5]     |TMR3RST   |Timer3 Controller Reset
S     * |        |          |0 = Timer3 controller normal operation.
S     * |        |          |1 = Timer3 controller reset.
S     * |[8]     |I2C0RST   |I2C0 Controller Reset
S     * |        |          |0 = I2C0 controller normal operation.
S     * |        |          |1 = I2C0 controller reset.
S     * |[9]     |I2C1RST   |I2C1 Controller Reset
S     * |        |          |0 = I2C1 controller normal operation.
S     * |        |          |1 = I2C1 controller reset.
S     * |[12]    |SPI0RST   |SPI0 Controller Reset
S     * |        |          |0 = SPI0 controller normal operation.
S     * |        |          |1 = SPI0 controller reset.
S     * |[13]    |SPI1RST   |SPI1 Controller Reset
S     * |        |          |0 = SPI1 controller normal operation.
S     * |        |          |1 = SPI1 controller reset.
S     * |[16]    |UART0RST  |UART0 Controller Reset
S     * |        |          |0 = UART0 controller normal operation.
S     * |        |          |1 = UART0 controller reset.
S     * |[17]    |UART1RST  |UART1 Controller Reset
S     * |        |          |0 = UART1 controller normal operation.
S     * |        |          |1 = UART1 controller reset.
S     * |[18]    |UART2RST  |UART2 Controller Reset
S     * |        |          |0 = UART2 controller normal operation.
S     * |        |          |1 = UART2 controller reset.
S     * |[20]    |PWM0RST   |PWM0 Controller Reset
S     * |        |          |0 = PWM0 controller normal operation.
S     * |        |          |1 = PWM0 controller reset.
S     * |[21]    |PWM1RST   |PWM1 Controller Reset
S     * |        |          |0 = PWM1 controller normal operation.
S     * |        |          |1 = PWM1 controller reset.
S     * |[22]    |ACMP01RST |ACMP01 Controller Reset
S     * |        |          |0 = ACMP01 controller normal operation.
S     * |        |          |1 = ACMP01 controller reset.
S     * |[27]    |USBDRST   |USB Device Controller Reset
S     * |        |          |0 = USB device controller normal operation.
S     * |        |          |1 = USB device controller reset.
S     * |[28]    |ADCRST    |ADC Controller Reset
S     * |        |          |0 = ADC controller normal operation.
S     * |        |          |1 = ADC controller reset.
S     * @var SYS_T::IPRST2
S     * Offset: 0x10  Peripheral Reset Control Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SC0RST    |SC0 Controller Reset
S     * |        |          |0 = SC0 controller normal operation.
S     * |        |          |1 = SC0 controller reset.
S     * |[1]     |SC1RST    |SC1 Controller Reset
S     * |        |          |0 = SC1 controller normal operation.
S     * |        |          |1 = SC1 controller reset.
S     * |[8]     |USCI0RST  |USCI0 Controller Reset
S     * |        |          |0 = USCI0 controller normal operation.
S     * |        |          |1 = USCI0 controller reset.
S     * |[9]     |USCI1RST  |USCI1 Controller Reset
S     * |        |          |0 = USCI1 controller normal operation.
S     * |        |          |1 = USCI1 controller reset.
S     * |[10]    |USCI2RST  |USCI2 Controller Reset
S     * |        |          |0 = USCI2 controller normal operation.
S     * |        |          |1 = USCI2 controller reset.
S     * @var SYS_T::BODCTL
S     * Offset: 0x18  Brown-out Detector Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |BODEN     |Brown-out Detector Enable Bit (Write Protect)
S     * |        |          |The default value is set by flash controller user configuration register CBODEN (CONFIG0 [23]).
S     * |        |          |0 = Brown-out Detector function Disabled.
S     * |        |          |1 = Brown-out Detector function Enabled.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[2:1]   |BODVL     |Brown-out Detector Threshold Voltage Selection (Write Protect)
S     * |        |          |The default value is set by flash controller user configuration register CBOV (CONFIG0 [22:21]).
S     * |        |          |00 = Brown-Out Detector threshold voltage is 2.2V.
S     * |        |          |01 = Brown-Out Detector threshold voltage is 2.7V.
S     * |        |          |10 = Brown-Out Detector threshold voltage is 3.7V.
S     * |        |          |11 = Brown-Out Detector threshold voltage is 4.5V.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[3]     |BODRSTEN  |Brown-out Reset Enable Bit (Write Protect)
S     * |        |          |The default value is set by flash controller user configuration register CBORST(CONFIG0[20]) bit.
S     * |        |          |0 = Brown-out interrupt function Enabled.
S     * |        |          |1 = Brown-out reset function Enabled.
S     * |        |          |Note1:
S     * |        |          |While the Brown-out Detector function is enabled (BODEN high) and BOD reset function is enabled (BODRSTEN high), BOD will assert a signal to reset chip when the detected voltage is lower than the threshold (BODOUT high).
S     * |        |          |While the BOD function is enabled (BODEN high) and BOD interrupt function is enabled (BODRSTEN low), BOD will assert an interrupt if BODOUT is high
S     * |        |          |BOD interrupt will keep till to the BODEN set to 0.
S     * |        |          |BOD interrupt can be blocked by disabling the NVIC BOD interrupt or disabling BOD function (set BODEN low).
S     * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[4]     |BODIF     |Brown-out Detector Interrupt Flag
S     * |        |          |0 = Brown-out Detector does not detect any voltage draft at VDD down through or up through the voltage of BODVL setting.
S     * |        |          |1 = When Brown-out Detector detects the VDD is dropped down through the voltage of BODVL setting or the VDD is raised up through the voltage of BODVL setting, this bit is set to 1 and the brown-out interrupt is requested if brown-out interrupt is enabled.
S     * |        |          |Note: This bit can be cleared by software writing 1.
S     * |[5]     |BODLPM    |Brown-out Detector Low Power Mode (Write Protect)
S     * |        |          |0 = BOD operate in normal mode (default).
S     * |        |          |1 = BOD Low Power mode Enabled.
S     * |        |          |Note1: The BOD consumes about 100uA in normal mode, the low power mode can reduce the current to about 1/10 but slow the BOD response.
S     * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[6]     |BODOUT    |Brown-out Detector Output Status
S     * |        |          |0 = Brown-out Detector output status is 0.
S     * |        |          |It means the detected voltage is higher than BODVL setting or BODEN is 0.
S     * |        |          |1 = Brown-out Detector output status is 1.
S     * |        |          |It means the detected voltage is lower than BODVL setting.
S     * |        |          |If the BODEN is 0, BOD function disabled, this bit always responds 0.
S     * |[7]     |LVREN     |Low Voltage Reset Enable Bit (Write Protect)
S     * |        |          |The LVR function resets the chip when the input power voltage is lower than LVR circuit setting.
S     * |        |          |LVR function is enabled by default.
S     * |        |          |0 = Low Voltage Reset function Disabled.
S     * |        |          |1 = Low Voltage Reset function Enabled.
S     * |        |          |Note1: After enabling the bit, the LVR function will be active with 200us delay for LVR output stable (default).
S     * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[10:8]  |BODDGSEL  |Brown-out Detector Output De-glitch Time Select (Write Protect)
S     * |        |          |000 = BOD output is sampled by RC10K clock.
S     * |        |          |001 = 4 system clock (HCLK).
S     * |        |          |010 = 8 system clock (HCLK).
S     * |        |          |011 = 16 system clock (HCLK).
S     * |        |          |100 = 32 system clock (HCLK).
S     * |        |          |101 = 64 system clock (HCLK).
S     * |        |          |110 = 128 system clock (HCLK).
S     * |        |          |111 = 256 system clock (HCLK).
S     * |        |          |Note: These bits are write protected. Refer to the SYS_REGLCTL register.
S     * |[14:12] |LVRDGSEL  |LVR Output De-glitch Time Select (Write Protect)
S     * |        |          |000 = Without de-glitch function.
S     * |        |          |001 = 4 system clock (HCLK).
S     * |        |          |010 = 8 system clock (HCLK).
S     * |        |          |011 = 16 system clock (HCLK).
S     * |        |          |100 = 32 system clock (HCLK).
S     * |        |          |101 = 64 system clock (HCLK).
S     * |        |          |110 = 128 system clock (HCLK).
S     * |        |          |111 = 256 system clock (HCLK).
S     * |        |          |Note: These bits are write protected. Refer to the SYS_REGLCTL register.
S     * |[16]    |EBODEN    |External BOD External Input Voltage Enable Bit
S     * |        |          |0 = EBOD detect external input voltage function Disabled.
S     * |        |          |1 = EBOD detect external input voltage function Enabled.
S     * |        |          |Note1: This function is still active in whole chip power-down mode.
S     * |        |          |Note2: This function need use LIRC or LXT as EBOD clock source, which is selected in EBODCKSEL (CLK_BODCLK[0]).
S     * |        |          |Note3: The input pin for EBOD detect voltage is selectabe by EBODPINSEL (SYS_BODCTL[17]).
S     * |[17]    |EBODPINSEL|External BOD External Input Voltage Pin Selection
S     * |        |          |0 = The input voltage is from P1.0.
S     * |        |          |1 = The input voltage is from P1.1.
S     * |        |          |Note1: If P1.0 is selected, multi-function pin must be selected correctly in P10MFP (SYS_GP1_MFPL[3:0]).
S     * |        |          |Note2: If P1.1 is selected, multi-function pin must be selected correctly in P11MFP (SYS_GP1_MFPL[7:4]).
S     * |[18]    |EBODIEN   |External BOD Interrupt Enable Bit
S     * |        |          |0 = EBOD interrupt Disabled.
S     * |        |          |1 = EBOD interrupt Enabled.
S     * |[19]    |EBODIF    |External BOD Interrupt Flag
S     * |        |          |0 = EBOD does not detect any voltage draft at external pin down through or up through the voltage of Bandgap.
S     * |        |          |1 = When EBOD detects the external pin is dropped down through the voltage of Bandgap or the external pin is raised up through the voltage of Bandgap, this bit is set to 1 and the brown-out interrupt is requested if brown-out interrupt is enabled.
S     * |        |          |Note: This bit can be cleared by software writing 1.
S     * |[21:20] |EBODDTSEL |External BOD Frequency Select for External Input Voltage
S     * |        |          |EBOD detect external voltage function can be enabled per serveral EBOD clocks for saving power.
S     * |        |          |00 = EBOD detect external voltage function is always enabled.
S     * |        |          |01 = EBOD detect external voltage function is enabled once per 64 EBOD clocks.
S     * |        |          |10 = EBOD detect external voltage function is enabled once per 128 EBOD clocks.
S     * |        |          |11 = EBOD detect external voltage function is enabled once per 256 EBOD clocks.
S     * |        |          |Note: The EBOD clock must be enabled. The EBOD clock is selected in EBODCKSEL (CLK_BODCLK[0]).
S     * |[23:22] |EBODBGSEL |External BOD Bandgap Enable Frequency Select for External Input Voltage
S     * |        |          |If EBODDTSEL (SYS_BODCTL[21:20]) is selected to 00, the EBOD bandgap can be enabled per serveral EBOD clocks for saving power.
S     * |        |          |00 = EBOD bandgap is always enabled.
S     * |        |          |01 = EBOD bandgap is enabled once per 64 EBOD clocks.
S     * |        |          |10 = EBOD bandgap is enabled once per 128 EBOD clocks.
S     * |        |          |11 = EBOD bandgap is enabled once per 256 EBOD clocks.
S     * |        |          |Note: The EBOD clock must be enabled. The EBOD clock is selected in EBODCKSEL (CLK_BODCLK[0]).
S     * |[24]    |EBODOUT   |External BOD Output Status
S     * |        |          |0 = EBOD output status is 0.
S     * |        |          |It means the detected voltage is higher than Bandgap or EBODEN is 0.
S     * |        |          |1 = EBOD output status is 1.
S     * |        |          |It means the detected voltage is lower than Bandgap.
S     * |        |          |If the EBODEN is 0, EBOD function disabled, this bit always responds 0.
S     * |[27:25] |EBODDGSEL |External BOD Output De-glitch Time Select (Write Protect)
S     * |        |          |000 = EBOD output is sampled by EBOD clock.
S     * |        |          |001 = 16 system clock (HCLK).
S     * |        |          |010 = 32 system clock (HCLK).
S     * |        |          |011 = 64 system clock (HCLK).
S     * |        |          |100 = 128 system clock (HCLK).
S     * |        |          |101 = 256 system clock (HCLK).
S     * |        |          |110 = 512 system clock (HCLK).
S     * |        |          |111 = 1024 system clock (HCLK).
S     * |        |          |Note: These bits are write protected. Refer to the SYS_REGLCTL register.
S     * @var SYS_T::IVSCTL
S     * Offset: 0x1C  Internal Voltage Source Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |VTEMPEN   |Temperature Sensor Enable Bit
S     * |        |          |This bit is used to enable/disable temperature sensor function.
S     * |        |          |0 = Temperature sensor function Disabled (default).
S     * |        |          |1 = Temperature sensor function Enabled.
S     * |        |          |Note: After this bit is set to 1, the value of temperature sensor output can be obtained from ADC conversion result.
S     * |[1]     |VBATUGEN  |VBAT Unity Gain Buffer Enable Bit
S     * |        |          |This bit is used to enable/disable VBAT unity gain buffer function.
S     * |        |          |0 = VBAT unity gain buffer function Disabled (default).
S     * |        |          |1 = VBAT unity gain buffer function Enabled.
S     * |        |          |Note: After this bit is set to 1, the value of VBAT unity gain buffer output voltage can be obtained from ADC conversion result.
S     * @var SYS_T::PORCTL
S     * Offset: 0x24  Power-on Reset Controller Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |POROFF    |Power-on Reset Enable Bit (Write Protect)
S     * |        |          |When powered on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again.
S     * |        |          |User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by writing 0x5AA5 to this field.
S     * |        |          |The POR function will be active again when this field is set to another value or chip is reset by other reset source, including:
S     * |        |          |nRESET, Watchdog, LVR reset, BOD reset, ICE reset command and the software-chip reset function.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * @var SYS_T::VREFCTL
S     * Offset: 0x28  VREF Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[4:0]   |VREFCTL   |VREF Control Bits (Write Protect)
S     * |        |          |00000 = From VREF pin.
S     * |        |          |00011 = VREF is internal 2.56V.
S     * |        |          |00111 = VREF is internal 2.048V.
S     * |        |          |01011 = VREF is internal 3.072V.
S     * |        |          |01111 = VREF is internal 4.096V.
S     * |        |          |10000 = VREF is from AVDD.
S     * |        |          |Others = Reserved.
S     * |        |          |Note: These bit are write protected. Refer to the SYS_REGLCTL register.
S     * @var SYS_T::GPA_MFPL
S     * Offset: 0x30  GPIOA Low Byte Multiple Function Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |PA0MFP    |PA.0 Multi-function Pin Selection
S     * |[7:4]   |PA1MFP    |PA.1 Multi-function Pin Selection
S     * |[11:8]  |PA2MFP    |PA.2 Multi-function Pin Selection
S     * |[15:12] |PA3MFP    |PA.3 Multi-function Pin Selection
S     * |[19:16] |PA4MFP    |PA.4 Multi-function Pin Selection
S     * |[23:20] |PA5MFP    |PA.5 Multi-function Pin Selection
S     * |[27:24] |PA6MFP    |PA.6 Multi-function Pin Selection
S     * |[31:28] |PA7MFP    |PA.7 Multi-function Pin Selection
S     * @var SYS_T::GPA_MFPH
S     * Offset: 0x34  GPIOA High Byte Multiple Function Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |PA8MFP    |PA.8 Multi-function Pin Selection
S     * |[7:4]   |PA9MFP    |PA.9 Multi-function Pin Selection
S     * |[11:8]  |PA10MFP   |PA.10 Multi-function Pin Selection
S     * |[15:12] |PA11MFP   |PA.11 Multi-function Pin Selection
S     * |[19:16] |PA12MFP   |PA.12 Multi-function Pin Selection
S     * |[23:20] |PA13MFP   |PA.13 Multi-function Pin Selection
S     * |[27:24] |PA14MFP   |PA.14 Multi-function Pin Selection
S     * |[31:28] |PA15MFP   |PA.15 Multi-function Pin Selection
S     * @var SYS_T::GPB_MFPL
S     * Offset: 0x38  GPIOB Low Byte Multiple Function Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |PB0MFP    |PB.0 Multi-function Pin Selection
S     * |[7:4]   |PB1MFP    |PB.1 Multi-function Pin Selection
S     * |[11:8]  |PB2MFP    |PB.2 Multi-function Pin Selection
S     * |[15:12] |PB3MFP    |PB.3 Multi-function Pin Selection
S     * |[19:16] |PB4MFP    |PB.4 Multi-function Pin Selection
S     * |[23:20] |PB5MFP    |PB.5 Multi-function Pin Selection
S     * |[27:24] |PB6MFP    |PB.6 Multi-function Pin Selection
S     * |[31:28] |PB7MFP    |PB.7 Multi-function Pin Selection
S     * @var SYS_T::GPB_MFPH
S     * Offset: 0x3C  GPIOB High Byte Multiple Function Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |PB8MFP    |PB.8 Multi-function Pin Selection
S     * |[7:4]   |PB9MFP    |PB.9 Multi-function Pin Selection
S     * |[11:8]  |PB10MFP   |PB.10 Multi-function Pin Selection
S     * |[15:12] |PB11MFP   |PB.11 Multi-function Pin Selection
S     * |[19:16] |PB12MFP   |PB.12 Multi-function Pin Selection
S     * |[23:20] |PB13MFP   |PB.13 Multi-function Pin Selection
S     * |[27:24] |PB14MFP   |PB.14 Multi-function Pin Selection
S     * |[31:28] |PB15MFP   |PB.15 Multi-function Pin Selection
S     * @var SYS_T::GPC_MFPL
S     * Offset: 0x40  GPIOC Low Byte Multiple Function Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |PC0MFP    |PC.0 Multi-function Pin Selection
S     * |[7:4]   |PC1MFP    |PC.1 Multi-function Pin Selection
S     * |[11:8]  |PC2MFP    |PC.2 Multi-function Pin Selection
S     * |[15:12] |PC3MFP    |PC.3 Multi-function Pin Selection
S     * |[19:16] |PC4MFP    |PC.4 Multi-function Pin Selection
S     * |[23:20] |PC5MFP    |PC.5 Multi-function Pin Selection
S     * |[27:24] |PC6MFP    |PC.6 Multi-function Pin Selection
S     * |[31:28] |PC7MFP    |PC.7 Multi-function Pin Selection
S     * @var SYS_T::GPC_MFPH
S     * Offset: 0x44  GPIOC High Byte Multiple Function Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |PC8MFP    |PC.8 Multi-function Pin Selection
S     * |[7:4]   |PC9MFP    |PC.9 Multi-function Pin Selection
S     * |[11:8]  |PC10MFP   |PC.10 Multi-function Pin Selection
S     * |[15:12] |PC11MFP   |PC.11 Multi-function Pin Selection
S     * |[19:16] |PC12MFP   |PC.12 Multi-function Pin Selection
S     * |[23:20] |PC13MFP   |PC.13 Multi-function Pin Selection
S     * |[27:24] |PC14MFP   |PC.14 Multi-function Pin Selection
S     * |[31:28] |PC15MFP   |PC.15 Multi-function Pin Selection
S     * @var SYS_T::GPD_MFPL
S     * Offset: 0x48  GPIOD Low Byte Multiple Function Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |PD0MFP    |PD.0 Multi-function Pin Selection
S     * |[7:4]   |PD1MFP    |PD.1 Multi-function Pin Selection
S     * |[11:8]  |PD2MFP    |PD.2 Multi-function Pin Selection
S     * |[15:12] |PD3MFP    |PD.3 Multi-function Pin Selection
S     * |[19:16] |PD4MFP    |PD.4 Multi-function Pin Selection
S     * |[23:20] |PD5MFP    |PD.5 Multi-function Pin Selection
S     * |[27:24] |PD6MFP    |PD.6 Multi-function Pin Selection
S     * |[31:28] |PD7MFP    |PD.7 Multi-function Pin Selection
S     * @var SYS_T::GPD_MFPH
S     * Offset: 0x4C  GPIOD High Byte Multiple Function Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |PD8MFP    |PD.8 Multi-function Pin Selection
S     * |[7:4]   |PD9MFP    |PD.9 Multi-function Pin Selection
S     * |[11:8]  |PD10MFP   |PD.10 Multi-function Pin Selection
S     * |[15:12] |PD11MFP   |PD.11 Multi-function Pin Selection
S     * |[19:16] |PD12MFP   |PD.12 Multi-function Pin Selection
S     * |[23:20] |PD13MFP   |PD.13 Multi-function Pin Selection
S     * |[27:24] |PD14MFP   |PD.14 Multi-function Pin Selection
S     * |[31:28] |PD15MFP   |PD.15 Multi-function Pin Selection
S     * @var SYS_T::GPE_MFPL
S     * Offset: 0x50  GPIOE Low Byte Multiple Function Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |PE0MFP    |PE.0 Multi-function Pin Selection
S     * |[7:4]   |PE1MFP    |PE.1 Multi-function Pin Selection
S     * |[11:8]  |PE2MFP    |PE.2 Multi-function Pin Selection
S     * |[15:12] |PE3MFP    |PE.3 Multi-function Pin Selection
S     * |[19:16] |PE4MFP    |PE.4 Multi-function Pin Selection
S     * |[23:20] |PE5MFP    |PE.5 Multi-function Pin Selection
S     * |[27:24] |PE6MFP    |PE.6 Multi-function Pin Selection
S     * |[31:28] |PE7MFP    |PE.7 Multi-function Pin Selection
S     * @var SYS_T::GPE_MFPH
S     * Offset: 0x54  GPIOE High Byte Multiple Function Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |PE8MFP    |PE.8 Multi-function Pin Selection
S     * |[7:4]   |PE9MFP    |PE.9 Multi-function Pin Selection
S     * |[11:8]  |PE10MFP   |PE.10 Multi-function Pin Selection
S     * |[15:12] |PE11MFP   |PE.11 Multi-function Pin Selection
S     * |[19:16] |PE12MFP   |PE.12 Multi-function Pin Selection
S     * |[23:20] |PE13MFP   |PE.13 Multi-function Pin Selection
S     * @var SYS_T::GPF_MFPL
S     * Offset: 0x58  GPIOF Low Byte Multiple Function Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |PF0MFP    |PF.0 Multi-function Pin Selection
S     * |[7:4]   |PF1MFP    |PF.1 Multi-function Pin Selection
S     * |[11:8]  |PF2MFP    |PF.2 Multi-function Pin Selection
S     * |[15:12] |PF3MFP    |PF.3 Multi-function Pin Selection
S     * |        |          |The default value is set by flash controller user configuration register CFGXT1(CONFIG0[27]) bit.
S     * |        |          |0 = PF.3 pin is configured as GPIO pins.
S     * |        |          |1 = PF.3 pin is configured as external 4~24 MHz external high speed crystal oscillator (HXT) pins.
S     * |[19:16] |PF4MFP    |PF.4 Multi-function Pin Selection
S     * |        |          |The default value is set by flash controller user configuration register CFGXT1(CONFIG0[27]) bit.
S     * |        |          |0 = PF.4 pin is configured as GPIO pins.
S     * |        |          |1 = PF.4 pin is configured as external 4~24 MHz external high speed crystal oscillator (HXT) pins.
S     * |[23:20] |PF5MFP    |PF.5 Multi-function Pin Selection
S     * |[27:24] |PF6MFP    |PF.6 Multi-function Pin Selection
S     * |[31:28] |PF7MFP    |PF.7 Multi-function Pin Selection
S     * @var SYS_T::IRCTCTL0
S     * Offset: 0x80  HIRC0 Trim Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |FREQSEL   |Trim Frequency Selection
S     * |        |          |This field indicates the target frequency of internal high speed RC oscillator 0 (HIRC0) auto trim.
S     * |        |          |During auto trim operation, if clock error detected with CESTOPEN(SYS_IRCTCTL0[8]) is set to 1 or trim retry limitation count reached, this field will be cleared to 00 automatically.
S     * |        |          |00 = Disable HIRC0 auto trim function.
S     * |        |          |01 = Enable HIRC0 auto trim function and trim HIRC to 22.1184 MHz.
S     * |        |          |10 = Reserved.
S     * |        |          |11 = Reserved.
S     * |[5:4]   |LOOPSEL   |Trim Calculation Loop Selection
S     * |        |          |This field defines that trim value calculation is based on how many clocks of reference clock (32.768 kHz, LXT).
S     * |        |          |00 = Trim value calculation is based on average difference in 4 clocks of reference clock.
S     * |        |          |01 = Trim value calculation is based on average difference in 8 clocks of reference clock.
S     * |        |          |10 = Trim value calculation is based on average difference in 16 clocks of reference clock.
S     * |        |          |11 = Trim value calculation is based on average difference in 32 clocks of reference clock.
S     * |        |          |Note: For example, if LOOPSEL is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 clocks of reference clock.
S     * |[7:6]   |RETRYCNT  |Trim Value Update Limitation Count
S     * |        |          |This field defines that how many times the auto trim circuit will try to update the HIRC0 trim value before the frequency of HIRC0 locked.
S     * |        |          |Once the HIRC0 locked, the internal trim value update counter will be reset.
S     * |        |          |If the trim value update counter reached this limitation value and frequency of HIRC0 still does not lock, the auto trim operation will be disabled and FREQSEL(SYS_IRCTCTL0[1:0]) will be cleared to 00.
S     * |        |          |00 = Trim retry count limitation is 64 loops.
S     * |        |          |01 = Trim retry count limitation is 128 loops.
S     * |        |          |10 = Trim retry count limitation is 256 loops.
S     * |        |          |11 = Trim retry count limitation is 512 loops.
S     * |[8]     |CESTOPEN  |Clock Error Stop Enable Bit
S     * |        |          |0 = The trim operation is keep going if clock is inaccuracy.
S     * |        |          |1 = The trim operation is stopped if clock is inaccuracy.
S     * |[10]    |REFCKSEL  |Reference Clock Selection
S     * |        |          |0 = HIRC trim reference clock is from LXT (32.768 kHz).
S     * |        |          |1 = HIRC trim reference clock is from internal USB synchronous mode.
S     * @var SYS_T::IRCTIEN
S     * Offset: 0x84  HIRC Trim Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |TFAILIEN  |HIRC0 Trim Failure Interrupt Enable Bit
S     * |        |          |This bit controls if an interrupt will be triggered while HIRC0 trim value update limitation count reached and HIRC frequency still not locked on target frequency set by FREQSEL(SYS_IRCTCTL0[1:0]).
S     * |        |          |If this bit is high and TFAILIF(SYS_IRCTSTS0[1]) is set during auto trim operation, an interrupt will be triggered to notify that HIRC0 trim value update limitation count was reached.
S     * |        |          |0 = Disable TFAILIF(SYS_IRCTSTS0[1]) status to trigger an interrupt to CPU.
S     * |        |          |1 = Enable TFAILIF(SYS_IRCTSTS0[1]) status to trigger an interrupt to CPU.
S     * |[2]     |CLKEIEN   |HIRC0 Clock Error Interrupt Enable Bit
S     * |        |          |This bit controls if CPU would get an interrupt while HIRC0 clock is inaccuracy during auto trim operation.
S     * |        |          |If this bit is set to1, and CLKERRIF(SYS_IRCTSTS0[2]) is set during auto trim operation, an interrupt will be triggered to notify the clock frequency is inaccuracy.
S     * |        |          |0 = Disable CLKERRIF(SYS_IRCTSTS0[2]) status to trigger an interrupt to CPU.
S     * |        |          |1 = Enable CLKERRIF(SYS_IRCTSTS0[2]) status to trigger an interrupt to CPU.
S     * |[9]     |TFAILIEN1 |HIRC1 Trim Failure Interrupt Enable Bit
S     * |        |          |This bit controls if an interrupt will be triggered while HIRC1 trim value update limitation count reached and HIRC1 frequency still not locked on target frequency set by FREQSEL(SYS_IRCTCTL1[1:0]).
S     * |        |          |If this bit is high and TFAILIF(SYS_IRCTSTS[1]) is set during auto trim operation, an interrupt will be triggered to notify that HIRC1 trim value update limitation count was reached.
S     * |        |          |0 = Disable TFAILIF(SYS_IRCTSTS[1]) status to trigger an interrupt to CPU.
S     * |        |          |1 = Enable TFAILIF(SYS_IRCTSTS[1]) status to trigger an interrupt to CPU.
S     * |[10]    |CLKEIEN1  |HIRC1 Clock Error Interrupt Enable Bit
S     * |        |          |This bit controls if CPU would get an interrupt while HIRC1 clock is inaccuracy during auto trim operation.
S     * |        |          |If this bit is set to1, and CLKERRIF(SYS_IRCTSTS[2]) is set during auto trim operation, an interrupt will be triggered to notify the clock frequency is inaccuracy.
S     * |        |          |0 = Disable CLKERRIF(SYS_IRCTSTS[2]) status to trigger an interrupt to CPU.
S     * |        |          |1 = Enable CLKERRIF(SYS_IRCTSTS[2]) status to trigger an interrupt to CPU.
S     * @var SYS_T::IRCTISTS
S     * Offset: 0x88  HIRC Trim Interrupt Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |FREQLOCK  |HIRC Frequency Lock Status
S     * |        |          |This bit indicates the HIRC0 frequency is locked.
S     * |        |          |This is a status bit and doesnu2019t trigger any interrupt.
S     * |        |          |0 = The internal high-speed RC oscillator 0 frequency does not lock at 22.1184 MHz yet.
S     * |        |          |1 = The internal high-speed RC oscillator 0 frequency locked at 22.1184 MHz.
S     * |[1]     |TFAILIF   |Trim Failure Interrupt Status
S     * |        |          |This bit indicates that HIRC0 trim value update limitation count reached and the HIRC0 clock frequency still does not be locked.
S     * |        |          |Once this bit is set, the auto trim operation stopped and FREQSEL(SYS_iRCTCTL0[1:0]) will be cleared to 00 by hardware automatically.
S     * |        |          |If this bit is set and TFAILIEN(SYS_IRCTIEN0[1]) is high, an interrupt will be triggered to notify that HIRC0 trim value update limitation count was reached.
S     * |        |          |Write 1 to clear this to 0.
S     * |        |          |0 = Trim value update limitation count does not reach.
S     * |        |          |1 = Trim value update limitation count reached and HIRC frequency still not locked.
S     * |[2]     |CLKERRIF  |Clock Error Interrupt Status
S     * |        |          |When the frequency of 32.768 kHz external low speed crystal oscillator (LXT) or 22.1184 MHz internal high speed RC oscillator 0 (HIRC0) is shift larger to unreasonable value, this bit will be set and to be an indicate that clock frequency is inaccuracy.
S     * |        |          |Once this bit is set to 1, the auto trim operation stopped and FREQSEL(SYS_IRCTCL0[1:0]) will be cleared to 00 by hardware automatically if CESTOPEN(SYS_IRCTCTL0[8]) is set to 1.
S     * |        |          |If this bit is set and CLKEIEN(SYS_IRCTIEN0[2]) is high, an interrupt will be triggered to notify the clock frequency is inaccuracy.
S     * |        |          |Write 1 to clear this to 0.
S     * |        |          |0 = Clock frequency is accuracy.
S     * |        |          |1 = Clock frequency is inaccuracy.
S     * |[8]     |FREQLOCK1 |HIRC1 Frequency Lock Status
S     * |        |          |This bit indicates the HIRC1 frequency is locked.
S     * |        |          |This is a status bit and doesn not trigger any interrupt.
S     * |        |          |0 = The internal high-speed RC oscillator 1 frequency does not lock at 48 MHz yet.
S     * |        |          |1 = The internal high-speed RC oscillator 1 frequency locked at 48 MHz.
S     * |[9]     |TFAILIF1  |HIRC1 Trim Failure Interrupt Status
S     * |        |          |This bit indicates that HIRC1 trim value update limitation count reached and the HIRC1 clock frequency still doesn not be locked
S     * |        |          |Once this bit is set, the auto trim operation stopped and FREQSEL(SYS_iRCTCTL1[1:0]) will be cleared to 00 by hardware automatically.
S     * |        |          |If this bit is set and TFAILIEN(SYS_IRCTIEN1[1]) is high, an interrupt will be triggered to notify that HIRC1 trim value update limitation count was reached.
S     * |        |          |Write 1 to clear this to 0.
S     * |        |          |0 = HIRC1 trim value update limitation count does not reach.
S     * |        |          |1 = HIRC1 trim value update limitation count reached and frequency still not locked.
S     * |[10]    |CLKERRIF1 |HIRC1 Clock Error Interrupt Status
S     * |        |          |When the frequency of 48 MHz internal high speed RC oscillator 1 (HIRC1) is shift larger to unreasonable value, this bit will be set and to be an indicate that clock frequency is inaccuracy.
S     * |        |          |Once this bit is set to 1, the auto trim operation stopped and FREQSEL(SYS_IRCTCL1[1:0]) will be cleared to 00 by hardware automatically if CESTOPEN(SYS_IRCTCTL1[8]) is set to 1.
S     * |        |          |If this bit is set and CLKEIEN(SYS_IRCTIEN1[2]) is high, an interrupt will be triggered to notify the clock frequency is inaccuracy.
S     * |        |          |Write 1 to clear this to 0.
S     * |        |          |0 = HIRC1 Clock frequency is accuracy.
S     * |        |          |1 = HIRC1 Clock frequency is inaccuracy.
S     * @var SYS_T::IRCTCTL1
S     * Offset: 0x90  HIRC1 Trim Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |FREQSEL   |Trim Frequency Selection
S     * |        |          |This field indicates the target frequency of internal high speed RC oscillator 1 (HIRC 1) auto trim.
S     * |        |          |During auto trim operation, if clock error detected with CESTOPEN(SYS_IRCTCTL1[8]) is set to 1 or trim retry limitation count reached, this field will be cleared to 00 automatically.
S     * |        |          |00 = Disable HIRC1 auto trim function.
S     * |        |          |01 = Reserved.
S     * |        |          |10 = Enable HIRC1 auto trim function and trim HIRC to 48 MHz.
S     * |        |          |11 = Reserved.
S     * |[5:4]   |LOOPSEL   |Trim Calculation Loop Selection
S     * |        |          |This field defines that trim value calculation is based on how many clocks of reference clock.
S     * |        |          |00 = Trim value calculation is based on average difference in 4 clocks of reference clock.
S     * |        |          |01 = Trim value calculation is based on average difference in 8 clocks of reference clock.
S     * |        |          |10 = Trim value calculation is based on average difference in 16 clocks of reference clock.
S     * |        |          |11 = Trim value calculation is based on average difference in 32 clocks of reference clock.
S     * |        |          |Note: For example, if LOOPSEL is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 clocks of reference clock.
S     * |[7:6]   |RETRYCNT  |Trim Value Update Limitation Count
S     * |        |          |This field defines that how many times the auto trim circuit will try to update the HIRC1 trim value before the frequency of HIRC1 locked.
S     * |        |          |Once the HIRC1 locked, the internal trim value update counter will be reset.
S     * |        |          |If the trim value update counter reached this limitation value and frequency of HIRC1 still doesnu2019t lock, the auto trim operation will be disabled and FREQSEL(SYS_IRCTCTL1[1:0]) will be cleared to 00.
S     * |        |          |00 = Trim retry count limitation is 64 loops.
S     * |        |          |01 = Trim retry count limitation is 128 loops.
S     * |        |          |10 = Trim retry count limitation is 256 loops.
S     * |        |          |11 = Trim retry count limitation is 512 loops.
S     * |[8]     |CESTOPEN  |Clock Error Stop Enable Bit
S     * |        |          |0 = The trim operation is keep going if clock is inaccuracy.
S     * |        |          |1 = The trim operation is stopped if clock is inaccuracy.
S     * |[10]    |REFCKSEL  |Reference Clock Selection
S     * |        |          |0 = HIRC trim reference clock is from LXT (32.768 kHz).
S     * |        |          |1 = HIRC trim reference clock is from internal USB synchronous mode.
S     * @var SYS_T::MODCTL
S     * Offset: 0xC0  Modulation Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |MODEN     |Modulation Function Enable Bit
S     * |        |          |This bit enables modulation funcion by modulating with PWM channel output and UART1_TXD.
S     * |        |          |0 = Modulation Function Disabled.
S     * |        |          |1 = Modulation Function Enabled.
S     * |[1]     |MODH      |Modulation at Data High
S     * |        |          |Select modulation pulse(PWM) at UART1_TXD high or low.
S     * |        |          |0 = Modulation pulse at UART1_TXD low.
S     * |        |          |1 = Modulation pulse at UART1_TXD high.
S     * |[6:4]   |MODPWMSEL |PWM0 Channel Select for Modulation
S     * |        |          |Select the PWM0 channel to modulate with the UART1_TXD.
S     * |        |          |000 = PWM0 channel 0 modulate with UART1_TXD.
S     * |        |          |001 = PWM0 channel 1 modulate with UART1_TXD.
S     * |        |          |010 = PWM0 channel 2 modulate with UART1_TXD.
S     * |        |          |011 = PWM0 channel 3 modulete with UART1_TXD.
S     * |        |          |Others = Reserved.
S     * |        |          |Note: This bis is valid while MODEN (SYS_MODCTL[0]) is set to 1.
S     * @var SYS_T::SRAM_BISTCTL
S     * Offset: 0xD0  System SRAM BIST Test Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SRBIST    |SRAM BIST Enable Bit (Write Protect)
S     * |        |          |This bit enables BIST test for SRAM located in address 0x2000_0000~0x2000_4FFF
S     * |        |          |0 = System SRAM BIST Disabled.
S     * |        |          |1 = System SRAM BIST Enabled.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[2]     |CRBIST    |CACHE BIST Enable Bit (Write Protect)
S     * |        |          |This bit enables BIST test for CACHE RAM.
S     * |        |          |0 = System CACHE BIST Disabled.
S     * |        |          |1 = System CACHE BIST Enabled.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[4]     |USBBIST   |USB BIST Enable Bit (Write Protect)
S     * |        |          |This bit enables BIST test for USB RAM.
S     * |        |          |0 = System USB BIST Disabled.
S     * |        |          |1 = System USB BIST Enabled.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * @var SYS_T::SRAM_BISTSTS
S     * Offset: 0xD4  System SRAM BIST Test Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SRBISTEF  |System SRAM BIST Fail Flag
S     * |        |          |0 = System SRAM BIST test pass.
S     * |        |          |1 = System SRAM BIST test fail.
S     * |[2]     |CRBISTEF  |CACHE SRAM BIST Fail Flag
S     * |        |          |0 = System CACHE RAM BIST test pass.
S     * |        |          |1 = System CACHE RAM BIST test fail.
S     * |[4]     |USBBEF    |USB SRAM BIST Fail Flag
S     * |        |          |0 = USB SRAM BIST test pass.
S     * |        |          |1 = USB SRAM BIST test fail.
S     * |[16]    |SRBEND    |SRAM BIST Test Finish
S     * |        |          |0 = System SRAM BIST active.
S     * |        |          |1 = System SRAM BIST finish.
S     * |[18]    |CRBEND    |CACHE SRAM BIST Test Finish
S     * |        |          |0 = System CACHE RAM BIST is active.
S     * |        |          |1 = System CACHE RAM BIST test finish.
S     * |[20]    |USBBEND   |USB SRAM BIST Test Finish
S     * |        |          |0 = USB SRAM BIST is active.
S     * |        |          |1 = USB SRAM BIST test finish.
S     * @var SYS_T::REGLCTL
S     * Offset: 0x100  Register Lock Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |REGLCTL   |Register Lock Control Code
S     * |        |          |Write operation:
S     * |        |          |Some registers have write-protection function.
S     * |        |          |Writing these registers have to disable the protected function by writing the sequence value "59h", "16h", "88h" to this field.
S     * |        |          |After this sequence is completed, the REGLCTL bit will be set to 1 and write-protection registers can be normal write.
S     * |        |          |Read operation:
S     * |        |          |0 = Write-protection Enabled for writing protected registers. Any write to the protected register is ignored.
S     * |        |          |1 = Write-protection Disabled for writing protected registers.
S     * @var SYS_T::TSOFFSET
S     * Offset: 0x114  Temperature Sensor Offset Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |VTEMP     |Temperature Sensor Offset Value
S     * |        |          |This field reflects temperature sensor output voltage offset at 25 Celsius degree from flash.
S     */
S
S    __I  uint32_t PDID;                  /*!< [0x0000] Part Device Identification Number Register                       */
S    __IO uint32_t RSTSTS;                /*!< [0x0004] System Reset Status Register                                     */
S    __IO uint32_t IPRST0;                /*!< [0x0008] Peripheral  Reset Control Register 0                             */
S    __IO uint32_t IPRST1;                /*!< [0x000c] Peripheral Reset Control Register 1                              */
S    __IO uint32_t IPRST2;                /*!< [0x0010] Peripheral Reset Control Register 2                              */
S    __I  uint32_t RESERVE0[1];
S    __IO uint32_t BODCTL;                /*!< [0x0018] Brown-out Detector Control Register                              */
S    __IO uint32_t IVSCTL;                /*!< [0x001c] Internal Voltage Source Control Register                         */
S    __I  uint32_t RESERVE1[1];
S    __IO uint32_t PORCTL;                /*!< [0x0024] Power-on Reset Controller Register                               */
S    __IO uint32_t VREFCTL;               /*!< [0x0028] VREF Control Register                                            */
S    __I  uint32_t RESERVE2[1];
S    __IO uint32_t GPA_MFPL;              /*!< [0x0030] GPIOA Low Byte Multiple Function Control Register                */
S    __IO uint32_t GPA_MFPH;              /*!< [0x0034] GPIOA High Byte Multiple Function Control Register               */
S    __IO uint32_t GPB_MFPL;              /*!< [0x0038] GPIOB Low Byte Multiple Function Control Register                */
S    __IO uint32_t GPB_MFPH;              /*!< [0x003c] GPIOB High Byte Multiple Function Control Register               */
S    __IO uint32_t GPC_MFPL;              /*!< [0x0040] GPIOC Low Byte Multiple Function Control Register                */
S    __IO uint32_t GPC_MFPH;              /*!< [0x0044] GPIOC High Byte Multiple Function Control Register               */
S    __IO uint32_t GPD_MFPL;              /*!< [0x0048] GPIOD Low Byte Multiple Function Control Register                */
S    __IO uint32_t GPD_MFPH;              /*!< [0x004c] GPIOD High Byte Multiple Function Control Register               */
S    __IO uint32_t GPE_MFPL;              /*!< [0x0050] GPIOE Low Byte Multiple Function Control Register                */
S    __IO uint32_t GPE_MFPH;              /*!< [0x0054] GPIOE High Byte Multiple Function Control Register               */
S    __IO uint32_t GPF_MFPL;              /*!< [0x0058] GPIOF Low Byte Multiple Function Control Register                */
S    __I  uint32_t RESERVE3[9];
S    __IO uint32_t IRCTCTL0;              /*!< [0x0080] HIRC0 Trim Control Register                                      */
S    __IO uint32_t IRCTIEN;               /*!< [0x0084] HIRC Trim Interrupt Enable Register                              */
S    __IO uint32_t IRCTISTS;              /*!< [0x0088] HIRC Trim Interrupt Status Register                              */
S    __I  uint32_t RESERVE4[1];
S    __IO uint32_t IRCTCTL1;              /*!< [0x0090] HIRC1 Trim Control Register                                      */
S    __I  uint32_t RESERVE5[11];
S    __IO uint32_t MODCTL;                /*!< [0x00c0] Modulation Control Register                                      */
S    __I  uint32_t RESERVE6[3];
S    __IO uint32_t SRAM_BISTCTL;          /*!< [0x00d0] System SRAM BIST Test Control Register                           */
S    __I  uint32_t SRAM_BISTSTS;          /*!< [0x00d4] System SRAM BIST Test Status Register                            */
S    __I  uint32_t RESERVE7[10];
S    __IO uint32_t REGLCTL;               /*!< [0x0100] Register Lock Control Register                                   */
S    __I  uint32_t RESERVE8[4];
S    __I  uint32_t TSOFFSET;              /*!< [0x0114] Temperature Sensor Offset Register                               */
S
S
S} SYS_T;
S
S/**
S    @addtogroup SYS_CONST SYS Bit Field Definition
S    Constant Definitions for SYS Controller
S@{ */
S
S#define SYS_PDID_PDID_Pos                (0)                                               /*!< SYS_T::PDID: PDID Position             */
S#define SYS_PDID_PDID_Msk                (0xfffffffful << SYS_PDID_PDID_Pos)               /*!< SYS_T::PDID: PDID Mask                 */
S
S#define SYS_RSTSTS_PORF_Pos              (0)                                               /*!< SYS_T::RSTSTS: PORF Position           */
S#define SYS_RSTSTS_PORF_Msk              (0x1ul << SYS_RSTSTS_PORF_Pos)                    /*!< SYS_T::RSTSTS: PORF Mask               */
S
S#define SYS_RSTSTS_PINRF_Pos             (1)                                               /*!< SYS_T::RSTSTS: PINRF Position          */
S#define SYS_RSTSTS_PINRF_Msk             (0x1ul << SYS_RSTSTS_PINRF_Pos)                   /*!< SYS_T::RSTSTS: PINRF Mask              */
S
S#define SYS_RSTSTS_WDTRF_Pos             (2)                                               /*!< SYS_T::RSTSTS: WDTRF Position          */
S#define SYS_RSTSTS_WDTRF_Msk             (0x1ul << SYS_RSTSTS_WDTRF_Pos)                   /*!< SYS_T::RSTSTS: WDTRF Mask              */
S
S#define SYS_RSTSTS_LVRF_Pos              (3)                                               /*!< SYS_T::RSTSTS: LVRF Position           */
S#define SYS_RSTSTS_LVRF_Msk              (0x1ul << SYS_RSTSTS_LVRF_Pos)                    /*!< SYS_T::RSTSTS: LVRF Mask               */
S
S#define SYS_RSTSTS_BODRF_Pos             (4)                                               /*!< SYS_T::RSTSTS: BODRF Position          */
S#define SYS_RSTSTS_BODRF_Msk             (0x1ul << SYS_RSTSTS_BODRF_Pos)                   /*!< SYS_T::RSTSTS: BODRF Mask              */
S
S#define SYS_RSTSTS_MCURF_Pos             (5)                                               /*!< SYS_T::RSTSTS: MCURF Position          */
S#define SYS_RSTSTS_MCURF_Msk             (0x1ul << SYS_RSTSTS_MCURF_Pos)                   /*!< SYS_T::RSTSTS: MCURF Mask              */
S
S#define SYS_RSTSTS_CPURF_Pos             (7)                                               /*!< SYS_T::RSTSTS: CPURF Position          */
S#define SYS_RSTSTS_CPURF_Msk             (0x1ul << SYS_RSTSTS_CPURF_Pos)                   /*!< SYS_T::RSTSTS: CPURF Mask              */
S
S#define SYS_RSTSTS_CPULKRF_Pos           (8)                                               /*!< SYS_T::RSTSTS: CPULKRF Position        */
S#define SYS_RSTSTS_CPULKRF_Msk           (0x1ul << SYS_RSTSTS_CPULKRF_Pos)                 /*!< SYS_T::RSTSTS: CPULKRF Mask            */
S
S#define SYS_IPRST0_CHIPRST_Pos           (0)                                               /*!< SYS_T::IPRST0: CHIPRST Position        */
S#define SYS_IPRST0_CHIPRST_Msk           (0x1ul << SYS_IPRST0_CHIPRST_Pos)                 /*!< SYS_T::IPRST0: CHIPRST Mask            */
S
S#define SYS_IPRST0_CPURST_Pos            (1)                                               /*!< SYS_T::IPRST0: CPURST Position         */
S#define SYS_IPRST0_CPURST_Msk            (0x1ul << SYS_IPRST0_CPURST_Pos)                  /*!< SYS_T::IPRST0: CPURST Mask             */
S
S#define SYS_IPRST0_PDMARST_Pos           (2)                                               /*!< SYS_T::IPRST0: PDMARST Position        */
S#define SYS_IPRST0_PDMARST_Msk           (0x1ul << SYS_IPRST0_PDMARST_Pos)                 /*!< SYS_T::IPRST0: PDMARST Mask            */
S
S#define SYS_IPRST0_EBIRST_Pos            (3)                                               /*!< SYS_T::IPRST0: EBIRST Position         */
S#define SYS_IPRST0_EBIRST_Msk            (0x1ul << SYS_IPRST0_EBIRST_Pos)                  /*!< SYS_T::IPRST0: EBIRST Mask             */
S
S#define SYS_IPRST0_HDIVRST_Pos           (4)                                               /*!< SYS_T::IPRST0: HDIVRST Position        */
S#define SYS_IPRST0_HDIVRST_Msk           (0x1ul << SYS_IPRST0_HDIVRST_Pos)                 /*!< SYS_T::IPRST0: HDIVRST Mask            */
S
S#define SYS_IPRST0_CRCRST_Pos            (7)                                               /*!< SYS_T::IPRST0: CRCRST Position         */
S#define SYS_IPRST0_CRCRST_Msk            (0x1ul << SYS_IPRST0_CRCRST_Pos)                  /*!< SYS_T::IPRST0: CRCRST Mask             */
S
S#define SYS_IPRST1_GPIORST_Pos           (1)                                               /*!< SYS_T::IPRST1: GPIORST Position        */
S#define SYS_IPRST1_GPIORST_Msk           (0x1ul << SYS_IPRST1_GPIORST_Pos)                 /*!< SYS_T::IPRST1: GPIORST Mask            */
S
S#define SYS_IPRST1_TMR0RST_Pos           (2)                                               /*!< SYS_T::IPRST1: TMR0RST Position        */
S#define SYS_IPRST1_TMR0RST_Msk           (0x1ul << SYS_IPRST1_TMR0RST_Pos)                 /*!< SYS_T::IPRST1: TMR0RST Mask            */
S
S#define SYS_IPRST1_TMR1RST_Pos           (3)                                               /*!< SYS_T::IPRST1: TMR1RST Position        */
S#define SYS_IPRST1_TMR1RST_Msk           (0x1ul << SYS_IPRST1_TMR1RST_Pos)                 /*!< SYS_T::IPRST1: TMR1RST Mask            */
S
S#define SYS_IPRST1_TMR2RST_Pos           (4)                                               /*!< SYS_T::IPRST1: TMR2RST Position        */
S#define SYS_IPRST1_TMR2RST_Msk           (0x1ul << SYS_IPRST1_TMR2RST_Pos)                 /*!< SYS_T::IPRST1: TMR2RST Mask            */
S
S#define SYS_IPRST1_TMR3RST_Pos           (5)                                               /*!< SYS_T::IPRST1: TMR3RST Position        */
S#define SYS_IPRST1_TMR3RST_Msk           (0x1ul << SYS_IPRST1_TMR3RST_Pos)                 /*!< SYS_T::IPRST1: TMR3RST Mask            */
S
S#define SYS_IPRST1_I2C0RST_Pos           (8)                                               /*!< SYS_T::IPRST1: I2C0RST Position        */
S#define SYS_IPRST1_I2C0RST_Msk           (0x1ul << SYS_IPRST1_I2C0RST_Pos)                 /*!< SYS_T::IPRST1: I2C0RST Mask            */
S
S#define SYS_IPRST1_I2C1RST_Pos           (9)                                               /*!< SYS_T::IPRST1: I2C1RST Position        */
S#define SYS_IPRST1_I2C1RST_Msk           (0x1ul << SYS_IPRST1_I2C1RST_Pos)                 /*!< SYS_T::IPRST1: I2C1RST Mask            */
S
S#define SYS_IPRST1_SPI0RST_Pos           (12)                                              /*!< SYS_T::IPRST1: SPI0RST Position        */
S#define SYS_IPRST1_SPI0RST_Msk           (0x1ul << SYS_IPRST1_SPI0RST_Pos)                 /*!< SYS_T::IPRST1: SPI0RST Mask            */
S
S#define SYS_IPRST1_SPI1RST_Pos           (13)                                              /*!< SYS_T::IPRST1: SPI1RST Position        */
S#define SYS_IPRST1_SPI1RST_Msk           (0x1ul << SYS_IPRST1_SPI1RST_Pos)                 /*!< SYS_T::IPRST1: SPI1RST Mask            */
S
S#define SYS_IPRST1_UART0RST_Pos          (16)                                              /*!< SYS_T::IPRST1: UART0RST Position       */
S#define SYS_IPRST1_UART0RST_Msk          (0x1ul << SYS_IPRST1_UART0RST_Pos)                /*!< SYS_T::IPRST1: UART0RST Mask           */
S
S#define SYS_IPRST1_UART1RST_Pos          (17)                                              /*!< SYS_T::IPRST1: UART1RST Position       */
S#define SYS_IPRST1_UART1RST_Msk          (0x1ul << SYS_IPRST1_UART1RST_Pos)                /*!< SYS_T::IPRST1: UART1RST Mask           */
S
S#define SYS_IPRST1_UART2RST_Pos          (18)                                              /*!< SYS_T::IPRST1: UART2RST Position       */
S#define SYS_IPRST1_UART2RST_Msk          (0x1ul << SYS_IPRST1_UART2RST_Pos)                /*!< SYS_T::IPRST1: UART2RST Mask           */
S
S#define SYS_IPRST1_PWM0RST_Pos           (20)                                              /*!< SYS_T::IPRST1: PWM0RST Position        */
S#define SYS_IPRST1_PWM0RST_Msk           (0x1ul << SYS_IPRST1_PWM0RST_Pos)                 /*!< SYS_T::IPRST1: PWM0RST Mask            */
S
S#define SYS_IPRST1_PWM1RST_Pos           (21)                                              /*!< SYS_T::IPRST1: PWM1RST Position        */
S#define SYS_IPRST1_PWM1RST_Msk           (0x1ul << SYS_IPRST1_PWM1RST_Pos)                 /*!< SYS_T::IPRST1: PWM1RST Mask            */
S
S#define SYS_IPRST1_ACMP01RST_Pos         (22)                                              /*!< SYS_T::IPRST1: ACMP01RST Position      */
S#define SYS_IPRST1_ACMP01RST_Msk         (0x1ul << SYS_IPRST1_ACMP01RST_Pos)               /*!< SYS_T::IPRST1: ACMP01RST Mask          */
S
S#define SYS_IPRST1_USBDRST_Pos           (27)                                              /*!< SYS_T::IPRST1: USBDRST Position        */
S#define SYS_IPRST1_USBDRST_Msk           (0x1ul << SYS_IPRST1_USBDRST_Pos)                 /*!< SYS_T::IPRST1: USBDRST Mask            */
S
S#define SYS_IPRST1_ADCRST_Pos            (28)                                              /*!< SYS_T::IPRST1: ADCRST Position         */
S#define SYS_IPRST1_ADCRST_Msk            (0x1ul << SYS_IPRST1_ADCRST_Pos)                  /*!< SYS_T::IPRST1: ADCRST Mask             */
S
S#define SYS_IPRST2_SC0RST_Pos            (0)                                               /*!< SYS_T::IPRST2: SC0RST Position         */
S#define SYS_IPRST2_SC0RST_Msk            (0x1ul << SYS_IPRST2_SC0RST_Pos)                  /*!< SYS_T::IPRST2: SC0RST Mask             */
S
S#define SYS_IPRST2_SC1RST_Pos            (1)                                               /*!< SYS_T::IPRST2: SC1RST Position         */
S#define SYS_IPRST2_SC1RST_Msk            (0x1ul << SYS_IPRST2_SC1RST_Pos)                  /*!< SYS_T::IPRST2: SC1RST Mask             */
S
S#define SYS_IPRST2_USCI0RST_Pos          (8)                                               /*!< SYS_T::IPRST2: USCI0RST Position       */
S#define SYS_IPRST2_USCI0RST_Msk          (0x1ul << SYS_IPRST2_USCI0RST_Pos)                /*!< SYS_T::IPRST2: USCI0RST Mask           */
S
S#define SYS_IPRST2_USCI1RST_Pos          (9)                                               /*!< SYS_T::IPRST2: USCI1RST Position       */
S#define SYS_IPRST2_USCI1RST_Msk          (0x1ul << SYS_IPRST2_USCI1RST_Pos)                /*!< SYS_T::IPRST2: USCI1RST Mask           */
S
S#define SYS_IPRST2_USCI2RST_Pos          (10)                                              /*!< SYS_T::IPRST2: USCI2RST Position       */
S#define SYS_IPRST2_USCI2RST_Msk          (0x1ul << SYS_IPRST2_USCI2RST_Pos)                /*!< SYS_T::IPRST2: USCI2RST Mask           */
S
S#define SYS_BODCTL_BODEN_Pos             (0)                                               /*!< SYS_T::BODCTL: BODEN Position          */
S#define SYS_BODCTL_BODEN_Msk             (0x1ul << SYS_BODCTL_BODEN_Pos)                   /*!< SYS_T::BODCTL: BODEN Mask              */
S
S#define SYS_BODCTL_BODVL_Pos             (1)                                               /*!< SYS_T::BODCTL: BODVL Position          */
S#define SYS_BODCTL_BODVL_Msk             (0x3ul << SYS_BODCTL_BODVL_Pos)                   /*!< SYS_T::BODCTL: BODVL Mask              */
S
S#define SYS_BODCTL_BODRSTEN_Pos          (3)                                               /*!< SYS_T::BODCTL: BODRSTEN Position       */
S#define SYS_BODCTL_BODRSTEN_Msk          (0x1ul << SYS_BODCTL_BODRSTEN_Pos)                /*!< SYS_T::BODCTL: BODRSTEN Mask           */
S
S#define SYS_BODCTL_BODIF_Pos             (4)                                               /*!< SYS_T::BODCTL: BODIF Position          */
S#define SYS_BODCTL_BODIF_Msk             (0x1ul << SYS_BODCTL_BODIF_Pos)                   /*!< SYS_T::BODCTL: BODIF Mask              */
S
S#define SYS_BODCTL_BODLPM_Pos            (5)                                               /*!< SYS_T::BODCTL: BODLPM Position         */
S#define SYS_BODCTL_BODLPM_Msk            (0x1ul << SYS_BODCTL_BODLPM_Pos)                  /*!< SYS_T::BODCTL: BODLPM Mask             */
S
S#define SYS_BODCTL_BODOUT_Pos            (6)                                               /*!< SYS_T::BODCTL: BODOUT Position         */
S#define SYS_BODCTL_BODOUT_Msk            (0x1ul << SYS_BODCTL_BODOUT_Pos)                  /*!< SYS_T::BODCTL: BODOUT Mask             */
S
S#define SYS_BODCTL_LVREN_Pos             (7)                                               /*!< SYS_T::BODCTL: LVREN Position          */
S#define SYS_BODCTL_LVREN_Msk             (0x1ul << SYS_BODCTL_LVREN_Pos)                   /*!< SYS_T::BODCTL: LVREN Mask              */
S
S#define SYS_BODCTL_BODDGSEL_Pos          (8)                                               /*!< SYS_T::BODCTL: BODDGSEL Position       */
S#define SYS_BODCTL_BODDGSEL_Msk          (0x7ul << SYS_BODCTL_BODDGSEL_Pos)                /*!< SYS_T::BODCTL: BODDGSEL Mask           */
S
S#define SYS_BODCTL_LVRDGSEL_Pos          (12)                                              /*!< SYS_T::BODCTL: LVRDGSEL Position       */
S#define SYS_BODCTL_LVRDGSEL_Msk          (0x7ul << SYS_BODCTL_LVRDGSEL_Pos)                /*!< SYS_T::BODCTL: LVRDGSEL Mask           */
S
S#define SYS_BODCTL_EBODEN_Pos            (16)                                              /*!< SYS_T::BODCTL: EBODEN Position         */
S#define SYS_BODCTL_EBODEN_Msk            (0x1ul << SYS_BODCTL_EBODEN_Pos)                  /*!< SYS_T::BODCTL: EBODEN Mask             */
S
S#define SYS_BODCTL_EBODPINSEL_Pos        (17)                                              /*!< SYS_T::BODCTL: EBODPINSEL Position     */
S#define SYS_BODCTL_EBODPINSEL_Msk        (0x1ul << SYS_BODCTL_EBODPINSEL_Pos)              /*!< SYS_T::BODCTL: EBODPINSEL Mask         */
S
S#define SYS_BODCTL_EBODIEN_Pos           (18)                                              /*!< SYS_T::BODCTL: EBODIEN Position        */
S#define SYS_BODCTL_EBODIEN_Msk           (0x1ul << SYS_BODCTL_EBODIEN_Pos)                 /*!< SYS_T::BODCTL: EBODIEN Mask            */
S
S#define SYS_BODCTL_EBODIF_Pos            (19)                                              /*!< SYS_T::BODCTL: EBODIF Position         */
S#define SYS_BODCTL_EBODIF_Msk            (0x1ul << SYS_BODCTL_EBODIF_Pos)                  /*!< SYS_T::BODCTL: EBODIF Mask             */
S
S#define SYS_BODCTL_EBODDTSEL_Pos         (20)                                              /*!< SYS_T::BODCTL: EBODDTSEL Position      */
S#define SYS_BODCTL_EBODDTSEL_Msk         (0x3ul << SYS_BODCTL_EBODDTSEL_Pos)               /*!< SYS_T::BODCTL: EBODDTSEL Mask          */
S
S#define SYS_BODCTL_EBODBGSEL_Pos         (22)                                              /*!< SYS_T::BODCTL: EBODBGSEL Position      */
S#define SYS_BODCTL_EBODBGSEL_Msk         (0x3ul << SYS_BODCTL_EBODBGSEL_Pos)               /*!< SYS_T::BODCTL: EBODBGSEL Mask          */
S
S#define SYS_BODCTL_EBODOUT_Pos           (24)                                              /*!< SYS_T::BODCTL: EBODOUT Position        */
S#define SYS_BODCTL_EBODOUT_Msk           (0x1ul << SYS_BODCTL_EBODOUT_Pos)                 /*!< SYS_T::BODCTL: EBODOUT Mask            */
S
S#define SYS_BODCTL_EBODDGSEL_Pos         (25)                                              /*!< SYS_T::BODCTL: EBODDGSEL Position      */
S#define SYS_BODCTL_EBODDGSEL_Msk         (0x7ul << SYS_BODCTL_EBODDGSEL_Pos)               /*!< SYS_T::BODCTL: EBODDGSEL Mask          */
S
S#define SYS_IVSCTL_VTEMPEN_Pos           (0)                                               /*!< SYS_T::IVSCTL: VTEMPEN Position        */
S#define SYS_IVSCTL_VTEMPEN_Msk           (0x1ul << SYS_IVSCTL_VTEMPEN_Pos)                 /*!< SYS_T::IVSCTL: VTEMPEN Mask            */
S
S#define SYS_IVSCTL_VBATUGEN_Pos          (1)                                               /*!< SYS_T::IVSCTL: VBATUGEN Position       */
S#define SYS_IVSCTL_VBATUGEN_Msk          (0x1ul << SYS_IVSCTL_VBATUGEN_Pos)                /*!< SYS_T::IVSCTL: VBATUGEN Mask           */
S
S#define SYS_PORCTL_POROFF_Pos            (0)                                               /*!< SYS_T::PORCTL: POROFF Position         */
S#define SYS_PORCTL_POROFF_Msk            (0xfffful << SYS_PORCTL_POROFF_Pos)               /*!< SYS_T::PORCTL: POROFF Mask             */
S
S#define SYS_VREFCTL_VREFCTL_Pos          (0)                                               /*!< SYS_T::VREFCTL: VREFCTL Position       */
S#define SYS_VREFCTL_VREFCTL_Msk          (0x1ful << SYS_VREFCTL_VREFCTL_Pos)               /*!< SYS_T::VREFCTL: VREFCTL Mask           */
S
S#define SYS_GPA_MFPL_PA0MFP_Pos          (0)                                               /*!< SYS_T::GPA_MFPL: PA0MFP Position       */
S#define SYS_GPA_MFPL_PA0MFP_Msk          (0xful << SYS_GPA_MFPL_PA0MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA0MFP Mask           */
S
S#define SYS_GPA_MFPL_PA1MFP_Pos          (4)                                               /*!< SYS_T::GPA_MFPL: PA1MFP Position       */
S#define SYS_GPA_MFPL_PA1MFP_Msk          (0xful << SYS_GPA_MFPL_PA1MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA1MFP Mask           */
S
S#define SYS_GPA_MFPL_PA2MFP_Pos          (8)                                               /*!< SYS_T::GPA_MFPL: PA2MFP Position       */
S#define SYS_GPA_MFPL_PA2MFP_Msk          (0xful << SYS_GPA_MFPL_PA2MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA2MFP Mask           */
S
S#define SYS_GPA_MFPL_PA3MFP_Pos          (12)                                              /*!< SYS_T::GPA_MFPL: PA3MFP Position       */
S#define SYS_GPA_MFPL_PA3MFP_Msk          (0xful << SYS_GPA_MFPL_PA3MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA3MFP Mask           */
S
S#define SYS_GPA_MFPL_PA4MFP_Pos          (16)                                              /*!< SYS_T::GPA_MFPL: PA4MFP Position       */
S#define SYS_GPA_MFPL_PA4MFP_Msk          (0xful << SYS_GPA_MFPL_PA4MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA4MFP Mask           */
S
S#define SYS_GPA_MFPL_PA5MFP_Pos          (20)                                              /*!< SYS_T::GPA_MFPL: PA5MFP Position       */
S#define SYS_GPA_MFPL_PA5MFP_Msk          (0xful << SYS_GPA_MFPL_PA5MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA5MFP Mask           */
S
S#define SYS_GPA_MFPL_PA6MFP_Pos          (24)                                              /*!< SYS_T::GPA_MFPL: PA6MFP Position       */
S#define SYS_GPA_MFPL_PA6MFP_Msk          (0xful << SYS_GPA_MFPL_PA6MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA6MFP Mask           */
S
S#define SYS_GPA_MFPL_PA7MFP_Pos          (28)                                              /*!< SYS_T::GPA_MFPL: PA7MFP Position       */
S#define SYS_GPA_MFPL_PA7MFP_Msk          (0xful << SYS_GPA_MFPL_PA7MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA7MFP Mask           */
S
S#define SYS_GPA_MFPH_PA8MFP_Pos          (0)                                               /*!< SYS_T::GPA_MFPH: PA8MFP Position       */
S#define SYS_GPA_MFPH_PA8MFP_Msk          (0xful << SYS_GPA_MFPH_PA8MFP_Pos)                /*!< SYS_T::GPA_MFPH: PA8MFP Mask           */
S
S#define SYS_GPA_MFPH_PA9MFP_Pos          (4)                                               /*!< SYS_T::GPA_MFPH: PA9MFP Position       */
S#define SYS_GPA_MFPH_PA9MFP_Msk          (0xful << SYS_GPA_MFPH_PA9MFP_Pos)                /*!< SYS_T::GPA_MFPH: PA9MFP Mask           */
S
S#define SYS_GPA_MFPH_PA10MFP_Pos         (8)                                               /*!< SYS_T::GPA_MFPH: PA10MFP Position      */
S#define SYS_GPA_MFPH_PA10MFP_Msk         (0xful << SYS_GPA_MFPH_PA10MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA10MFP Mask          */
S
S#define SYS_GPA_MFPH_PA11MFP_Pos         (12)                                              /*!< SYS_T::GPA_MFPH: PA11MFP Position      */
S#define SYS_GPA_MFPH_PA11MFP_Msk         (0xful << SYS_GPA_MFPH_PA11MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA11MFP Mask          */
S
S#define SYS_GPA_MFPH_PA12MFP_Pos         (16)                                              /*!< SYS_T::GPA_MFPH: PA12MFP Position      */
S#define SYS_GPA_MFPH_PA12MFP_Msk         (0xful << SYS_GPA_MFPH_PA12MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA12MFP Mask          */
S
S#define SYS_GPA_MFPH_PA13MFP_Pos         (20)                                              /*!< SYS_T::GPA_MFPH: PA13MFP Position      */
S#define SYS_GPA_MFPH_PA13MFP_Msk         (0xful << SYS_GPA_MFPH_PA13MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA13MFP Mask          */
S
S#define SYS_GPA_MFPH_PA14MFP_Pos         (24)                                              /*!< SYS_T::GPA_MFPH: PA14MFP Position      */
S#define SYS_GPA_MFPH_PA14MFP_Msk         (0xful << SYS_GPA_MFPH_PA14MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA14MFP Mask          */
S
S#define SYS_GPA_MFPH_PA15MFP_Pos         (28)                                              /*!< SYS_T::GPA_MFPH: PA15MFP Position      */
S#define SYS_GPA_MFPH_PA15MFP_Msk         (0xful << SYS_GPA_MFPH_PA15MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA15MFP Mask          */
S
S#define SYS_GPB_MFPL_PB0MFP_Pos          (0)                                               /*!< SYS_T::GPB_MFPL: PB0MFP Position       */
S#define SYS_GPB_MFPL_PB0MFP_Msk          (0xful << SYS_GPB_MFPL_PB0MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB0MFP Mask           */
S
S#define SYS_GPB_MFPL_PB1MFP_Pos          (4)                                               /*!< SYS_T::GPB_MFPL: PB1MFP Position       */
S#define SYS_GPB_MFPL_PB1MFP_Msk          (0xful << SYS_GPB_MFPL_PB1MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB1MFP Mask           */
S
S#define SYS_GPB_MFPL_PB2MFP_Pos          (8)                                               /*!< SYS_T::GPB_MFPL: PB2MFP Position       */
S#define SYS_GPB_MFPL_PB2MFP_Msk          (0xful << SYS_GPB_MFPL_PB2MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB2MFP Mask           */
S
S#define SYS_GPB_MFPL_PB3MFP_Pos          (12)                                              /*!< SYS_T::GPB_MFPL: PB3MFP Position       */
S#define SYS_GPB_MFPL_PB3MFP_Msk          (0xful << SYS_GPB_MFPL_PB3MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB3MFP Mask           */
S
S#define SYS_GPB_MFPL_PB4MFP_Pos          (16)                                              /*!< SYS_T::GPB_MFPL: PB4MFP Position       */
S#define SYS_GPB_MFPL_PB4MFP_Msk          (0xful << SYS_GPB_MFPL_PB4MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB4MFP Mask           */
S
S#define SYS_GPB_MFPL_PB5MFP_Pos          (20)                                              /*!< SYS_T::GPB_MFPL: PB5MFP Position       */
S#define SYS_GPB_MFPL_PB5MFP_Msk          (0xful << SYS_GPB_MFPL_PB5MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB5MFP Mask           */
S
S#define SYS_GPB_MFPL_PB6MFP_Pos          (24)                                              /*!< SYS_T::GPB_MFPL: PB6MFP Position       */
S#define SYS_GPB_MFPL_PB6MFP_Msk          (0xful << SYS_GPB_MFPL_PB6MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB6MFP Mask           */
S
S#define SYS_GPB_MFPL_PB7MFP_Pos          (28)                                              /*!< SYS_T::GPB_MFPL: PB7MFP Position       */
S#define SYS_GPB_MFPL_PB7MFP_Msk          (0xful << SYS_GPB_MFPL_PB7MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB7MFP Mask           */
S
S#define SYS_GPB_MFPH_PB8MFP_Pos          (0)                                               /*!< SYS_T::GPB_MFPH: PB8MFP Position       */
S#define SYS_GPB_MFPH_PB8MFP_Msk          (0xful << SYS_GPB_MFPH_PB8MFP_Pos)                /*!< SYS_T::GPB_MFPH: PB8MFP Mask           */
S
S#define SYS_GPB_MFPH_PB9MFP_Pos          (4)                                               /*!< SYS_T::GPB_MFPH: PB9MFP Position       */
S#define SYS_GPB_MFPH_PB9MFP_Msk          (0xful << SYS_GPB_MFPH_PB9MFP_Pos)                /*!< SYS_T::GPB_MFPH: PB9MFP Mask           */
S
S#define SYS_GPB_MFPH_PB10MFP_Pos         (8)                                               /*!< SYS_T::GPB_MFPH: PB10MFP Position      */
S#define SYS_GPB_MFPH_PB10MFP_Msk         (0xful << SYS_GPB_MFPH_PB10MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB10MFP Mask          */
S
S#define SYS_GPB_MFPH_PB11MFP_Pos         (12)                                              /*!< SYS_T::GPB_MFPH: PB11MFP Position      */
S#define SYS_GPB_MFPH_PB11MFP_Msk         (0xful << SYS_GPB_MFPH_PB11MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB11MFP Mask          */
S
S#define SYS_GPB_MFPH_PB12MFP_Pos         (16)                                              /*!< SYS_T::GPB_MFPH: PB12MFP Position      */
S#define SYS_GPB_MFPH_PB12MFP_Msk         (0xful << SYS_GPB_MFPH_PB12MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB12MFP Mask          */
S
S#define SYS_GPB_MFPH_PB13MFP_Pos         (20)                                              /*!< SYS_T::GPB_MFPH: PB13MFP Position      */
S#define SYS_GPB_MFPH_PB13MFP_Msk         (0xful << SYS_GPB_MFPH_PB13MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB13MFP Mask          */
S
S#define SYS_GPB_MFPH_PB14MFP_Pos         (24)                                              /*!< SYS_T::GPB_MFPH: PB14MFP Position      */
S#define SYS_GPB_MFPH_PB14MFP_Msk         (0xful << SYS_GPB_MFPH_PB14MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB14MFP Mask          */
S
S#define SYS_GPB_MFPH_PB15MFP_Pos         (28)                                              /*!< SYS_T::GPB_MFPH: PB15MFP Position      */
S#define SYS_GPB_MFPH_PB15MFP_Msk         (0xful << SYS_GPB_MFPH_PB15MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB15MFP Mask          */
S
S#define SYS_GPC_MFPL_PC0MFP_Pos          (0)                                               /*!< SYS_T::GPC_MFPL: PC0MFP Position       */
S#define SYS_GPC_MFPL_PC0MFP_Msk          (0xful << SYS_GPC_MFPL_PC0MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC0MFP Mask           */
S
S#define SYS_GPC_MFPL_PC1MFP_Pos          (4)                                               /*!< SYS_T::GPC_MFPL: PC1MFP Position       */
S#define SYS_GPC_MFPL_PC1MFP_Msk          (0xful << SYS_GPC_MFPL_PC1MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC1MFP Mask           */
S
S#define SYS_GPC_MFPL_PC2MFP_Pos          (8)                                               /*!< SYS_T::GPC_MFPL: PC2MFP Position       */
S#define SYS_GPC_MFPL_PC2MFP_Msk          (0xful << SYS_GPC_MFPL_PC2MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC2MFP Mask           */
S
S#define SYS_GPC_MFPL_PC3MFP_Pos          (12)                                              /*!< SYS_T::GPC_MFPL: PC3MFP Position       */
S#define SYS_GPC_MFPL_PC3MFP_Msk          (0xful << SYS_GPC_MFPL_PC3MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC3MFP Mask           */
S
S#define SYS_GPC_MFPL_PC4MFP_Pos          (16)                                              /*!< SYS_T::GPC_MFPL: PC4MFP Position       */
S#define SYS_GPC_MFPL_PC4MFP_Msk          (0xful << SYS_GPC_MFPL_PC4MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC4MFP Mask           */
S
S#define SYS_GPC_MFPL_PC5MFP_Pos          (20)                                              /*!< SYS_T::GPC_MFPL: PC5MFP Position       */
S#define SYS_GPC_MFPL_PC5MFP_Msk          (0xful << SYS_GPC_MFPL_PC5MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC5MFP Mask           */
S
S#define SYS_GPC_MFPL_PC6MFP_Pos          (24)                                              /*!< SYS_T::GPC_MFPL: PC6MFP Position       */
S#define SYS_GPC_MFPL_PC6MFP_Msk          (0xful << SYS_GPC_MFPL_PC6MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC6MFP Mask           */
S
S#define SYS_GPC_MFPL_PC7MFP_Pos          (28)                                              /*!< SYS_T::GPC_MFPL: PC7MFP Position       */
S#define SYS_GPC_MFPL_PC7MFP_Msk          (0xful << SYS_GPC_MFPL_PC7MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC7MFP Mask           */
S
S#define SYS_GPC_MFPH_PC8MFP_Pos          (0)                                               /*!< SYS_T::GPC_MFPH: PC8MFP Position       */
S#define SYS_GPC_MFPH_PC8MFP_Msk          (0xful << SYS_GPC_MFPH_PC8MFP_Pos)                /*!< SYS_T::GPC_MFPH: PC8MFP Mask           */
S
S#define SYS_GPC_MFPH_PC9MFP_Pos          (4)                                               /*!< SYS_T::GPC_MFPH: PC9MFP Position       */
S#define SYS_GPC_MFPH_PC9MFP_Msk          (0xful << SYS_GPC_MFPH_PC9MFP_Pos)                /*!< SYS_T::GPC_MFPH: PC9MFP Mask           */
S
S#define SYS_GPC_MFPH_PC10MFP_Pos         (8)                                               /*!< SYS_T::GPC_MFPH: PC10MFP Position      */
S#define SYS_GPC_MFPH_PC10MFP_Msk         (0xful << SYS_GPC_MFPH_PC10MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC10MFP Mask          */
S
S#define SYS_GPC_MFPH_PC11MFP_Pos         (12)                                              /*!< SYS_T::GPC_MFPH: PC11MFP Position      */
S#define SYS_GPC_MFPH_PC11MFP_Msk         (0xful << SYS_GPC_MFPH_PC11MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC11MFP Mask          */
S
S#define SYS_GPC_MFPH_PC12MFP_Pos         (16)                                              /*!< SYS_T::GPC_MFPH: PC12MFP Position      */
S#define SYS_GPC_MFPH_PC12MFP_Msk         (0xful << SYS_GPC_MFPH_PC12MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC12MFP Mask          */
S
S#define SYS_GPC_MFPH_PC13MFP_Pos         (20)                                              /*!< SYS_T::GPC_MFPH: PC13MFP Position      */
S#define SYS_GPC_MFPH_PC13MFP_Msk         (0xful << SYS_GPC_MFPH_PC13MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC13MFP Mask          */
S
S#define SYS_GPC_MFPH_PC14MFP_Pos         (24)                                              /*!< SYS_T::GPC_MFPH: PC14MFP Position      */
S#define SYS_GPC_MFPH_PC14MFP_Msk         (0xful << SYS_GPC_MFPH_PC14MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC14MFP Mask          */
S
S#define SYS_GPC_MFPH_PC15MFP_Pos         (28)                                              /*!< SYS_T::GPC_MFPH: PC15MFP Position      */
S#define SYS_GPC_MFPH_PC15MFP_Msk         (0xful << SYS_GPC_MFPH_PC15MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC15MFP Mask          */
S
S#define SYS_GPD_MFPL_PD0MFP_Pos          (0)                                               /*!< SYS_T::GPD_MFPL: PD0MFP Position       */
S#define SYS_GPD_MFPL_PD0MFP_Msk          (0xful << SYS_GPD_MFPL_PD0MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD0MFP Mask           */
S
S#define SYS_GPD_MFPL_PD1MFP_Pos          (4)                                               /*!< SYS_T::GPD_MFPL: PD1MFP Position       */
S#define SYS_GPD_MFPL_PD1MFP_Msk          (0xful << SYS_GPD_MFPL_PD1MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD1MFP Mask           */
S
S#define SYS_GPD_MFPL_PD2MFP_Pos          (8)                                               /*!< SYS_T::GPD_MFPL: PD2MFP Position       */
S#define SYS_GPD_MFPL_PD2MFP_Msk          (0xful << SYS_GPD_MFPL_PD2MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD2MFP Mask           */
S
S#define SYS_GPD_MFPL_PD3MFP_Pos          (12)                                              /*!< SYS_T::GPD_MFPL: PD3MFP Position       */
S#define SYS_GPD_MFPL_PD3MFP_Msk          (0xful << SYS_GPD_MFPL_PD3MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD3MFP Mask           */
S
S#define SYS_GPD_MFPL_PD4MFP_Pos          (16)                                              /*!< SYS_T::GPD_MFPL: PD4MFP Position       */
S#define SYS_GPD_MFPL_PD4MFP_Msk          (0xful << SYS_GPD_MFPL_PD4MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD4MFP Mask           */
S
S#define SYS_GPD_MFPL_PD5MFP_Pos          (20)                                              /*!< SYS_T::GPD_MFPL: PD5MFP Position       */
S#define SYS_GPD_MFPL_PD5MFP_Msk          (0xful << SYS_GPD_MFPL_PD5MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD5MFP Mask           */
S
S#define SYS_GPD_MFPL_PD6MFP_Pos          (24)                                              /*!< SYS_T::GPD_MFPL: PD6MFP Position       */
S#define SYS_GPD_MFPL_PD6MFP_Msk          (0xful << SYS_GPD_MFPL_PD6MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD6MFP Mask           */
S
S#define SYS_GPD_MFPL_PD7MFP_Pos          (28)                                              /*!< SYS_T::GPD_MFPL: PD7MFP Position       */
S#define SYS_GPD_MFPL_PD7MFP_Msk          (0xful << SYS_GPD_MFPL_PD7MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD7MFP Mask           */
S
S#define SYS_GPD_MFPH_PD8MFP_Pos          (0)                                               /*!< SYS_T::GPD_MFPH: PD8MFP Position       */
S#define SYS_GPD_MFPH_PD8MFP_Msk          (0xful << SYS_GPD_MFPH_PD8MFP_Pos)                /*!< SYS_T::GPD_MFPH: PD8MFP Mask           */
S
S#define SYS_GPD_MFPH_PD9MFP_Pos          (4)                                               /*!< SYS_T::GPD_MFPH: PD9MFP Position       */
S#define SYS_GPD_MFPH_PD9MFP_Msk          (0xful << SYS_GPD_MFPH_PD9MFP_Pos)                /*!< SYS_T::GPD_MFPH: PD9MFP Mask           */
S
S#define SYS_GPD_MFPH_PD10MFP_Pos         (8)                                               /*!< SYS_T::GPD_MFPH: PD10MFP Position      */
S#define SYS_GPD_MFPH_PD10MFP_Msk         (0xful << SYS_GPD_MFPH_PD10MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD10MFP Mask          */
S
S#define SYS_GPD_MFPH_PD11MFP_Pos         (12)                                              /*!< SYS_T::GPD_MFPH: PD11MFP Position      */
S#define SYS_GPD_MFPH_PD11MFP_Msk         (0xful << SYS_GPD_MFPH_PD11MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD11MFP Mask          */
S
S#define SYS_GPD_MFPH_PD12MFP_Pos         (16)                                              /*!< SYS_T::GPD_MFPH: PD12MFP Position      */
S#define SYS_GPD_MFPH_PD12MFP_Msk         (0xful << SYS_GPD_MFPH_PD12MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD12MFP Mask          */
S
S#define SYS_GPD_MFPH_PD13MFP_Pos         (20)                                              /*!< SYS_T::GPD_MFPH: PD13MFP Position      */
S#define SYS_GPD_MFPH_PD13MFP_Msk         (0xful << SYS_GPD_MFPH_PD13MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD13MFP Mask          */
S
S#define SYS_GPD_MFPH_PD14MFP_Pos         (24)                                              /*!< SYS_T::GPD_MFPH: PD14MFP Position      */
S#define SYS_GPD_MFPH_PD14MFP_Msk         (0xful << SYS_GPD_MFPH_PD14MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD14MFP Mask          */
S
S#define SYS_GPD_MFPH_PD15MFP_Pos         (28)                                              /*!< SYS_T::GPD_MFPH: PD15MFP Position      */
S#define SYS_GPD_MFPH_PD15MFP_Msk         (0xful << SYS_GPD_MFPH_PD15MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD15MFP Mask          */
S
S#define SYS_GPE_MFPL_PE0MFP_Pos          (0)                                               /*!< SYS_T::GPE_MFPL: PE0MFP Position       */
S#define SYS_GPE_MFPL_PE0MFP_Msk          (0xful << SYS_GPE_MFPL_PE0MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE0MFP Mask           */
S
S#define SYS_GPE_MFPL_PE1MFP_Pos          (4)                                               /*!< SYS_T::GPE_MFPL: PE1MFP Position       */
S#define SYS_GPE_MFPL_PE1MFP_Msk          (0xful << SYS_GPE_MFPL_PE1MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE1MFP Mask           */
S
S#define SYS_GPE_MFPL_PE2MFP_Pos          (8)                                               /*!< SYS_T::GPE_MFPL: PE2MFP Position       */
S#define SYS_GPE_MFPL_PE2MFP_Msk          (0xful << SYS_GPE_MFPL_PE2MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE2MFP Mask           */
S
S#define SYS_GPE_MFPL_PE3MFP_Pos          (12)                                              /*!< SYS_T::GPE_MFPL: PE3MFP Position       */
S#define SYS_GPE_MFPL_PE3MFP_Msk          (0xful << SYS_GPE_MFPL_PE3MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE3MFP Mask           */
S
S#define SYS_GPE_MFPL_PE4MFP_Pos          (16)                                              /*!< SYS_T::GPE_MFPL: PE4MFP Position       */
S#define SYS_GPE_MFPL_PE4MFP_Msk          (0xful << SYS_GPE_MFPL_PE4MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE4MFP Mask           */
S
S#define SYS_GPE_MFPL_PE5MFP_Pos          (20)                                              /*!< SYS_T::GPE_MFPL: PE5MFP Position       */
S#define SYS_GPE_MFPL_PE5MFP_Msk          (0xful << SYS_GPE_MFPL_PE5MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE5MFP Mask           */
S
S#define SYS_GPE_MFPL_PE6MFP_Pos          (24)                                              /*!< SYS_T::GPE_MFPL: PE6MFP Position       */
S#define SYS_GPE_MFPL_PE6MFP_Msk          (0xful << SYS_GPE_MFPL_PE6MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE6MFP Mask           */
S
S#define SYS_GPE_MFPL_PE7MFP_Pos          (28)                                              /*!< SYS_T::GPE_MFPL: PE7MFP Position       */
S#define SYS_GPE_MFPL_PE7MFP_Msk          (0xful << SYS_GPE_MFPL_PE7MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE7MFP Mask           */
S
S#define SYS_GPE_MFPH_PE8MFP_Pos          (0)                                               /*!< SYS_T::GPE_MFPH: PE8MFP Position       */
S#define SYS_GPE_MFPH_PE8MFP_Msk          (0xful << SYS_GPE_MFPH_PE8MFP_Pos)                /*!< SYS_T::GPE_MFPH: PE8MFP Mask           */
S
S#define SYS_GPE_MFPH_PE9MFP_Pos          (4)                                               /*!< SYS_T::GPE_MFPH: PE9MFP Position       */
S#define SYS_GPE_MFPH_PE9MFP_Msk          (0xful << SYS_GPE_MFPH_PE9MFP_Pos)                /*!< SYS_T::GPE_MFPH: PE9MFP Mask           */
S
S#define SYS_GPE_MFPH_PE10MFP_Pos         (8)                                               /*!< SYS_T::GPE_MFPH: PE10MFP Position      */
S#define SYS_GPE_MFPH_PE10MFP_Msk         (0xful << SYS_GPE_MFPH_PE10MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE10MFP Mask          */
S
S#define SYS_GPE_MFPH_PE11MFP_Pos         (12)                                              /*!< SYS_T::GPE_MFPH: PE11MFP Position      */
S#define SYS_GPE_MFPH_PE11MFP_Msk         (0xful << SYS_GPE_MFPH_PE11MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE11MFP Mask          */
S
S#define SYS_GPE_MFPH_PE12MFP_Pos         (16)                                              /*!< SYS_T::GPE_MFPH: PE12MFP Position      */
S#define SYS_GPE_MFPH_PE12MFP_Msk         (0xful << SYS_GPE_MFPH_PE12MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE12MFP Mask          */
S
S#define SYS_GPE_MFPH_PE13MFP_Pos         (20)                                              /*!< SYS_T::GPE_MFPH: PE13MFP Position      */
S#define SYS_GPE_MFPH_PE13MFP_Msk         (0xful << SYS_GPE_MFPH_PE13MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE13MFP Mask          */
S
S#define SYS_GPF_MFPL_PF0MFP_Pos          (0)                                               /*!< SYS_T::GPF_MFPL: PF0MFP Position       */
S#define SYS_GPF_MFPL_PF0MFP_Msk          (0xful << SYS_GPF_MFPL_PF0MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF0MFP Mask           */
S
S#define SYS_GPF_MFPL_PF1MFP_Pos          (4)                                               /*!< SYS_T::GPF_MFPL: PF1MFP Position       */
S#define SYS_GPF_MFPL_PF1MFP_Msk          (0xful << SYS_GPF_MFPL_PF1MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF1MFP Mask           */
S
S#define SYS_GPF_MFPL_PF2MFP_Pos          (8)                                               /*!< SYS_T::GPF_MFPL: PF2MFP Position       */
S#define SYS_GPF_MFPL_PF2MFP_Msk          (0xful << SYS_GPF_MFPL_PF2MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF2MFP Mask           */
S
S#define SYS_GPF_MFPL_PF3MFP_Pos          (12)                                              /*!< SYS_T::GPF_MFPL: PF3MFP Position       */
S#define SYS_GPF_MFPL_PF3MFP_Msk          (0xful << SYS_GPF_MFPL_PF3MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF3MFP Mask           */
S
S#define SYS_GPF_MFPL_PF4MFP_Pos          (16)                                              /*!< SYS_T::GPF_MFPL: PF4MFP Position       */
S#define SYS_GPF_MFPL_PF4MFP_Msk          (0xful << SYS_GPF_MFPL_PF4MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF4MFP Mask           */
S
S#define SYS_GPF_MFPL_PF5MFP_Pos          (20)                                              /*!< SYS_T::GPF_MFPL: PF5MFP Position       */
S#define SYS_GPF_MFPL_PF5MFP_Msk          (0xful << SYS_GPF_MFPL_PF5MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF5MFP Mask           */
S
S#define SYS_GPF_MFPL_PF6MFP_Pos          (24)                                              /*!< SYS_T::GPF_MFPL: PF6MFP Position       */
S#define SYS_GPF_MFPL_PF6MFP_Msk          (0xful << SYS_GPF_MFPL_PF6MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF6MFP Mask           */
S
S#define SYS_GPF_MFPL_PF7MFP_Pos          (28)                                              /*!< SYS_T::GPF_MFPL: PF7MFP Position       */
S#define SYS_GPF_MFPL_PF7MFP_Msk          (0xful << SYS_GPF_MFPL_PF7MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF7MFP Mask           */
S
S#define SYS_IRCTCTL0_FREQSEL_Pos         (0)                                               /*!< SYS_T::IRCTCTL0: FREQSEL Position      */
S#define SYS_IRCTCTL0_FREQSEL_Msk         (0x3ul << SYS_IRCTCTL0_FREQSEL_Pos)               /*!< SYS_T::IRCTCTL0: FREQSEL Mask          */
S
S#define SYS_IRCTCTL0_LOOPSEL_Pos         (4)                                               /*!< SYS_T::IRCTCTL0: LOOPSEL Position      */
S#define SYS_IRCTCTL0_LOOPSEL_Msk         (0x3ul << SYS_IRCTCTL0_LOOPSEL_Pos)               /*!< SYS_T::IRCTCTL0: LOOPSEL Mask          */
S
S#define SYS_IRCTCTL0_RETRYCNT_Pos        (6)                                               /*!< SYS_T::IRCTCTL0: RETRYCNT Position     */
S#define SYS_IRCTCTL0_RETRYCNT_Msk        (0x3ul << SYS_IRCTCTL0_RETRYCNT_Pos)              /*!< SYS_T::IRCTCTL0: RETRYCNT Mask         */
S
S#define SYS_IRCTCTL0_CESTOPEN_Pos        (8)                                               /*!< SYS_T::IRCTCTL0: CESTOPEN Position     */
S#define SYS_IRCTCTL0_CESTOPEN_Msk        (0x1ul << SYS_IRCTCTL0_CESTOPEN_Pos)              /*!< SYS_T::IRCTCTL0: CESTOPEN Mask         */
S
S#define SYS_IRCTCTL0_REFCKSEL_Pos        (10)                                              /*!< SYS_T::IRCTCTL0: REFCKSEL Position     */
S#define SYS_IRCTCTL0_REFCKSEL_Msk        (0x1ul << SYS_IRCTCTL0_REFCKSEL_Pos)              /*!< SYS_T::IRCTCTL0: REFCKSEL Mask         */
S
S#define SYS_IRCTIEN_TFAILIEN_Pos         (1)                                               /*!< SYS_T::IRCTIEN: TFAILIEN Position      */
S#define SYS_IRCTIEN_TFAILIEN_Msk         (0x1ul << SYS_IRCTIEN_TFAILIEN_Pos)               /*!< SYS_T::IRCTIEN: TFAILIEN Mask          */
S
S#define SYS_IRCTIEN_CLKEIEN_Pos          (2)                                               /*!< SYS_T::IRCTIEN: CLKEIEN Position       */
S#define SYS_IRCTIEN_CLKEIEN_Msk          (0x1ul << SYS_IRCTIEN_CLKEIEN_Pos)                /*!< SYS_T::IRCTIEN: CLKEIEN Mask           */
S
S#define SYS_IRCTIEN_TFAILIEN1_Pos        (9)                                               /*!< SYS_T::IRCTIEN: TFAILIEN1 Position     */
S#define SYS_IRCTIEN_TFAILIEN1_Msk        (0x1ul << SYS_IRCTIEN_TFAILIEN1_Pos)              /*!< SYS_T::IRCTIEN: TFAILIEN1 Mask         */
S
S#define SYS_IRCTIEN_CLKEIEN1_Pos         (10)                                              /*!< SYS_T::IRCTIEN: CLKEIEN1 Position      */
S#define SYS_IRCTIEN_CLKEIEN1_Msk         (0x1ul << SYS_IRCTIEN_CLKEIEN1_Pos)               /*!< SYS_T::IRCTIEN: CLKEIEN1 Mask          */
S
S#define SYS_IRCTISTS_FREQLOCK_Pos        (0)                                               /*!< SYS_T::IRCTISTS: FREQLOCK Position     */
S#define SYS_IRCTISTS_FREQLOCK_Msk        (0x1ul << SYS_IRCTISTS_FREQLOCK_Pos)              /*!< SYS_T::IRCTISTS: FREQLOCK Mask         */
S
S#define SYS_IRCTISTS_TFAILIF_Pos         (1)                                               /*!< SYS_T::IRCTISTS: TFAILIF Position      */
S#define SYS_IRCTISTS_TFAILIF_Msk         (0x1ul << SYS_IRCTISTS_TFAILIF_Pos)               /*!< SYS_T::IRCTISTS: TFAILIF Mask          */
S
S#define SYS_IRCTISTS_CLKERRIF_Pos        (2)                                               /*!< SYS_T::IRCTISTS: CLKERRIF Position     */
S#define SYS_IRCTISTS_CLKERRIF_Msk        (0x1ul << SYS_IRCTISTS_CLKERRIF_Pos)              /*!< SYS_T::IRCTISTS: CLKERRIF Mask         */
S
S#define SYS_IRCTISTS_FREQLOCK1_Pos       (8)                                               /*!< SYS_T::IRCTISTS: FREQLOCK1 Position    */
S#define SYS_IRCTISTS_FREQLOCK1_Msk       (0x1ul << SYS_IRCTISTS_FREQLOCK1_Pos)             /*!< SYS_T::IRCTISTS: FREQLOCK1 Mask        */
S
S#define SYS_IRCTISTS_TFAILIF1_Pos        (9)                                               /*!< SYS_T::IRCTISTS: TFAILIF1 Position     */
S#define SYS_IRCTISTS_TFAILIF1_Msk        (0x1ul << SYS_IRCTISTS_TFAILIF1_Pos)              /*!< SYS_T::IRCTISTS: TFAILIF1 Mask         */
S
S#define SYS_IRCTISTS_CLKERRIF1_Pos       (10)                                              /*!< SYS_T::IRCTISTS: CLKERRIF1 Position    */
S#define SYS_IRCTISTS_CLKERRIF1_Msk       (0x1ul << SYS_IRCTISTS_CLKERRIF1_Pos)             /*!< SYS_T::IRCTISTS: CLKERRIF1 Mask        */
S
S#define SYS_IRCTCTL1_FREQSEL_Pos         (0)                                               /*!< SYS_T::IRCTCTL1: FREQSEL Position      */
S#define SYS_IRCTCTL1_FREQSEL_Msk         (0x3ul << SYS_IRCTCTL1_FREQSEL_Pos)               /*!< SYS_T::IRCTCTL1: FREQSEL Mask          */
S
S#define SYS_IRCTCTL1_LOOPSEL_Pos         (4)                                               /*!< SYS_T::IRCTCTL1: LOOPSEL Position      */
S#define SYS_IRCTCTL1_LOOPSEL_Msk         (0x3ul << SYS_IRCTCTL1_LOOPSEL_Pos)               /*!< SYS_T::IRCTCTL1: LOOPSEL Mask          */
S
S#define SYS_IRCTCTL1_RETRYCNT_Pos        (6)                                               /*!< SYS_T::IRCTCTL1: RETRYCNT Position     */
S#define SYS_IRCTCTL1_RETRYCNT_Msk        (0x3ul << SYS_IRCTCTL1_RETRYCNT_Pos)              /*!< SYS_T::IRCTCTL1: RETRYCNT Mask         */
S
S#define SYS_IRCTCTL1_CESTOPEN_Pos        (8)                                               /*!< SYS_T::IRCTCTL1: CESTOPEN Position     */
S#define SYS_IRCTCTL1_CESTOPEN_Msk        (0x1ul << SYS_IRCTCTL1_CESTOPEN_Pos)              /*!< SYS_T::IRCTCTL1: CESTOPEN Mask         */
S
S#define SYS_IRCTCTL1_REFCKSEL_Pos        (10)                                              /*!< SYS_T::IRCTCTL1: REFCKSEL Position     */
S#define SYS_IRCTCTL1_REFCKSEL_Msk        (0x1ul << SYS_IRCTCTL1_REFCKSEL_Pos)              /*!< SYS_T::IRCTCTL1: REFCKSEL Mask         */
S
S#define SYS_MODCTL_MODEN_Pos             (0)                                               /*!< SYS_T::MODCTL: MODEN Position          */
S#define SYS_MODCTL_MODEN_Msk             (0x1ul << SYS_MODCTL_MODEN_Pos)                   /*!< SYS_T::MODCTL: MODEN Mask              */
S
S#define SYS_MODCTL_MODH_Pos              (1)                                               /*!< SYS_T::MODCTL: MODH Position           */
S#define SYS_MODCTL_MODH_Msk              (0x1ul << SYS_MODCTL_MODH_Pos)                    /*!< SYS_T::MODCTL: MODH Mask               */
S
S#define SYS_MODCTL_MODPWMSEL_Pos         (4)                                               /*!< SYS_T::MODCTL: MODPWMSEL Position      */
S#define SYS_MODCTL_MODPWMSEL_Msk         (0x7ul << SYS_MODCTL_MODPWMSEL_Pos)               /*!< SYS_T::MODCTL: MODPWMSEL Mask          */
S
S#define SYS_SRAM_BISTCTL_SRBIST_Pos      (0)                                               /*!< SYS_T::SRAM_BISTCTL: SRBIST Position   */
S#define SYS_SRAM_BISTCTL_SRBIST_Msk      (0x1ul << SYS_SRAM_BISTCTL_SRBIST_Pos)            /*!< SYS_T::SRAM_BISTCTL: SRBIST Mask       */
S
S#define SYS_SRAM_BISTCTL_CRBIST_Pos      (2)                                               /*!< SYS_T::SRAM_BISTCTL: CRBIST Position   */
S#define SYS_SRAM_BISTCTL_CRBIST_Msk      (0x1ul << SYS_SRAM_BISTCTL_CRBIST_Pos)            /*!< SYS_T::SRAM_BISTCTL: CRBIST Mask       */
S
S#define SYS_SRAM_BISTCTL_USBBIST_Pos     (4)                                               /*!< SYS_T::SRAM_BISTCTL: USBBIST Position  */
S#define SYS_SRAM_BISTCTL_USBBIST_Msk     (0x1ul << SYS_SRAM_BISTCTL_USBBIST_Pos)           /*!< SYS_T::SRAM_BISTCTL: USBBIST Mask      */
S
S#define SYS_SRAM_BISTSTS_SRBISTEF_Pos    (0)                                               /*!< SYS_T::SRAM_BISTSTS: SRBISTEF Position */
S#define SYS_SRAM_BISTSTS_SRBISTEF_Msk    (0x1ul << SYS_SRAM_BISTSTS_SRBISTEF_Pos)          /*!< SYS_T::SRAM_BISTSTS: SRBISTEF Mask     */
S
S#define SYS_SRAM_BISTSTS_CRBISTEF_Pos    (2)                                               /*!< SYS_T::SRAM_BISTSTS: CRBISTEF Position */
S#define SYS_SRAM_BISTSTS_CRBISTEF_Msk    (0x1ul << SYS_SRAM_BISTSTS_CRBISTEF_Pos)          /*!< SYS_T::SRAM_BISTSTS: CRBISTEF Mask     */
S
S#define SYS_SRAM_BISTSTS_USBBEF_Pos      (4)                                               /*!< SYS_T::SRAM_BISTSTS: USBBEF Position   */
S#define SYS_SRAM_BISTSTS_USBBEF_Msk      (0x1ul << SYS_SRAM_BISTSTS_USBBEF_Pos)            /*!< SYS_T::SRAM_BISTSTS: USBBEF Mask       */
S
S#define SYS_SRAM_BISTSTS_SRBEND_Pos      (16)                                              /*!< SYS_T::SRAM_BISTSTS: SRBEND Position   */
S#define SYS_SRAM_BISTSTS_SRBEND_Msk      (0x1ul << SYS_SRAM_BISTSTS_SRBEND_Pos)            /*!< SYS_T::SRAM_BISTSTS: SRBEND Mask       */
S
S#define SYS_SRAM_BISTSTS_CRBEND_Pos      (18)                                              /*!< SYS_T::SRAM_BISTSTS: CRBEND Position   */
S#define SYS_SRAM_BISTSTS_CRBEND_Msk      (0x1ul << SYS_SRAM_BISTSTS_CRBEND_Pos)            /*!< SYS_T::SRAM_BISTSTS: CRBEND Mask       */
S
S#define SYS_SRAM_BISTSTS_USBBEND_Pos     (20)                                              /*!< SYS_T::SRAM_BISTSTS: USBBEND Position  */
S#define SYS_SRAM_BISTSTS_USBBEND_Msk     (0x1ul << SYS_SRAM_BISTSTS_USBBEND_Pos)           /*!< SYS_T::SRAM_BISTSTS: USBBEND Mask      */
S
S#define SYS_TSOFFSET_VTEMP_Pos           (0)                                               /*!< SYS_T::TSOFFSET: VTEMP Position        */
S#define SYS_TSOFFSET_VTEMP_Msk           (0xffful << SYS_TSOFFSET_VTEMP_Pos)               /*!< SYS_T::TSOFFSET: VTEMP Mask            */
S
S/**@}*/ /* SYS_CONST */
S
S
S
Stypedef struct
S{
S
S
S    /**
S     * @var SYS_INT_T::IRQSRC
S     * Offset: 0x00  Interrupt Source Identity Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |INTSRC    |Interrupt Source
S     * |        |          |Define the interrupt sources for interrupt event.
S     * |        |          |IRQSRC[0].0 - BOD INT
S     * |        |          |IRQSRC[0].1 - 0
S     * |        |          |IRQSRC[0].2 - 0
S     * |        |          |IRQSRC[1].0 - WDT INT
S     * |        |          |IRQSRC[1].1 - WWDT_INT
S     * |        |          |IRQSRC[1].2 - 0
S     * |        |          |IRQSRC[2].0 - EINT0, external interrupt 0 from PA.0/PD.2/PE.4
S     * |        |          |IRQSRC[2].1 - EINT2, external interrupt 2 from PC.0
S     * |        |          |IRQSRC[2].2 - EINT4, external interrupt 4 from PE.0
S     * |        |          |IRQSRC[3].0 - EINT1, external interrupt 1 from PB.0/PD.3/PE.5
S     * |        |          |IRQSRC[3].1 - EINT3, external interrupt 3 from PD.0
S     * |        |          |IRQSRC[3].2 - EINT5, external interrupt 5 from PF.0
S     * |        |          |IRQSRC[4].0 - GPA_INT
S     * |        |          |IRQSRC[4].1 - GPB_INT
S     * |        |          |IRQSRC[4].2 - 0
S     * |        |          |IRQSRC[5].0 - GPC_INT
S     * |        |          |IRQSRC[5].1 - GPD_INT
S     * |        |          |IRQSRC[5].2 - GPE_INT
S     * |        |          |IRQSRC[5].3 - GPF_INT
S     * |        |          |IRQSRC[6].0 - PWM1 INT
S     * |        |          |IRQSRC[6].1 - BRAKE0_INT
S     * |        |          |IRQSRC[6].2 - 0
S     * |        |          |IRQSRC[6].3 - 0
S     * |        |          |IRQSRC[7].0 - PWM1_INT
S     * |        |          |IRQSRC[7].1 - BRAKE1_INT
S     * |        |          |IRQSRC[7].2 - 0
S     * |        |          |IRQSRC[7].3 - 0
S     * |        |          |IRQSRC[8].0 - TMR0_INT
S     * |        |          |IRQSRC[8].1 - 0
S     * |        |          |IRQSRC[8].2 - 0
S     * |        |          |IRQSRC[9].0 - TMR1_INT
S     * |        |          |IRQSRC[9].1 - 0
S     * |        |          |IRQSRC[9].2 - 0
S     * |        |          |IRQSRC[10].0 - TMR2_INT
S     * |        |          |IRQSRC[10].1 - 0
S     * |        |          |IRQSRC[10].2 - 0
S     * |        |          |IRQSRC[11].0 - TMR3_INT
S     * |        |          |IRQSRC[11].1 - 0
S     * |        |          |IRQSRC[11].2 - 0
S     * |        |          |IRQSRC[12].0 - UART0_INT
S     * |        |          |IRQSRC[12].1 - UART2_INT
S     * |        |          |IRQSRC[12].2 - 0
S     * |        |          |IRQSRC[13].0 - UART1_INT
S     * |        |          |IRQSRC[13].1 - 0
S     * |        |          |IRQSRC[13].2 - 0
S     * |        |          |IRQSRC[14].0 - SPI0_INT
S     * |        |          |IRQSRC[14].1 - 0
S     * |        |          |IRQSRC[14].2 - 0
S     * |        |          |IRQSRC[15].0 - SPI1_INT
S     * |        |          |IRQSRC[15].1 - 0
S     * |        |          |IRQSRC[15].2 - 0
S     * |        |          |IRQSRC[16].0 - 0
S     * |        |          |IRQSRC[16].1 - 0
S     * |        |          |IRQSRC[16].2 - 0
S     * |        |          |IRQSRC[17].0 - 0
S     * |        |          |IRQSRC[17].1 - 0
S     * |        |          |IRQSRC[17].2 - 0
S     * |        |          |IRQSRC[18].0 - I2C0_INT
S     * |        |          |IRQSRC[18].1 - 0
S     * |        |          |IRQSRC[18].2 - 0
S     * |        |          |IRQSRC[19].0 - I2C1_INT
S     * |        |          |IRQSRC[19].1 - 0
S     * |        |          |IRQSRC[19].2 - 0
S     * |        |          |IRQSRC[20].0 - 0
S     * |        |          |IRQSRC[20].1 - 0
S     * |        |          |IRQSRC[20].2 - 0
S     * |        |          |IRQSRC[21].0 - 0
S     * |        |          |IRQSRC[21].1 - 0
S     * |        |          |IRQSRC[21].2 - 0
S     * |        |          |IRQSRC[22].0 - USCI0_INT
S     * |        |          |IRQSRC[22].1 - USCI1_INT
S     * |        |          |IRQSRC[22].2 - USCI2_INT
S     * |        |          |IRQSRC[23].0 - USBD_INT
S     * |        |          |IRQSRC[23].1 - 0
S     * |        |          |IRQSRC[23].2 - 0
S     * |        |          |IRQSRC[24].0 - SMC0_INT
S     * |        |          |IRQSRC[24].1 - SMC1_INT
S     * |        |          |IRQSRC[24].2 - 0
S     * |        |          |IRQSRC[25].0 - ACMP_INT
S     * |        |          |IRQSRC[25].1 - 0
S     * |        |          |IRQSRC[25].2 - 0
S     * |        |          |IRQSRC[26].0 - PDMA_INT
S     * |        |          |IRQSRC[26].1 - 0
S     * |        |          |IRQSRC[26].2 - 0
S     * |        |          |IRQSRC[27].0 - 0
S     * |        |          |IRQSRC[27].1 - 0
S     * |        |          |IRQSRC[27].2 - 0
S     * |        |          |IRQSRC[28].0 - PWRWU_INT
S     * |        |          |IRQSRC[28].1 - 0
S     * |        |          |IRQSRC[28].2 - 0
S     * |        |          |IRQSRC[29].0 - ADC_INT
S     * |        |          |IRQSRC[29].1 - 0
S     * |        |          |IRQSRC[29].2 - 0
S     * |        |          |IRQSRC[30].0 - IRC_INT
S     * |        |          |IRQSRC[30].1 - CLKD_INT
S     * |        |          |IRQSRC[30].2 - SRAMF_INT
S     * |        |          |IRQSRC[31].0 - RTC_INT
S     * |        |          |IRQSRC[31].1 - 0
S     * |        |          |IRQSRC[31].2 - 0
S     * @var SYS_INT_T::NMISEL
S     * Offset: 0x80  NMI Source Interrupt Select Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[4:0]   |NMISEL    |NMI Interrupt Source Selection
S     * |        |          |The NMI interrupt to Cortex-M0 can be selected from one of the peripheral interrupt by setting NMISEL.
S     * |[8]     |NMIEN     |NMI Interrupt Enable Bit (Write Protect)
S     * |        |          |0 = NMI interrupt Disabled.
S     * |        |          |1 = NMI interrupt Enabled.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     */
S
S
S    __I  uint32_t IRQSRC[32];            /*!< [0x0000-0x007C] MCU IRQn(n=0~31) Interrupt Source Identity Register       */
S    __IO uint32_t NMISEL;                /*!< [0x0080] NMI Source Interrupt Select Control Register                     */
S
S
S} SYS_INT_T;
S
S/**
S    @addtogroup INT_CONST INT Bit Field Definition
S    Constant Definitions for INT Controller
S@{ */
S
S#define INT_INTSRC_INTSRC_Pos             (0)                                               /*!< SYS_INT_T::INTSRC: INTSRC Position           */
S#define INT_INTSRC_INTSRC_Msk             (0xful << INT_INTSRC_INTSRC_Pos)                  /*!< SYS_INT_T::INTSRC: INTSRC Mask               */
S
S#define INT_NMISEL_NMISEL_Pos             (0)                                               /*!< SYS_INT_T::NMISEL: NMISEL Position           */
S#define INT_NMISEL_NMISEL_Msk             (0x1ful << INT_NMISEL_NMISEL_Msk)                 /*!< SYS_INT_T::NMISEL: NMISEL Mask               */
S
S#define INT_NMISEL_NMIEN_Pos              (8)                                               /*!< SYS_INT_T::NMISEL: NMIEN Position            */
S#define INT_NMISEL_NMIEN_Msk              (0x1ul << INT_NMISEL_NMIEN_Pos)                   /*!< SYS_INT_T::NMISEL: NMIEN Mask                */
S
S/**@}*/ /* INT_CONST */
S/**@}*/ /* end of SYS register group */
S
S
S
S
S/*---------------------- Timer Controller -------------------------*/
S/**
S    @addtogroup TIMER Timer Controller(TIMER)
S    Memory Mapped Structure for TIMER Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var TIMER_T::CTL
S     * Offset: 0x00  Timer Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |PSC       |Prescale Counter
S     * |        |          |Timer input clock or event source is divided by (PSC+1) before it is fed to the timer up counter
S     * |        |          |If this field is 0 (PSC = 0), then there is no scaling.
S     * |        |          |Note: Update prescale counter value will reset internal 8-bit prescale counter and 24-bit up counter value.
S     * |[19]    |INTRGEN   |Inter-Timer Trigger Mode Enable Control
S     * |        |          |Setting this bit will enable the inter-timer trigger capture function.
S     * |        |          |The Timer0/2 will be in event counter mode and counting with external clock source or event
S     * |        |          |Also, Timer1/3 will be in trigger-counting mode of capture function.
S     * |        |          |0 = Inter-Timer Trigger Capture mode Disabled.
S     * |        |          |1 = Inter-Timer Trigger Capture mode Enabled.
S     * |        |          |Note: For Timer1/3, this bit is ignored and the read back value is always 0.
S     * |[20]    |PERIOSEL  |Periodic Mode Behavior Selection Enable Bit
S     * |        |          |0 = The behavior selection in periodic mode is Disabled.
S     * |        |          |When user updates CMPDAT while timer is running in periodic mode,
S     * |        |          |CNT will be reset to default value.
S     * |        |          |1 = The behavior selection in periodic mode is Enabled.
S     * |        |          |When user update CMPDAT while timer is running in periodic mode, the limitations as bellows list,
S     * |        |          |If updated CMPDAT value > CNT, CMPDAT will be updated and CNT keep running continually.
S     * |        |          |If updated CMPDAT value = CNT, timer time-out interrupt will be asserted immediately.
S     * |        |          |If updated CMPDAT value < CNT, CNT will be reset to default value.
S     * |[21]    |TGLPINSEL |Toggle-Output Pin Select
S     * |        |          |0 = Toggle mode output to Tx (Timer Event Counter Pin).
S     * |        |          |1 = Toggle mode output to Tx_EXT (Timer External Capture Pin).
S     * |[22]    |CAPSRC    |Capture Pin Source Selection
S     * |        |          |0 = Capture Function source is from Tx_EXT (x= 0~3) pin.
S     * |        |          |1 = Capture Function source is from internal ACMP output signal
S     * |        |          |User can set ACMPSSEL (TIMERx_EXTCTL[8]) to decide which internal ACMP output signal as timer capture source.
S     * |[23]    |WKEN      |Wake-Up Function Enable Bit
S     * |        |          |If this bit is set to 1, while timer interrupt flag TIF (TIMERx_INTSTS[0]) is 1 and INTEN (TIMERx_CTL[29]) is enabled, the timer interrupt signal will generate a wake-up trigger event to CPU.
S     * |        |          |0 = Wake-up function Disabled if timer interrupt signal generated.
S     * |        |          |1 = Wake-up function Enabled if timer interrupt signal generated.
S     * |[24]    |EXTCNTEN  |Event Counter Mode Enable Bit
S     * |        |          |This bit is for external counting pin function enabled.
S     * |        |          |0 = Event counter mode Disabled.
S     * |        |          |1 = Event counter mode Enabled.
S     * |        |          |Note: When timer is used as an event counter, this bit should be set to 1 and select PCLK as timer clock source.
S     * |[25]    |ACTSTS    |Timer Active Status Bit (Read Only)
S     * |        |          |This bit indicates the 24-bit up counter status.
S     * |        |          |0 = 24-bit up counter is not active.
S     * |        |          |1 = 24-bit up counter is active.
S     * |[28:27] |OPMODE    |Timer Counting Mode Select
S     * |        |          |00 = The Timer controller is operated in One-shot mode.
S     * |        |          |01 = The Timer controller is operated in Periodic mode.
S     * |        |          |10 = The Timer controller is operated in Toggle-output mode.
S     * |        |          |11 = The Timer controller is operated in Continuous Counting mode.
S     * |[29]    |INTEN     |Timer Interrupt Enable Bit
S     * |        |          |0 = Timer time-out iInterrupt Disabled.
S     * |        |          |1 = Timer time-out iInterrupt Enabled.
S     * |        |          |Note: If this bit is enabled, when the timer time-out interrupt flag TIF is set to 1, the timer interrupt signal is generated and inform to CPU.
S     * |[30]    |CNTEN     |Timer Counting Enable Bit
S     * |        |          |0 = Stops/Suspends counting.
S     * |        |          |1 = Starts counting.
S     * |        |          |Note1: In stop status, and then set CNTEN to 1 will enable the 24-bit up counter to keep counting from the last stop counting value.
S     * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode (TIMER_CTL[28:27] = 00) when the timer time-out interrupt flag TIF (TIMERx_INTSTS[0]) is generated.
S     * |        |          |Note3: Set enable/disable this bit needs 2 * TMR_CLK period to become active, user can read ACTSTS (TIMERx_CTL[25]) to check enabe/disable command is completed or not.
S     * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control (Write Protect)
S     * |        |          |0 = ICE debug mode acknowledgement effects TIMER counting.
S     * |        |          |TIMER counter will be held while CPU is held by ICE.
S     * |        |          |1 = ICE debug mode acknowledgement Disabled.
S     * |        |          |TIMER counter will keep going no matter CPU is held by ICE or not.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * @var TIMER_T::CMP
S     * Offset: 0x04  Timer Comparator Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[23:0]  |CMPDAT    |Timer Comparedator Value
S     * |        |          |CMPDAT is a 24-bit compared value register
S     * |        |          |When the internal 24-bit up counter value is equal to CMPDAT value, the TIF (TIMERx_INTSTS[0] Timer Interrupt Flag) will set to 1.
S     * |        |          |Time-out period = (Period of timer clock input) * (8-bit PSC + 1) * (24-bit CMPDAT).
S     * |        |          |Note1: Never write 0x0 or 0x1 in CMPDAT field, or the core will run into unknown state.
S     * |        |          |Note2: When timer is operating at continuous counting mode, the 24-bit up counter will keep counting continuously even if user writes a new value into CMPDAT field
S     * |        |          |But if timer is operating at other modes, the 24-bit up counter will restart counting from 0 and using newest CMPDAT value to be the timer compared value while user writes a new value into CMPDAT field.
S     * @var TIMER_T::INTSTS
S     * Offset: 0x08  Timer Interrupt Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TIF       |Timer Interrupt Flag
S     * |        |          |This bit indicates the interrupt flag status of Timer while 24-bit timer up counter CNT (TIMERx_CNT[23:0]) value reaches to CMPDAT (TIMERx_CMP[23:0]) value.
S     * |        |          |0 = No effect.
S     * |        |          |1 = CNT value matches the CMPDAT value.
S     * |        |          |Note: This bit is cleared by writing 1 to it.
S     * |[1]     |TWKF      |Timer Wake-Up Flag
S     * |        |          |This bit indicates the interrupt wake-up flag status of timer.
S     * |        |          |0 = Timer does not cause CPU wake-up.
S     * |        |          |1 = CPU wake-up from Idle or Power-down mode if timer time-out interrupt signal generated.
S     * |        |          |Note: This bit is cleared by writing 1 to it.
S     * @var TIMER_T::CNT
S     * Offset: 0x0C  Timer Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[23:0]  |CNT       |Timer Data Register
S     * |        |          |Read operation.
S     * |        |          |Read this register to get CNT value. For example:
S     * |        |          |If EXTCNTEN (TIMERx_CTL[24] ) is 0, user can read CNT value for getting current 24-bit counter value.
S     * |        |          |If EXTCNTEN (TIMERx_CTL[24] ) is 1, user can read CNT value for getting current 24-bit event input counter value.
S     * |        |          |Write operation.
S     * |        |          |Writing any value to this register will reset current CNT value to 0 and reload internal 8-bit prescale counter.
S     * |[31]    |RSTACT    |Timer Data Register Reset Active (Read Only)
S     * |        |          |This bit indicates if the counter reset operation active.
S     * |        |          |When user writes this CNT register, timer starts to reset its internal 24-bit timer up-counter to 0 and reload 8-bit pre-scale counter
S     * |        |          |At the same time, timer set this flag to 1 to indicate the counter reset operation is in progress
S     * |        |          |Once the counter reset operation done, timer clear this bit to 0 automatically.
S     * |        |          |0 = Reset operation is done.
S     * |        |          |1 = Reset operation triggered by writing TIMERx_CNT is in progress.
S     * |        |          |Note: This bit is read only.
S     * @var TIMER_T::CAP
S     * Offset: 0x10  Timer Capture Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[23:0]  |CAPDAT    |Timer Capture Data Register
S     * |        |          |When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on Tx_EXT pin matched the CAPEDGE (TIMERx_EXTCTL[14:12]) setting, CAPIF (TIMERx_EINTSTS[0]) will set to 1 and the current timer counter value CNT (TIMERx_CNT[23:0]) will be auto-loaded into this CAPDAT field.
S     * @var TIMER_T::EXTCTL
S     * Offset: 0x14  Timer External Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CNTPHASE  |Timer External Count Phase
S     * |        |          |This bit indicates the detection phase of external counting pin Tx (x= 0~3).
S     * |        |          |0 = A falling edge of external counting pin will be counted.
S     * |        |          |1 = A rising edge of external counting pin will be counted.
S     * |[3]     |CAPEN     |Timer External Capture Pin Enable Bit
S     * |        |          |This bit enables the Tx_EXT capture pin input function.
S     * |        |          |0 =Tx_EXT (x= 0~3) pin Disabled.
S     * |        |          |1 =Tx_EXT (x= 0~3) pin Enabled.
S     * |[4]     |CAPFUNCS  |Capture Function Selection
S     * |        |          |0 = External Capture Mode Enabled.
S     * |        |          |1 = External Reset Mode Enabled.
S     * |        |          |Note1: When CAPFUNCS is 0, transition on Tx_EXT (x= 0~3) pin is using to save current 24-bit timer counter value (CNT value) to CAPDAT field.
S     * |        |          |Note2: When CAPFUNCS is 1, transition on Tx_EXT (x= 0~3) pin is using to save current 24-bit timer counter value (CNT value) to CAPDAT field and then CNT value will be reset immediately.
S     * |[5]     |CAPIEN    |Timer External Capture Interrupt Enable Bit
S     * |        |          |0 = Tx_EXT (x= 0~3) pin detection Interrupt Disabled.
S     * |        |          |1 = Tx_EXT (x= 0~3) pin detection Interrupt Enabled.
S     * |        |          |Note: CAPIEN is used to enable timer external interrupt
S     * |        |          |If CAPIEN enabled, timer will rise an interrupt when CAPIF (TIMERx_EINTSTS[0]) is 1.
S     * |        |          |For example, while CAPIEN = 1, CAPEN = 1, and CAPEDGE = 00, a 1 to 0 transition on the Tx_EXT pin will cause the CAPIF to be set then the interrupt signal is generated and sent to NVIC to inform CPU.
S     * |[6]     |CAPDBEN   |Timer External Capture Pin De-Bounce Enable Bit
S     * |        |          |0 = Tx_EXT (x= 0~3) pin de-bounce or ACMP output de-bounce Disabled.
S     * |        |          |1 = Tx_EXT (x= 0~3) pin de-bounce or ACMP output de-bounce Enabled.
S     * |        |          |Note: If this bit is enabled, the edge detection of Tx_EXT pin or ACMP output is detected with de-bounce circuit.
S     * |[7]     |CNTDBEN   |Timer Counter Pin De-Bounce Enable Bit
S     * |        |          |0 = Tx (x= 0~3) pin de-bounce Disabled.
S     * |        |          |1 = Tx (x= 0~3) pin de-bounce Enabled.
S     * |        |          |Note: If this bit is enabled, the edge detection of Tx pin is detected with de-bounce circuit.
S     * |[8]     |ACMPSSEL  |ACMP Source Selection to Trigger Capture Function
S     * |        |          |0 = Capture Function source is from internal ACMP0 output signal.
S     * |        |          |1 = Capture Function source is from internal ACMP1 output signal.
S     * |        |          |Note: these bits only available when CAPSRC (TIMERx_CTL[22]) is 1.
S     * |[14:12] |CAPEDGE   |Timer External Capture Pin Edge Detect
S     * |        |          |When first capture event is generated, the CNT (TIMERx_CNT[23:0]) will be reset to 0 and first CAPDAT (TIMERx_CAP[23:0]) should be to 0.
S     * |        |          |000 = Capture event occurred when detect falling edge transfer on Tx_EXT (x= 0~3) pin.
S     * |        |          |001 = Capture event occurred when detect rising edge transfer on Tx_EXT (x= 0~3) pin.
S     * |        |          |010 = Capture event occurred when detect both falling and rising edge transfer on Tx_EXT (x= 0~3) pin, and first capture event occurred at falling edge transfer.
S     * |        |          |011 = Capture event occurred when detect both rising and falling edge transfer on Tx_EXT (x= 0~3) pin, and first capture event occurred at rising edge transfer.
S     * |        |          |110 = First capture event occurred at falling edge, follows capture events are at rising edge transfer on Tx_EXT (x= 0~3) pin.
S     * |        |          |111 = First capture event occurred at rising edge, follows capture events are at falling edge transfer on Tx_EXT (x= 0~3) pin.
S     * |        |          |100, 101 = Reserved.
S     * |[16]    |ECNTSSEL  |Event Counter Source Selection to Trigger Event Counter Function
S     * |        |          |0 = Event Counter input source is from Tx (x= 0~3) pin.
S     * |        |          |1 = Event Counter input source is from USB internal SOF output signal.
S     * @var TIMER_T::EINTSTS
S     * Offset: 0x18  Timer0 External Interrupt Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CAPIF     |Timer External Capture Interrupt Flag
S     * |        |          |This bit indicates the timer external capture interrupt flag status.
S     * |        |          |0 = Tx_EXT (x= 0~3) pin interrupt did not occur.
S     * |        |          |1 = Tx_EXT (x= 0~3) pin interrupt occurred.
S     * |        |          |Note1: This bit is cleared by writing 1 to it.
S     * |        |          |Note2: When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on Tx_EXT (x= 0~3) pin matched the CAPEDGE (TIMERx_EXTCTL[2:1]) setting, this bit will set to 1 by hardware.
S     * |        |          |Note3: There is a new incoming capture event detected before CPU clearing the CAPIF status
S     * |        |          |If the above condition occurred, the Timer will keep register TIMERx_CAP unchanged and drop the new capture value.
S     * @var TIMER_T::TRGCTL
S     * Offset: 0x1C  Timer Trigger Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TRGSSEL   |Trigger Source Select Bit
S     * |        |          |This bit is used to select internal trigger source is form Timer timer time-out interrupt signal or capture interrupt signal.
S     * |        |          |0 = Timer tTime-out interrupt signal is used to internal trigger PWM, PDMA, and ADC.
S     * |        |          |1 = Capture interrupt signal is used to internal trigger PWM, PDMA, and ADC.
S     * |[1]     |TRGPWM    |Trigger PWM Enable Bit
S     * |        |          |If this bit is set to 1, each timer time-out event interrupt or capture interrupt event can be as PWM counter clock source.triggered PWM.
S     * |        |          |0 = Timer interrupt trigger PWM Disabled.
S     * |        |          |1 = Timer interrupt trigger PWM Enabled.
S     * |        |          |Note: If TRGSSEL (TIMERx_TRGCTL[0]) = 0, time-out interrupt signal will as trigger PWM counter clock source.
S     * |        |          |If TRGSSEL (TIMERx_TRGCTL[0]) = 1, capture interrupt signal as PWM counter clock source will trigger PWM.
S     * |[2]     |TRGADC    |Trigger ADC Enable Bit
S     * |        |          |If this bit is set to 1, each timer time-out event interrupt or capture interrupt event can be triggered ADC conversion.
S     * |        |          |0 = Timer interrupt trigger ADC Disabled.
S     * |        |          |1 = Timer interrupt trigger ADC Enabled.
S     * |        |          |Note: If TRGSSEL (TIMERx_TRGCTL[0]) = 0, time-out interrupt signal will trigger EADC conversion.
S     * |        |          |If TRGSSEL (TIMERx_TRGCTL[0]) = 1, capture interrupt signal will trigger EADC conversion.
S     * |[4]     |TRGPDMA   |Trigger PDMA Enable Bit
S     * |        |          |If this bit is set to 1, each timer time-out interrupt event or capture interrupt event can be triggered PDMA transfer.
S     * |        |          |0 = Timer interrupt trigger PDMA Disabled.
S     * |        |          |1 = Timer interrupt trigger PDMA Enabled.
S     * |        |          |Note: If TRGSSEL (TIMERx_TRGCTL[0]) = 0, time-out interrupt signal will trigger PDMA transfer.
S     * |        |          |If TRGSSEL (TIMERx_TRGCTL[0]) = 1, capture interrupt signal will trigger PDMA transfer.
S     * @var TIMER_T::ALTCTL
S     * Offset: 0x20  Timer Alternative Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |FUNCSEL   |Function Selection
S     * |        |          |0 = Timer controller is used as timer function.
S     * |        |          |1 = Timer controller is used as PWM function.
S     * |        |          |Note: When timer is used as PWM, the clock source of time controller will be forced to PCLKx automatically.
S     * @var TIMER_T::PWMCTL
S     * Offset: 0x40  Timer PWM Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CNTEN     |PWM Counter Enable Bit
S     * |        |          |0 = PWM counter and clock prescale Stop Running.
S     * |        |          |1 = PWM counter and clock prescale Start Running.
S     * |[2:1]   |CNTTYPE   |PWM Counter Behavior Type
S     * |        |          |00 = Up count type.
S     * |        |          |01 = Down count type.
S     * |        |          |10 = Up-down count type.
S     * |        |          |11 = Reserved.
S     * |[3]     |CNTMODE   |PWM Counter Mode
S     * |        |          |0 = Auto-reload mode.
S     * |        |          |1 = One-shot mode.
S     * |[8]     |CTRLD     |Center Re-Load
S     * |        |          |In up-down count type, PERIOD will load to PBUF when current PWM period is completedat the end point of each period
S     * |        |          |always and CMPDAT will load to CMPBUF at the center point of current period at the center point of a period.
S     * |[9]     |IMMLDEN   |Immediately Load Enable Bit
S     * |        |          |0 = PERIOD will load to PBUF when current PWM period is completed no matter CTRLD is enabled/disabled.at the end point of each period
S     * |        |          |If CTRLD is disabled, CMPDAT will load to CMPBUF when current PWM period is completed; if CTRLD is enabled in up-down count type, CMPDAT will load to CMPBUF at the center point of current period at the end point of each period by setting CTRLD bit.
S     * |        |          |1 = PERIOD//CMPDAT will load to PBUF and /CMPBUF immediately when usersoftware update PPERIOD//CMPDAT.
S     * |        |          |Note: If IMMLDEN is enabled, CTRLD will be invalid.
S     * |[16]    |OUTMODE   |PWM Output Mode
S     * |        |          |0 = PWM independent mode.
S     * |        |          |1 = PWM complementary mode.
S     * |[30]    |DBGHALT   |ICE Debug Mode Counter Halt (Write Protect)
S     * |        |          |If debug mode counter halt is enabled, PWM all counters will keep current value until exit ICE debug mode.
S     * |        |          |0 = ICE debug mode counter halt disable.
S     * |        |          |1 = ICE debug mode counter halt enable.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[31]    |DBGTRIOFF |ICE Debug Mode Acknowledge Disable Bit (Write Protect)
S     * |        |          |0 = ICE debug mode acknowledgement effects PWM output.
S     * |        |          |PWM output pin will be forced as tri-state while ICE debug mode acknowledged.
S     * |        |          |1 = ICE debug mode acknowledgement disabled.
S     * |        |          |PWM output pin will keep output no matter ICE debug mode acknowledged or not.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * @var TIMER_T::PWMCLKSRC
S     * Offset: 0x44  Timer PWM Counter Clock Source Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2:0]   |CLKSRC    |PWM Counter External Clock Source Select
S     * |        |          |The PWM counter clock source can be selected from TMRx_CLK or internal timer time-out or capture event.
S     * |        |          |000 = TMRx_CLK.
S     * |        |          |001 = Internal TIMER0 time-out or capture event overflow.
S     * |        |          |010 = Internal TIMER1 time-out or capture event TIMER1 overflow.
S     * |        |          |011 = Internal TIMER2 time-out or capture event TIMER2 overflow.
S     * |        |          |100 = Internal TIMER3 time-out or capture event TIMER3 overflow.
S     * |        |          |Others = Reserved.
S     * |        |          |Note: If TIMER0 PWM function is enabled, trigger sourcthe PWM counter clock source can be selected from TMR0_CLK, TIMER1 interrupt events, TIMER2 interrupt events, or TIMER3 interrupt eventse from different TIMER1, TIMER2, and TIMER3u2019s overflow.
S     * @var TIMER_T::PWMCLKPSC
S     * Offset: 0x48  Timer PWM Counter Clock Pre-scale Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-Scale
S     * |        |          |The active clock of PWM counter is decided by counter clock prescale and
S     * |        |          |Each PWM channel pair share one PWM counter clock prescale
S     * |        |          |The clock of PWM counter is divided by (CLKPSC + 1)
S     * |        |          |If CLKPSC is 0, then there is no scaling in PWM counter clock source.
S     * @var TIMER_T::PWMCNTCLR
S     * Offset: 0x4C  Timer PWM Clear Counter Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CNTCLR    |Clear PWM Counter Control Bit
S     * |        |          |It is automatically cleared by hardware.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear 16-bit PWM counter to 0000 0x10000 in up and up-down count type and reset counter value to PERIOD in down count type.H.
S     * @var TIMER_T::PWMPERIOD
S     * Offset: 0x50  Timer PWM Period Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |PERIOD    |PWM Period Register
S     * |        |          |In uUp cCount typemode: In this mode, PWM counter counts from 00 to PERIOD, and restarts from 00.
S     * |        |          |In dDown cCount typemode: In this mode, PWM counter counts from PERIOD to 0, and restarts from PERIOD.
S     * |        |          |In up-down count type: PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
S     * |        |          |In up and down count type:
S     * |        |          |PWM period time = (PERIOD + 1) ** (CLKPSC + 1) x * TMRx_PWMCLK.
S     * |        |          |In up-down count type:
S     * |        |          |Up-Down Count mode: In this mode, PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
S     * |        |          |PWM period time = 2 * * PERIOD * * (CLKPSC+ 1) x * TMRx_PWMCLK
S     * |        |          |Note: User should take care DIRF (TIMERx_PWMCNT[16]) bit in up/down/up-down count type to monitor current counter direction in each count type..
S     * @var TIMER_T::PWMCMPDAT
S     * Offset: 0x54  Timer PWM Comparator Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CMPDAT    |PWM Comparator
S     * |        |          |PWM CMPDAT is used to compare with PWM CNT to generate PWM output waveform, interrupt events and trigger ADC to start convert.
S     * @var TIMER_T::PWMDTCTL
S     * Offset: 0x58  Timer PWM Dead-Time Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |DTCNT     |Dead-Time Counter (Write Protect)
S     * |        |          |The dead-time can be calculated from the following two formulas:
S     * |        |          |Dead-time = (DTCNT[11:0] + 1) * * TMRx_PWMCLK, if DTCKSEL is 0.
S     * |        |          |Dead-time = (DTCNT[11:0] + 1) * TMRx_PWMCLK * (CLKPSC + 1), if DTCKSEL is 1.
S     * |        |          |period.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[16]    |DTEN      |Enable Dead-Time Insertion For PWM Pair (PWMx_CH0 and, PWMx_CH1) (PWM_CH2, PWM_CH3) (Write Protect)
S     * |        |          |Dead-time insertion function is only active when this pair of complementary PWM complementary mode is enabled
S     * |        |          |If dead- time insertion is inactive, the outputs of pin PWMx_CH0 and PWMx_CH1pair are complementary without any delay.
S     * |        |          |0 = Dead-time insertion Disabled on the pin pair.
S     * |        |          |1 = Dead-time insertion Enabled on the pin pair.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[24]    |DTCKSEL   |Dead-Ttime Cclock Sselect (Write Protect)
S     * |        |          |0 = Dead-time clock source from TMRx_PWMCLK without counter clock prescale.
S     * |        |          |1 = Dead-time clock source from TMRx_PWMCLK with counter clock prescale prescale output.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL REGWRPROT register.
S     * @var TIMER_T::PWMCNT
S     * Offset: 0x5C  Timer PWM Counter Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CNT       |PWM Counter ValueData Register (Read Only)
S     * |        |          |User can monitor CNTR to know the current counter value in 16-bit period counter.
S     * |[16]    |DIRF      |PWM Counter Direction Indicator Flag (Read Only)
S     * |        |          |0 = Counter is active in dDown count.
S     * |        |          |1 = Counter is active upUP count.
S     * @var TIMER_T::PWMMSKEN
S     * Offset: 0x60  Timer PWM Output Mask Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |MSKEN0    |PWMx_CH0 Output Mask Enable Bit
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |The PWMx_CH0 output signal will be masked when this bit is enabled
S     * |        |          |The corresponding PWMx_CH0 channel n will output MSKDAT0n (TIMER_PWM_MSK[1:0]) data.
S     * |        |          |0 = PWMx_CH0 output signal is non-masked.
S     * |        |          |1 = PWMx_CH0M output signal is masked and output MSKDAT0n data.
S     * |        |          |Note: n=0, 1.
S     * |[1]     |MSKEN1    |PWMx_CH1 Output Mask Enable Bit
S     * |        |          |The PWMx_CH1 output signal will be masked when this bit is enabled
S     * |        |          |The PWMx_CH1 will output MSKDAT1 (TIMER_PWMMSK[1]) data.
S     * |        |          |0 = PWMx_CH1 output signal is non-masked.
S     * |        |          |1 = PWMx_CH1 output signal is masked and output MSKDAT1 data.
S     * @var TIMER_T::PWMMSK
S     * Offset: 0x64  Timer PWM Output Mask Data Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |MSKDAT0   |PWMx_CH0 Output Mask Data Control Bit Bit
S     * |        |          |This bit is used to control the output state of PWMx_CH0 pin whenThis data bit control the state of PWMn output pin, if PWMx_CH0 correspooutput nding mask mask function is enabled (MSKEN0 = 1)
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Output logic Llow to PWMnPWMx_CH0.
S     * |        |          |1 = Output logic Hhigh to PWMx_CH0PWMn.
S     * |        |          |Note: n=0, 1.
S     * |[1]     |MSKDAT1   |PWMx_CH1 Output Mask Data Control Bit
S     * |        |          |This bit is used to control the output state of PWMx_CH1 pin when PWMx_CH1 output mask function is enabled (MSKEN1 = 1).
S     * |        |          |0 = Output logic Low to PWMx_CH1.
S     * |        |          |1 = Output logic High to PWMx_CH1.
S     * @var TIMER_T::PWMBNF
S     * Offset: 0x68  Timer PWM Brake Pin Noise Filter Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |BRKNFEN   |Brake Pin Noise Filter Enable Bit
S     * |        |          |0 = Pin dDe-bBounce detect of TMR_BRAKEx Disabled.
S     * |        |          |1 = Pin dDe-bBounce detect of TMR_BRAKEx Enabled.
S     * |[3:1]   |BRKNFSEL  |Brake Edge Pin Detector De-Bounce Clock Selection
S     * |        |          |000 = De-Bounce clock = is PCLKx.
S     * |        |          |001 = De-Bounce clock = is PCLKx/2.
S     * |        |          |010 = De-Bounce clock = is PCLKx/4.
S     * |        |          |011 = De-Bounce clock = is PCLKx/8.
S     * |        |          |100 = De-Bounce clock = is PCLKx/16.
S     * |        |          |101 = De-Bounce clock = is PCLKx/32.
S     * |        |          |110 = De-Bounce clock = is PCLKx/64.
S     * |        |          |111 = De-Bounce clock = is PCLKx/128.
S     * |[6:4]   |BRKFCNT   |Brake Pin Edge Detector De-Bounce Count
S     * |        |          |The register fields is used to bits control the active de-bounce sample time.
S     * |        |          |Once de-bounce sample time = (Period time of BRKDBCS)Brake0 filter counter to count from 0 to BRK0FCNT
S     * |        |          |* BRKDBCNT.
S     * |[7]     |BRKPINV   |Brake Pin InverseDetection Control Bit
S     * |        |          |0 = The state of pin TM_BRAKEx is passed to the negative edge detector. x=0~3.
S     * |        |          |Set BRKPINV 0 will detect TM_BRAKEx Brake pin event will be detected if TM_BRAKEx pin status transfer from from low lowto to high in edge-detect, or pin status is high in level-detect.high
S     * |        |          |1 = Brake pin event will be detected if TM_BRAKEx pin status transfer from high to low in edge-detect, or pin status is low in level-detect The inversed state of pin TM_BRAKEx is passed to the negative edge detector
S     * |        |          |x=0~3.
S     * |        |          |Set BRKPINV 1 will detect TM_BRAKEx pin status from high to low.
S     * |[17:16] |BKPINSRC  |Brake Pin Source Select
S     * |        |          |00 = Brake pin source comes from TMR_BRAKE0.
S     * |        |          |01 = Brake pin source comes from TMR_BRAKE1.
S     * |        |          |10 = Brake pin source comes from TMR_BRAKE2.
S     * |        |          |11 = Brake pin source comes from TMR_BRAKE3.
S     * @var TIMER_T::PWMFAILBRK
S     * Offset: 0x6C  Timer PWM System Fail Brake Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CSSBRKEN  |Clock Security System Detection Trigger PWM Brake Function Enable Bit
S     * |        |          |0 = Brake Function triggered by CSS clock fail detection Disabled.
S     * |        |          |1 = Brake Function triggered by clock fail CSS detection Enabled.
S     * |        |          |Note: This register is only in TIMER0 and TIMER2.
S     * |[1]     |BODBRKEN  |Brown-Out Detection Trigger PWM Brake Function Enable Bit
S     * |        |          |0 = Brake Function triggered by BOD event Disabled.
S     * |        |          |1 = Brake Function triggered by BOD event Enabled.
S     * |        |          |Note: This register is only in TIMER0 and TIMER2.
S     * |[3]     |CORBRKEN  |Core Lockup Detection Trigger PWM Brake Function Enable Bit
S     * |        |          |0 = Brake Function triggered by cCore lockup detection event Disabled.
S     * |        |          |1 = Brake Function triggered by cCore lockup detection event Enabled.
S     * |        |          |Note: This register is only in TIMER0 and TIMER2.
S     * @var TIMER_T::PWMBRKCTL
S     * Offset: 0x70  Timer PWM Brake Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CPO0EBEN  |Enable Internal ACMP0_O Digital Output As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = Internal ACMP0_O signal as edge-detect brake source Disabled.
S     * |        |          |1 = Internal ACMP0_O signal as edge-detect brake source Enabled.
S     * |        |          |Note1: Only internal ACMP0_O signal from low to high will be detected as brake event.
S     * |        |          |Note2: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[1]     |CPO1EBEN  |Enable Internal ACMP1_O Digital Output As Edge-detect Brake Source (Write Protect)
S     * |        |          |0 = Internal ACMP1_O signal as edge-detect brake source Disabled.
S     * |        |          |1 = Internal ACMP1_O signal as edge-detect brake source Enabled.
S     * |        |          |Note1: Only internal ACMP1_O signal from low to high will be detected as brake event.
S     * |        |          |Note2: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[4]     |BRKPEEN   |Enable TMR_BRAKEx Pin As Edge-Detect Brake Source (Write Protect)
S     * |        |          |0 = TMR_BRAKEx pin event as edge-detect brake source Disabled.
S     * |        |          |1 = TMR_BRAKEx pin event as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[7]     |SYSEBEN   |Enable System Fail As Edge-Detect Brake Source (Write Protect)
S     * |        |          |0 = System fFail condition as edge-detect brake source Disabled.
S     * |        |          |1 = System fFail condition as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[8]     |CPO0LBEN  |Enable Internal ACMP0_O Digital Output As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = Internal ACMP0_O signal as level-detect brake source Disabled.
S     * |        |          |1 = Internal ACMP0_O signal as level-detect brake source Enabled.
S     * |        |          |Note1: Only internal ACMP0_O signal from low to high will be detected as brake event.
S     * |        |          |Note2: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[9]     |CPO1LBEN  |Enable Internal ACMP1_O Digital Output As Level-detect Brake Source (Write Protect)
S     * |        |          |0 = Internal ACMP1_O signal as level-detect brake source Disabled.
S     * |        |          |1 = Internal ACMP1_O signal as level-detect brake source Enabled.
S     * |        |          |Note1: Only internal ACMP1_O signal from low to high will be detected as brake event.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[12]    |BRKPLEN   |Enable TMR_BRAKEx Pin As Level-Detect Brake Source (Write Protect)
S     * |        |          |0 = TMR_BRAKEx Brake pin event as level-detect brake source Disabled.
S     * |        |          |1 = TMR_BRAKEx Brake pin event as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[15]    |SYSLBEN   |Enable System Fail As Level-Detect Brake Source (Write Protect)
S     * |        |          |0 = System fFail condition as level-detect brake source Disabled.
S     * |        |          |1 = System fFail condition as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[17:16] |BRKAEVEN  |PWM Brake Action Select For Even ChannelPWMx_CH0 (Write Protect)
S     * |        |          |00 = TIMERx_PWM even brake eventchannel level-detect brake functi willon not affect channel PWMx_CH0outpu outputt.
S     * |        |          |01 = PWMx_CH0PWM even channel output tri-state when TIMERx_PWM brake eventlevel-detect brake happened.
S     * |        |          |10 = PWMx_CH0 outputPWM even channel output low level when TIMERx_PWM brake event level-detect brake happened.
S     * |        |          |11 = PWMx_CH0 outputPWM even channel output high level when TIMERx_PWM brake eventlevel-detect brake happened.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[19:18] |BRKAODD   |PWM Brake Action Select For PWMx_CH1Odd Channel (Write Protect)
S     * |        |          |00 = TIMERx_PWM brake event will not affect PWMx_CH1 output.
S     * |        |          |01 = PWMx_CH1 output tri-state when TIMERx_PWM brake event happened.
S     * |        |          |10 = PWMx_CH1 output low level when TIMERx_PWM brake event happened.
S     * |        |          |11 = PWMx_CH1 output high level when TIMERx_PWM brake event happened.
S     * |        |          |00 = TIMER_PWM odd channel level-detect brake function not affect channel output.
S     * |        |          |01 = TIMER_PWM odd channel output tri-state when level-detect brake happened.
S     * |        |          |10 = TIMER_PWM odd channel output low level when level-detect brake happened.
S     * |        |          |11 = TIMER_PWM odd channel output high level when level-detect brake happened.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * @var TIMER_T::PWMPOLCTL
S     * Offset: 0x74  Timer PWM Output Pin Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PINV0     |PWMx_CH0 Output Pin Polar Control Bit
S     * |        |          |The register bit is used to controlcontrols polarity state of PWMx_CH0 output pin
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWMx_CH0 output pin polar inverse Disabled.
S     * |        |          |1 = PWMx_CH0 output pin PWM output polar inverse Enabled.
S     * |        |          |n=0, 1.
S     * |[1]     |PINV1     |PWMx_CH1 Output Pin Polar Control Bit
S     * |        |          |The bit is used to control polarity state of PWMx_CH1 output pin.
S     * |        |          |0 = PWMx_CH1 output pin polar inverse Disabled.
S     * |        |          |1 = PWMx_CH1 output pin polar inverse Enabled.
S     * @var TIMER_T::PWMPOEN
S     * Offset: 0x78  Timer PWM Output Pin Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |POEN0     |PWMx_CH0 Output Pin Output Enable Bit
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWMx_CH0 pin at tri-state mode.
S     * |        |          |1 = PWMx_CH0PWM pin in output mode.
S     * |        |          |n=0, 1.
S     * |[1]     |POEN1     |PWMx_CH1 Output Pin Enable Bit
S     * |        |          |0 = PWMx_CH1 pin at tri-state mode.
S     * |        |          |1 = PWMx_CH1 pin in output mode.
S     * @var TIMER_T::PWMSWBRK
S     * Offset: 0x7C  Timer PWM Software Trigger Brake Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |BRKETRG   |PWM Software Trigger Edge-Detect Brake SourceSoftware Trigger (Write Only) (Write Protect)
S     * |        |          |Write 1 to this bit will trigger PWM edge-detect brake source, then BRKEIF0 and BRKEIF1 will set to 1 automatically in TIMERx_PWMINTSTS1, and set BRKEIF to 1 in PWM_INTSTS1 register.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[8]     |BRKLTRG   |Software Trigger Level-Detect Brake Source PWM Level Brake Software Trigger (Write Only) (Write Protect)
S     * |        |          |Write 1 to this bit will trigger PWM level-detect brake source, and then set BRKLIF0 and BRKLIF1 will set to 1 automatically in TIMERx_PWM_INTSTS1 register.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * @var TIMER_T::PWMINTEN0
S     * Offset: 0x80  Timer PWM Interrupt Enable Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ZIEN      |PWM Zero Point Interrupt Enable Bit
S     * |        |          |0 = Zero point interrupt Disabled.
S     * |        |          |1 = Zero point interrupt Enabled.
S     * |        |          |Note: Odd channels will read always 0 at complementary mode.
S     * |[1]     |PIEN      |PWM Period Point Interrupt Enable Bit
S     * |        |          |0 = Period point interrupt Disabled.
S     * |        |          |1 = Period point interrupt Enabled.
S     * |        |          |Note: When When in up-down count type, period point means the center point of current PWM period.
S     * |[2]     |CMPUIEN   |PWM Compare Up Count Interrupt Enable Bit
S     * |        |          |0 = Compare up count interrupt Disabled.
S     * |        |          |1 = Compare up count interrupt Enabled.
S     * |[3]     |CMPDIEN   |PWM Compare Down Count Interrupt Enable Bit
S     * |        |          |0 = Compare down count interrupt Disabled.
S     * |        |          |1 = Compare down count interrupt Enabled.
S     * @var TIMER_T::PWMINTEN1
S     * Offset: 0x84  Timer PWM Interrupt Enable Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |BRKEIEN   |PWM Edge-Detect Brake Interrupt Enable For Channel0/1 (Write Protect)
S     * |        |          |0 = PWM eEdge-detect Brake brake interrupt for channel0/1 Disabled.
S     * |        |          |1 = PWM eEdge-detect Brake brake interrupt for channel0/1 Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[8]     |BRKLIEN   |PWM Level-Detect Brake Interrupt Enable For Channel0/1 (Write Protect)
S     * |        |          |0 = PWM lLevel-detect Brake brake interrupt for channel0/1 Disabled.
S     * |        |          |1 = PWM level-detect brake interruptLevel-detect Brake interrupt for channel0/1 Enabled.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * @var TIMER_T::PWMINTSTS0
S     * Offset: 0x88  Timer PWM Interrupt Status Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ZIF       |PWM Zero Point Interrupt Flag
S     * |        |          |This bit is set by hardware when TIMERx_PWM_CHx counter reaches zero, software can write 1 to clear this bit to zero
S     * |        |          |x=0, 1..
S     * |        |          |Note: This bit is cleared by writing 1 to it.
S     * |[1]     |PIF       |PWM Period Point Interrupt Flag
S     * |        |          |This bit is set by hardware when TIMERx_PWMPWM_CHx counter reaches PWMPERIOD.
S     * |        |          |Note: This bit is cleared by writing 1 to it.Note1: When in up-down count type, PIF flag means the center point flag of current PWM period.
S     * |        |          |Note2: This bit is cleared by writing 1 to it., software can write 1 to clear this bit to zero. x=0, 1.
S     * |[2]     |CMPUIF    |PWM Compare Up Count Interrupt Flag
S     * |        |          |Flag This bit is set by hardware when TIMERx_PWMPWM counter in up count direction and reaches PWMCMPDAT.,
S     * |        |          |Note1: This bit is cleared by writing 1 to it. software can clear this bit by writing 1 to it.
S     * |        |          |Note12: If CMPDAT equal to PERIOD, there is no CMPUIF flag this flag is not working in up count type and up-down count type
S     * |        |          |selection.
S     * |        |          |Note2: This bit is cleared by writing 1 to it.
S     * |[3]     |CMPDIF    |PWM Compare Down Count Interrupt Flag
S     * |        |          |Flag This bit is set by hardware when TIMERx_PWM PWM counter in down count direction and reaches PWMCMPDAT, software can clear this bit by writing 1 to it.
S     * |        |          |Note1: This bit is cleared by writing 1 to it.
S     * |        |          |Note12: If CMPDAT equal to PERIOD, this there is no CMPDIFflag flag is not working in down count type selection.
S     * |        |          |Note2: This bit is cleared by writing 1 to it.
S     * @var TIMER_T::PWMINTSTS1
S     * Offset: 0x8C  Timer PWM Interrupt Status Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |BRKEIF0   |PWM Channel0 Edge-Detect Brake Interrupt Flag on PWMx_CH0 (Write Protect)
S     * |        |          |0 = PWMx_CH0 channel0 edge-detect brake event do not happened.
S     * |        |          |1 = PWMx_CH0When PWM channel0 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
S     * |        |          |Note1: This bit is cleared by writing 1 to it.
S     * |        |          |Note2: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[1]     |BRKEIF1   |PWM Channel1 Edge-Detect Brake Interrupt Flag PWMx_CH1 (Write Protect)
S     * |        |          |0 = PWMx_CH1 edge-detect brake event do not happened.
S     * |        |          |1 = PWMx_CH1 edge-detect brake event happened.
S     * |        |          |0 = PWM channel1 edge-detect brake event do not happened.
S     * |        |          |1 = When PWM channel1 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
S     * |        |          |Note1: This bit is cleared by writing 1 to it.
S     * |        |          |Note2: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[8]     |BRKLIF0   |PWM Channel0 Level-Detect Brake Interrupt Flag on PWMx_CH0 (Write Protect)
S     * |        |          |0 = PWMx_CH0PWM channel0 level-detect brake event do not happened.
S     * |        |          |1 = PWMx_CH0When PWM channel0 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
S     * |        |          |Note1: This bit is cleared by writing 1 to it.
S     * |        |          |Note2: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[9]     |BRKLIF1   |PWM Channel1 Level-Detect Brake Interrupt Flag on PWMx_CH1 (Write Protect)
S     * |        |          |0 = PWMx_CH1 level-detect brake event do not happened.
S     * |        |          |1 = PWMx_CH1 level-detect brake event happened.
S     * |        |          |0 = PWM channel1 level-detect brake event do not happened.
S     * |        |          |1 = When PWM channel1 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
S     * |        |          |Note1: This bit is cleared by writing 1 to it.
S     * |        |          |Note2: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[16]    |BRKESTS0  |Edge -Detect Brake Status of PWMx_CH0 (Read Only)
S     * |        |          |0 = PWMx_CH0 edge-detect brake state is released.
S     * |        |          |1 = PWMx_CH0 at edge-detect brake state.
S     * |        |          |Note: User can set BRKEIF0 1 to clear BRKEIF0 flag and PWMx_CH0 will release brake state when current PWM period finished and resume PWMx_CH0 output waveform start from next full PWM period.PWM Channel0 Edge-Detect Brake Status (Read Only)
S     * |        |          |0 = PWM channel0 edge-detect brake state is released.
S     * |        |          |1 = When PWM channel0 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel0 at brake state.
S     * |[17]    |BRKESTS1  |PWM Channel1 Edge-Detect Brake Status of PWMx_CH1 (Read Only)
S     * |        |          |0 = PWMx_CH1 edge-detect brake state is released.
S     * |        |          |1 = PWMx_CH1 at edge-detect brake state.
S     * |        |          |Note: User can set BRKEIF1 1 to clear BRKEIF1 flag and PWMx_CH1 will release brake state when current PWM period finished and resume PWMx_CH1 output waveform start from next full PWM period.0 = PWM channel1 edge-detect brake state is released.
S     * |        |          |1 = When PWM channel1 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel1 at brake state.
S     * |[24]    |BRKLSTS0  |PWM Channel0 Level-Detect Brake Status of PWMx_CH0 (Read Only)
S     * |        |          |0 = PWMx_CH0PWM channel0 level-detect brake state is released.
S     * |        |          |1 = PWMx_CH0 at level-detect brake stateWhen PWM channel0 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel0 at brake state.
S     * |        |          |Note: This bit is read only and auto cleared by hardware
S     * |        |          |WhenIf TIMERx_PWM enabled level-detect brake source has released, both return to high level, PWMx_CH0 and PWMx_CH1PWM will release brake state until when current PWM period finished and resume
S     * |        |          |The PWMx_CH0 and PWMx_CH1 output waveform will start output from next full PWM period.
S     * |[25]    |BRKLSTS1  |PWM Channel1 Level-Detect Brake Status of PWMx_CH1 (Read Only)
S     * |        |          |0 = PWMx_CH1PWM channel1 level-detect brake state is released.
S     * |        |          |1 = PWMx_CH1 at level-detect brake state.
S     * |        |          |Note: If TIMERx_PWM level-detect brake source has released, both PWMx_CH0 and PWMx_CH1 will release brake state when current PWM period finished and resume PWMx_CH0 and PWMx_CH1 output waveform start from next full PWM period.1 = When PWM channel1 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel1 at brake state.
S     * |        |          |Note: This bit is read only and auto cleared by hardware
S     * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished
S     * |        |          |The PWM waveform will start output from next full PWM period.
S     * @var TIMER_T::PWMADCTS
S     * Offset: 0x90  Timer PWM Trigger ADC Source Select Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2:0]   |TRGSEL    |PWM Counter Event Source Select To Trigger ADC ConversionPWM_CH Trigger ADC Source Select
S     * |        |          |000 = Trigger ADC conversion at PWM_CH0 zero point. (ZIF).
S     * |        |          |001 = Trigger ADC conversion atPWM_CH0 period point. (PIF).
S     * |        |          |010 = Trigger ADC conversion atPWM_CH0 zero or period point. (ZIF or PIF).
S     * |        |          |011 = Trigger ADC conversion atPWM_CH0 compare up count CMPDAT point (CMPUIF).
S     * |        |          |100 = Trigger ADC conversion atPWM_CH0 compare down count CMPDAT point (CMPDIF).
S     * |        |          |Others = Rreserved.
S     * |[7]     |TRGEN     |PWM Counter Event Trigger ADC Conversion Enable Bit
S     * |        |          |0 = PWM counter event trigger ADC conversion Disabled.
S     * |        |          |1 = PWM counter event trigger ADC conversion Enabled.PWM_CH0 Trigger ADC enable bit.
S     * @var TIMER_T::PWMSCTL
S     * Offset: 0x94  Timer PWM Synchronous Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |SYNCMODE  |PWM Synchronous Mode Enable Select
S     * |        |          |00 = PWM synchronous function Disabled.
S     * |        |          |01 = PWM synchronous counter start function Enabled.
S     * |        |          |10 = Reserved.
S     * |        |          |11 = PWM synchronous counter clear function Enabled.
S     * |[8]     |SYNCSRC   |PWM Synchronous Counter Start/Clear Start Source Select
S     * |        |          |0 = Counter sSynchronous start/clear source by triggercome from TIMER0_PWMSSTRG STRGENCNTSEN.
S     * |        |          |1 = Counter sSynchronous start/clear source by triggercome from TIMER2_PWMSSTRG STRGENCNTSEN.
S     * |        |          |Note1: If TIMER0/1/2/3 PWM counter synchronous source are from TIMER0, TIME0_PWMSCTL[8], TIME1_PWMSCTL[8], TIME2_PWMSCTL[8] and TIME3_PWMSCTL[8] should be 0.
S     * |        |          |Note2: If TIMER0/1/ PWM counter synchronous source are from TIMER0, TIME0_PWMSCTL[8] and TIME1_PWMSCTL[8] should be set 0, and TIMER2/3/ PWM counter synchronous source are from TIMER2, TIME2_PWMSCTL[8] and TIME3_PWMSCTL[8] should be set 1.Note: This register is only in TIMER0 and TIMER2.
S     * @var TIMER_T::PWMSTRG
S     * Offset: 0x98  Timer PWM Synchronous Trigger Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |STRGEN    |PWM Counter Counter Synchronous Trigger Enable BitStart Enable (Write Only)
S     * |        |          |PMW counter synchronous enable function is used to make selected PWM channels (include TIMER0/1/2/3_ PWM, _CHx and TIMER02/1 PWM and TIMER2/33_ PWM_CHx) start counting or clear counter at the same time according to TIMERx_PWMSCTL setting.
S     * |        |          |Writing this bit to 1 will also set the counter enable bit (CNTEN) if correlated PWM channel counter synchronous start function is enabled.
S     * |        |          |Note: This register bit is only available in TIMER0 and TIMER2.
S     * @var TIMER_T::PWMSTATUS
S     * Offset: 0x9C  Timer PWM Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CNTMAXF   |Time-BasePWM Counter Counter Equal To 0xFFFF Latched SStatus
S     * |        |          |0 = Iindicates the timePWM counter-base coun valueter never reached its maximum value 0xFFFF.
S     * |        |          |1 = Iindicates the PWM counter value has time-base counter reached its maximum value, software can write 1 to clear this bit.e.
S     * |        |          |Note: This bit is cleared by writing 1 to it.
S     * |[16]    |ADCTRGF   |Trigger ADC Start Of Conversion Status
S     * |        |          |0 = PWM counter event trigger ADC start conversion is not occurred.Indicates no ADC start of conversion trigger event has occurred.
S     * |        |          |1 = PWM counter event trigger ADC start conversion has occurredIndicates an ADC start of conversion trigger event has occurred, software can write 1 to clear this bit..
S     * |        |          |Note: This bit is cleared by writing 1 to it.
S     * @var TIMER_T::PWMPBUF
S     * Offset: 0xA0  Timer PWM Period Buffer Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |PBUF      |PWM Period Buffer Register Buffer (Read Only)
S     * |        |          |Used as PERIOD active register.
S     * @var TIMER_T::PWMCMPBUF
S     * Offset: 0xA4  Timer PWM Comparator Buffer Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CMPBUF    |PWM Comparator Buffer Register Buffer (Read Only)
S     * |        |          |Used as CMPDAT active register.
S     */
S
S    __IO uint32_t CTL;                   /*!< [0x0000] Timer Control Register                                           */
S    __IO uint32_t CMP;                   /*!< [0x0004] Timer Comparator Register                                        */
S    __IO uint32_t INTSTS;                /*!< [0x0008] Timer Interrupt Status Register                                  */
S    __IO uint32_t CNT;                   /*!< [0x000c] Timer Data Register                                              */
S    __I  uint32_t CAP;                   /*!< [0x0010] Timer Capture Data Register                                      */
S    __IO uint32_t EXTCTL;                /*!< [0x0014] Timer External Control Register                                  */
S    __IO uint32_t EINTSTS;               /*!< [0x0018] Timer External Interrupt Status Register                         */
S    __IO uint32_t TRGCTL;                /*!< [0x001c] Timer Trigger Control Register                                   */
S    __IO uint32_t ALTCTL;                /*!< [0x0020] Timer Alternative Control Register                               */
S    __I  uint32_t RESERVE0[7];
S    __IO uint32_t PWMCTL;                /*!< [0x0040] Timer PWM Control Register                                       */
S    __IO uint32_t PWMCLKSRC;             /*!< [0x0044] Timer PWM Counter Clock Source Register                          */
S    __IO uint32_t PWMCLKPSC;             /*!< [0x0048] Timer PWM Counter Clock Pre-scale Register                       */
S    __IO uint32_t PWMCNTCLR;             /*!< [0x004c] Timer PWM Clear Counter Register                                 */
S    __IO uint32_t PWMPERIOD;             /*!< [0x0050] Timer PWM Period Register                                        */
S    __IO uint32_t PWMCMPDAT;             /*!< [0x0054] Timer PWM Comparator Register                                    */
S    __IO uint32_t PWMDTCTL;              /*!< [0x0058] Timer PWM Dead-Time Control Register                             */
S    __I  uint32_t PWMCNT;                /*!< [0x005c] Timer PWM Counter Register                                       */
S    __IO uint32_t PWMMSKEN;              /*!< [0x0060] Timer PWM Output Mask Enable Register                            */
S    __IO uint32_t PWMMSK;                /*!< [0x0064] Timer PWM Output Mask Data Control Register                      */
S    __IO uint32_t PWMBNF;                /*!< [0x0068] Timer PWM Brake Pin Noise Filter Register                          */
S    __IO uint32_t PWMFAILBRK;            /*!< [0x006c] Timer PWM System Fail Brake Control Register                     */
S    __IO uint32_t PWMBRKCTL;             /*!< [0x0070] Timer PWM Brake Control Register                                 */
S    __IO uint32_t PWMPOLCTL;             /*!< [0x0074] Timer PWM Pin Output Control Register                            */
S    __IO uint32_t PWMPOEN;               /*!< [0x0078] Timer PWM Pin Output Enable Register                             */
S    __O  uint32_t PWMSWBRK;              /*!< [0x007c] Timer PWM Software Trigger Brake Control Register                */
S    __IO uint32_t PWMINTEN0;             /*!< [0x0080] Timer PWM Interrupt Enable Register 0                            */
S    __IO uint32_t PWMINTEN1;             /*!< [0x0084] Timer PWM Interrupt Enable Register 1                            */
S    __IO uint32_t PWMINTSTS0;            /*!< [0x0088] Timer PWM Interrupt Status Register 0                            */
S    __IO uint32_t PWMINTSTS1;            /*!< [0x008c] Timer PWM Interrupt Status Register 1                            */
S    __IO uint32_t PWMADCTS;              /*!< [0x0090] Timer PWM ADC Trigger Source Select Register                     */
S    __IO uint32_t PWMSCTL;               /*!< [0x0094] Timer PWM Synchronous Control Register                           */
S    __O  uint32_t PWMSTRG;               /*!< [0x0098] Timer PWM Synchronous Trigger Register                           */
S    __IO uint32_t PWMSTATUS;             /*!< [0x009c] Timer PWM Status Register                                        */
S    __I  uint32_t PWMPBUF;               /*!< [0x00a0] Timer PWM Period Buffer Register                                 */
S    __I  uint32_t PWMCMPBUF;             /*!< [0x00a4] Timer PWM Comparator Buffer Register                             */
S
S} TIMER_T;
S
S/**
S    @addtogroup TIMER_CONST TIMER Bit Field Definition
S    Constant Definitions for TIMER Controller
S@{ */
S
S#define TIMER_CTL_PSC_Pos                (0)                                               /*!< TIMER_T::CTL: PSC Position             */
S#define TIMER_CTL_PSC_Msk                (0xfful << TIMER_CTL_PSC_Pos)                     /*!< TIMER_T::CTL: PSC Mask                 */
S
S#define TIMER_CTL_INTRGEN_Pos            (19)                                              /*!< TIMER_T::CTL: INTRGEN Position         */
S#define TIMER_CTL_INTRGEN_Msk            (0x1ul << TIMER_CTL_INTRGEN_Pos)                  /*!< TIMER_T::CTL: INTRGEN Mask             */
S
S#define TIMER_CTL_PERIOSEL_Pos           (20)                                              /*!< TIMER_T::CTL: PERIOSEL Position        */
S#define TIMER_CTL_PERIOSEL_Msk           (0x1ul << TIMER_CTL_PERIOSEL_Pos)                 /*!< TIMER_T::CTL: PERIOSEL Mask            */
S
S#define TIMER_CTL_TGLPINSEL_Pos          (21)                                              /*!< TIMER_T::CTL: TGLPINSEL Position       */
S#define TIMER_CTL_TGLPINSEL_Msk          (0x1ul << TIMER_CTL_TGLPINSEL_Pos)                /*!< TIMER_T::CTL: TGLPINSEL Mask           */
S
S#define TIMER_CTL_CAPSRC_Pos             (22)                                              /*!< TIMER_T::CTL: CAPSRC Position          */
S#define TIMER_CTL_CAPSRC_Msk             (0x1ul << TIMER_CTL_CAPSRC_Pos)                   /*!< TIMER_T::CTL: CAPSRC Mask              */
S
S#define TIMER_CTL_WKEN_Pos               (23)                                              /*!< TIMER_T::CTL: WKEN Position            */
S#define TIMER_CTL_WKEN_Msk               (0x1ul << TIMER_CTL_WKEN_Pos)                     /*!< TIMER_T::CTL: WKEN Mask                */
S
S#define TIMER_CTL_EXTCNTEN_Pos           (24)                                              /*!< TIMER_T::CTL: EXTCNTEN Position        */
S#define TIMER_CTL_EXTCNTEN_Msk           (0x1ul << TIMER_CTL_EXTCNTEN_Pos)                 /*!< TIMER_T::CTL: EXTCNTEN Mask            */
S
S#define TIMER_CTL_ACTSTS_Pos             (25)                                              /*!< TIMER_T::CTL: ACTSTS Position          */
S#define TIMER_CTL_ACTSTS_Msk             (0x1ul << TIMER_CTL_ACTSTS_Pos)                   /*!< TIMER_T::CTL: ACTSTS Mask              */
S
S#define TIMER_CTL_OPMODE_Pos             (27)                                              /*!< TIMER_T::CTL: OPMODE Position          */
S#define TIMER_CTL_OPMODE_Msk             (0x3ul << TIMER_CTL_OPMODE_Pos)                   /*!< TIMER_T::CTL: OPMODE Mask              */
S
S#define TIMER_CTL_INTEN_Pos              (29)                                              /*!< TIMER_T::CTL: INTEN Position           */
S#define TIMER_CTL_INTEN_Msk              (0x1ul << TIMER_CTL_INTEN_Pos)                    /*!< TIMER_T::CTL: INTEN Mask               */
S
S#define TIMER_CTL_CNTEN_Pos              (30)                                              /*!< TIMER_T::CTL: CNTEN Position           */
S#define TIMER_CTL_CNTEN_Msk              (0x1ul << TIMER_CTL_CNTEN_Pos)                    /*!< TIMER_T::CTL: CNTEN Mask               */
S
S#define TIMER_CTL_ICEDEBUG_Pos           (31)                                              /*!< TIMER_T::CTL: ICEDEBUG Position        */
S#define TIMER_CTL_ICEDEBUG_Msk           (0x1ul << TIMER_CTL_ICEDEBUG_Pos)                 /*!< TIMER_T::CTL: ICEDEBUG Mask            */
S
S#define TIMER_CMP_CMPDAT_Pos             (0)                                               /*!< TIMER_T::CMP: CMPDAT Position          */
S#define TIMER_CMP_CMPDAT_Msk             (0xfffffful << TIMER_CMP_CMPDAT_Pos)              /*!< TIMER_T::CMP: CMPDAT Mask              */
S
S#define TIMER_INTSTS_TIF_Pos             (0)                                               /*!< TIMER_T::INTSTS: TIF Position          */
S#define TIMER_INTSTS_TIF_Msk             (0x1ul << TIMER_INTSTS_TIF_Pos)                   /*!< TIMER_T::INTSTS: TIF Mask              */
S
S#define TIMER_INTSTS_TWKF_Pos            (1)                                               /*!< TIMER_T::INTSTS: TWKF Position         */
S#define TIMER_INTSTS_TWKF_Msk            (0x1ul << TIMER_INTSTS_TWKF_Pos)                  /*!< TIMER_T::INTSTS: TWKF Mask             */
S
S#define TIMER_CNT_CNT_Pos                (0)                                               /*!< TIMER_T::CNT: CNT Position             */
S#define TIMER_CNT_CNT_Msk                (0xfffffful << TIMER_CNT_CNT_Pos)                 /*!< TIMER_T::CNT: CNT Mask                 */
S
S#define TIMER_CNT_RSTACT_Pos             (31)                                              /*!< TIMER_T::CNT: RSTACT Position          */
S#define TIMER_CNT_RSTACT_Msk             (0x1ul << TIMER_CNT_RSTACT_Pos)                   /*!< TIMER_T::CNT: RSTACT Mask              */
S
S#define TIMER_CAP_CAPDAT_Pos             (0)                                               /*!< TIMER_T::CAP: CAPDAT Position          */
S#define TIMER_CAP_CAPDAT_Msk             (0xfffffful << TIMER_CAP_CAPDAT_Pos)              /*!< TIMER_T::CAP: CAPDAT Mask              */
S
S#define TIMER_EXTCTL_CNTPHASE_Pos        (0)                                               /*!< TIMER_T::EXTCTL: CNTPHASE Position     */
S#define TIMER_EXTCTL_CNTPHASE_Msk        (0x1ul << TIMER_EXTCTL_CNTPHASE_Pos)              /*!< TIMER_T::EXTCTL: CNTPHASE Mask         */
S
S#define TIMER_EXTCTL_CAPEN_Pos           (3)                                               /*!< TIMER_T::EXTCTL: CAPEN Position        */
S#define TIMER_EXTCTL_CAPEN_Msk           (0x1ul << TIMER_EXTCTL_CAPEN_Pos)                 /*!< TIMER_T::EXTCTL: CAPEN Mask            */
S
S#define TIMER_EXTCTL_CAPFUNCS_Pos        (4)                                               /*!< TIMER_T::EXTCTL: CAPFUNCS Position     */
S#define TIMER_EXTCTL_CAPFUNCS_Msk        (0x1ul << TIMER_EXTCTL_CAPFUNCS_Pos)              /*!< TIMER_T::EXTCTL: CAPFUNCS Mask         */
S
S#define TIMER_EXTCTL_CAPIEN_Pos          (5)                                               /*!< TIMER_T::EXTCTL: CAPIEN Position       */
S#define TIMER_EXTCTL_CAPIEN_Msk          (0x1ul << TIMER_EXTCTL_CAPIEN_Pos)                /*!< TIMER_T::EXTCTL: CAPIEN Mask           */
S
S#define TIMER_EXTCTL_CAPDBEN_Pos         (6)                                               /*!< TIMER_T::EXTCTL: CAPDBEN Position      */
S#define TIMER_EXTCTL_CAPDBEN_Msk         (0x1ul << TIMER_EXTCTL_CAPDBEN_Pos)               /*!< TIMER_T::EXTCTL: CAPDBEN Mask          */
S
S#define TIMER_EXTCTL_CNTDBEN_Pos         (7)                                               /*!< TIMER_T::EXTCTL: CNTDBEN Position      */
S#define TIMER_EXTCTL_CNTDBEN_Msk         (0x1ul << TIMER_EXTCTL_CNTDBEN_Pos)               /*!< TIMER_T::EXTCTL: CNTDBEN Mask          */
S
S#define TIMER_EXTCTL_ACMPSSEL_Pos        (8)                                               /*!< TIMER_T::EXTCTL: ACMPSSEL Position     */
S#define TIMER_EXTCTL_ACMPSSEL_Msk        (0x1ul << TIMER_EXTCTL_ACMPSSEL_Pos)              /*!< TIMER_T::EXTCTL: ACMPSSEL Mask         */
S
S#define TIMER_EXTCTL_CAPEDGE_Pos         (12)                                              /*!< TIMER_T::EXTCTL: CAPEDGE Position      */
S#define TIMER_EXTCTL_CAPEDGE_Msk         (0x7ul << TIMER_EXTCTL_CAPEDGE_Pos)               /*!< TIMER_T::EXTCTL: CAPEDGE Mask          */
S
S#define TIMER_EXTCTL_ECNTSSEL_Pos        (16)                                              /*!< TIMER_T::EXTCTL: ECNTSSEL Position     */
S#define TIMER_EXTCTL_ECNTSSEL_Msk        (0x1ul << TIMER_EXTCTL_ECNTSSEL_Pos)              /*!< TIMER_T::EXTCTL: ECNTSSEL Mask         */
S
S#define TIMER_EINTSTS_CAPIF_Pos          (0)                                               /*!< TIMER_T::EINTSTS: CAPIF Position       */
S#define TIMER_EINTSTS_CAPIF_Msk          (0x1ul << TIMER_EINTSTS_CAPIF_Pos)                /*!< TIMER_T::EINTSTS: CAPIF Mask           */
S
S#define TIMER_TRGCTL_TRGSSEL_Pos         (0)                                               /*!< TIMER_T::TRGCTL: TRGSSEL Position      */
S#define TIMER_TRGCTL_TRGSSEL_Msk         (0x1ul << TIMER_TRGCTL_TRGSSEL_Pos)               /*!< TIMER_T::TRGCTL: TRGSSEL Mask          */
S
S#define TIMER_TRGCTL_TRGPWM_Pos          (1)                                               /*!< TIMER_T::TRGCTL: TRGPWM Position       */
S#define TIMER_TRGCTL_TRGPWM_Msk          (0x1ul << TIMER_TRGCTL_TRGPWM_Pos)                /*!< TIMER_T::TRGCTL: TRGPWM Mask           */
S
S#define TIMER_TRGCTL_TRGADC_Pos          (2)                                               /*!< TIMER_T::TRGCTL: TRGADC Position       */
S#define TIMER_TRGCTL_TRGADC_Msk          (0x1ul << TIMER_TRGCTL_TRGADC_Pos)                /*!< TIMER_T::TRGCTL: TRGADC Mask           */
S
S#define TIMER_TRGCTL_TRGPDMA_Pos         (4)                                               /*!< TIMER_T::TRGCTL: TRGPDMA Position      */
S#define TIMER_TRGCTL_TRGPDMA_Msk         (0x1ul << TIMER_TRGCTL_TRGPDMA_Pos)               /*!< TIMER_T::TRGCTL: TRGPDMA Mask          */
S
S#define TIMER_ALTCTL_FUNCSEL_Pos         (0)                                               /*!< TIMER_T::ALTCTL: FUNCSEL Position      */
S#define TIMER_ALTCTL_FUNCSEL_Msk         (0x1ul << TIMER_ALTCTL_FUNCSEL_Pos)               /*!< TIMER_T::ALTCTL: FUNCSEL Mask          */
S
S#define TIMER_PWMCTL_CNTEN_Pos           (0)                                               /*!< TIMER_T::PWMCTL: CNTEN Position        */
S#define TIMER_PWMCTL_CNTEN_Msk           (0x1ul << TIMER_PWMCTL_CNTEN_Pos)                 /*!< TIMER_T::PWMCTL: CNTEN Mask            */
S
S#define TIMER_PWMCTL_CNTTYPE_Pos         (1)                                               /*!< TIMER_T::PWMCTL: CNTTYPE Position      */
S#define TIMER_PWMCTL_CNTTYPE_Msk         (0x3ul << TIMER_PWMCTL_CNTTYPE_Pos)               /*!< TIMER_T::PWMCTL: CNTTYPE Mask          */
S
S#define TIMER_PWMCTL_CNTMODE_Pos         (3)                                               /*!< TIMER_T::PWMCTL: CNTMODE Position      */
S#define TIMER_PWMCTL_CNTMODE_Msk         (0x1ul << TIMER_PWMCTL_CNTMODE_Pos)               /*!< TIMER_T::PWMCTL: CNTMODE Mask          */
S
S#define TIMER_PWMCTL_CTRLD_Pos           (8)                                               /*!< TIMER_T::PWMCTL: CTRLD Position        */
S#define TIMER_PWMCTL_CTRLD_Msk           (0x1ul << TIMER_PWMCTL_CTRLD_Pos)                 /*!< TIMER_T::PWMCTL: CTRLD Mask            */
S
S#define TIMER_PWMCTL_IMMLDEN_Pos         (9)                                               /*!< TIMER_T::PWMCTL: IMMLDEN Position      */
S#define TIMER_PWMCTL_IMMLDEN_Msk         (0x1ul << TIMER_PWMCTL_IMMLDEN_Pos)               /*!< TIMER_T::PWMCTL: IMMLDEN Mask          */
S
S#define TIMER_PWMCTL_OUTMODE_Pos         (16)                                              /*!< TIMER_T::PWMCTL: OUTMODE Position      */
S#define TIMER_PWMCTL_OUTMODE_Msk         (0x1ul << TIMER_PWMCTL_OUTMODE_Pos)               /*!< TIMER_T::PWMCTL: OUTMODE Mask          */
S
S#define TIMER_PWMCTL_DBGHALT_Pos         (30)                                              /*!< TIMER_T::PWMCTL: DBGHALT Position      */
S#define TIMER_PWMCTL_DBGHALT_Msk         (0x1ul << TIMER_PWMCTL_DBGHALT_Pos)               /*!< TIMER_T::PWMCTL: DBGHALT Mask          */
S
S#define TIMER_PWMCTL_DBGTRIOFF_Pos       (31)                                              /*!< TIMER_T::PWMCTL: DBGTRIOFF Position    */
S#define TIMER_PWMCTL_DBGTRIOFF_Msk       (0x1ul << TIMER_PWMCTL_DBGTRIOFF_Pos)             /*!< TIMER_T::PWMCTL: DBGTRIOFF Mask        */
S
S#define TIMER_PWMCLKSRC_CLKSRC_Pos       (0)                                               /*!< TIMER_T::PWMCLKSRC: CLKSRC Position    */
S#define TIMER_PWMCLKSRC_CLKSRC_Msk       (0x7ul << TIMER_PWMCLKSRC_CLKSRC_Pos)             /*!< TIMER_T::PWMCLKSRC: CLKSRC Mask        */
S
S#define TIMER_PWMCLKPSC_CLKPSC_Pos       (0)                                               /*!< TIMER_T::PWMCLKPSC: CLKPSC Position    */
S#define TIMER_PWMCLKPSC_CLKPSC_Msk       (0xffful << TIMER_PWMCLKPSC_CLKPSC_Pos)           /*!< TIMER_T::PWMCLKPSC: CLKPSC Mask        */
S
S#define TIMER_PWMCNTCLR_CNTCLR_Pos       (0)                                               /*!< TIMER_T::PWMCNTCLR: CNTCLR Position    */
S#define TIMER_PWMCNTCLR_CNTCLR_Msk       (0x1ul << TIMER_PWMCNTCLR_CNTCLR_Pos)             /*!< TIMER_T::PWMCNTCLR: CNTCLR Mask        */
S
S#define TIMER_PWMPERIOD_PERIOD_Pos       (0)                                               /*!< TIMER_T::PWMPERIOD: PERIOD Position    */
S#define TIMER_PWMPERIOD_PERIOD_Msk       (0xfffful << TIMER_PWMPERIOD_PERIOD_Pos)          /*!< TIMER_T::PWMPERIOD: PERIOD Mask        */
S
S#define TIMER_PWMCMPDAT_CMP_Pos         (0)                                                /*!< TIMER_T::PWMCMPDAT: CMP Position         */
S#define TIMER_PWMCMPDAT_CMP_Msk         (0xfffful << TIMER_PWMCMPDAT_CMP_Pos)              /*!< TIMER_T::PWMCMPDAT: CMP Mask             */
S
S#define TIMER_PWMDTCTL_DTCNT_Pos         (0)                                               /*!< TIMER_T::PWMDTCTL: DTCNT Position      */
S#define TIMER_PWMDTCTL_DTCNT_Msk         (0xffful << TIMER_PWMDTCTL_DTCNT_Pos)             /*!< TIMER_T::PWMDTCTL: DTCNT Mask          */
S
S#define TIMER_PWMDTCTL_DTEN_Pos          (16)                                              /*!< TIMER_T::PWMDTCTL: DTEN Position       */
S#define TIMER_PWMDTCTL_DTEN_Msk          (0x1ul << TIMER_PWMDTCTL_DTEN_Pos)                /*!< TIMER_T::PWMDTCTL: DTEN Mask           */
S
S#define TIMER_PWMDTCTL_DTCKSEL_Pos       (24)                                              /*!< TIMER_T::PWMDTCTL: DTCKSEL Position    */
S#define TIMER_PWMDTCTL_DTCKSEL_Msk       (0x1ul << TIMER_PWMDTCTL_DTCKSEL_Pos)             /*!< TIMER_T::PWMDTCTL: DTCKSEL Mask        */
S
S#define TIMER_PWMCNT_CNT_Pos             (0)                                               /*!< TIMER_T::PWMCNT: CNT Position          */
S#define TIMER_PWMCNT_CNT_Msk             (0xfffful << TIMER_PWMCNT_CNT_Pos)                /*!< TIMER_T::PWMCNT: CNT Mask              */
S
S#define TIMER_PWMCNT_DIRF_Pos            (16)                                              /*!< TIMER_T::PWMCNT: DIRF Position         */
S#define TIMER_PWMCNT_DIRF_Msk            (0x1ul << TIMER_PWMCNT_DIRF_Pos)                  /*!< TIMER_T::PWMCNT: DIRF Mask             */
S
S#define TIMER_PWMMSKEN_MSKEN0_Pos        (0)                                               /*!< TIMER_T::PWMMSKEN: MSKEN0 Position     */
S#define TIMER_PWMMSKEN_MSKEN0_Msk        (0x1ul << TIMER_PWMMSKEN_MSKEN0_Pos)              /*!< TIMER_T::PWMMSKEN: MSKEN0 Mask         */
S
S#define TIMER_PWMMSKEN_MSKEN1_Pos        (1)                                               /*!< TIMER_T::PWMMSKEN: MSKEN1 Position     */
S#define TIMER_PWMMSKEN_MSKEN1_Msk        (0x1ul << TIMER_PWMMSKEN_MSKEN1_Pos)              /*!< TIMER_T::PWMMSKEN: MSKEN1 Mask         */
S
S#define TIMER_PWMMSK_MSKDAT0_Pos         (0)                                               /*!< TIMER_T::PWMMSK: MSKDAT0 Position      */
S#define TIMER_PWMMSK_MSKDAT0_Msk         (0x1ul << TIMER_PWMMSK_MSKDAT0_Pos)                 /*!< TIMER_T::PWMMSK: MSKDAT0 Mask          */
S
S#define TIMER_PWMMSK_MSKDAT1_Pos         (1)                                               /*!< TIMER_T::PWMMSK: MSKDAT1 Position      */
S#define TIMER_PWMMSK_MSKDAT1_Msk         (0x1ul << TIMER_PWMMSK_MSKDAT1_Pos)                 /*!< TIMER_T::PWMMSK: MSKDAT1 Mask          */
S
S#define TIMER_PWMBNF_BRKNFEN_Pos         (0)                                               /*!< TIMER_T::PWMBNF: BRKNFEN Position        */
S#define TIMER_PWMBNF_BRKNFEN_Msk         (0x1ul << TIMER_PWMBNF_BRKNFEN_Pos)               /*!< TIMER_T::PWMBNF: BRKNFEN Mask            */
S
S#define TIMER_PWMBNF_BRKNFSEL_Pos        (1)                                               /*!< TIMER_T::PWMBNF: BRKNFSEL Position     */
S#define TIMER_PWMBNF_BRKNFSEL_Msk        (0x7ul << TIMER_PWMBNF_BRKNFSEL_Pos)              /*!< TIMER_T::PWMBNF: BRKNFSEL Mask         */
S
S#define TIMER_PWMBNF_BRKFCNT_Pos         (4)                                               /*!< TIMER_T::PWMBNF: BRKFCNT Position      */
S#define TIMER_PWMBNF_BRKFCNT_Msk         (0x7ul << TIMER_PWMBNF_BRKFCNT_Pos)               /*!< TIMER_T::PWMBNF: BRKFCNT Mask          */
S
S#define TIMER_PWMBNF_BRKPINV_Pos         (7)                                               /*!< TIMER_T::PWMBNF: BRKPINV Position      */
S#define TIMER_PWMBNF_BRKPINV_Msk         (0x1ul << TIMER_PWMBNF_BRKPINV_Pos)               /*!< TIMER_T::PWMBNF: BRKPINV Mask          */
S
S#define TIMER_PWMBNF_BKPINSRC_Pos        (16)                                              /*!< TIMER_T::PWMBNF: BKPINSRC Position     */
S#define TIMER_PWMBNF_BKPINSRC_Msk        (0x3ul << TIMER_PWMBNF_BKPINSRC_Pos)              /*!< TIMER_T::PWMBNF: BKPINSRC Mask         */
S
S#define TIMER_PWMFAILBRK_CSSBRKEN_Pos    (0)                                               /*!< TIMER_T::PWMFAILBRK: CSSBRKEN Position */
S#define TIMER_PWMFAILBRK_CSSBRKEN_Msk    (0x1ul << TIMER_PWMFAILBRK_CSSBRKEN_Pos)          /*!< TIMER_T::PWMFAILBRK: CSSBRKEN Mask     */
S
S#define TIMER_PWMFAILBRK_BODBRKEN_Pos    (1)                                               /*!< TIMER_T::PWMFAILBRK: BODBRKEN Position */
S#define TIMER_PWMFAILBRK_BODBRKEN_Msk    (0x1ul << TIMER_PWMFAILBRK_BODBRKEN_Pos)          /*!< TIMER_T::PWMFAILBRK: BODBRKEN Mask     */
S
S#define TIMER_PWMFAILBRK_CORBRKEN_Pos    (3)                                               /*!< TIMER_T::PWMFAILBRK: CORBRKEN Position */
S#define TIMER_PWMFAILBRK_CORBRKEN_Msk    (0x1ul << TIMER_PWMFAILBRK_CORBRKEN_Pos)          /*!< TIMER_T::PWMFAILBRK: CORBRKEN Mask     */
S
S#define TIMER_PWMBRKCTL_CPO0EBEN_Pos     (0)                                               /*!< TIMER_T::PWMBRKCTL: CPO0EBEN Position  */
S#define TIMER_PWMBRKCTL_CPO0EBEN_Msk     (0x1ul << TIMER_PWMBRKCTL_CPO0EBEN_Pos)           /*!< TIMER_T::PWMBRKCTL: CPO0EBEN Mask      */
S
S#define TIMER_PWMBRKCTL_CPO1EBEN_Pos     (1)                                               /*!< TIMER_T::PWMBRKCTL: CPO1EBEN Position  */
S#define TIMER_PWMBRKCTL_CPO1EBEN_Msk     (0x1ul << TIMER_PWMBRKCTL_CPO1EBEN_Pos)           /*!< TIMER_T::PWMBRKCTL: CPO1EBEN Mask      */
S
S#define TIMER_PWMBRKCTL_BRKPEEN_Pos      (4)                                               /*!< TIMER_T::PWMBRKCTL: BRKPEEN Position   */
S#define TIMER_PWMBRKCTL_BRKPEEN_Msk      (0x1ul << TIMER_PWMBRKCTL_BRKPEEN_Pos)            /*!< TIMER_T::PWMBRKCTL: BRKPEEN Mask       */
S
S#define TIMER_PWMBRKCTL_SYSEBEN_Pos      (7)                                               /*!< TIMER_T::PWMBRKCTL: SYSEBEN Position   */
S#define TIMER_PWMBRKCTL_SYSEBEN_Msk      (0x1ul << TIMER_PWMBRKCTL_SYSEBEN_Pos)            /*!< TIMER_T::PWMBRKCTL: SYSEBEN Mask       */
S
S#define TIMER_PWMBRKCTL_CPO0LBEN_Pos     (8)                                               /*!< TIMER_T::PWMBRKCTL: CPO0LBEN Position  */
S#define TIMER_PWMBRKCTL_CPO0LBEN_Msk     (0x1ul << TIMER_PWMBRKCTL_CPO0LBEN_Pos)           /*!< TIMER_T::PWMBRKCTL: CPO0LBEN Mask      */
S
S#define TIMER_PWMBRKCTL_CPO1LBEN_Pos     (9)                                               /*!< TIMER_T::PWMBRKCTL: CPO1LBEN Position  */
S#define TIMER_PWMBRKCTL_CPO1LBEN_Msk     (0x1ul << TIMER_PWMBRKCTL_CPO1LBEN_Pos)           /*!< TIMER_T::PWMBRKCTL: CPO1LBEN Mask      */
S
S#define TIMER_PWMBRKCTL_BRKPLEN_Pos      (12)                                              /*!< TIMER_T::PWMBRKCTL: BRKPLEN Position   */
S#define TIMER_PWMBRKCTL_BRKPLEN_Msk      (0x1ul << TIMER_PWMBRKCTL_BRKPLEN_Pos)            /*!< TIMER_T::PWMBRKCTL: BRKPLEN Mask       */
S
S#define TIMER_PWMBRKCTL_SYSLBEN_Pos      (15)                                              /*!< TIMER_T::PWMBRKCTL: SYSLBEN Position   */
S#define TIMER_PWMBRKCTL_SYSLBEN_Msk      (0x1ul << TIMER_PWMBRKCTL_SYSLBEN_Pos)            /*!< TIMER_T::PWMBRKCTL: SYSLBEN Mask       */
S
S#define TIMER_PWMBRKCTL_BRKAEVEN_Pos     (16)                                              /*!< TIMER_T::PWMBRKCTL: BRKAEVEN Position  */
S#define TIMER_PWMBRKCTL_BRKAEVEN_Msk     (0x3ul << TIMER_PWMBRKCTL_BRKAEVEN_Pos)           /*!< TIMER_T::PWMBRKCTL: BRKAEVEN Mask      */
S
S#define TIMER_PWMBRKCTL_BRKAODD_Pos      (18)                                              /*!< TIMER_T::PWMBRKCTL: BRKAODD Position   */
S#define TIMER_PWMBRKCTL_BRKAODD_Msk      (0x3ul << TIMER_PWMBRKCTL_BRKAODD_Pos)            /*!< TIMER_T::PWMBRKCTL: BRKAODD Mask       */
S
S#define TIMER_PWMPOLCTL_PINV0_Pos        (0)                                               /*!< TIMER_T::PWMPOLCTL: PINV0 Position     */
S#define TIMER_PWMPOLCTL_PINV0_Msk        (0x1ul << TIMER_PWMPOLCTL_PINV0_Pos)              /*!< TIMER_T::PWMPOLCTL: PINV0 Mask         */
S
S#define TIMER_PWMPOLCTL_PINV1_Pos        (1)                                               /*!< TIMER_T::PWMPOLCTL: PINV1 Position     */
S#define TIMER_PWMPOLCTL_PINV1_Msk        (0x1ul << TIMER_PWMPOLCTL_PINV1_Pos)              /*!< TIMER_T::PWMPOLCTL: PINV1 Mask         */
S
S#define TIMER_PWMPOEN_POEN0_Pos          (0)                                               /*!< TIMER_T::PWMPOEN: POEN0 Position       */
S#define TIMER_PWMPOEN_POEN0_Msk          (0x1ul << TIMER_PWMPOEN_POEN0_Pos)                /*!< TIMER_T::PWMPOEN: POEN0 Mask           */
S
S#define TIMER_PWMPOEN_POEN1_Pos          (1)                                               /*!< TIMER_T::PWMPOEN: POEN1 Position       */
S#define TIMER_PWMPOEN_POEN1_Msk          (0x1ul << TIMER_PWMPOEN_POEN1_Pos)                /*!< TIMER_T::PWMPOEN: POEN1 Mask           */
S
S#define TIMER_PWMSWBRK_BRKETRG_Pos       (0)                                               /*!< TIMER_T::PWMSWBRK: BRKETRG Position    */
S#define TIMER_PWMSWBRK_BRKETRG_Msk       (0x1ul << TIMER_PWMSWBRK_BRKETRG_Pos)             /*!< TIMER_T::PWMSWBRK: BRKETRG Mask        */
S
S#define TIMER_PWMSWBRK_BRKLTRG_Pos       (8)                                               /*!< TIMER_T::PWMSWBRK: BRKLTRG Position    */
S#define TIMER_PWMSWBRK_BRKLTRG_Msk       (0x1ul << TIMER_PWMSWBRK_BRKLTRG_Pos)             /*!< TIMER_T::PWMSWBRK: BRKLTRG Mask        */
S
S#define TIMER_PWMINTEN0_ZIEN_Pos         (0)                                               /*!< TIMER_T::PWMINTEN0: ZIEN Position      */
S#define TIMER_PWMINTEN0_ZIEN_Msk         (0x1ul << TIMER_PWMINTEN0_ZIEN_Pos)               /*!< TIMER_T::PWMINTEN0: ZIEN Mask          */
S
S#define TIMER_PWMINTEN0_PIEN_Pos         (1)                                               /*!< TIMER_T::PWMINTEN0: PIEN Position      */
S#define TIMER_PWMINTEN0_PIEN_Msk         (0x1ul << TIMER_PWMINTEN0_PIEN_Pos)               /*!< TIMER_T::PWMINTEN0: PIEN Mask          */
S
S#define TIMER_PWMINTEN0_CMPUIEN_Pos      (2)                                               /*!< TIMER_T::PWMINTEN0: CMPUIEN Position   */
S#define TIMER_PWMINTEN0_CMPUIEN_Msk      (0x1ul << TIMER_PWMINTEN0_CMPUIEN_Pos)            /*!< TIMER_T::PWMINTEN0: CMPUIEN Mask       */
S
S#define TIMER_PWMINTEN0_CMPDIEN_Pos      (3)                                               /*!< TIMER_T::PWMINTEN0: CMPDIEN Position   */
S#define TIMER_PWMINTEN0_CMPDIEN_Msk      (0x1ul << TIMER_PWMINTEN0_CMPDIEN_Pos)            /*!< TIMER_T::PWMINTEN0: CMPDIEN Mask       */
S
S#define TIMER_PWMINTEN1_BRKEIEN_Pos      (0)                                               /*!< TIMER_T::PWMINTEN1: BRKEIEN Position   */
S#define TIMER_PWMINTEN1_BRKEIEN_Msk      (0x1ul << TIMER_PWMINTEN1_BRKEIEN_Pos)            /*!< TIMER_T::PWMINTEN1: BRKEIEN Mask       */
S
S#define TIMER_PWMINTEN1_BRKLIEN_Pos      (8)                                               /*!< TIMER_T::PWMINTEN1: BRKLIEN Position   */
S#define TIMER_PWMINTEN1_BRKLIEN_Msk      (0x1ul << TIMER_PWMINTEN1_BRKLIEN_Pos)            /*!< TIMER_T::PWMINTEN1: BRKLIEN Mask       */
S
S#define TIMER_PWMINTSTS0_ZIF_Pos         (0)                                               /*!< TIMER_T::PWMINTSTS0: ZIF Position      */
S#define TIMER_PWMINTSTS0_ZIF_Msk         (0x1ul << TIMER_PWMINTSTS0_ZIF_Pos)               /*!< TIMER_T::PWMINTSTS0: ZIF Mask          */
S
S#define TIMER_PWMINTSTS0_PIF_Pos         (1)                                               /*!< TIMER_T::PWMINTSTS0: PIF Position      */
S#define TIMER_PWMINTSTS0_PIF_Msk         (0x1ul << TIMER_PWMINTSTS0_PIF_Pos)               /*!< TIMER_T::PWMINTSTS0: PIF Mask          */
S
S#define TIMER_PWMINTSTS0_CMPUIF_Pos      (2)                                               /*!< TIMER_T::PWMINTSTS0: CMPUIF Position   */
S#define TIMER_PWMINTSTS0_CMPUIF_Msk      (0x1ul << TIMER_PWMINTSTS0_CMPUIF_Pos)            /*!< TIMER_T::PWMINTSTS0: CMPUIF Mask       */
S
S#define TIMER_PWMINTSTS0_CMPDIF_Pos      (3)                                               /*!< TIMER_T::PWMINTSTS0: CMPDIF Position   */
S#define TIMER_PWMINTSTS0_CMPDIF_Msk      (0x1ul << TIMER_PWMINTSTS0_CMPDIF_Pos)            /*!< TIMER_T::PWMINTSTS0: CMPDIF Mask       */
S
S#define TIMER_PWMINTSTS1_BRKEIF0_Pos     (0)                                               /*!< TIMER_T::PWMINTSTS1: BRKEIF0 Position  */
S#define TIMER_PWMINTSTS1_BRKEIF0_Msk     (0x1ul << TIMER_PWMINTSTS1_BRKEIF0_Pos)           /*!< TIMER_T::PWMINTSTS1: BRKEIF0 Mask      */
S
S#define TIMER_PWMINTSTS1_BRKEIF1_Pos     (1)                                               /*!< TIMER_T::PWMINTSTS1: BRKEIF1 Position  */
S#define TIMER_PWMINTSTS1_BRKEIF1_Msk     (0x1ul << TIMER_PWMINTSTS1_BRKEIF1_Pos)           /*!< TIMER_T::PWMINTSTS1: BRKEIF1 Mask      */
S
S#define TIMER_PWMINTSTS1_BRKLIF0_Pos     (8)                                               /*!< TIMER_T::PWMINTSTS1: BRKLIF0 Position  */
S#define TIMER_PWMINTSTS1_BRKLIF0_Msk     (0x1ul << TIMER_PWMINTSTS1_BRKLIF0_Pos)           /*!< TIMER_T::PWMINTSTS1: BRKLIF0 Mask      */
S
S#define TIMER_PWMINTSTS1_BRKLIF1_Pos     (9)                                               /*!< TIMER_T::PWMINTSTS1: BRKLIF1 Position  */
S#define TIMER_PWMINTSTS1_BRKLIF1_Msk     (0x1ul << TIMER_PWMINTSTS1_BRKLIF1_Pos)           /*!< TIMER_T::PWMINTSTS1: BRKLIF1 Mask      */
S
S#define TIMER_PWMINTSTS1_BRKESTS0_Pos    (16)                                              /*!< TIMER_T::PWMINTSTS1: BRKESTS0 Position */
S#define TIMER_PWMINTSTS1_BRKESTS0_Msk    (0x1ul << TIMER_PWMINTSTS1_BRKESTS0_Pos)          /*!< TIMER_T::PWMINTSTS1: BRKESTS0 Mask     */
S
S#define TIMER_PWMINTSTS1_BRKESTS1_Pos    (17)                                              /*!< TIMER_T::PWMINTSTS1: BRKESTS1 Position */
S#define TIMER_PWMINTSTS1_BRKESTS1_Msk    (0x1ul << TIMER_PWMINTSTS1_BRKESTS1_Pos)          /*!< TIMER_T::PWMINTSTS1: BRKESTS1 Mask     */
S
S#define TIMER_PWMINTSTS1_BRKLSTS0_Pos    (24)                                              /*!< TIMER_T::PWMINTSTS1: BRKLSTS0 Position */
S#define TIMER_PWMINTSTS1_BRKLSTS0_Msk    (0x1ul << TIMER_PWMINTSTS1_BRKLSTS0_Pos)          /*!< TIMER_T::PWMINTSTS1: BRKLSTS0 Mask     */
S
S#define TIMER_PWMINTSTS1_BRKLSTS1_Pos    (25)                                              /*!< TIMER_T::PWMINTSTS1: BRKLSTS1 Position */
S#define TIMER_PWMINTSTS1_BRKLSTS1_Msk    (0x1ul << TIMER_PWMINTSTS1_BRKLSTS1_Pos)          /*!< TIMER_T::PWMINTSTS1: BRKLSTS1 Mask     */
S
S#define TIMER_PWMADCTS_TRGSEL_Pos        (0)                                               /*!< TIMER_T::PWMADCTS: TRGSEL Position     */
S#define TIMER_PWMADCTS_TRGSEL_Msk        (0x7ul << TIMER_PWMADCTS_TRGSEL_Pos)              /*!< TIMER_T::PWMADCTS: TRGSEL Mask         */
S
S#define TIMER_PWMADCTS_TRGEN_Pos         (7)                                               /*!< TIMER_T::PWMADCTS: TRGEN Position      */
S#define TIMER_PWMADCTS_TRGEN_Msk         (0x1ul << TIMER_PWMADCTS_TRGEN_Pos)               /*!< TIMER_T::PWMADCTS: TRGEN Mask          */
S
S#define TIMER_PWMSCTL_SYNCMODE_Pos       (0)                                               /*!< TIMER_T::PWMSCTL: SYNCMODE Position    */
S#define TIMER_PWMSCTL_SYNCMODE_Msk       (0x3ul << TIMER_PWMSCTL_SYNCMODE_Pos)             /*!< TIMER_T::PWMSCTL: SYNCMODE Mask        */
S
S#define TIMER_PWMSCTL_SYNCSRC_Pos        (8)                                               /*!< TIMER_T::PWMSCTL: SYNCSRC Position     */
S#define TIMER_PWMSCTL_SYNCSRC_Msk        (0x1ul << TIMER_PWMSCTL_SYNCSRC_Pos)              /*!< TIMER_T::PWMSCTL: SYNCSRC Mask         */
S
S#define TIMER_PWMSTRG_STRGEN_Pos         (0)                                               /*!< TIMER_T::PWMSTRG: STRGEN Position      */
S#define TIMER_PWMSTRG_STRGEN_Msk         (0x1ul << TIMER_PWMSTRG_STRGEN_Pos)               /*!< TIMER_T::PWMSTRG: STRGEN Mask          */
S
S#define TIMER_PWMSTATUS_CNTMAXF_Pos      (0)                                               /*!< TIMER_T::PWMSTATUS: CNTMAXF Position   */
S#define TIMER_PWMSTATUS_CNTMAXF_Msk      (0x1ul << TIMER_PWMSTATUS_CNTMAXF_Pos)            /*!< TIMER_T::PWMSTATUS: CNTMAXF Mask       */
S
S#define TIMER_PWMSTATUS_ADCTRGF_Pos      (16)                                              /*!< TIMER_T::PWMSTATUS: ADCTRGF Position   */
S#define TIMER_PWMSTATUS_ADCTRGF_Msk      (0x1ul << TIMER_PWMSTATUS_ADCTRGF_Pos)            /*!< TIMER_T::PWMSTATUS: ADCTRGF Mask       */
S
S#define TIMER_PWMPBUF_PBUF_Pos           (0)                                               /*!< TIMER_T::PWMPBUF: PBUF Position        */
S#define TIMER_PWMPBUF_PBUF_Msk           (0xfffful << TIMER_PWMPBUF_PBUF_Pos)              /*!< TIMER_T::PWMPBUF: PBUF Mask            */
S
S#define TIMER_PWMCMPBUF_CMPBUF_Pos       (0)                                               /*!< TIMER_T::PWMCMPBUF: CMPBUF Position    */
S#define TIMER_PWMCMPBUF_CMPBUF_Msk       (0xfffful << TIMER_PWMCMPBUF_CMPBUF_Pos)          /*!< TIMER_T::PWMCMPBUF: CMPBUF Mask        */
S
S/**@}*/ /* TIMER_CONST */
S/**@}*/ /* end of TIMER register group */
S
S
S
S
S/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
S/**
S    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
S    Memory Mapped Structure for UART Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var UART_T::DAT
S     * Offset: 0x00  UART Receive/Transmit Buffer Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |DAT       |Data Receivinge/Transmit Buffer
S     * |        |          |Write Operation:
S     * |        |          |By writing one byte to this register, the data byte will be stored in transmitter FIFO.
S     * |        |          |The UART Controller will send out the data stored in transmitter FIFO top location through the UART_TXD.
S     * |        |          |Read Operation:
S     * |        |          |By reading this register, the UART controller will return an 8-bit data received from receiver FIFO.
S     * |[8]     |PARITY    |Parity Bit Receive/Transmit Buffer
S     * |        |          |Write Operation:
S     * |        |          |By writing to this bit, the parity bit will be stored in transmitter FIFO.
S     * |        |          |If PBE (UART_LINE[3]) and PSS (UART_LINE[7]) are set, the UART controller will send out this bit follow the DAT (UART_DAT[7:0]) through the UART_TXD.
S     * |        |          |Read Operation:
S     * |        |          |If PBE (UART_LINE[3]) and PSS (UART_LINE[7]) are enabled, the parity bit can be read by this bit.
S     * |        |          |Note: This bit has effect only when PBE (UART_LINE[3]) and PSS (UART_LINE[7]) are set.
S     * @var UART_T::INTEN
S     * Offset: 0x04  UART Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RDAIEN    |Receive Data Available Interrupt Enable Bit
S     * |        |          |0 = Receive data available interrupt Disabled.
S     * |        |          |1 = Receive data available interrupt Enabled.
S     * |[1]     |THREIEN   |Transmit Holding Register Empty Interrupt Enable Bit
S     * |        |          |0 = Transmit holding register empty interrupt Disabled.
S     * |        |          |1 = Transmit holding register empty interrupt Enabled.
S     * |[2]     |RLSIEN    |Receive Line Status Interrupt Enable Bit
S     * |        |          |0 = Receive Line Status interrupt Disabled.
S     * |        |          |1 = Receive Line Status interrupt Enabled.
S     * |[3]     |MODEMIEN  |Modem Status Interrupt Enable Bit
S     * |        |          |0 = Modem status interrupt Disabled.
S     * |        |          |1 = Modem status interrupt Enabled.
S     * |[4]     |RXTOIEN   |RX Time-out Interrupt Enable Bit
S     * |        |          |0 = RX time-out interrupt Disabled.
S     * |        |          |1 = RX time-out interrupt Enabled.
S     * |[5]     |BUFERRIEN |Buffer Error Interrupt Enable Bit
S     * |        |          |0 = Buffer error interrupt Disabled.
S     * |        |          |1 = Buffer error interrupt Enabled.
S     * |[6]     |WKIEN     |Wake-up Interrupt Enable Bit
S     * |        |          |0 = Wake-up Interrupt Disabled.
S     * |        |          |1 = Wake-up Interrupt Enabled.
S     * |[8]     |LINIEN    |LIN Bus Interrupt Enable Bit
S     * |        |          |0 = LIN bus interrupt Disabled.
S     * |        |          |1 = LIN bus interrupt Enabled.
S     * |        |          |Note: This bit is used for LIN function mode.
S     * |[11]    |TOCNTEN   |Receive Buffer Time-out Counter Enable Bit
S     * |        |          |0 = Receive Buffer Time-out counter Disabled.
S     * |        |          |1 = Receive Buffer Time-out counter Enabled.
S     * |[12]    |ATORTSEN  |nRTS Auto-flow Control Enable Bit
S     * |        |          |0 = nRTS auto-flow control Disabled.
S     * |        |          |1 = nRTS auto-flow control Enabled.
S     * |        |          |Note: When nRTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTSTRGLV (UART_FIFO[19:16]), the UART will de-assert nRTS signal.
S     * |[13]    |ATOCTSEN  |nCTS Auto-flow Control Enable Bit
S     * |        |          |0 = nCTS auto-flow control Disabled.
S     * |        |          |1 = nCTS auto-flow control Enabled.
S     * |        |          |Note: When nCTS auto-flow is enabled, the UART will send data to external device if nCTS input assert (UART will not send data to device until nCTS is asserted).
S     * |[14]    |TXPDMAEN  |TX PDMA Enable Bit
S     * |        |          |This bit can enable or disable TX PDMA service.
S     * |        |          |0 = TX PDMA Disabled.
S     * |        |          |1 = TX PDMA Enabled.
S     * |[15]    |RXPDMAEN  |RX PDMA Enable Bit
S     * |        |          |This bit can enable or disable RX PDMA service.
S     * |        |          |0 = RX PDMA Disabled.
S     * |        |          |1 = RX PDMA Enabled.
S     * |        |          |Note: If RLSIEN (UART_INTEN[2]) is enabled and HWRLSINT (UART_INTSTS[26]) is set to 1, the RLS (Receive Line Status) Interrupt is caused.
S     * |        |          |If RLS interrupt is caused by Break Error Flag BIF(UART_FIFOSTS[6]), Frame Error Flag FEF(UART_FIFO[5]) or Parity Error Flag PEF(UART_FIFOSTS[4]), UART PDMA receive request operation is stop.
S     * |        |          |Clear Break Error Flag BIF or Frame Error Flag FEF or Parity Error Flag PEF by writing 1 to corresponding BIF, FEF and PEF to make UART PDMA receive request operation continue.
S     * |[18]    |ABRIEN    |Auto-baud Rate Interrupt Enable Bit
S     * |        |          |0 = Auto-baud rate interrupt Disabled.
S     * |        |          |1 = Auto-baud rate interrupt Enabled.
S     * |[22]    |TXENDIEN  |Transmitter Empty Interrupt Enable Bit
S     * |        |          |If TXENDIEN (UART_INTEN[22]) is enabled, the Transmitter Empty interrupt TXENDINT (UART_INTSTS[30]) will be generated when TXENDIF (UART_INTSTS[22]) is set (TX FIFO (UART_DAT) is empty and the STOP bit of the last byte has been transmitted).
S     * |        |          |0 = Transmitter empty interrupt Disabled.
S     * |        |          |1 = Transmitter empty interrupt Enabled.
S     * @var UART_T::FIFO
S     * Offset: 0x08  UART FIFO Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |RXRST     |RX Field Software Reset
S     * |        |          |When RXRST (UART_FIFO[1]) is set, all the byte in the receiver FIFO and RX internal state machine are cleared.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset the RX internal state machine and pointers.
S     * |        |          |Note1: This bit will automatically clear at least 3 UART peripheral clock cycles.
S     * |        |          |Note2: Before setting this bit, it should wait for the RXIDLE (UART_FIFOSTS[29]) be set.
S     * |[2]     |TXRST     |TX Field Software Reset
S     * |        |          |When TXRST (UART_FIFO[2]) is set, all the byte in the transmit FIFO and TX internal state machine are cleared.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset the TX internal state machine and pointers.
S     * |        |          |Note1: This bit will automatically clear at least 3 UART peripheral clock cycles.
S     * |        |          |Note2: Before setting this bit, it should wait for the TXEMPTYF (UART_FIFOSTS[28]) be set.
S     * |[7:4]   |RFITL     |RX FIFO Interrupt Trigger Level
S     * |        |          |When the number of bytes in the receive FIFO equals the RFITL, the RDAIF (UART_INTSTS[0]) will be set (if RDAIEN (UART_INTEN [0]) enabled, and an interrupt will be generated).
S     * |        |          |0000 = RX FIFO Interrupt Trigger Level is 1 byte.
S     * |        |          |0001 = RX FIFO Interrupt Trigger Level is 4 bytes.
S     * |        |          |0010 = RX FIFO Interrupt Trigger Level is 8 bytes.
S     * |        |          |0011 = RX FIFO Interrupt Trigger Level is 14 bytes.
S     * |        |          |Others = Reserved.
S     * |[8]     |RXOFF     |Receiver Disable Bit
S     * |        |          |The receiver is disabled or not (set 1 to disable receiver).
S     * |        |          |0 = Receiver Enabled.
S     * |        |          |1 = Receiver Disabled.
S     * |        |          |Note: This bit is used for RS-485 Normal Multi-drop mode.
S     * |        |          |It should be programmed before RS485NMM (UART_ALTCTL [8]) is programmed.
S     * |[19:16] |RTSTRGLV  |nRTS Trigger Level for Auto-flow Control Use
S     * |        |          |0000 = nRTS Trigger Level is 1 byte.
S     * |        |          |0001 = nRTS Trigger Level is 4 bytes.
S     * |        |          |0010 = nRTS Trigger Level is 8 bytes.
S     * |        |          |0011 = nRTS Trigger Level is 14 bytes.
S     * |        |          |Others = Reserved.
S     * |        |          |Note: This field is used for auto nRTS flow control.
S     * @var UART_T::LINE
S     * Offset: 0x0C  UART Line Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |WLS       |Word Length Selection
S     * |        |          |This field sets UART word length.
S     * |        |          |00 = 5 bits.
S     * |        |          |01 = 6 bits.
S     * |        |          |10 = 7 bits.
S     * |        |          |11 = 8 bits.
S     * |[2]     |NSB       |Number of STOP Bit
S     * |        |          |0 = One STOP bit is generated in the transmitted data.
S     * |        |          |1 = When select 5-bit word length, 1.5 STOP bit is generated in the transmitted data.
S     * |        |          |When select 6-, 7- and 8-bit word length, 2 STOP bit is generated in the transmitted data.
S     * |[3]     |PBE       |Parity Bit Enable Bit
S     * |        |          |0 = Parity bit generated Disabled.
S     * |        |          |1 = Parity bit generated Enabled.
S     * |        |          |Note: Parity bit is generated on each outgoing character and is checked on each incoming data.
S     * |[4]     |EPE       |Even Parity Enable Bit
S     * |        |          |0 = Odd number of logic 1 is transmitted and checked in each word.
S     * |        |          |1 = Even number of logic 1 is transmitted and checked in each word.
S     * |        |          |Note: This bit has effect only when PBE (UART_LINE[3]) is set.
S     * |[5]     |SPE       |Stick Parity Enable Bit
S     * |        |          |0 = Stick parity Disabled.
S     * |        |          |1 = Stick parity Enabled.
S     * |        |          |Note: If PBE (UART_LINE[3]) and EPE (UART_LINE[4]) are logic 1, the parity bit is transmitted and checked as logic 0.
S     * |        |          |If PBE (UART_LINE[3]) is 1 and EPE (UART_LINE[4]) is 0 then the parity bit is transmitted and checked as 1.
S     * |[6]     |BCB       |Break Control Bit
S     * |        |          |0 = Break Control Disabled.
S     * |        |          |1 = Break Control Enabled.
S     * |        |          |Note: When this bit is set to logic 1, the transmitted serial data output (TX) is forced to the Spacing State (logic 0).
S     * |        |          |This bit acts only on TX line and has no effect on the transmitter logic.
S     * |[7]     |PSS       |Parity Bit Source Selection
S     * |        |          |The parity bit can be selected to be generated and checked automatically or by software.
S     * |        |          |0 = Parity bit is generated by EPE (UART_LINE[4]) and SPE (UART_LINE[5]) setting and checked automatically.
S     * |        |          |1 = Parity bit generated and checked by software.
S     * |        |          |Note1: This bit has effect only when PBE (UART_LINE[3]) is set.
S     * |        |          |Note2: If PSS is 0, the parity bit is transmitted and checked automatically.
S     * |        |          |If PSS is 1, the transmitted parity bit value can be determined by writing PARITY (UART_DAT[8]) and the parity bit can be read by reading PARITY (UART_DAT[8]).
S     * |[8]     |TXDINV    |TX Data Inverted
S     * |        |          |0 = Transmitted data signal inverted Disabled.
S     * |        |          |1 = Transmitted data signal inverted Enabled.
S     * |        |          |Note1: Before setting this bit, TXRXDIS (UART_FUNCSEL[3]) should be set then waited for TXRXACT (UART_FIFOSTS[31]) is cleared.
S     * |        |          |When the configuration is done, cleared TXRXDIS (UART_FUNCSEL[3]) to activate UART controller.
S     * |        |          |Note2: This bit is valid when FUNCSEL (UART_FUNCSEL[1:0]) is select UART, LIN or RS485 function.
S     * |[9]     |RXDINV    |RX Data Inverted
S     * |        |          |0 = Received data signal inverted Disabled.
S     * |        |          |1 = Received data signal inverted Enabled.
S     * |        |          |Note1: Before setting this bit, TXRXDIS (UART_FUNCSEL[3]) should be set then waited for TXRXACT (UART_FIFOSTS[31]) is cleared.
S     * |        |          |When the configuration is done, cleared TXRXDIS (UART_FUNCSEL[3]) to activate UART controller.
S     * |        |          |Note2: This bit is valid when FUNCSEL (UART_FUNCSEL[1:0]) is select UART, LIN or RS485 function.
S     * @var UART_T::MODEM
S     * Offset: 0x10  UART Modem Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |RTS       |nRTS (Request-to-send) Signal Control
S     * |        |          |This bit is direct control internal nRTS signal active or not, and then drive the nRTS pin output with RTSACTLV bit configuration.
S     * |        |          |0 = nRTS signal is active.
S     * |        |          |1 = nRTS signal is inactive.
S     * |        |          |Note1: This nRTS signal control bit is not effective when nRTS auto-flow control is enabled in UART function mode.
S     * |        |          |Note2: This nRTS signal control bit is not effective when RS-485 auto direction mode (AUD) is enabled in RS-485 function mode.
S     * |[9]     |RTSACTLV  |nRTS Pin Active Level
S     * |        |          |This bit defines the active level state of nRTS pin output.
S     * |        |          |0 = nRTS pin output is high level active.
S     * |        |          |1 = nRTS pin output is low level active. (Default)
S     * |        |          |Note3: Before setting this bit, TXRXDIS (UART_FUNCSEL[3]) should be set then waited for TXRXACT (UART_FIFOSTS[31]) is cleared.
S     * |        |          |When the configuration is done, cleared TXRXDIS (UART_FUNCSEL[3]) to activate UART controller.
S     * |[13]    |RTSSTS    |nRTS Pin Status (Read Only)
S     * |        |          |This bit mirror from nRTS pin output of voltage logic status.
S     * |        |          |0 = nRTS pin output is low level voltage logic state.
S     * |        |          |1 = nRTS pin output is high level voltage logic state.
S     * @var UART_T::MODEMSTS
S     * Offset: 0x14  UART Modem Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CTSDETF   |Detect nCTS State Change Flag
S     * |        |          |This bit is set whenever nCTS input has change state, and it will generate Modem interrupt to CPU when MODEMIEN (UART_INTEN [3]) is set to 1.
S     * |        |          |0 = nCTS input has not change state.
S     * |        |          |1 = nCTS input has change state.
S     * |        |          |Note: This bit can be cleared by writing 1 to it.
S     * |[4]     |CTSSTS    |nCTS Pin Status (Read Only)
S     * |        |          |This bit mirror from nCTS pin input of voltage logic status.
S     * |        |          |0 = nCTS pin input is low level voltage logic state.
S     * |        |          |1 = nCTS pin input is high level voltage logic state.
S     * |        |          |Note: This bit echoes when UART controller peripheral clock is enabled, and nCTS multi-function port is selected.
S     * |[8]     |CTSACTLV  |nCTS Pin Active Level
S     * |        |          |This bit defines the active level state of nCTS pin input.
S     * |        |          |0 = nCTS pin input is high level active.
S     * |        |          |1 = nCTS pin input is low level active. (Default)
S     * |        |          |Note: Before setting this bit, TXRXDIS (UART_FUNCSEL[3]) should be set then waited for TXRXACT (UART_FIFOSTS[31]) is cleared.
S     * |        |          |When the configuration is done, cleared TXRXDIS (UART_FUNCSEL[3]) to activate UART controller.
S     * @var UART_T::FIFOSTS
S     * Offset: 0x18  UART FIFO Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RXOVIF    |RX Overflow Error Interrupt Flag
S     * |        |          |This bit is set when RX FIFO overflow.
S     * |        |          |If the number of bytes of received data is greater than RX_FIFO (UART_DAT) size, 16 bytes, this bit will be set.
S     * |        |          |0 = RX FIFO is not overflow.
S     * |        |          |1 = RX FIFO is overflow.
S     * |        |          |Note: This bit can be cleared by writing 1 to it.
S     * |[1]     |ABRDIF    |Auto-baud Rate Detect Interrupt Flag
S     * |        |          |This bit is set to logic 1 when auto-baud rate detect function is finished.
S     * |        |          |0 = Auto-baud rate detect function is not finished.
S     * |        |          |1 = Auto-baud rate detect function is finished.
S     * |        |          |Note: This bit can be cleared by writing 1 to it.
S     * |[2]     |ABRDTOIF  |Auto-baud Rate Detect Time-out Interrupt Flag
S     * |        |          |This bit is set to logic 1 in Auto-baud Rate Detect mode when the baud rate counter is overflow.
S     * |        |          |0 = Auto-baud rate counter is underflow.
S     * |        |          |1 = Auto-baud rate counter is overflow.
S     * |        |          |Note: This bit can be cleared by writing 1 to it.
S     * |[3]     |ADDRDETF  |RS-485 Address Byte Detect Flag
S     * |        |          |0 = Receiver detects a data that is not an address bit (bit 9 = 1).
S     * |        |          |1 = Receiver detects a data that is an address bit (bit 9 = 1).
S     * |        |          |Note1: This field is used for RS-485 function mode and ADDRDEN (UART_ALTCTL[15]) is set to 1 to enable Address detection mode.
S     * |        |          |Note2: This bit can be cleared by writing 1 to it.
S     * |[4]     |PEF       |Parity Error Flag
S     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid parity bit.
S     * |        |          |0 = No parity error is generated.
S     * |        |          |1 = Parity error is generated.
S     * |        |          |Note: This bit can be cleared by writing 1 to it.
S     * |[5]     |FEF       |Framing Error Flag
S     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid stop bit (that is, the stop bit following the last data bit or parity bit is detected as logic 0).
S     * |        |          |0 = No framing error is generated.
S     * |        |          |1 = Framing error is generated.
S     * |        |          |Note: This bit can be cleared by writing 1 to it.
S     * |[6]     |BIF       |Break Interrupt Flag
S     * |        |          |This bit is set to logic 1 whenever the received data input (RX) is held in the spacing state (logic 0) for longer than a full word transmission time (that is, the total time of start bit + data bits + parity + stop bits).
S     * |        |          |0 = No Break interrupt is generated.
S     * |        |          |1 = Break interrupt is generated.
S     * |        |          |Note: This bit can be cleared by writing 1 to it.
S     * |[13:8]  |RXPTR     |RX FIFO Pointer (Read Only)
S     * |        |          |This field indicates the RX FIFO Buffer Pointer.
S     * |        |          |When UART receives one byte from external device, RXPTR increases one.
S     * |        |          |When one byte of RX FIFO is read by CPU, RXPTR decreases one.
S     * |        |          |The Maximum value shown in RXPTR is 15.
S     * |        |          |When the using level of RX FIFO Buffer equal to 16, the RXFULL bit is set to 1 and RXPTR will show 0.
S     * |        |          |As one byte of RX FIFO is read by CPU, the RXFULL bit is cleared to 0 and RXPTR will show 15.
S     * |[14]    |RXEMPTY   |Receiver FIFO Empty (Read Only)
S     * |        |          |This bit initiate RX FIFO empty or not.
S     * |        |          |0 = RX FIFO is not empty.
S     * |        |          |1 = RX FIFO is empty.
S     * |        |          |Note: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high.
S     * |        |          |It will be cleared when UART receives any new data.
S     * |[15]    |RXFULL    |Receiver FIFO Full (Read Only)
S     * |        |          |This bit initiates RX FIFO full or not.
S     * |        |          |0 = RX FIFO is not full.
S     * |        |          |1 = RX FIFO is full.
S     * |        |          |Note: This bit is set when the number of usage in RX FIFO Buffer is equal to 16, otherwise it is cleared by hardware.
S     * |[21:16] |TXPTR     |TX FIFO Pointer (Read Only)
S     * |        |          |This field indicates the TX FIFO Buffer Pointer.
S     * |        |          |When CPU writes one byte into UART_DAT, TXPTR increases one.
S     * |        |          |When one byte of TX FIFO is transferred to Transmitter Shift Register, TXPTR decreases one.
S     * |        |          |The Maximum value shown in TXPTR is 15
S     * |        |          |When the using level of TX FIFO Buffer equal to 16, the TXFULL bit is set to 1 and TXPTR will show 0.
S     * |        |          |As one byte of TX FIFO is transferred to Transmitter Shift Register, the TXFULL bit is cleared to 0 and TXPTR will show 15.
S     * |[22]    |TXEMPTY   |Transmitter FIFO Empty (Read Only)
S     * |        |          |This bit indicates TX FIFO empty or not.
S     * |        |          |0 = TX FIFO is not empty.
S     * |        |          |1 = TX FIFO is empty.
S     * |        |          |Note: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high.
S     * |        |          |It will be cleared when writing data into UART_DAT (TX FIFO not empty).
S     * |[23]    |TXFULL    |Transmitter FIFO Full (Read Only)
S     * |        |          |This bit indicates TX FIFO full or not.
S     * |        |          |0 = TX FIFO is not full.
S     * |        |          |1 = TX FIFO is full.
S     * |        |          |Note: This bit is set when the number of usage in TX FIFO Buffer is equal to 16, otherwise it is cleared by hardware.
S     * |[24]    |TXOVIF    |TX Overflow Error Interrupt Flag
S     * |        |          |If TX FIFO (UART_DAT) is full, an additional write to UART_DAT will cause this bit to logic 1.
S     * |        |          |0 = TX FIFO is not overflow.
S     * |        |          |1 = TX FIFO is overflow.
S     * |        |          |Note: This bit can be cleared by writing 1 to it.
S     * |[28]    |TXEMPTYF  |Transmitter Empty Flag (Read Only)
S     * |        |          |This bit is set by hardware when TX FIFO (UART_DAT) is empty and the STOP bit of the last byte has been transmitted.
S     * |        |          |0 = TX FIFO is not empty or the STOP bit of the last byte has been not transmitted.
S     * |        |          |1 = TX FIFO is empty and the STOP bit of the last byte has been transmitted.
S     * |        |          |Note: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.
S     * |[29]    |RXIDLE    |RX Idle Status (Read Only)
S     * |        |          |This bit is set by hardware when RX is idle.
S     * |        |          |0 = RX is busy.
S     * |        |          |1 = RX is idle. (Default)
S     * |[31]    |TXRXACT   |TX and RX Active Status (Read Only)
S     * |        |          |This bit indicates TX and RX are active or inactive.
S     * |        |          |0 = TX and RX are inactive.
S     * |        |          |1 = TX and RX are active. (Default)
S     * |        |          |Note: When TXRXDIS (UART_FUNCSEL[3]) is set and both TX and RX are in idle state, this bit is cleared.
S     * |        |          |The UART controller can not transmit or receive data at this moment. Otherwise this bit is set.
S     * @var UART_T::INTSTS
S     * Offset: 0x1C  UART Interrupt Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RDAIF     |Receive Data Available Interrupt Flag (Read Only)
S     * |        |          |When the number of bytes in the RX FIFO equals the RFITL then the RDAIF(UART_INTSTS[0]) will be set.
S     * |        |          |If RDAIEN (UART_INTEN [0]) is enabled, the RDA interrupt will be generated.
S     * |        |          |0 = No RDA interrupt flag is generated.
S     * |        |          |1 = RDA interrupt flag is generated.
S     * |        |          |Note: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UART_FIFO[7:4]).
S     * |[1]     |THREIF    |Transmit Holding Register Empty Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register.
S     * |        |          |If THREIEN (UART_INTEN[1]) is enabled, the THRE interrupt will be generated.
S     * |        |          |0 = No THRE interrupt flag is generated.
S     * |        |          |1 = THRE interrupt flag is generated.
S     * |        |          |Note: This bit is read only and it will be cleared when writing data into UART_DAT (TX FIFO not empty).
S     * |[2]     |RLSIF     |Receive Line Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UART_FIFOSTS[6]), FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]), is set).
S     * |        |          |If RLSIEN (UART_INTEN [2]) is enabled, the RLS interrupt will be generated.
S     * |        |          |0 = No RLS interrupt flag is generated.
S     * |        |          |1 = RLS interrupt flag is generated.
S     * |        |          |Note1: In RS-485 function mode, this field is set include receiver detect and received address byte character (bit9 = 1) bit.
S     * |        |          |At the same time, the bit of ADDRDETF (UART_FIFOSTS[3]) is also set.
S     * |        |          |Note2: This bit is read only and reset to 0 when all bits of BIF (UART_FIFOSTS[6]), FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) are cleared.
S     * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF (UART_FIFOSTS[6]) , FEF(UART_FIFOSTS[5]), and PEF(UART_FIFOSTS[4]) and ADDRDETF (UART_FIFOSTS[3]) are cleared.
S     * |[3]     |MODEMIF   |MODEM Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the nCTS pin has state change (CTSDETF (UART_MODEMSTS[0]) = 1)
S     * |        |          |If MODEMIEN (UART_INTEN [3]) is enabled, the Modem interrupt will be generated.
S     * |        |          |0 = No Modem interrupt flag is generated.
S     * |        |          |1 = Modem interrupt flag is generated.
S     * |        |          |Note: This bit is read only and reset to 0 when bit CTSDETF is cleared by a write 1 on CTSDETF(UART_MODEMSTS[0]).
S     * |[4]     |RXTOIF    |RX Time-out Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC (UART_TOUT[7:0])
S     * |        |          |If RXTOIENTOUTIEN (UART_INTEN [4]) is enabled, the Tout RX time-out interrupt will be generated.
S     * |        |          |0 = No RX time-outTime-out interrupt flag is generated.
S     * |        |          |1 = RX time-outTime-out interrupt flag is generated.
S     * |        |          |Note: This bit is read only and user can read UART_DAT (RX is in active) to clear it.
S     * |[5]     |BUFERRIF  |Buffer Error Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the TX FIFO or RX FIFO overflows (TXOVIF (UART_FIFOSTS[24]) or RXOVIF (UART_FIFOSTS[0]) is set)
S     * |        |          |When BUFERRIF (UART_INTSTS[5]) is set, the transfer is not correct.
S     * |        |          |If BUFERRIEN (UART_INTEN [5]) is enabled, the buffer error interrupt will be generated.
S     * |        |          |0 = No buffer error interrupt flag is generated.
S     * |        |          |1 = Buffer error interrupt flag is generated.
S     * |        |          |Note: This bit is cleared if both of RXOVIF(UART_FIFOSTS[0]) and TXOVIF(UART_FIFOSTS[24]) are cleared to 0 by writing 1 to RXOVIF(UART_FIFOSTS[0]) and TXOVIF(UART_FIFOSTS[24]).
S     * |[6]     |WKIF      |UART Wake-up Interrupt Flag (Read Only)
S     * |        |          |This bit is set when TOUTWKF (UART_WKSTS[4]), RS485WKF (UART_WKSTS[3]), RFRTWKF (UART_WKSTS[2]), DATWKIF (UART_WKSTS[1]) or CTSWKIF(UART_IWKSTS[0]) is set to 1.
S     * |        |          |0 = No UART wake-up interrupt flag is generated.
S     * |        |          |1 = UART wake-up interrupt flag is generated.
S     * |        |          |Note: This bit is cleared if all of TOUTWKF, RS485WKF, RFRTWKF, DATWKF and CTSWKF are cleared to 0 by writing 1 to the corresponding interrupt flag.
S     * |[7]     |LINIF     |LIN Bus Interrupt Flag (Read Only)
S     * |        |          |This bit is set when LIN slave header detect (SLVHDETF (UART_LINSTS[0] =1)), LIN break detect (BRKDETF(UART_LINSTS[98]=1)), bit error detect (BITEF(UART_LINSTS[9]=1)), LIN slave ID parity error (SLVIDPEF(UART_LINSTS[2] = 1)) or LIN slave header error detect (SLVHEF (UART_LINSTS[1] =1 ))
S     * |        |          |If LINIEN (UART_INTEN [8]) is enabled the LIN interrupt will be generated.
S     * |        |          |0 = None of SLVHDETF, BRKDETF, BITEF, SLVIDPEF and SLVHEF is generated.
S     * |        |          |1 = At least one of SLVHDETF, BRKDETF, BITEF, SLVIDPEF and SLVHEF is generated.
S     * |        |          |Note: This bit is cleared when SLVHDETF(UART_LINSTS[0]), BRKDETF(UART_LINSTS[8]), BITEF(UART_LINSTS[9]), SLVIDPEF (UART_LINSTS[2]) and SLVHEF(UART_LINSTS[1]) all are cleared and software writing 1 to LINIF(UART_INTSTS[7]).
S     * |[8]     |RDAINT    |Receive Data Available Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if RDAIEN (UART_INTEN[0]) and RDAIF (UART_INTSTS[0]) are both set to 1.
S     * |        |          |0 = No RDA interrupt is generated.
S     * |        |          |1 = RDA interrupt is generated.
S     * |[9]     |THREINT   |Transmit Holding Register Empty Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if THREIEN (UART_INTEN[1]) and THREIF(UART_INTSTS[1]) are both set to 1.
S     * |        |          |0 = No DATETHRE interrupt is generated.
S     * |        |          |1 = THREDATE interrupt is generated.
S     * |[10]    |RLSINT    |Receive Line Status Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if RLSIEN (UART_INTEN[2]) and RLSIF(UART_INTSTS[2]) are both set to 1.
S     * |        |          |0 = No RLS interrupt is generated.
S     * |        |          |1 = RLS interrupt is generated.
S     * |[11]    |MODEMINT  |MODEM Status Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if MODEMIEN(UART_INTEN[3]) and MODEMIF(UART_INTSTS[3]) are both set to 1
S     * |        |          |0 = No Modem interrupt is generated.
S     * |        |          |1 = Modem interrupt is generated..
S     * |[12]    |RXTOINT   |TRX Time-out Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if RXTOIEN (UART_INTEN[4]) and RXTOIF(UART_INTSTS[4]) are both set to 1.
S     * |        |          |0 = No RX time-out interrupt is generated.
S     * |        |          |1 = RX time-out interrupt is generated.
S     * |[13]    |BUFERRINT |Buffer Error Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if BUFERRIEN(UART_INTEN[5]) and BUFERRIF(UART_INTSTS[5]) are both set to 1.
S     * |        |          |0 = No buffer error interrupt is generated.
S     * |        |          |1 = Buffer error interrupt is generated.
S     * |[14]    |WKINT     |UART Wake-up Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if WKIEN (UART_INTEN[6]) and WKIF (UART_INTSTS[6]) are both set to 1.
S     * |        |          |0 = No UART wake-up interrupt is generated.
S     * |        |          |1 = UART wake-up interrupt is generated.
S     * |[15]    |LININT    |LIN Bus Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if LINIEN (UART_INTEN[8]) and LINIF(UART_INTSTS[7]) are both set to 1.
S     * |        |          |0 = No LIN Bus interrupt is generated.
S     * |        |          |1 = The LIN Bus interrupt is generated.
S     * |[18]    |HWRLSIF   |PDMA Mode Receive Line Status Flag (Read Only)
S     * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF (UART_FIFOSTS[6]), FEF (UART_FIFOSTS[5]) and PEF (UART_FIFOSTS[4]) is set).
S     * |        |          |If RLSIEN (UART_INTEN [2]) is enabled, the RLS interrupt will be generated.
S     * |        |          |0 = No RLS interrupt flag is generated in PDMA mode.
S     * |        |          |1 = RLS interrupt flag is generated in PDMA mode.
S     * |        |          |Note1: In RS-485 function mode, this field include receiver detect any address byte received address byte character (bit9 = 1) bit.
S     * |        |          |Note2: In UART function mode, this bit is read only and reset to 0 when all bits of BIF(UART_FIFOSTS[6]) , FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) are cleared.
S     * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UART_FIFOSTS[6]) , FEF(UART_FIFOSTS[5]), and PEF(UART_FIFOSTS[4]) and ADDRDETF (UART_FIFOSTS[3]) are cleared.
S     * |[19]    |HWMODIF   |PDMA Mode MODEM Status Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the nCTS pin has state change (CTSDETF (UART_MODEMSTS[0] =1)).
S     * |        |          |If MODEMIEN (UART_INTEN [3]) is enabled, the Modem interrupt will be generated.
S     * |        |          |0 = No Modem statusinterrupt flag is generated in PDMA mode.
S     * |        |          |1 = Modem status interrupt flag is generated in PDMA mode.
S     * |        |          |Note: This bit is read only and reset to 0 when the bit CTSDETF (UART_MODEMSTS[0]) is cleared by writing 1 on CTSDETF (UART_MODEMSTS[0]).
S     * |[20]    |HWTOIF    |PDMA Mode RX Time-out Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC (UART_TOUT[7:0]).
S     * |        |          |If RXTOIEN (UART_INTEN [4]) is enabled, the Tout RX time-out interrupt will be generated .
S     * |        |          |0 = No RX time-out interrupt flag is generated in PDMA mode.
S     * |        |          |1 = RX time-out interrupt flag is generated in PDMA mode.
S     * |        |          |Note: This bit is read only and user can read UART_DAT (RX is in active) to clear it.
S     * |[21]    |HWBUFEIF  |PDMA Mode Buffer Error Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the TX or RX FIFO overflows (TXOVIF (UART_FIFOSTS [24]) or RXOVIF (UART_FIFOSTS[0]) is set). When BUFERRIF (UART_INTSTS[5]) is set, the transfer maybe is not correct.
S     * |        |          |If BUFERRIEN (UART_INTEN [5]) is enabled, the buffer error interrupt will be generated.
S     * |        |          |0 = No buffer error interrupt flag is generated in PDMA mode.
S     * |        |          |1 = Buffer error interrupt flag is generated in PDMA mode.
S     * |        |          |Note: This bit is cleared when both TXOVIF (UART_FIFOSTS[24]]) and RXOVIF (UART_FIFOSTS[0]) are cleared.
S     * |[22]    |TXENDIF   |Transmitter Empty Interrupt Flag (Read Only)
S     * |        |          |This bit is set when TX FIFO (UART_DAT) is empty and the STOP bit of the last byte has been transmitted (TXEMPTYF (UART_FIFOSTS[28]) is set).
S     * |        |          |If TXENDIEN (UART_INTEN[22]) is enabled, the Transmitter Empty interrupt will be generated.
S     * |        |          |0 = No transmitter empty interrupt flag is generated.
S     * |        |          |1 = Transmitter empty interrupt flag is generated.
S     * |        |          |Note: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.
S     * |[26]    |HWRLSINT  |PDMA Mode Receive Line Status Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if RLSIEN (UART_INTEN[2]) and HWRLSIF(UART_INTSTS[18]) are both set to 1.
S     * |        |          |0 = No RLS interrupt is generated in PDMA mode.
S     * |        |          |1 = RLS interrupt is generated in PDMA mode.
S     * |[27]    |HWMODINT  |PDMA Mode MODEM Status Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if MODEMIEN (UART_INTEN[3]) and HWMODIF(UART_INTSTS[19]) are both set to 1.
S     * |        |          |0 = No Modem interrupt is generated in PDMA mode.
S     * |        |          |1 = Modem interrupt is generated in PDMA mode.
S     * |[28]    |HWTOINT   |PDMA Mode RX Time-out Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if RXTOIEN (UART_INTEN[4]) and HWTOIF(UART_INTSTS[20]) are both set to 1.
S     * |        |          |0 = No RX time-out interrupt is generated in PDMA mode.
S     * |        |          |1 = RX time-out interrupt is generated in PDMA mode.
S     * |[29]    |HWBUFEINT |PDMA Mode Buffer Error Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if BUFERRIEN (UART_INTEN[5]) and HWBUFEIF (UART_INTSTS[21]) are both set to 1.
S     * |        |          |0 = No buffer error interrupt is generated in PDMA mode.
S     * |        |          |1 = Buffer error interrupt is generated in PDMA mode.
S     * |[30]    |TXENDINT  |Transmitter Empty Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if TXENDIEN (UART_INTEN[22]) and TXENDIF(UART_INTSTS[22]) are both set to 1.
S     * |        |          |0 = No Transmitter Empty interrupt is generated.
S     * |        |          |1 = Transmitter Empty interrupt is generated.
S     * |[31]    |ABRINT    |Auto-baud Rate Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if ABRIEN (UART_INTEN[18]) and ABRIF (UART_ALTCTL[17]) are both set to 1.
S     * |        |          |0 = No Auto-baud Rate interrupt is generated.
S     * |        |          |1 = The Auto-baud Rate interrupt is generated.
S     * @var UART_T::TOUT
S     * Offset: 0x20  UART Time-out Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |TOIC      |Time-out Interrupt Comparator
S     * |        |          |The time-out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word if time out counter is enabled by setting TOCNTEN (UART_INTEN[11]).
S     * |        |          |Once the content of time-out counter is equal to that of time-out interrupt comparator (TOIC (UART_TOUT[7:0])), a receiver time-out interrupt (RXTOINT(UART_INTSTS[12])) is generated if RXTOIEN (UART_INTEN [4]) enabled.
S     * |        |          |A new incoming data word or RX FIFO empty will clear RXTOIF (UART_INTSTS[4]).
S     * |        |          |In order to avoid receiver time-out interrupt generation immediately during one character is being received, TOIC value should be set between 40 and 255.
S     * |        |          |So, for example, if TOIC is set with 40, the time-out interrupt is generated after four characters are not received when 1 stop bit and no parity check is set for UART transfer.
S     * |[15:8]  |DLY       |TX Delay Time Value
S     * |        |          |This field is used to programming the transfer delay time between the last stop bit and next start bit.
S     * |        |          |The unit is bit time.
S     * @var UART_T::BAUD
S     * Offset: 0x24  UART Baud Rate Divider Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |BRD       |Baud Rate Divider
S     * |        |          |The field indicates the baud rate divider. This filed is used in baud rate calculation.
S     * |[27:24] |EDIVM1    |Extra Divider for BAUD Rate Mode 1
S     * |        |          |This field is used for baud rate calculation in mode 1 and has no effect for baud rate calculation in mode 0 and mode 2.
S     * |[28]    |BAUDM0    |BAUD Rate Mode Selection Bit 0
S     * |        |          |This bit is baud rate mode selection bit 0.
S     * |        |          |UART provides three baud rate calculation modes.
S     * |        |          |This bit combines with BAUDM1 (UART_BAUD[29]) to select baud rate calculation mode.
S     * |[29]    |BAUDM1    |BAUD Rate Mode Selection Bit 1
S     * |        |          |This bit is baud rate mode selection bit 1.
S     * |        |          |UART provides three baud rate calculation modes.
S     * |        |          |This bit combines with BAUDM0 (UART_BAUD[28]) to select baud rate calculation mode.
S     * |        |          |Note: In IrDA mode must be operated in mode 0.
S     * @var UART_T::IRDA
S     * Offset: 0x28  UART IrDA Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |TXEN      |IrDA Receiver/Transmitter Selection Enable Bit
S     * |        |          |0 = IrDA Transmitter Disabled and Receiver Enabled. (Default)
S     * |        |          |1 = IrDA Transmitter Enabled and Receiver Disabled.
S     * |        |          |Note: In IrDA mode, the BAUDM1 (UART_BAUD [29]) register must be disabled, the baud equation must be Clock / (16 * (BRD + 2)).
S     * |[5]     |TXINV     |IrDA Inverse Transmitting Output Signal
S     * |        |          |0 = None inverse transmitting signal. (Default).
S     * |        |          |1 = Inverse transmitting output signal.
S     * |        |          |Note1: Before setting this bit, TXRXDIS (UART_FUNCSEL[3]) should be set then waited for TXRXACT (UART_FIFOSTS[31]) is cleared.
S     * |        |          |When the configuration is done, cleared TXRXDIS (UART_FUNCSEL[3]) to activate UART controller.
S     * |        |          |Note2: This bit is valid when FUNCSEL (UART_FUNCSEL[1:0]) is select IrDA function.
S     * |[6]     |RXINV     |IrDA Inverse Receive Input Signal
S     * |        |          |0 = None inverse receiving input signal.
S     * |        |          |1 = Inverse receiving input signal. (Default)
S     * |        |          |Note1: Before setting this bit, TXRXDIS (UART_FUNCSEL[3]) should be set then waited for TXRXACT (UART_FIFOSTS[31]) is cleared.
S     * |        |          |When the configuration is done, cleared TXRXDIS (UART_FUNCSEL[3]) to activate UART controller.
S     * |        |          |Note2: This bit is valid when FUNCSEL (UART_FUNCSEL[1:0]) is select IrDA function.
S     * @var UART_T::ALTCTL
S     * Offset: 0x2C  UART Alternate Control/Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |BRKFL     |UART LIN Break Field Length
S     * |        |          |This field indicates a 4-bit LIN TX break field count.
S     * |        |          |Note1: This break field length is BRKFL + 1.
S     * |        |          |Note2: According to LIN spec, the reset value is 0xC (break field length = 13).
S     * |[6]     |LINRXEN   |LIN RX Enable Bit
S     * |        |          |0 = LIN RX mode Disabled.
S     * |        |          |1 = LIN RX mode Enabled.
S     * |[7]     |LINTXEN   |LIN TX Break Mode Enable Bit
S     * |        |          |0 = LIN TX Break mode Disabled.
S     * |        |          |1 = LIN TX Break mode Enabled.
S     * |        |          |Note: When TX break field transfer operation finished, this bit will be cleared automatically.
S     * |[8]     |RS485NMM  |RS-485 Normal Multi-drop Operation Mode (NMM)
S     * |        |          |0 = RS-485 Normal Multi-drop Operation mode (NMM) Disabled.
S     * |        |          |1 = RS-485 Normal Multi-drop Operation mode (NMM) Enabled.
S     * |        |          |Note: It cannot be active with RS-485_AAD operation mode.
S     * |[9]     |RS485AAD  |RS-485 Auto Address Detection Operation Mode (AAD)
S     * |        |          |0 = RS-485 Auto Address Detection Operation mode (AAD) Disabled.
S     * |        |          |1 = RS-485 Auto Address Detection Operation mode (AAD) Enabled.
S     * |        |          |Note: It cannot be active with RS-485_NMM operation mode.
S     * |[10]    |RS485AUD  |RS-485 Auto Direction Function (AUD)
S     * |        |          |0 = RS-485 Auto Direction Operation function (AUD) Disabled.
S     * |        |          |1 = RS-485 Auto Direction Operation function (AUD) Enabled.
S     * |        |          |Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.
S     * |[15]    |ADDRDEN   |RS-485 Address Detection Enable Bit
S     * |        |          |This bit is used to enable RS-485 Address Detection mode.
S     * |        |          |0 = Address detection mode Disabled.
S     * |        |          |1 = Address detection mode Enabled.
S     * |        |          |Note: This bit is used for RS-485 any operation mode.
S     * |[17]    |ABRIF     |Auto-baud Rate Interrupt Flag (Read Only)
S     * |        |          |This bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABRIEN(UART_INTEN [18]) is set then the auto-baud rate interrupt will be generated.
S     * |        |          |0 = No auto-baud rate interrupt flag is generated.
S     * |        |          |1 = Auto-baud rate interrupt flag is generated.
S     * |        |          |Note: This bit can be cleared by writing 1 to ABRDTOIF (UART_FIFOSTS[2]) and ABRDIF(UART_FIFOSTS[1]).
S     * |[18]    |ABRDEN    |Auto-baud Rate Detect Enable Bit
S     * |        |          |0 = Auto-baud rate detect function Disabled.
S     * |        |          |1 = Auto-baud rate detect function Enabled.
S     * |        |          |Note : This bit is cleared automatically after auto-baud detection is finished.
S     * |[20:19] |ABRDBITS  |Auto-baud Rate Detect Bit Length
S     * |        |          |00 = 1-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x01.
S     * |        |          |01 = 2-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x02.
S     * |        |          |10 = 4-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x08.
S     * |        |          |11 = 8-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x80.
S     * |        |          |Note : The calculation of bit number includes the START bit.
S     * |[31:24] |ADDRMV    |Address Match Value
S     * |        |          |This field contains the RS-485 address match values.
S     * |        |          |Note: This field is used for RS-485 auto address detection mode.
S     * @var UART_T::FUNCSEL
S     * Offset: 0x30  UART Function Select Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |FUNCSEL   |Function Select
S     * |        |          |00 = UART function.
S     * |        |          |01 = LIN function.
S     * |        |          |10 = IrDA function.
S     * |        |          |11 = RS-485 function.
S     * |[3]     |TXRXDIS   |TX and RX Disable Bit
S     * |        |          |Setting this bit can disable TX and RX.
S     * |        |          |0 = TX and RX Enabled.
S     * |        |          |1 = TX and RX Disabled.
S     * |        |          |Note: The TX and RX will not disable immediately when this bit is set.
S     * |        |          |The TX and RX compelet current task before disable TX and RX.
S     * |        |          |When TX and RX disable, the TXRXACT (UART_FIFOSTS[31]) is cleared.
S     * @var UART_T::LINCTL
S     * Offset: 0x34  UART LIN Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SLVEN     |LIN Slave Mode Enable Bit
S     * |        |          |0 = LIN slave mode Disabled.
S     * |        |          |1 = LIN slave mode Enabled.
S     * |[1]     |SLVHDEN   |LIN Slave Header Detection Enable Bit
S     * |        |          |0 = LIN slave header detection Disabled.
S     * |        |          |1 = LIN slave header detection Enabled.
S     * |        |          |Note1: This bit only valid when in LIN slave mode (SLVEN (UART_LINCTL[0]) = 1).
S     * |        |          |Note2: In LIN function mode, when detect header field (break + sync + frame ID), SLVHDETF (UART_LINSTS [0]) flag will be asserted.
S     * |        |          |If the LINIEN (UART_INTEN[8]) = 1, an interrupt will be generated.
S     * |[2]     |SLVAREN   |LIN Slave Automatic Resynchronization Mode Enable Bit
S     * |        |          |0 = LIN automatic resynchronization Disabled.
S     * |        |          |1 = LIN automatic resynchronization Enabled.
S     * |        |          |Note1: This bit only valid when in LIN slave mode (SLVEN (UART_LINCTL[0]) = 1).
S     * |        |          |Note2: When operation in Automatic Resynchronization mode, the baud rate setting must be mode2 (BAUDM1 (UART_BAUD [29]) and BAUDM0 (UART_BAUD [28]) must be 1).
S     * |[3]     |SLVDUEN   |LIN Slave Divider Update Method Enable Bit
S     * |        |          |0 = UART_BAUD updated is written by software (if no automatic resynchronization update occurs at the same time).
S     * |        |          |1 = UART_BAUD is updated at the next received character
S     * |        |          |User must set the bit before checksum reception.
S     * |        |          |Note1: This bit only valid when in LIN slave mode (SLVEN (UART_LINCTL[0]) = 1).
S     * |        |          |Note2: This bit used for LIN Slave Automatic Resynchronization mode.
S     * |        |          |(for Non-Automatic Resynchronization mode, this bit should be kept cleared).
S     * |[4]     |MUTE      |LIN Mute Mode Enable Bit
S     * |        |          |0 = LIN mute mode Disabled.
S     * |        |          |1 = LIN mute mode Enabled.
S     * |[8]     |SENDH     |LIN TX Send Header Enable Bit
S     * |        |          |The LIN TX header can be "break field" or "break and sync field" or "break, sync and frame ID field", it is depend on setting HSEL (UART_LINCTL[23:22]).
S     * |        |          |0 = Send LIN TX header Disabled.
S     * |        |          |1 = Send LIN TX header Enabled.
S     * |        |          |Note1: These registers are This bit is shadow registers bit of LINTXEN (UART_ALTCTL [7]); user can read/write it by setting LINTXEN (UART_ALTCTL [7]) or SENDH (UART_LINCTL [8]).
S     * |        |          |Note2: When transmitter header field (it may be "break" or "break + sync" or "break + sync + frame ID" selected by HSEL (UART_LINCTL[23:22]) field) transfer operation finished, this bit will be cleared automatically.
S     * |[9]     |IDPEN     |LIN ID Parity Enable Bit
S     * |        |          |0 = LIN frame ID parity Disabled.
S     * |        |          |1 = LIN frame ID parity Enabled.
S     * |        |          |Note1: This bit can be used for LIN master to sending header field (SENDH (UART_LINCTL[8])) = 1 and HSEL (UART_LINCTL[23:22]) = 10) or be used for enable LIN slave received frame ID parity checked.
S     * |        |          |Note2: This bit is only used when the operation header transmitter is in HSEL (UART_LINCTL[23:22]) = 10.
S     * |[10]    |BRKDETEN  |LIN Break Detection Enable Bit
S     * |        |          |When detect consecutive dominant greater than 11 bits, and are followed by a delimiter character, the BRKDETF (UART_LINSTS[8]) flag is set in UART_LINSTS register at the end of break field.
S     * |        |          |If the LINIEN (UART_INTEN [8])=1, an interrupt will be generated.
S     * |        |          |0 = LIN break detection Disabled.
S     * |        |          |1 = LIN break detection Enabled.
S     * |[11]    |LINRXOFF  |LIN Receiver Disable Bit
S     * |        |          |If the receiver is enabled (LINRXOFF (UART_LINCTL[11]) = 0), all received byte data will be accepted and stored in the RX FIFO, and if the receiver is disabled (LINRXOFF (UART_LINCTL[11] = 1), all received byte data will be ignore.
S     * |        |          |0 = LIN receiver Enabled.
S     * |        |          |1 = LIN receiver Disabled.
S     * |        |          |Note: This bit is only valid when operating in LIN function mode (FUNCSEL (UART_FUNCSEL[1:0]) = 01).
S     * |[12]    |BITERREN  |Bit Error Detect Enable Bit
S     * |        |          |0 = Bit error detection function Disabled.
S     * |        |          |1 = Bit error detection function Enabled.
S     * |        |          |Note: In LIN function mode, when occur bit error, the BITEF (UART_LINSTS[9]) flag will be asserted.
S     * |        |          |If the LINIEN (UART_INTEN[8]) = 1, an interrupt will be generated.
S     * |[19:16] |BRKFL     |LIN Break Field Length
S     * |        |          |This field indicates a 4-bit LIN TX break field count.
S     * |        |          |Note1: These registers are shadow registers of BRKFL (UART_ALTCTL[3:0]), User can read/write it by setting BRKFL (UART_ALTCTL[3:0]) or BRKFL (UART_LINCTL[19:16]).
S     * |        |          |Note2: This break field length is BRKFL + 1.
S     * |        |          |Note3: According to LIN spec, the reset value is 12 (break field length = 13).
S     * |[21:20] |BSL       |LIN Break/Sync Delimiter Length
S     * |        |          |00 = The LIN break/sync delimiter length is 1-bit time.
S     * |        |          |01 = The LIN break/sync delimiter length is 2-bit time.
S     * |        |          |10 = The LIN break/sync delimiter length is 3-bit time.
S     * |        |          |11 = The LIN break/sync delimiter length is 4-bit time.
S     * |        |          |Note: This bit used for LIN master to sending header field.
S     * |[23:22] |HSEL      |LIN Header Select
S     * |        |          |00 = The LIN header includes break field.
S     * |        |          |01 = The LIN header includes break field and sync field.
S     * |        |          |10 = The LIN header includes break field, ync field and frame ID field.
S     * |        |          |11 = Reserved.
S     * |        |          |Note: This bit is used to master mode for LIN to send header field (SENDH (UART_LINCTL [8]) = 1) or used to slave to indicates exit from mute mode condition (MUTE (UART_LINCTL[4] = 1).
S     * |[31:24] |PID       |LIN PID Bits
S     * |        |          |This field contains the LIN frame ID value when in LIN function mode, the frame ID parity can be generated by software or hardware depends on IDPEN (UART_LINCTL[9]) = 1.
S     * |        |          |If the parity generated by hardware, user fill ID0~ID5 , (PID [29:24] ), hardware will calculate P0 (PID[30]) and P1 (PID[31]), otherwise user must filled frame ID and parity in this field.
S     * |        |          |Note1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first).
S     * |        |          |Note2: This field can be used for LIN master mode or slave mode.
S     * @var UART_T::LINSTS
S     * Offset: 0x38  UART LIN Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SLVHDETF  |LIN Slave Header Detection Flag
S     * |        |          |This bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared by writing 1 to it.
S     * |        |          |0 = LIN header not detected.
S     * |        |          |1 = LIN header detected (break + sync + frame ID).
S     * |        |          |Note1: This bitcan be cleared by writing 1 to it.
S     * |        |          |Note2: This bit is only valid when in LIN slave mode (SLVEN (UART_LINCTL [0]) = 1) and enable LIN slave header detection function (SLVHDEN (UART_LINCTL [1])).
S     * |        |          |Note3: When enable ID parity check IDPEN (UART_LINCTL [9]), if hardware detect complete header (u201Cbreak + sync + frame IDu201D), the SLVHDETF will be set whether the frame ID correct or not.
S     * |[1]     |SLVHEF    |LIN Slave Header Error Flag
S     * |        |          |This bit is set by hardware when a LIN header error is detected in LIN slave mode and be cleared by writing 1 to it.
S     * |        |          |The header errors include "break delimiter is too short (less than 0.5 bit time)", "frame error in sync field or Identifier fieldu", "sync field data is not 0x55 in Non-Automatic Resynchronization modeu", "sync field deviation error with Automatic Resynchronization modeu", "sync field measure time-out with Automatic Resynchronization mode" and "LIN header reception time-out".
S     * |        |          |0 = LIN header error not detected.
S     * |        |          |1 = LIN header error detected.
S     * |        |          |Note1: This bit can be cleared by writing 1 to it.
S     * |        |          |Note2: This bit is only valid when UART is operated in LIN slave mode (SLVEN (UART_LINCTL [0]) = 1) and enables LIN slave header detection function (SLVHDEN (UART_LINCTL [1])).
S     * |[2]     |SLVIDPEF  |LIN Slave ID Parity Error Flag
S     * |        |          |This bit is set by hardware when receipted frame ID parity is not correct.
S     * |        |          |0 = No active.
S     * |        |          |1 = Receipted frame ID parity is not correct.
S     * |        |          |Note1: This can be cleared by writing 1 to it.
S     * |        |          |Note2: This bit is only valid when in LIN slave mode (SLVEN (UART_LINCTL [0])= 1) and enable LIN frame ID parity check function IDPEN (UART_LINCTL [9]).
S     * |[3]     |SLVSYNCF  |LIN Slave Sync Field
S     * |        |          |This bit indicates that the LIN sync field is being analyzed in Automatic Resynchronization mode.
S     * |        |          |When the receiver header have some error been detect, user must reset the internal circuit to re-search new frame header by writing 1 to this bit.
S     * |        |          |0 = The current character is not at LIN sync state.
S     * |        |          |1 = The current character is at LIN sync state.
S     * |        |          |Note1: This bit is only valid when in LIN Slave mode (SLVEN(UART_LINCTL[0]) = 1).
S     * |        |          |Note2: This bit can be cleared by writing 1 to it.
S     * |        |          |Note3: When writing 1 to it, hardware will reload the initial baud rate and re-search a new frame header.
S     * |[8]     |BRKDETF   |LIN Break Detection Flag
S     * |        |          |This bit is set by hardware when a break is detected and be cleared by writing 1 to it through software.
S     * |        |          |0 = LIN break not detected.
S     * |        |          |1 = LIN break detected.
S     * |        |          |Note1: This bitcan be cleared by writing 1 to it.
S     * |        |          |Note2: This bit is only valid when LIN break detection function is enabled (BRKDETEN (UART_LINCTL[10]) =1).
S     * |[9]     |BITEF     |Bit Error Detect Status Flag (Read Only)
S     * |        |          |At TX transfer state, hardware will monitoring the bus state, if the input pin (UART_RXD) state not equals to the output pin (UART_TXD) state, BITEF (UART_LINSTS[9]) will be set.
S     * |        |          |When occur bit error, if the LINIEN (UART_INTEN[8]) = 1, an interrupt will be generated.
S     * |        |          |0 = Bit error not detected.
S     * |        |          |1 = Bit error detected.
S     * |        |          |Note1: This bit can be cleared by writing 1 to it.
S     * |        |          |Note2: This bit is only valid when enable bit error detection function (BITERREN (UART_LINCTL [12]) = 1).
S     * @var UART_T::BRCOMP
S     * Offset: 0x3C  UART Baud Rate Compensation Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[8:0]   |BRCOMP    |Baud Rate Compensation Patten
S     * |        |          |These 9-bits are used to define the relative bit is compensated or not.
S     * |        |          |BRCOMP[7:0] is used to define the compensation of UART_DAT[7:0] and BRCOMP[8] is used to define the parity bit.
S     * |[31]    |BRCOMPDEC |Baud Rate Compensation Decrease
S     * |        |          |0 = Positive (increase one module clock) compensation for each compensated bit.
S     * |        |          |1 = Negative (decrease one module clock) compensation for each compensated bit.
S     * @var UART_T::WKCTL
S     * Offset: 0x40  UART Wake-up Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WKCTSEN   |nCTS Wake-up Enable Bit
S     * |        |          |0 = nCTS Wake-up system function Disabled.
S     * |        |          |1 = nCTS Wake-up system function Enabled, when the system is in Power-down mode, an external nCTS change will wake-up system from Power-down mode.
S     * |[1]     |WKDATEN   |Incoming Data Wake-up Enable Bit
S     * |        |          |0 = Incoming data wake-up system function Disabled.
S     * |        |          |1 = Incoming data wake-up system function Enabled, when the system is in Power-down mode, incoming data will wake-up system from Power-down mode.
S     * |[2]     |WKRFRTEN  |Received Data FIFO Reached Threshold Wake-up Enable Bit
S     * |        |          |0 = Received Data FIFO reached threshold wake-up system function Disabled.
S     * |        |          |1 = Received Data FIFO reached threshold wake-up system function Enabled, when the system is .
S     * |        |          |in Power-down mode, Received Data FIFO reached threshold will wake-up system from Power-down mode.
S     * |[3]     |WKRS485EN |RS-485 Address Match (AAD Mode) Wake-up Enable Bit
S     * |        |          |0 = RS-485 Address Match (AAD mode) wake-up system function Disabled.
S     * |        |          |1 = RS-485 Address Match (AAD mode) wake-up system function Enabled, when the system is in Power-down mode, RS-485 Address Match will wake-up system from Power-down mode.
S     * |        |          |Note: This bit is used for RS-485 Auto Address Detection (AAD) mode in RS-485 function mode and ADDRDEN (UART_ALTCTL[15]) is set to 1.
S     * |[4]     |WKTOUTEN  |Received Data FIFO Reached Threshold Time-out Wake-up Enable Bit
S     * |        |          |0 = Received Data FIFO reached threshold time-out wake-up system function Disabled.
S     * |        |          |1 = Received Data FIFO reached threshold time-out wake-up system function Enabled, when the system is in Power-down mode, Received Data FIFO reached threshold time-out will wake-up system from Power-down mode.
S     * |        |          |Note: It is suggest the function is enabled when the WKRFRTEN (UART_WKCTL[2]) is set to 1.
S     * @var UART_T::WKSTS
S     * Offset: 0x44  UART Wake-up Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CTSWKF    |nCTS Wake-up Flag
S     * |        |          |This bit is set if chip wake-up from power-down state by nCTS wake-up.
S     * |        |          |0 = Chip stays in power-down state.
S     * |        |          |1 = Chip wake-up from power-down state by nCTS wake-up.
S     * |        |          |Note1: If WKCTSEN (UART_WKCTL[0]) is enabled, the nCTS wake-up cause this bit is set to 1.
S     * |        |          |Note2: This bit can be cleared by writing 1 to it.
S     * |[1]     |DATWKF    |Incoming Data Wake-up Flag
S     * |        |          |This bit is set if chip wake-up from power-down state by data wake-up.
S     * |        |          |0 = Chip stays in power-down state.
S     * |        |          |1 = Chip wake-up from power-down state by Incoming Data wake-up.
S     * |        |          |Note1: If WKDATEN (UART_WKCTL[1]) is enabled, the Incoming Data wake-up cause this bit is set to 1.
S     * |        |          |Note2: This bit can be cleared by writing 1 to it.
S     * |[2]     |RFRTWKF   |Received Data FIFO Reached Threshold Wake-up Flag
S     * |        |          |This bit is set if chip wake-up from power-down state by Received Data FIFO reached threshold wake-up.
S     * |        |          |0 = Chip stays in power-down state.
S     * |        |          |1 = Chip wake-up from power-down state by Received Data FIFO Reached Threshold wake-up.
S     * |        |          |Note1: If WKRFRTEN (UART_WKCTL[2]) is enabled, the Received Data FIFO Reached Threshold wake-up cause this bit is set to 1.
S     * |        |          |Note2: This bit can be cleared by writing 1 to it.
S     * |[3]     |RS485WKF  |RS-485 Address Match (AAD Mode) Wake-up Flag
S     * |        |          |This bit is set if chip wake-up from power-down state by RS-485 Address Match (AAD mode).
S     * |        |          |0 = Chip stays in power-down state.
S     * |        |          |1 = Chip wake-up from power-down state by RS-485 Address Match (AAD mode) wake-up.
S     * |        |          |Note1: If WKRS485EN (UART_WKCTL[3]) is enabled, the RS-485 Address Match (AAD mode) wake-up cause this bit is set to 1.
S     * |        |          |Note2: This bit can be cleared by writing 1 to it.
S     * |[4]     |TOUTWKF   |Received Data FIFO Threshold Time-out Wake-up Flag
S     * |        |          |This bit is set if chip wake-up from power-down state by Received Data FIFO Threshold Time-out wake-up.
S     * |        |          |0 = Chip stays in power-down state.
S     * |        |          |1 = Chip wake-up from power-down state by Received Data FIFO reached threshold time-out wake-up.
S     * |        |          |Note1: If WKTOUTEN (UART_WKCTL[4]) is enabled, the Received Data FIFO reached threshold time-out wake-up cause this bit is set to 1.
S     * |        |          |Note2: This bit can be cleared by writing 1 to it.
S     * @var UART_T::DWKCOMP
S     * Offset: 0x48  UART Imcoming Data Wake-up Compensation Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |STCOMP    |Start Bit Compensation Value
S     * |        |          |These bits field indicate how many clock cycle selected by UART_CLK do the UART controller can get the 1st bit (start bit) when the device is wake-up from power-down mode.
S     * |        |          |Note: It is valid only when WKDATEN (UART_WKCTL[1]) is set.
S     */
S
S
S    __IO uint32_t DAT;                   /*!< [0x0000] UART Receive/Transmit Buffer Register                            */
S    __IO uint32_t INTEN;                 /*!< [0x0004] UART Interrupt Enable Register                                   */
S    __IO uint32_t FIFO;                  /*!< [0x0008] UART FIFO Control Register                                       */
S    __IO uint32_t LINE;                  /*!< [0x000c] UART Line Control Register                                       */
S    __IO uint32_t MODEM;                 /*!< [0x0010] UART Modem Control Register                                      */
S    __IO uint32_t MODEMSTS;              /*!< [0x0014] UART Modem Status Register                                       */
S    __IO uint32_t FIFOSTS;               /*!< [0x0018] UART FIFO Status Register                                        */
S    __IO uint32_t INTSTS;                /*!< [0x001c] UART Interrupt Status Register                                   */
S    __IO uint32_t TOUT;                  /*!< [0x0020] UART Time-out Register                                           */
S    __IO uint32_t BAUD;                  /*!< [0x0024] UART Baud Rate Divider Register                                  */
S    __IO uint32_t IRDA;                  /*!< [0x0028] UART IrDA Control Register                                       */
S    __IO uint32_t ALTCTL;                /*!< [0x002c] UART Alternate Control/Status Register                           */
S    __IO uint32_t FUNCSEL;               /*!< [0x0030] UART Function Select Register                                    */
S    __IO uint32_t LINCTL;                /*!< [0x0034] UART LIN Control Register                                        */
S    __IO uint32_t LINSTS;                /*!< [0x0038] UART LIN Status Register                                         */
S    __IO uint32_t BRCOMP;                /*!< [0x003c] UART Baud Rate Compensation Register                             */
S    __IO uint32_t WKCTL;                 /*!< [0x0040] UART Wake-up Control Register                                    */
S    __IO uint32_t WKSTS;                 /*!< [0x0044] UART Wake-up Status Register                                     */
S    __IO uint32_t DWKCOMP;               /*!< [0x0048] UART Imcoming Data Wake-up Compensation Register                 */
S
S
S} UART_T;
S
S/**
S    @addtogroup UART_CONST UART Bit Field Definition
S    Constant Definitions for UART Controller
S@{ */
S
S#define UART_DAT_DAT_Pos                 (0)                                               /*!< UART_T::DAT: DAT Position              */
S#define UART_DAT_DAT_Msk                 (0xfful << UART_DAT_DAT_Pos)                      /*!< UART_T::DAT: DAT Mask                  */
S
S#define UART_DAT_PARITY_Pos              (8)                                               /*!< UART_T::DAT: PARITY Position           */
S#define UART_DAT_PARITY_Msk              (0x1ul << UART_DAT_PARITY_Pos)                    /*!< UART_T::DAT: PARITY Mask               */
S
S#define UART_INTEN_RDAIEN_Pos            (0)                                               /*!< UART_T::INTEN: RDAIEN Position         */
S#define UART_INTEN_RDAIEN_Msk            (0x1ul << UART_INTEN_RDAIEN_Pos)                  /*!< UART_T::INTEN: RDAIEN Mask             */
S
S#define UART_INTEN_THREIEN_Pos           (1)                                               /*!< UART_T::INTEN: THREIEN Position        */
S#define UART_INTEN_THREIEN_Msk           (0x1ul << UART_INTEN_THREIEN_Pos)                 /*!< UART_T::INTEN: THREIEN Mask            */
S
S#define UART_INTEN_RLSIEN_Pos            (2)                                               /*!< UART_T::INTEN: RLSIEN Position         */
S#define UART_INTEN_RLSIEN_Msk            (0x1ul << UART_INTEN_RLSIEN_Pos)                  /*!< UART_T::INTEN: RLSIEN Mask             */
S
S#define UART_INTEN_MODEMIEN_Pos          (3)                                               /*!< UART_T::INTEN: MODEMIEN Position       */
S#define UART_INTEN_MODEMIEN_Msk          (0x1ul << UART_INTEN_MODEMIEN_Pos)                /*!< UART_T::INTEN: MODEMIEN Mask           */
S
S#define UART_INTEN_RXTOIEN_Pos           (4)                                               /*!< UART_T::INTEN: RXTOIEN Position        */
S#define UART_INTEN_RXTOIEN_Msk           (0x1ul << UART_INTEN_RXTOIEN_Pos)                 /*!< UART_T::INTEN: RXTOIEN Mask            */
S
S#define UART_INTEN_BUFERRIEN_Pos         (5)                                               /*!< UART_T::INTEN: BUFERRIEN Position      */
S#define UART_INTEN_BUFERRIEN_Msk         (0x1ul << UART_INTEN_BUFERRIEN_Pos)               /*!< UART_T::INTEN: BUFERRIEN Mask          */
S
S#define UART_INTEN_WKIEN_Pos             (6)                                               /*!< UART_T::INTEN: WKIEN Position          */
S#define UART_INTEN_WKIEN_Msk             (0x1ul << UART_INTEN_WKIEN_Pos)                   /*!< UART_T::INTEN: WKIEN Mask              */
S
S#define UART_INTEN_LINIEN_Pos            (8)                                               /*!< UART_T::INTEN: LINIEN Position         */
S#define UART_INTEN_LINIEN_Msk            (0x1ul << UART_INTEN_LINIEN_Pos)                  /*!< UART_T::INTEN: LINIEN Mask             */
S
S#define UART_INTEN_TOCNTEN_Pos           (11)                                              /*!< UART_T::INTEN: TOCNTEN Position        */
S#define UART_INTEN_TOCNTEN_Msk           (0x1ul << UART_INTEN_TOCNTEN_Pos)                 /*!< UART_T::INTEN: TOCNTEN Mask            */
S
S#define UART_INTEN_ATORTSEN_Pos          (12)                                              /*!< UART_T::INTEN: ATORTSEN Position       */
S#define UART_INTEN_ATORTSEN_Msk          (0x1ul << UART_INTEN_ATORTSEN_Pos)                /*!< UART_T::INTEN: ATORTSEN Mask           */
S
S#define UART_INTEN_ATOCTSEN_Pos          (13)                                              /*!< UART_T::INTEN: ATOCTSEN Position       */
S#define UART_INTEN_ATOCTSEN_Msk          (0x1ul << UART_INTEN_ATOCTSEN_Pos)                /*!< UART_T::INTEN: ATOCTSEN Mask           */
S
S#define UART_INTEN_TXPDMAEN_Pos          (14)                                              /*!< UART_T::INTEN: TXPDMAEN Position       */
S#define UART_INTEN_TXPDMAEN_Msk          (0x1ul << UART_INTEN_TXPDMAEN_Pos)                /*!< UART_T::INTEN: TXPDMAEN Mask           */
S
S#define UART_INTEN_RXPDMAEN_Pos          (15)                                              /*!< UART_T::INTEN: RXPDMAEN Position       */
S#define UART_INTEN_RXPDMAEN_Msk          (0x1ul << UART_INTEN_RXPDMAEN_Pos)                /*!< UART_T::INTEN: RXPDMAEN Mask           */
S
S#define UART_INTEN_ABRIEN_Pos            (18)                                              /*!< UART_T::INTEN: ABRIEN Position         */
S#define UART_INTEN_ABRIEN_Msk            (0x1ul << UART_INTEN_ABRIEN_Pos)                  /*!< UART_T::INTEN: ABRIEN Mask             */
S
S#define UART_INTEN_TXENDIEN_Pos          (22)                                              /*!< UART_T::INTEN: TXENDIEN Position       */
S#define UART_INTEN_TXENDIEN_Msk          (0x1ul << UART_INTEN_TXENDIEN_Pos)                /*!< UART_T::INTEN: TXENDIEN Mask           */
S
S#define UART_FIFO_RXRST_Pos              (1)                                               /*!< UART_T::FIFO: RXRST Position           */
S#define UART_FIFO_RXRST_Msk              (0x1ul << UART_FIFO_RXRST_Pos)                    /*!< UART_T::FIFO: RXRST Mask               */
S
S#define UART_FIFO_TXRST_Pos              (2)                                               /*!< UART_T::FIFO: TXRST Position           */
S#define UART_FIFO_TXRST_Msk              (0x1ul << UART_FIFO_TXRST_Pos)                    /*!< UART_T::FIFO: TXRST Mask               */
S
S#define UART_FIFO_RFITL_Pos              (4)                                               /*!< UART_T::FIFO: RFITL Position           */
S#define UART_FIFO_RFITL_Msk              (0xful << UART_FIFO_RFITL_Pos)                    /*!< UART_T::FIFO: RFITL Mask               */
S
S#define UART_FIFO_RXOFF_Pos              (8)                                               /*!< UART_T::FIFO: RXOFF Position           */
S#define UART_FIFO_RXOFF_Msk              (0x1ul << UART_FIFO_RXOFF_Pos)                    /*!< UART_T::FIFO: RXOFF Mask               */
S
S#define UART_FIFO_RTSTRGLV_Pos           (16)                                              /*!< UART_T::FIFO: RTSTRGLV Position        */
S#define UART_FIFO_RTSTRGLV_Msk           (0xful << UART_FIFO_RTSTRGLV_Pos)                 /*!< UART_T::FIFO: RTSTRGLV Mask            */
S
S#define UART_LINE_WLS_Pos                (0)                                               /*!< UART_T::LINE: WLS Position             */
S#define UART_LINE_WLS_Msk                (0x3ul << UART_LINE_WLS_Pos)                      /*!< UART_T::LINE: WLS Mask                 */
S
S#define UART_LINE_NSB_Pos                (2)                                               /*!< UART_T::LINE: NSB Position             */
S#define UART_LINE_NSB_Msk                (0x1ul << UART_LINE_NSB_Pos)                      /*!< UART_T::LINE: NSB Mask                 */
S
S#define UART_LINE_PBE_Pos                (3)                                               /*!< UART_T::LINE: PBE Position             */
S#define UART_LINE_PBE_Msk                (0x1ul << UART_LINE_PBE_Pos)                      /*!< UART_T::LINE: PBE Mask                 */
S
S#define UART_LINE_EPE_Pos                (4)                                               /*!< UART_T::LINE: EPE Position             */
S#define UART_LINE_EPE_Msk                (0x1ul << UART_LINE_EPE_Pos)                      /*!< UART_T::LINE: EPE Mask                 */
S
S#define UART_LINE_SPE_Pos                (5)                                               /*!< UART_T::LINE: SPE Position             */
S#define UART_LINE_SPE_Msk                (0x1ul << UART_LINE_SPE_Pos)                      /*!< UART_T::LINE: SPE Mask                 */
S
S#define UART_LINE_BCB_Pos                (6)                                               /*!< UART_T::LINE: BCB Position             */
S#define UART_LINE_BCB_Msk                (0x1ul << UART_LINE_BCB_Pos)                      /*!< UART_T::LINE: BCB Mask                 */
S
S#define UART_LINE_PSS_Pos                (7)                                               /*!< UART_T::LINE: PSS Position             */
S#define UART_LINE_PSS_Msk                (0x1ul << UART_LINE_PSS_Pos)                      /*!< UART_T::LINE: PSS Mask                 */
S
S#define UART_LINE_TXDINV_Pos             (8)                                               /*!< UART_T::LINE: TXDINV Position          */
S#define UART_LINE_TXDINV_Msk             (0x1ul << UART_LINE_TXDINV_Pos)                   /*!< UART_T::LINE: TXDINV Mask              */
S
S#define UART_LINE_RXDINV_Pos             (9)                                               /*!< UART_T::LINE: RXDINV Position          */
S#define UART_LINE_RXDINV_Msk             (0x1ul << UART_LINE_RXDINV_Pos)                   /*!< UART_T::LINE: RXDINV Mask              */
S
S#define UART_MODEM_RTS_Pos               (1)                                               /*!< UART_T::MODEM: RTS Position            */
S#define UART_MODEM_RTS_Msk               (0x1ul << UART_MODEM_RTS_Pos)                     /*!< UART_T::MODEM: RTS Mask                */
S
S#define UART_MODEM_RTSACTLV_Pos          (9)                                               /*!< UART_T::MODEM: RTSACTLV Position       */
S#define UART_MODEM_RTSACTLV_Msk          (0x1ul << UART_MODEM_RTSACTLV_Pos)                /*!< UART_T::MODEM: RTSACTLV Mask           */
S
S#define UART_MODEM_RTSSTS_Pos            (13)                                              /*!< UART_T::MODEM: RTSSTS Position         */
S#define UART_MODEM_RTSSTS_Msk            (0x1ul << UART_MODEM_RTSSTS_Pos)                  /*!< UART_T::MODEM: RTSSTS Mask             */
S
S#define UART_MODEMSTS_CTSDETF_Pos        (0)                                               /*!< UART_T::MODEMSTS: CTSDETF Position     */
S#define UART_MODEMSTS_CTSDETF_Msk        (0x1ul << UART_MODEMSTS_CTSDETF_Pos)              /*!< UART_T::MODEMSTS: CTSDETF Mask         */
S
S#define UART_MODEMSTS_CTSSTS_Pos         (4)                                               /*!< UART_T::MODEMSTS: CTSSTS Position      */
S#define UART_MODEMSTS_CTSSTS_Msk         (0x1ul << UART_MODEMSTS_CTSSTS_Pos)               /*!< UART_T::MODEMSTS: CTSSTS Mask          */
S
S#define UART_MODEMSTS_CTSACTLV_Pos       (8)                                               /*!< UART_T::MODEMSTS: CTSACTLV Position    */
S#define UART_MODEMSTS_CTSACTLV_Msk       (0x1ul << UART_MODEMSTS_CTSACTLV_Pos)             /*!< UART_T::MODEMSTS: CTSACTLV Mask        */
S
S#define UART_FIFOSTS_RXOVIF_Pos          (0)                                               /*!< UART_T::FIFOSTS: RXOVIF Position       */
S#define UART_FIFOSTS_RXOVIF_Msk          (0x1ul << UART_FIFOSTS_RXOVIF_Pos)                /*!< UART_T::FIFOSTS: RXOVIF Mask           */
S
S#define UART_FIFOSTS_ABRDIF_Pos          (1)                                               /*!< UART_T::FIFOSTS: ABRDIF Position       */
S#define UART_FIFOSTS_ABRDIF_Msk          (0x1ul << UART_FIFOSTS_ABRDIF_Pos)                /*!< UART_T::FIFOSTS: ABRDIF Mask           */
S
S#define UART_FIFOSTS_ABRDTOIF_Pos        (2)                                               /*!< UART_T::FIFOSTS: ABRDTOIF Position     */
S#define UART_FIFOSTS_ABRDTOIF_Msk        (0x1ul << UART_FIFOSTS_ABRDTOIF_Pos)              /*!< UART_T::FIFOSTS: ABRDTOIF Mask         */
S
S#define UART_FIFOSTS_ADDRDETF_Pos        (3)                                               /*!< UART_T::FIFOSTS: ADDRDETF Position     */
S#define UART_FIFOSTS_ADDRDETF_Msk        (0x1ul << UART_FIFOSTS_ADDRDETF_Pos)              /*!< UART_T::FIFOSTS: ADDRDETF Mask         */
S
S#define UART_FIFOSTS_PEF_Pos             (4)                                               /*!< UART_T::FIFOSTS: PEF Position          */
S#define UART_FIFOSTS_PEF_Msk             (0x1ul << UART_FIFOSTS_PEF_Pos)                   /*!< UART_T::FIFOSTS: PEF Mask              */
S
S#define UART_FIFOSTS_FEF_Pos             (5)                                               /*!< UART_T::FIFOSTS: FEF Position          */
S#define UART_FIFOSTS_FEF_Msk             (0x1ul << UART_FIFOSTS_FEF_Pos)                   /*!< UART_T::FIFOSTS: FEF Mask              */
S
S#define UART_FIFOSTS_BIF_Pos             (6)                                               /*!< UART_T::FIFOSTS: BIF Position          */
S#define UART_FIFOSTS_BIF_Msk             (0x1ul << UART_FIFOSTS_BIF_Pos)                   /*!< UART_T::FIFOSTS: BIF Mask              */
S
S#define UART_FIFOSTS_RXPTR_Pos           (8)                                               /*!< UART_T::FIFOSTS: RXPTR Position        */
S#define UART_FIFOSTS_RXPTR_Msk           (0x3ful << UART_FIFOSTS_RXPTR_Pos)                /*!< UART_T::FIFOSTS: RXPTR Mask            */
S
S#define UART_FIFOSTS_RXEMPTY_Pos         (14)                                              /*!< UART_T::FIFOSTS: RXEMPTY Position      */
S#define UART_FIFOSTS_RXEMPTY_Msk         (0x1ul << UART_FIFOSTS_RXEMPTY_Pos)               /*!< UART_T::FIFOSTS: RXEMPTY Mask          */
S
S#define UART_FIFOSTS_RXFULL_Pos          (15)                                              /*!< UART_T::FIFOSTS: RXFULL Position       */
S#define UART_FIFOSTS_RXFULL_Msk          (0x1ul << UART_FIFOSTS_RXFULL_Pos)                /*!< UART_T::FIFOSTS: RXFULL Mask           */
S
S#define UART_FIFOSTS_TXPTR_Pos           (16)                                              /*!< UART_T::FIFOSTS: TXPTR Position        */
S#define UART_FIFOSTS_TXPTR_Msk           (0x3ful << UART_FIFOSTS_TXPTR_Pos)                /*!< UART_T::FIFOSTS: TXPTR Mask            */
S
S#define UART_FIFOSTS_TXEMPTY_Pos         (22)                                              /*!< UART_T::FIFOSTS: TXEMPTY Position      */
S#define UART_FIFOSTS_TXEMPTY_Msk         (0x1ul << UART_FIFOSTS_TXEMPTY_Pos)               /*!< UART_T::FIFOSTS: TXEMPTY Mask          */
S
S#define UART_FIFOSTS_TXFULL_Pos          (23)                                              /*!< UART_T::FIFOSTS: TXFULL Position       */
S#define UART_FIFOSTS_TXFULL_Msk          (0x1ul << UART_FIFOSTS_TXFULL_Pos)                /*!< UART_T::FIFOSTS: TXFULL Mask           */
S
S#define UART_FIFOSTS_TXOVIF_Pos          (24)                                              /*!< UART_T::FIFOSTS: TXOVIF Position       */
S#define UART_FIFOSTS_TXOVIF_Msk          (0x1ul << UART_FIFOSTS_TXOVIF_Pos)                /*!< UART_T::FIFOSTS: TXOVIF Mask           */
S
S#define UART_FIFOSTS_TXEMPTYF_Pos        (28)                                              /*!< UART_T::FIFOSTS: TXEMPTYF Position     */
S#define UART_FIFOSTS_TXEMPTYF_Msk        (0x1ul << UART_FIFOSTS_TXEMPTYF_Pos)              /*!< UART_T::FIFOSTS: TXEMPTYF Mask         */
S
S#define UART_FIFOSTS_RXIDLE_Pos          (29)                                              /*!< UART_T::FIFOSTS: RXIDLE Position       */
S#define UART_FIFOSTS_RXIDLE_Msk          (0x1ul << UART_FIFOSTS_RXIDLE_Pos)                /*!< UART_T::FIFOSTS: RXIDLE Mask           */
S
S#define UART_FIFOSTS_TXRXACT_Pos         (31)                                              /*!< UART_T::FIFOSTS: TXRXACT Position      */
S#define UART_FIFOSTS_TXRXACT_Msk         (0x1ul << UART_FIFOSTS_TXRXACT_Pos)               /*!< UART_T::FIFOSTS: TXRXACT Mask          */
S
S#define UART_INTSTS_RDAIF_Pos            (0)                                               /*!< UART_T::INTSTS: RDAIF Position         */
S#define UART_INTSTS_RDAIF_Msk            (0x1ul << UART_INTSTS_RDAIF_Pos)                  /*!< UART_T::INTSTS: RDAIF Mask             */
S
S#define UART_INTSTS_THREIF_Pos           (1)                                               /*!< UART_T::INTSTS: THREIF Position        */
S#define UART_INTSTS_THREIF_Msk           (0x1ul << UART_INTSTS_THREIF_Pos)                 /*!< UART_T::INTSTS: THREIF Mask            */
S
S#define UART_INTSTS_RLSIF_Pos            (2)                                               /*!< UART_T::INTSTS: RLSIF Position         */
S#define UART_INTSTS_RLSIF_Msk            (0x1ul << UART_INTSTS_RLSIF_Pos)                  /*!< UART_T::INTSTS: RLSIF Mask             */
S
S#define UART_INTSTS_MODEMIF_Pos          (3)                                               /*!< UART_T::INTSTS: MODEMIF Position       */
S#define UART_INTSTS_MODEMIF_Msk          (0x1ul << UART_INTSTS_MODEMIF_Pos)                /*!< UART_T::INTSTS: MODEMIF Mask           */
S
S#define UART_INTSTS_RXTOIF_Pos           (4)                                               /*!< UART_T::INTSTS: RXTOIF Position        */
S#define UART_INTSTS_RXTOIF_Msk           (0x1ul << UART_INTSTS_RXTOIF_Pos)                 /*!< UART_T::INTSTS: RXTOIF Mask            */
S
S#define UART_INTSTS_BUFERRIF_Pos         (5)                                               /*!< UART_T::INTSTS: BUFERRIF Position      */
S#define UART_INTSTS_BUFERRIF_Msk         (0x1ul << UART_INTSTS_BUFERRIF_Pos)               /*!< UART_T::INTSTS: BUFERRIF Mask          */
S
S#define UART_INTSTS_WKIF_Pos             (6)                                               /*!< UART_T::INTSTS: WKIF Position          */
S#define UART_INTSTS_WKIF_Msk             (0x1ul << UART_INTSTS_WKIF_Pos)                   /*!< UART_T::INTSTS: WKIF Mask              */
S
S#define UART_INTSTS_LINIF_Pos            (7)                                               /*!< UART_T::INTSTS: LINIF Position         */
S#define UART_INTSTS_LINIF_Msk            (0x1ul << UART_INTSTS_LINIF_Pos)                  /*!< UART_T::INTSTS: LINIF Mask             */
S
S#define UART_INTSTS_RDAINT_Pos           (8)                                               /*!< UART_T::INTSTS: RDAINT Position        */
S#define UART_INTSTS_RDAINT_Msk           (0x1ul << UART_INTSTS_RDAINT_Pos)                 /*!< UART_T::INTSTS: RDAINT Mask            */
S
S#define UART_INTSTS_THREINT_Pos          (9)                                               /*!< UART_T::INTSTS: THREINT Position       */
S#define UART_INTSTS_THREINT_Msk          (0x1ul << UART_INTSTS_THREINT_Pos)                /*!< UART_T::INTSTS: THREINT Mask           */
S
S#define UART_INTSTS_RLSINT_Pos           (10)                                              /*!< UART_T::INTSTS: RLSINT Position        */
S#define UART_INTSTS_RLSINT_Msk           (0x1ul << UART_INTSTS_RLSINT_Pos)                 /*!< UART_T::INTSTS: RLSINT Mask            */
S
S#define UART_INTSTS_MODEMINT_Pos         (11)                                              /*!< UART_T::INTSTS: MODEMINT Position      */
S#define UART_INTSTS_MODEMINT_Msk         (0x1ul << UART_INTSTS_MODEMINT_Pos)               /*!< UART_T::INTSTS: MODEMINT Mask          */
S
S#define UART_INTSTS_RXTOINT_Pos          (12)                                              /*!< UART_T::INTSTS: RXTOINT Position       */
S#define UART_INTSTS_RXTOINT_Msk          (0x1ul << UART_INTSTS_RXTOINT_Pos)                /*!< UART_T::INTSTS: RXTOINT Mask           */
S
S#define UART_INTSTS_BUFERRINT_Pos        (13)                                              /*!< UART_T::INTSTS: BUFERRINT Position     */
S#define UART_INTSTS_BUFERRINT_Msk        (0x1ul << UART_INTSTS_BUFERRINT_Pos)              /*!< UART_T::INTSTS: BUFERRINT Mask         */
S
S#define UART_INTSTS_WKINT_Pos            (14)                                              /*!< UART_T::INTSTS: WKINT Position         */
S#define UART_INTSTS_WKINT_Msk            (0x1ul << UART_INTSTS_WKINT_Pos)                  /*!< UART_T::INTSTS: WKINT Mask             */
S
S#define UART_INTSTS_LININT_Pos           (15)                                              /*!< UART_T::INTSTS: LININT Position        */
S#define UART_INTSTS_LININT_Msk           (0x1ul << UART_INTSTS_LININT_Pos)                 /*!< UART_T::INTSTS: LININT Mask            */
S
S#define UART_INTSTS_HWRLSIF_Pos          (18)                                              /*!< UART_T::INTSTS: HWRLSIF Position       */
S#define UART_INTSTS_HWRLSIF_Msk          (0x1ul << UART_INTSTS_HWRLSIF_Pos)                /*!< UART_T::INTSTS: HWRLSIF Mask           */
S
S#define UART_INTSTS_HWMODIF_Pos          (19)                                              /*!< UART_T::INTSTS: HWMODIF Position       */
S#define UART_INTSTS_HWMODIF_Msk          (0x1ul << UART_INTSTS_HWMODIF_Pos)                /*!< UART_T::INTSTS: HWMODIF Mask           */
S
S#define UART_INTSTS_HWTOIF_Pos           (20)                                              /*!< UART_T::INTSTS: HWTOIF Position        */
S#define UART_INTSTS_HWTOIF_Msk           (0x1ul << UART_INTSTS_HWTOIF_Pos)                 /*!< UART_T::INTSTS: HWTOIF Mask            */
S
S#define UART_INTSTS_HWBUFEIF_Pos         (21)                                              /*!< UART_T::INTSTS: HWBUFEIF Position      */
S#define UART_INTSTS_HWBUFEIF_Msk         (0x1ul << UART_INTSTS_HWBUFEIF_Pos)               /*!< UART_T::INTSTS: HWBUFEIF Mask          */
S
S#define UART_INTSTS_TXENDIF_Pos          (22)                                              /*!< UART_T::INTSTS: TXENDIF Position       */
S#define UART_INTSTS_TXENDIF_Msk          (0x1ul << UART_INTSTS_TXENDIF_Pos)                /*!< UART_T::INTSTS: TXENDIF Mask           */
S
S#define UART_INTSTS_HWRLSINT_Pos         (26)                                              /*!< UART_T::INTSTS: HWRLSINT Position      */
S#define UART_INTSTS_HWRLSINT_Msk         (0x1ul << UART_INTSTS_HWRLSINT_Pos)               /*!< UART_T::INTSTS: HWRLSINT Mask          */
S
S#define UART_INTSTS_HWMODINT_Pos         (27)                                              /*!< UART_T::INTSTS: HWMODINT Position      */
S#define UART_INTSTS_HWMODINT_Msk         (0x1ul << UART_INTSTS_HWMODINT_Pos)               /*!< UART_T::INTSTS: HWMODINT Mask          */
S
S#define UART_INTSTS_HWTOINT_Pos          (28)                                              /*!< UART_T::INTSTS: HWTOINT Position       */
S#define UART_INTSTS_HWTOINT_Msk          (0x1ul << UART_INTSTS_HWTOINT_Pos)                /*!< UART_T::INTSTS: HWTOINT Mask           */
S
S#define UART_INTSTS_HWBUFEINT_Pos        (29)                                              /*!< UART_T::INTSTS: HWBUFEINT Position     */
S#define UART_INTSTS_HWBUFEINT_Msk        (0x1ul << UART_INTSTS_HWBUFEINT_Pos)              /*!< UART_T::INTSTS: HWBUFEINT Mask         */
S
S#define UART_INTSTS_TXENDINT_Pos         (30)                                              /*!< UART_T::INTSTS: TXENDINT Position      */
S#define UART_INTSTS_TXENDINT_Msk         (0x1ul << UART_INTSTS_TXENDINT_Pos)               /*!< UART_T::INTSTS: TXENDINT Mask          */
S
S#define UART_INTSTS_ABRINT_Pos           (31)                                              /*!< UART_T::INTSTS: ABRINT Position        */
S#define UART_INTSTS_ABRINT_Msk           (0x1ul << UART_INTSTS_ABRINT_Pos)                 /*!< UART_T::INTSTS: ABRINT Mask            */
S
S#define UART_TOUT_TOIC_Pos               (0)                                               /*!< UART_T::TOUT: TOIC Position            */
S#define UART_TOUT_TOIC_Msk               (0xfful << UART_TOUT_TOIC_Pos)                    /*!< UART_T::TOUT: TOIC Mask                */
S
S#define UART_TOUT_DLY_Pos                (8)                                               /*!< UART_T::TOUT: DLY Position             */
S#define UART_TOUT_DLY_Msk                (0xfful << UART_TOUT_DLY_Pos)                     /*!< UART_T::TOUT: DLY Mask                 */
S
S#define UART_BAUD_BRD_Pos                (0)                                               /*!< UART_T::BAUD: BRD Position             */
S#define UART_BAUD_BRD_Msk                (0xfffful << UART_BAUD_BRD_Pos)                   /*!< UART_T::BAUD: BRD Mask                 */
S
S#define UART_BAUD_EDIVM1_Pos             (24)                                              /*!< UART_T::BAUD: EDIVM1 Position          */
S#define UART_BAUD_EDIVM1_Msk             (0xful << UART_BAUD_EDIVM1_Pos)                   /*!< UART_T::BAUD: EDIVM1 Mask              */
S
S#define UART_BAUD_BAUDM0_Pos             (28)                                              /*!< UART_T::BAUD: BAUDM0 Position          */
S#define UART_BAUD_BAUDM0_Msk             (0x1ul << UART_BAUD_BAUDM0_Pos)                   /*!< UART_T::BAUD: BAUDM0 Mask              */
S
S#define UART_BAUD_BAUDM1_Pos             (29)                                              /*!< UART_T::BAUD: BAUDM1 Position          */
S#define UART_BAUD_BAUDM1_Msk             (0x1ul << UART_BAUD_BAUDM1_Pos)                   /*!< UART_T::BAUD: BAUDM1 Mask              */
S
S#define UART_IRDA_TXEN_Pos               (1)                                               /*!< UART_T::IRDA: TXEN Position            */
S#define UART_IRDA_TXEN_Msk               (0x1ul << UART_IRDA_TXEN_Pos)                     /*!< UART_T::IRDA: TXEN Mask                */
S
S#define UART_IRDA_TXINV_Pos              (5)                                               /*!< UART_T::IRDA: TXINV Position           */
S#define UART_IRDA_TXINV_Msk              (0x1ul << UART_IRDA_TXINV_Pos)                    /*!< UART_T::IRDA: TXINV Mask               */
S
S#define UART_IRDA_RXINV_Pos              (6)                                               /*!< UART_T::IRDA: RXINV Position           */
S#define UART_IRDA_RXINV_Msk              (0x1ul << UART_IRDA_RXINV_Pos)                    /*!< UART_T::IRDA: RXINV Mask               */
S
S#define UART_ALTCTL_BRKFL_Pos            (0)                                               /*!< UART_T::ALTCTL: BRKFL Position         */
S#define UART_ALTCTL_BRKFL_Msk            (0xful << UART_ALTCTL_BRKFL_Pos)                  /*!< UART_T::ALTCTL: BRKFL Mask             */
S
S#define UART_ALTCTL_LINRXEN_Pos          (6)                                               /*!< UART_T::ALTCTL: LINRXEN Position       */
S#define UART_ALTCTL_LINRXEN_Msk          (0x1ul << UART_ALTCTL_LINRXEN_Pos)                /*!< UART_T::ALTCTL: LINRXEN Mask           */
S
S#define UART_ALTCTL_LINTXEN_Pos          (7)                                               /*!< UART_T::ALTCTL: LINTXEN Position       */
S#define UART_ALTCTL_LINTXEN_Msk          (0x1ul << UART_ALTCTL_LINTXEN_Pos)                /*!< UART_T::ALTCTL: LINTXEN Mask           */
S
S#define UART_ALTCTL_RS485NMM_Pos         (8)                                               /*!< UART_T::ALTCTL: RS485NMM Position      */
S#define UART_ALTCTL_RS485NMM_Msk         (0x1ul << UART_ALTCTL_RS485NMM_Pos)               /*!< UART_T::ALTCTL: RS485NMM Mask          */
S
S#define UART_ALTCTL_RS485AAD_Pos         (9)                                               /*!< UART_T::ALTCTL: RS485AAD Position      */
S#define UART_ALTCTL_RS485AAD_Msk         (0x1ul << UART_ALTCTL_RS485AAD_Pos)               /*!< UART_T::ALTCTL: RS485AAD Mask          */
S
S#define UART_ALTCTL_RS485AUD_Pos         (10)                                              /*!< UART_T::ALTCTL: RS485AUD Position      */
S#define UART_ALTCTL_RS485AUD_Msk         (0x1ul << UART_ALTCTL_RS485AUD_Pos)               /*!< UART_T::ALTCTL: RS485AUD Mask          */
S
S#define UART_ALTCTL_ADDRDEN_Pos          (15)                                              /*!< UART_T::ALTCTL: ADDRDEN Position       */
S#define UART_ALTCTL_ADDRDEN_Msk          (0x1ul << UART_ALTCTL_ADDRDEN_Pos)                /*!< UART_T::ALTCTL: ADDRDEN Mask           */
S
S#define UART_ALTCTL_ABRIF_Pos            (17)                                              /*!< UART_T::ALTCTL: ABRIF Position         */
S#define UART_ALTCTL_ABRIF_Msk            (0x1ul << UART_ALTCTL_ABRIF_Pos)                  /*!< UART_T::ALTCTL: ABRIF Mask             */
S
S#define UART_ALTCTL_ABRDEN_Pos           (18)                                              /*!< UART_T::ALTCTL: ABRDEN Position        */
S#define UART_ALTCTL_ABRDEN_Msk           (0x1ul << UART_ALTCTL_ABRDEN_Pos)                 /*!< UART_T::ALTCTL: ABRDEN Mask            */
S
S#define UART_ALTCTL_ABRDBITS_Pos         (19)                                              /*!< UART_T::ALTCTL: ABRDBITS Position      */
S#define UART_ALTCTL_ABRDBITS_Msk         (0x3ul << UART_ALTCTL_ABRDBITS_Pos)               /*!< UART_T::ALTCTL: ABRDBITS Mask          */
S
S#define UART_ALTCTL_ADDRMV_Pos           (24)                                              /*!< UART_T::ALTCTL: ADDRMV Position        */
S#define UART_ALTCTL_ADDRMV_Msk           (0xfful << UART_ALTCTL_ADDRMV_Pos)                /*!< UART_T::ALTCTL: ADDRMV Mask            */
S
S#define UART_FUNCSEL_FUNCSEL_Pos         (0)                                               /*!< UART_T::FUNCSEL: FUNCSEL Position      */
S#define UART_FUNCSEL_FUNCSEL_Msk         (0x3ul << UART_FUNCSEL_FUNCSEL_Pos)               /*!< UART_T::FUNCSEL: FUNCSEL Mask          */
S
S#define UART_FUNCSEL_TXRXDIS_Pos         (3)                                               /*!< UART_T::FUNCSEL: TXRXDIS Position      */
S#define UART_FUNCSEL_TXRXDIS_Msk         (0x1ul << UART_FUNCSEL_TXRXDIS_Pos)               /*!< UART_T::FUNCSEL: TXRXDIS Mask          */
S
S#define UART_LINCTL_SLVEN_Pos            (0)                                               /*!< UART_T::LINCTL: SLVEN Position         */
S#define UART_LINCTL_SLVEN_Msk            (0x1ul << UART_LINCTL_SLVEN_Pos)                  /*!< UART_T::LINCTL: SLVEN Mask             */
S
S#define UART_LINCTL_SLVHDEN_Pos          (1)                                               /*!< UART_T::LINCTL: SLVHDEN Position       */
S#define UART_LINCTL_SLVHDEN_Msk          (0x1ul << UART_LINCTL_SLVHDEN_Pos)                /*!< UART_T::LINCTL: SLVHDEN Mask           */
S
S#define UART_LINCTL_SLVAREN_Pos          (2)                                               /*!< UART_T::LINCTL: SLVAREN Position       */
S#define UART_LINCTL_SLVAREN_Msk          (0x1ul << UART_LINCTL_SLVAREN_Pos)                /*!< UART_T::LINCTL: SLVAREN Mask           */
S
S#define UART_LINCTL_SLVDUEN_Pos          (3)                                               /*!< UART_T::LINCTL: SLVDUEN Position       */
S#define UART_LINCTL_SLVDUEN_Msk          (0x1ul << UART_LINCTL_SLVDUEN_Pos)                /*!< UART_T::LINCTL: SLVDUEN Mask           */
S
S#define UART_LINCTL_MUTE_Pos             (4)                                               /*!< UART_T::LINCTL: MUTE Position          */
S#define UART_LINCTL_MUTE_Msk             (0x1ul << UART_LINCTL_MUTE_Pos)                   /*!< UART_T::LINCTL: MUTE Mask              */
S
S#define UART_LINCTL_SENDH_Pos            (8)                                               /*!< UART_T::LINCTL: SENDH Position         */
S#define UART_LINCTL_SENDH_Msk            (0x1ul << UART_LINCTL_SENDH_Pos)                  /*!< UART_T::LINCTL: SENDH Mask             */
S
S#define UART_LINCTL_IDPEN_Pos            (9)                                               /*!< UART_T::LINCTL: IDPEN Position         */
S#define UART_LINCTL_IDPEN_Msk            (0x1ul << UART_LINCTL_IDPEN_Pos)                  /*!< UART_T::LINCTL: IDPEN Mask             */
S
S#define UART_LINCTL_BRKDETEN_Pos         (10)                                              /*!< UART_T::LINCTL: BRKDETEN Position      */
S#define UART_LINCTL_BRKDETEN_Msk         (0x1ul << UART_LINCTL_BRKDETEN_Pos)               /*!< UART_T::LINCTL: BRKDETEN Mask          */
S
S#define UART_LINCTL_LINRXOFF_Pos         (11)                                              /*!< UART_T::LINCTL: LINRXOFF Position      */
S#define UART_LINCTL_LINRXOFF_Msk         (0x1ul << UART_LINCTL_LINRXOFF_Pos)               /*!< UART_T::LINCTL: LINRXOFF Mask          */
S
S#define UART_LINCTL_BITERREN_Pos         (12)                                              /*!< UART_T::LINCTL: BITERREN Position      */
S#define UART_LINCTL_BITERREN_Msk         (0x1ul << UART_LINCTL_BITERREN_Pos)               /*!< UART_T::LINCTL: BITERREN Mask          */
S
S#define UART_LINCTL_BRKFL_Pos            (16)                                              /*!< UART_T::LINCTL: BRKFL Position         */
S#define UART_LINCTL_BRKFL_Msk            (0xful << UART_LINCTL_BRKFL_Pos)                  /*!< UART_T::LINCTL: BRKFL Mask             */
S
S#define UART_LINCTL_BSL_Pos              (20)                                              /*!< UART_T::LINCTL: BSL Position           */
S#define UART_LINCTL_BSL_Msk              (0x3ul << UART_LINCTL_BSL_Pos)                    /*!< UART_T::LINCTL: BSL Mask               */
S
S#define UART_LINCTL_HSEL_Pos             (22)                                              /*!< UART_T::LINCTL: HSEL Position          */
S#define UART_LINCTL_HSEL_Msk             (0x3ul << UART_LINCTL_HSEL_Pos)                   /*!< UART_T::LINCTL: HSEL Mask              */
S
S#define UART_LINCTL_PID_Pos              (24)                                              /*!< UART_T::LINCTL: PID Position           */
S#define UART_LINCTL_PID_Msk              (0xfful << UART_LINCTL_PID_Pos)                   /*!< UART_T::LINCTL: PID Mask               */
S
S#define UART_LINSTS_SLVHDETF_Pos         (0)                                               /*!< UART_T::LINSTS: SLVHDETF Position      */
S#define UART_LINSTS_SLVHDETF_Msk         (0x1ul << UART_LINSTS_SLVHDETF_Pos)               /*!< UART_T::LINSTS: SLVHDETF Mask          */
S
S#define UART_LINSTS_SLVHEF_Pos           (1)                                               /*!< UART_T::LINSTS: SLVHEF Position        */
S#define UART_LINSTS_SLVHEF_Msk           (0x1ul << UART_LINSTS_SLVHEF_Pos)                 /*!< UART_T::LINSTS: SLVHEF Mask            */
S
S#define UART_LINSTS_SLVIDPEF_Pos         (2)                                               /*!< UART_T::LINSTS: SLVIDPEF Position      */
S#define UART_LINSTS_SLVIDPEF_Msk         (0x1ul << UART_LINSTS_SLVIDPEF_Pos)               /*!< UART_T::LINSTS: SLVIDPEF Mask          */
S
S#define UART_LINSTS_SLVSYNCF_Pos         (3)                                               /*!< UART_T::LINSTS: SLVSYNCF Position      */
S#define UART_LINSTS_SLVSYNCF_Msk         (0x1ul << UART_LINSTS_SLVSYNCF_Pos)               /*!< UART_T::LINSTS: SLVSYNCF Mask          */
S
S#define UART_LINSTS_BRKDETF_Pos          (8)                                               /*!< UART_T::LINSTS: BRKDETF Position       */
S#define UART_LINSTS_BRKDETF_Msk          (0x1ul << UART_LINSTS_BRKDETF_Pos)                /*!< UART_T::LINSTS: BRKDETF Mask           */
S
S#define UART_LINSTS_BITEF_Pos            (9)                                               /*!< UART_T::LINSTS: BITEF Position         */
S#define UART_LINSTS_BITEF_Msk            (0x1ul << UART_LINSTS_BITEF_Pos)                  /*!< UART_T::LINSTS: BITEF Mask             */
S
S#define UART_BRCOMP_BRCOMP_Pos           (0)                                               /*!< UART_T::BRCOMP: BRCOMP Position        */
S#define UART_BRCOMP_BRCOMP_Msk           (0x1fful << UART_BRCOMP_BRCOMP_Pos)               /*!< UART_T::BRCOMP: BRCOMP Mask            */
S
S#define UART_BRCOMP_BRCOMPDEC_Pos        (31)                                              /*!< UART_T::BRCOMP: BRCOMPDEC Position     */
S#define UART_BRCOMP_BRCOMPDEC_Msk        (0x1ul << UART_BRCOMP_BRCOMPDEC_Pos)              /*!< UART_T::BRCOMP: BRCOMPDEC Mask         */
S
S#define UART_WKCTL_WKCTSEN_Pos           (0)                                               /*!< UART_T::WKCTL: WKCTSEN Position        */
S#define UART_WKCTL_WKCTSEN_Msk           (0x1ul << UART_WKCTL_WKCTSEN_Pos)                 /*!< UART_T::WKCTL: WKCTSEN Mask            */
S
S#define UART_WKCTL_WKDATEN_Pos           (1)                                               /*!< UART_T::WKCTL: WKDATEN Position        */
S#define UART_WKCTL_WKDATEN_Msk           (0x1ul << UART_WKCTL_WKDATEN_Pos)                 /*!< UART_T::WKCTL: WKDATEN Mask            */
S
S#define UART_WKCTL_WKRFRTEN_Pos          (2)                                               /*!< UART_T::WKCTL: WKRFRTEN Position       */
S#define UART_WKCTL_WKRFRTEN_Msk          (0x1ul << UART_WKCTL_WKRFRTEN_Pos)                /*!< UART_T::WKCTL: WKRFRTEN Mask           */
S
S#define UART_WKCTL_WKRS485EN_Pos         (3)                                               /*!< UART_T::WKCTL: WKRS485EN Position      */
S#define UART_WKCTL_WKRS485EN_Msk         (0x1ul << UART_WKCTL_WKRS485EN_Pos)               /*!< UART_T::WKCTL: WKRS485EN Mask          */
S
S#define UART_WKCTL_WKTOUTEN_Pos          (4)                                               /*!< UART_T::WKCTL: WKTOUTEN Position       */
S#define UART_WKCTL_WKTOUTEN_Msk          (0x1ul << UART_WKCTL_WKTOUTEN_Pos)                /*!< UART_T::WKCTL: WKTOUTEN Mask           */
S
S#define UART_WKSTS_CTSWKF_Pos            (0)                                               /*!< UART_T::WKSTS: CTSWKF Position         */
S#define UART_WKSTS_CTSWKF_Msk            (0x1ul << UART_WKSTS_CTSWKF_Pos)                  /*!< UART_T::WKSTS: CTSWKF Mask             */
S
S#define UART_WKSTS_DATWKF_Pos            (1)                                               /*!< UART_T::WKSTS: DATWKF Position         */
S#define UART_WKSTS_DATWKF_Msk            (0x1ul << UART_WKSTS_DATWKF_Pos)                  /*!< UART_T::WKSTS: DATWKF Mask             */
S
S#define UART_WKSTS_RFRTWKF_Pos           (2)                                               /*!< UART_T::WKSTS: RFRTWKF Position        */
S#define UART_WKSTS_RFRTWKF_Msk           (0x1ul << UART_WKSTS_RFRTWKF_Pos)                 /*!< UART_T::WKSTS: RFRTWKF Mask            */
S
S#define UART_WKSTS_RS485WKF_Pos          (3)                                               /*!< UART_T::WKSTS: RS485WKF Position       */
S#define UART_WKSTS_RS485WKF_Msk          (0x1ul << UART_WKSTS_RS485WKF_Pos)                /*!< UART_T::WKSTS: RS485WKF Mask           */
S
S#define UART_WKSTS_TOUTWKF_Pos           (4)                                               /*!< UART_T::WKSTS: TOUTWKF Position        */
S#define UART_WKSTS_TOUTWKF_Msk           (0x1ul << UART_WKSTS_TOUTWKF_Pos)                 /*!< UART_T::WKSTS: TOUTWKF Mask            */
S
S#define UART_DWKCOMP_STCOMP_Pos          (0)                                               /*!< UART_T::DWKCOMP: STCOMP Position       */
S#define UART_DWKCOMP_STCOMP_Msk          (0xfffful << UART_DWKCOMP_STCOMP_Pos)             /*!< UART_T::DWKCOMP: STCOMP Mask           */
S
S/**@}*/ /* UART_CONST */
S/**@}*/ /* end of UART register group */
S
S
S/*---------------------- I2C Mode of USCI Controller -------------------------*/
S/**
S    @addtogroup UI2C I2C Mode of USCI Controller(UI2C)
S    Memory Mapped Structure for UI2C Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var UI2C_T::CTL
S     * Offset: 0x00  USCI Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2:0]   |FUNMODE   |Function Mode
S     * |        |          |This bit field selects the protocol for this USCI controller.
S     * |        |          |Selecting a protocol that is not available or a reserved combination disables the USCI.
S     * |        |          |When switching between two protocols, the USCI has to be disabled before selecting a new protocol.
S     * |        |          |Simultaneously, the USCI will be reset when user write 000 to FUNMODE.
S     * |        |          |000 = The USCI is disabled. All protocol related state machines are set to idle state.
S     * |        |          |001 = The SPI protocol is selected.
S     * |        |          |010 = The UART protocol is selected.
S     * |        |          |100 = The I2C protocol is selected.
S     * |        |          |Note: Other bit combinations are reserved.
S     * @var UI2C_T::BRGEN
S     * Offset: 0x08  USCI Baud Rate Generator Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RCLKSEL   |Reference Clock Source Selection
S     * |        |          |This bit selects the source signal of reference clock (fREF_CLK).
S     * |        |          |0 = Peripheral device clock fPCLK.
S     * |        |          |1 = Reserved.
S     * |[1]     |PTCLKSEL  |Protocol Clock Source Selection
S     * |        |          |This bit selects the source signal of protocol clock (fPROT_CLK).
S     * |        |          |0 = Reference clock fREF_CLK.
S     * |        |          |1 = fREF_CLK2 (its frequency is half of fREF_CLK).
S     * |[3:2]   |SPCLKSEL  |Sample Clock Source Selection
S     * |        |          |This bit field used for the clock source selection of a sample clock (fSAMP_CLK) for the protocol processor.
S     * |        |          |00 = fSAMP_CLK = fDIV_CLK.
S     * |        |          |01 = fSAMP_CLK = fPROT_CLK.
S     * |        |          |10 = fSAMP_CLK = fSCLK.
S     * |        |          |11 = fSAMP_CLK = fREF_CLK.
S     * |[4]     |TMCNTEN   |Time Measurement Counter Enable Bit
S     * |        |          |This bit enables the 10-bit timing measurement counter.
S     * |        |          |0 = Time measurement counter is Disabled.
S     * |        |          |1 = Time measurement counter is Enabled.
S     * |[5]     |TMCNTSRC  |Time Measurement Counter Clock Source Selection
S     * |        |          |0 = Time measurement counter with fPROT_CLK.
S     * |        |          |1 = Time measurement counter with fDIV_CLK.
S     * |[9:8]   |PDSCNT    |Pre-divider for Sample Counter
S     * |        |          |This bit field defines the divide ratio of the clock division from sample clock fSAMP_CLK.
S     * |        |          |The divided frequency fPDS_CNT = fSAMP_CLK / (PDSCNT+1).
S     * |[14:10] |DSCNT     |Denominator for Sample Counter
S     * |        |          |This bit field defines the divide ratio of the sample clock fSAMP_CLK.
S     * |        |          |The divided frequency fDS_CNT = fPDS_CNT / (DSCNT+1).
S     * |        |          |Note: The maximum value of DSCNT is 0xF on UART mode and suggest to set over 4 to confirm the receiver data is sampled in right value.
S     * |[25:16] |CLKDIV    |Clock Divider
S     * |        |          |This bit field defines the ratio between the protocol clock frequency fPROT_CLK and the clock divider frequency fDIV_CLK (fDIV_CLK = fPROT_CLK / (CLKDIV+1) ).
S     * |        |          |Note: In UART function, it can be updated by hardware in the 4th falling edge of the input data 0x55 when the auto baud rate function (ABREN(UI2C_PROTCTL[6])) is enabled
S     * |        |          |The revised value is the average bit time between bit 5 and bit 6
S     * |        |          |The user can use revised CLKDIV and new BRDETITV (UI2C_PROTCTL[24:16]) to calculate the precise baud rate.
S     * @var UI2C_T::LINECTL
S     * Offset: 0x2C  USCI Line Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |LSB       |LSB First Transmission Selection
S     * |        |          |0 = The MSB, which bit of transmit/receive data buffer depends on the setting of DWIDTH, is transmitted/received first.
S     * |        |          |1 = The LSB, the bit 0 of data buffer, will be transmitted/received first.
S     * |[11:8]  |DWIDTH    |Word Length of Transmission
S     * |        |          |This bit field defines the data word length (amount of bits) for reception and transmission
S     * |        |          |The data word is always right-aligned in the data buffer.
S     * |        |          |USCI support word length from 4 to 16 bits.
S     * |        |          |0x0: The data word contains 16 bits located at bit positions [15:0].
S     * |        |          |0x1: Reserved.
S     * |        |          |0x2: Reserved.
S     * |        |          |0x3: Reserved.
S     * |        |          |0x4: The data word contains 4 bits located at bit positions [3:0].
S     * |        |          |0x5: The data word contains 5 bits located at bit positions [4:0].
S     * |        |          |...
S     * |        |          |0xF: The data word contains 15 bits located at bit positions [14:0].
S     * |        |          |Note: In I2C protocol, the length must be configured as 8 bits.
S     * @var UI2C_T::TXDAT
S     * Offset: 0x30  USCI Transmit Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |TXDAT     |Transmit Data
S     * |        |          |Software can use this bit field to write 16-bit transmit data for transmission.
S     * @var UI2C_T::RXDAT
S     * Offset: 0x34  USCI Receive Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RXDAT     |Received Data
S     * |        |          |This bit field monitors the received data which stored in receive data buffer.
S     * |        |          |Note 1: In I2C protocol, only use RXDAT[7:0].
S     * @var UI2C_T::DEVADDR0
S     * Offset: 0x44  USCI Device Address Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[9:0]   |DEVADDR   |Device Address
S     * |        |          |In I2C protocol, this bit field contains the programmed slave address.
S     * |        |          |If the first received address byte are b1111 0AAX, the AA bits are compared to the bits DEVADDR[9:8] to check for address match, where the X is R/W bit.
S     * |        |          |Then the second address byte is also compared to DEVADDR[7:0].
S     * |        |          |Note: When I2C operating in 7-bit address mode, only use DEVADDR[6:0].
S     * @var UI2C_T::DEVADDR1
S     * Offset: 0x48  USCI Device Address Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[9:0]   |DEVADDR   |Device Address
S     * |        |          |In I2C protocol, this bit field contains the programmed slave address.
S     * |        |          |If the first received address byte are b1111 0AAX, the AA bits are compared to the bits DEVADDR[9:8] to check for address match, where the X is R/W bit.
S     * |        |          |Then the second address byte is also compared to DEVADDR[7:0].
S     * |        |          |Note: When I2C operating in 7-bit address mode, only use DEVADDR[6:0].
S     * @var UI2C_T::ADDRMSK0
S     * Offset: 0x4C  USCI Device Address Mask Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[9:0]   |ADDRMSK   |USCI Device Address Mask
S     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register).
S     * |        |          |1 = Mask Enabled (the received corresponding address bit is donu2019t care).
S     * |        |          |USCI support multiple address recognition with two address mask register.
S     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care
S     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
S     * @var UI2C_T::ADDRMSK1
S     * Offset: 0x50  USCI Device Address Mask Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[9:0]   |ADDRMSK   |USCI Device Address Mask
S     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register).
S     * |        |          |1 = Mask Enabled (the received corresponding address bit is donu2019t care).
S     * |        |          |USCI support multiple address recognition with two address mask register.
S     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care
S     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
S     * @var UI2C_T::WKCTL
S     * Offset: 0x54  USCI Wake-up Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WKEN      |Wake-up Enable Bit
S     * |        |          |0 = Wake-up function Disabled.
S     * |        |          |1 = Wake-up function Enabled.
S     * |[1]     |WKADDREN  |Wake-up Address Match Enable Bit
S     * |        |          |0 = The chip is woken up according data toggle.
S     * |        |          |1 = The chip is woken up according address match.
S     * @var UI2C_T::WKSTS
S     * Offset: 0x58  USCI Wake-up Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WKF       |Wake-up Flag
S     * |        |          |When chip is woken up from Power-down mode, this bit is set to 1.
S     * |        |          |Software can write 1 to clear this bit.
S     * @var UI2C_T::PROTCTL
S     * Offset: 0x5C  USCI Protocol Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GCFUNC    |General Call Function
S     * |        |          |0 = General Call Function Disabled.
S     * |        |          |1 = General Call Function Enabled.
S     * |[1]     |AA        |Assert Acknowledge Control
S     * |        |          |When AA=1 prior to address or data received, an acknowledged (low level to SDA) will be returned during the acknowledge clock pulse on the SCL line when 1.) A slave is acknowledging the address sent from master, 2.) The receiver devices are acknowledging the data sent by transmitter.
S     * |        |          |When AA=0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse on the SCL line.
S     * |[2]     |STO       |I2C STOP Control
S     * |        |          |In Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this bit will be cleared by hardware automatically.
S     * |        |          |In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode when bus error (UI2C_PROTSTS.ERRIF = 1).
S     * |[3]     |STA       |I2C START Control
S     * |        |          |Setting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.
S     * |[4]     |ADDR10EN  |Address 10-bit Function Enable Bit
S     * |        |          |0 = Address match 10 bit function is disabled.
S     * |        |          |1 = Address match 10 bit function is enabled.
S     * |[5]     |PTRG      |I2C Protocol Trigger
S     * |        |          |When a new state is present in the UI2C_PROTSTS register, if the related interrupt enable bits are set, the I2C interrupt is requested.
S     * |        |          |It must write one by software to this bit after the related interrupt flags are set to 1 and the I2C protocol function will go ahead until the STOP is active or the PROTEN is disabled.
S     * |        |          |0 = I2C's stretch disabled and the I2C protocol function will go ahead.
S     * |        |          |1 = I2C's stretch active.
S     * |[8]     |SCLOUTEN  |SCL Output Enable Bit
S     * |        |          |This bit enables monitor pulling SCL to low.
S     * |        |          |This monitor will pull SCL to low until it has had time to respond to an I2C interrupt.
S     * |        |          |0 = SCL output will be forced high due to open drain mechanism.
S     * |        |          |1 = I2C module may act as a slave peripheral just like in normal operation, the I2C holds the clock line low until it has had time to clear I2C interrupt.
S     * |[9]     |MONEN     |Monitor Mode Enable Bit
S     * |        |          |This bit enables monitor mode.
S     * |        |          |In monitor mode the SDA output will be put in high impedance mode.
S     * |        |          |This prevents the I2C module from outputting data of any kind (including ACK) onto the I2C data bus.
S     * |        |          |0 = The monitor mode is disabled.
S     * |        |          |1 = The monitor mode is enabled.
S     * |        |          |Note: Depending on the state of the SCLOUTEN bit, the SCL output may be also forced high, preventing the module from having control over the I2C clock line.
S     * |[25:16] |TOCNT     |Time-out Clock Cycle
S     * |        |          |This bit field indicates how many clock cycle selected by TMCNTSRC (UI2C_BRGEN [5]) when each interrupt flags are clear.
S     * |        |          |The time-out is enable when TOCNT bigger than 0.
S     * |        |          |Note: The TMCNTSRC (UI2C_BRGEN [5]) must be set zero on I2C mode.
S     * |[31]    |PROTEN    |I2C Protocol Enable Bit
S     * |        |          |0 = I2C Protocol disable.
S     * |        |          |1 = I2C Protocol enable.
S     * @var UI2C_T::PROTIEN
S     * Offset: 0x60  USCI Protocol Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TOIEN     |Time-out Interrupt Enable Control
S     * |        |          |In I2C protocol, this bit enables the interrupt generation in case of a time-out event.
S     * |        |          |0 = The time-out interrupt is disabled.
S     * |        |          |1 = The time-out interrupt is enabled.
S     * |[1]     |STARIEN   |Start Condition Received Interrupt Enable Control
S     * |        |          |This bit enables the generation of a protocol interrupt if a start condition is detected.
S     * |        |          |0 = The start condition interrupt is disabled.
S     * |        |          |1 = The start condition interrupt is enabled.
S     * |[2]     |STORIEN   |Stop Condition Received Interrupt Enable Control
S     * |        |          |This bit enables the generation of a protocol interrupt if a stop condition is detected.
S     * |        |          |0 = The stop condition interrupt is disabled.
S     * |        |          |1 = The stop condition interrupt is enabled.
S     * |[3]     |NACKIEN   |Non - Acknowledge Interrupt Enable Control
S     * |        |          |This bit enables the generation of a protocol interrupt if a non-acknowledge is detected by a master.
S     * |        |          |0 = The non-acknowledge interrupt is disabled.
S     * |        |          |1 = The non-acknowledge interrupt is enabled.
S     * |[4]     |ARBLOIEN  |Arbitration Lost Interrupt Enable Control
S     * |        |          |This bit enables the generation of a protocol interrupt if an arbitration lost event is detected.
S     * |        |          |0 = The arbitration lost interrupt is disabled.
S     * |        |          |1 = The arbitration lost interrupt is enabled.
S     * |[5]     |ERRIEN    |Error Interrupt Enable Control
S     * |        |          |This bit enables the generation of a protocol interrupt if an I2C error condition is detected (indicated by ERR (UI2C_PROTSTS [16])).
S     * |        |          |0 = The error interrupt is disabled.
S     * |        |          |1 = The error interrupt is enabled.
S     * |[6]     |ACKIEN    |Acknowledge Interrupt Enable Control
S     * |        |          |This bit enables the generation of a protocol interrupt if an acknowledge is detected by a master.
S     * |        |          |0 = The acknowledge interrupt is disabled.
S     * |        |          |1 = The acknowledge interrupt is enabled.
S     * @var UI2C_T::PROTSTS
S     * Offset: 0x64  USCI Protocol Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5]     |TOIF      |Time-out Interrupt Flag
S     * |        |          |0 = A time-out interrupt status has not occurred.
S     * |        |          |1 = A time-out interrupt status has occurred.
S     * |        |          |Note: It is cleared by software writing one into this bit.
S     * |[6]     |ONBUSY    |On Bus Busy
S     * |        |          |Indicates that a communication is in progress on the bus.
S     * |        |          |It is set by hardware when a START condition is detected.
S     * |        |          |It is cleared by hardware when a STOP condition is detected.
S     * |        |          |0 = The bus is IDLE (both SCLK and SDA High).
S     * |        |          |1 = The bus is busy.
S     * |[8]     |STARIF    |Start Condition Received Interrupt Flag
S     * |        |          |This bit indicates that a start condition or repeated start condition has been detected on master mode.
S     * |        |          |However, this bit also indicates that a repeated start condition has been detected on slave mode.
S     * |        |          |A protocol interrupt can be generated if UI2C_PROTCTL.STARIEN = 1.
S     * |        |          |0 = A start condition has not yet been detected.
S     * |        |          |1 = A start condition has been detected.
S     * |        |          |It is cleared by software writing one into this bit.
S     * |[9]     |STORIF    |Stop Condition Received Interrupt Flag
S     * |        |          |This bit indicates that a stop condition has been detected on the I2C bus lines.
S     * |        |          |A protocol interrupt can be generated if UI2C_PROTCTL.STORIEN = 1.
S     * |        |          |0 = A stop condition has not yet been detected.
S     * |        |          |1 = A stop condition has been detected.
S     * |        |          |It is cleared by software writing one into this bit.
S     * |[10]    |NACKIF    |Non - Acknowledge Received Interrupt Flag
S     * |        |          |This bit indicates that a non - acknowledge has been received in master mode.
S     * |        |          |This bit is not set in slave mode.
S     * |        |          |A protocol interrupt can be generated if UI2C_PROTCTL.NACKIEN = 1.
S     * |        |          |0 = A non - acknowledge has not been received.
S     * |        |          |1 = A non - acknowledge has been received.
S     * |        |          |It is cleared by software writing one into this bit.
S     * |[11]    |ARBLOIF   |Arbitration Lost Interrupt Flag
S     * |        |          |This bit indicates that an arbitration has been lost.
S     * |        |          |A protocol interrupt can be generated if UI2C_PROTCTL.ARBLOIEN = 1.
S     * |        |          |0 = An arbitration has not been lost.
S     * |        |          |1 = An arbitration has been lost.
S     * |        |          |It is cleared by software writing one into this bit.
S     * |[12]    |ERRIF     |Error Interrupt Flag
S     * |        |          |This bit indicates that a Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame.
S     * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.
S     * |        |          |A protocol interrupt can be generated if UI2C_PROTCTL.ERRIEN = 1.
S     * |        |          |0 = An I2C error has not been detected.
S     * |        |          |1 = An I2C error has been detected.
S     * |        |          |It is cleared by software writing one into this bit.
S     * |        |          |Note: This bit is set when slave mode, user must write one into STO register to the defined "not addressed" slave mode.
S     * |[13]    |ACKIF     |Acknowledge Received Interrupt Flag
S     * |        |          |This bit indicates that an acknowledge has been received in master mode.
S     * |        |          |This bit is not set in slave mode.
S     * |        |          |A protocol interrupt can be generated if UI2C_PROTCTL.ACKIEN = 1.
S     * |        |          |0 = An acknowledge has not been received.
S     * |        |          |1 = An acknowledge has been received.
S     * |        |          |It is cleared by software writing one into this bit.
S     * |[14]    |SLASEL    |Slave Select Status
S     * |        |          |This bit indicates that this device has been selected as slave.
S     * |        |          |0 = The device is not selected as slave.
S     * |        |          |1 = The device is selected as slave.
S     * |        |          |Note: This bit has no interrupt signal, and it will be cleared automatically by hardware.
S     * |[15]    |SLAREAD   |Slave Read Request Status
S     * |        |          |This bit indicates that a slave read request has been detected.
S     * |        |          |0 = A slave read request has not been detected.
S     * |        |          |1 = A slave read request has been detected.
S     * |        |          |Note: This bit has no interrupt signal, and it will be cleared automatically by hardware.
S     * |[16]    |WKAKDONE  |Wakeup Address Frame Acknowledge Bit Done
S     * |        |          |0 = The ACK bit cycle of address match frame isn't done.
S     * |        |          |1 = The ACK bit cycle of address match frame is done in power-down.
S     * |        |          |Note: This bit can't release when WKUPIF is set.
S     * |[17]    |WRSTSWK   |Read/Write Status Bit in Address Wakeup Frame
S     * |        |          |0 = Write command be record on the address match wakeup frame.
S     * |        |          |1 = Read command be record on the address match wakeup frame.
S     * |[18]    |BUSHANG   |Bus Hang-up
S     * |        |          |This bit indicates bus hang-up status.
S     * |        |          |There is 4-bit counter count when SCL hold high and refer fSAMP_CLK.
S     * |        |          |The hang-up counter will count to overflow and set this bit when SDA is low.
S     * |        |          |The counter will be reset by falling edge of SCL signal.
S     * |        |          |0 = The bus is normal status for transmission.
S     * |        |          |1 = The bus is hang-up status for transmission.
S     * |        |          |Note: This bit has no interrupt signal, and it will be cleared automatically by hardware.
S     * |[19]    |ERRARBLO  |Error Arbitration Lost
S     * |        |          |This bit indicates bus arbitration lost due to bigger noise which is can't be filtered by input processor.
S     * |        |          |The I2C can send start condition when ERRARBLO is set.
S     * |        |          |Thus this bit doesn't be cared on slave mode.
S     * |        |          |0 = The bus is normal status for transmission.
S     * |        |          |1 = The bus is error arbitration lost status for transmission.
S     * |        |          |Note: This bit has no interrupt signal, and it will be cleared automatically by hardware.
S     * @var UI2C_T::ADMAT
S     * Offset: 0x88  I2C Slave Match Address Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ADMAT0    |USCI Address 0 Match Status Register
S     * |        |          |When address 0 is matched, hardware will inform which address used.
S     * |        |          |This bit will set to 1, and software can write 1 to clear this bit.
S     * |[1]     |ADMAT1    |USCI Address 1 Match Status Register
S     * |        |          |When address 1 is matched, hardware will inform which address used.
S     * |        |          |This bit will set to 1, and software can write 1 to clear this bit.
S     * @var UI2C_T::TMCTL
S     * Offset: 0x8C  I2C Timing Configure Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |STCTL     |Setup Time Configure Control Register
S     * |        |          |This field is used to generate a delay timing between SDA edge and SCL rising edge in transmission mode.
S     * |        |          |The delay setup time is numbers of peripheral clock = STCTL x fPCLK.
S     * |[11:6]  |HTCTL     |Hold Time Configure Control Register
S     * |        |          |This field is used to generate the delay timing between SCL falling edge SDA edge in transmission mode.
S     * |        |          |The delay hold time is numbers of peripheral clock = HTCTL x fPCLK.
S     */
S    __IO uint32_t CTL;                   /*!< [0x0000] USCI Control Register                                            */
S    __I  uint32_t RESERVE0[1];
S    __IO uint32_t BRGEN;                 /*!< [0x0008] USCI Baud Rate Generator Register                                */
S    __I  uint32_t RESERVE1[8];
S    __IO uint32_t LINECTL;               /*!< [0x002c] USCI Line Control Register                                       */
S    __O  uint32_t TXDAT;                 /*!< [0x0030] USCI Transmit Data Register                                      */
S    __I  uint32_t RXDAT;                 /*!< [0x0034] USCI Receive Data Register                                       */
S    __I  uint32_t RESERVE2[3];
S    __IO uint32_t DEVADDR0;              /*!< [0x0044] USCI Device Address Register 0                                   */
S    __IO uint32_t DEVADDR1;              /*!< [0x0048] USCI Device Address Register 1                                   */
S    __IO uint32_t ADDRMSK0;              /*!< [0x004c] USCI Device Address Mask Register 0                              */
S    __IO uint32_t ADDRMSK1;              /*!< [0x0050] USCI Device Address Mask Register 1                              */
S    __IO uint32_t WKCTL;                 /*!< [0x0054] USCI Wake-up Control Register                                    */
S    __IO uint32_t WKSTS;                 /*!< [0x0058] USCI Wake-up Status Register                                     */
S    __IO uint32_t PROTCTL;               /*!< [0x005c] USCI Protocol Control Register                                   */
S    __IO uint32_t PROTIEN;               /*!< [0x0060] USCI Protocol Interrupt Enable Register                          */
S    __IO uint32_t PROTSTS;               /*!< [0x0064] USCI Protocol Status Register                                    */
S    __I  uint32_t RESERVE3[8];
S    __IO uint32_t ADMAT;                 /*!< [0x0088] I2C Slave Match Address Register                                 */
S    __IO uint32_t TMCTL;                 /*!< [0x008c] I2C Timing Configure Control Register                            */
S
S} UI2C_T;
S
S/**
S    @addtogroup UI2C_CONST UI2C Bit Field Definition
S    Constant Definitions for UI2C Controller
S@{ */
S
S#define UI2C_CTL_FUNMODE_Pos             (0)                                               /*!< UI2C_T::CTL: FUNMODE Position          */
S#define UI2C_CTL_FUNMODE_Msk             (0x7ul << UI2C_CTL_FUNMODE_Pos)                   /*!< UI2C_T::CTL: FUNMODE Mask              */
S
S#define UI2C_BRGEN_RCLKSEL_Pos           (0)                                               /*!< UI2C_T::BRGEN: RCLKSEL Position        */
S#define UI2C_BRGEN_RCLKSEL_Msk           (0x1ul << UI2C_BRGEN_RCLKSEL_Pos)                 /*!< UI2C_T::BRGEN: RCLKSEL Mask            */
S
S#define UI2C_BRGEN_PTCLKSEL_Pos          (1)                                               /*!< UI2C_T::BRGEN: PTCLKSEL Position       */
S#define UI2C_BRGEN_PTCLKSEL_Msk          (0x1ul << UI2C_BRGEN_PTCLKSEL_Pos)                /*!< UI2C_T::BRGEN: PTCLKSEL Mask           */
S
S#define UI2C_BRGEN_SPCLKSEL_Pos          (2)                                               /*!< UI2C_T::BRGEN: SPCLKSEL Position       */
S#define UI2C_BRGEN_SPCLKSEL_Msk          (0x3ul << UI2C_BRGEN_SPCLKSEL_Pos)                /*!< UI2C_T::BRGEN: SPCLKSEL Mask           */
S
S#define UI2C_BRGEN_TMCNTEN_Pos           (4)                                               /*!< UI2C_T::BRGEN: TMCNTEN Position        */
S#define UI2C_BRGEN_TMCNTEN_Msk           (0x1ul << UI2C_BRGEN_TMCNTEN_Pos)                 /*!< UI2C_T::BRGEN: TMCNTEN Mask            */
S
S#define UI2C_BRGEN_TMCNTSRC_Pos          (5)                                               /*!< UI2C_T::BRGEN: TMCNTSRC Position       */
S#define UI2C_BRGEN_TMCNTSRC_Msk          (0x1ul << UI2C_BRGEN_TMCNTSRC_Pos)                /*!< UI2C_T::BRGEN: TMCNTSRC Mask           */
S
S#define UI2C_BRGEN_PDSCNT_Pos            (8)                                               /*!< UI2C_T::BRGEN: PDSCNT Position         */
S#define UI2C_BRGEN_PDSCNT_Msk            (0x3ul << UI2C_BRGEN_PDSCNT_Pos)                  /*!< UI2C_T::BRGEN: PDSCNT Mask             */
S
S#define UI2C_BRGEN_DSCNT_Pos             (10)                                              /*!< UI2C_T::BRGEN: DSCNT Position          */
S#define UI2C_BRGEN_DSCNT_Msk             (0x1ful << UI2C_BRGEN_DSCNT_Pos)                  /*!< UI2C_T::BRGEN: DSCNT Mask              */
S
S#define UI2C_BRGEN_CLKDIV_Pos            (16)                                              /*!< UI2C_T::BRGEN: CLKDIV Position         */
S#define UI2C_BRGEN_CLKDIV_Msk            (0x3fful << UI2C_BRGEN_CLKDIV_Pos)                /*!< UI2C_T::BRGEN: CLKDIV Mask             */
S
S#define UI2C_LINECTL_LSB_Pos             (0)                                               /*!< UI2C_T::LINECTL: LSB Position          */
S#define UI2C_LINECTL_LSB_Msk             (0x1ul << UI2C_LINECTL_LSB_Pos)                   /*!< UI2C_T::LINECTL: LSB Mask              */
S
S#define UI2C_LINECTL_DWIDTH_Pos          (8)                                               /*!< UI2C_T::LINECTL: DWIDTH Position       */
S#define UI2C_LINECTL_DWIDTH_Msk          (0xful << UI2C_LINECTL_DWIDTH_Pos)                /*!< UI2C_T::LINECTL: DWIDTH Mask           */
S
S#define UI2C_TXDAT_TXDAT_Pos             (0)                                               /*!< UI2C_T::TXDAT: TXDAT Position          */
S#define UI2C_TXDAT_TXDAT_Msk             (0xfffful << UI2C_TXDAT_TXDAT_Pos)                /*!< UI2C_T::TXDAT: TXDAT Mask              */
S
S#define UI2C_RXDAT_RXDAT_Pos             (0)                                               /*!< UI2C_T::RXDAT: RXDAT Position          */
S#define UI2C_RXDAT_RXDAT_Msk             (0xfffful << UI2C_RXDAT_RXDAT_Pos)                /*!< UI2C_T::RXDAT: RXDAT Mask              */
S
S#define UI2C_DEVADDR0_DEVADDR_Pos        (0)                                               /*!< UI2C_T::DEVADDR0: DEVADDR Position     */
S#define UI2C_DEVADDR0_DEVADDR_Msk        (0x3fful << UI2C_DEVADDR0_DEVADDR_Pos)            /*!< UI2C_T::DEVADDR0: DEVADDR Mask         */
S
S#define UI2C_DEVADDR1_DEVADDR_Pos        (0)                                               /*!< UI2C_T::DEVADDR1: DEVADDR Position     */
S#define UI2C_DEVADDR1_DEVADDR_Msk        (0x3fful << UI2C_DEVADDR1_DEVADDR_Pos)            /*!< UI2C_T::DEVADDR1: DEVADDR Mask         */
S
S#define UI2C_ADDRMSK0_ADDRMSK_Pos        (0)                                               /*!< UI2C_T::ADDRMSK0: ADDRMSK Position     */
S#define UI2C_ADDRMSK0_ADDRMSK_Msk        (0x3fful << UI2C_ADDRMSK0_ADDRMSK_Pos)            /*!< UI2C_T::ADDRMSK0: ADDRMSK Mask         */
S
S#define UI2C_ADDRMSK1_ADDRMSK_Pos        (0)                                               /*!< UI2C_T::ADDRMSK1: ADDRMSK Position     */
S#define UI2C_ADDRMSK1_ADDRMSK_Msk        (0x3fful << UI2C_ADDRMSK1_ADDRMSK_Pos)            /*!< UI2C_T::ADDRMSK1: ADDRMSK Mask         */
S
S#define UI2C_WKCTL_WKEN_Pos              (0)                                               /*!< UI2C_T::WKCTL: WKEN Position           */
S#define UI2C_WKCTL_WKEN_Msk              (0x1ul << UI2C_WKCTL_WKEN_Pos)                    /*!< UI2C_T::WKCTL: WKEN Mask               */
S
S#define UI2C_WKCTL_WKADDREN_Pos          (1)                                               /*!< UI2C_T::WKCTL: WKADDREN Position       */
S#define UI2C_WKCTL_WKADDREN_Msk          (0x1ul << UI2C_WKCTL_WKADDREN_Pos)                /*!< UI2C_T::WKCTL: WKADDREN Mask           */
S
S#define UI2C_WKSTS_WKF_Pos               (0)                                               /*!< UI2C_T::WKSTS: WKF Position            */
S#define UI2C_WKSTS_WKF_Msk               (0x1ul << UI2C_WKSTS_WKF_Pos)                     /*!< UI2C_T::WKSTS: WKF Mask                */
S
S#define UI2C_PROTCTL_GCFUNC_Pos          (0)                                               /*!< UI2C_T::PROTCTL: GCFUNC Position       */
S#define UI2C_PROTCTL_GCFUNC_Msk          (0x1ul << UI2C_PROTCTL_GCFUNC_Pos)                /*!< UI2C_T::PROTCTL: GCFUNC Mask           */
S
S#define UI2C_PROTCTL_AA_Pos              (1)                                               /*!< UI2C_T::PROTCTL: AA Position           */
S#define UI2C_PROTCTL_AA_Msk              (0x1ul << UI2C_PROTCTL_AA_Pos)                    /*!< UI2C_T::PROTCTL: AA Mask               */
S
S#define UI2C_PROTCTL_STO_Pos             (2)                                               /*!< UI2C_T::PROTCTL: STO Position          */
S#define UI2C_PROTCTL_STO_Msk             (0x1ul << UI2C_PROTCTL_STO_Pos)                   /*!< UI2C_T::PROTCTL: STO Mask              */
S
S#define UI2C_PROTCTL_STA_Pos             (3)                                               /*!< UI2C_T::PROTCTL: STA Position          */
S#define UI2C_PROTCTL_STA_Msk             (0x1ul << UI2C_PROTCTL_STA_Pos)                   /*!< UI2C_T::PROTCTL: STA Mask              */
S
S#define UI2C_PROTCTL_ADDR10EN_Pos        (4)                                               /*!< UI2C_T::PROTCTL: ADDR10EN Position     */
S#define UI2C_PROTCTL_ADDR10EN_Msk        (0x1ul << UI2C_PROTCTL_ADDR10EN_Pos)              /*!< UI2C_T::PROTCTL: ADDR10EN Mask         */
S
S#define UI2C_PROTCTL_PTRG_Pos            (5)                                               /*!< UI2C_T::PROTCTL: PTRG Position         */
S#define UI2C_PROTCTL_PTRG_Msk            (0x1ul << UI2C_PROTCTL_PTRG_Pos)                  /*!< UI2C_T::PROTCTL: PTRG Mask             */
S
S#define UI2C_PROTCTL_SCLOUTEN_Pos        (8)                                               /*!< UI2C_T::PROTCTL: SCLOUTEN Position     */
S#define UI2C_PROTCTL_SCLOUTEN_Msk        (0x1ul << UI2C_PROTCTL_SCLOUTEN_Pos)              /*!< UI2C_T::PROTCTL: SCLOUTEN Mask         */
S
S#define UI2C_PROTCTL_MONEN_Pos           (9)                                               /*!< UI2C_T::PROTCTL: MONEN Position        */
S#define UI2C_PROTCTL_MONEN_Msk           (0x1ul << UI2C_PROTCTL_MONEN_Pos)                 /*!< UI2C_T::PROTCTL: MONEN Mask            */
S
S#define UI2C_PROTCTL_TOCNT_Pos           (16)                                              /*!< UI2C_T::PROTCTL: TOCNT Position        */
S#define UI2C_PROTCTL_TOCNT_Msk           (0x3fful << UI2C_PROTCTL_TOCNT_Pos)               /*!< UI2C_T::PROTCTL: TOCNT Mask            */
S
S#define UI2C_PROTCTL_PROTEN_Pos          (31)                                              /*!< UI2C_T::PROTCTL: PROTEN Position       */
S#define UI2C_PROTCTL_PROTEN_Msk          (0x1ul << UI2C_PROTCTL_PROTEN_Pos)                /*!< UI2C_T::PROTCTL: PROTEN Mask           */
S
S#define UI2C_PROTIEN_TOIEN_Pos           (0)                                               /*!< UI2C_T::PROTIEN: TOIEN Position        */
S#define UI2C_PROTIEN_TOIEN_Msk           (0x1ul << UI2C_PROTIEN_TOIEN_Pos)                 /*!< UI2C_T::PROTIEN: TOIEN Mask            */
S
S#define UI2C_PROTIEN_STARIEN_Pos         (1)                                               /*!< UI2C_T::PROTIEN: STARIEN Position      */
S#define UI2C_PROTIEN_STARIEN_Msk         (0x1ul << UI2C_PROTIEN_STARIEN_Pos)               /*!< UI2C_T::PROTIEN: STARIEN Mask          */
S
S#define UI2C_PROTIEN_STORIEN_Pos         (2)                                               /*!< UI2C_T::PROTIEN: STORIEN Position      */
S#define UI2C_PROTIEN_STORIEN_Msk         (0x1ul << UI2C_PROTIEN_STORIEN_Pos)               /*!< UI2C_T::PROTIEN: STORIEN Mask          */
S
S#define UI2C_PROTIEN_NACKIEN_Pos         (3)                                               /*!< UI2C_T::PROTIEN: NACKIEN Position      */
S#define UI2C_PROTIEN_NACKIEN_Msk         (0x1ul << UI2C_PROTIEN_NACKIEN_Pos)               /*!< UI2C_T::PROTIEN: NACKIEN Mask          */
S
S#define UI2C_PROTIEN_ARBLOIEN_Pos        (4)                                               /*!< UI2C_T::PROTIEN: ARBLOIEN Position     */
S#define UI2C_PROTIEN_ARBLOIEN_Msk        (0x1ul << UI2C_PROTIEN_ARBLOIEN_Pos)              /*!< UI2C_T::PROTIEN: ARBLOIEN Mask         */
S
S#define UI2C_PROTIEN_ERRIEN_Pos          (5)                                               /*!< UI2C_T::PROTIEN: ERRIEN Position       */
S#define UI2C_PROTIEN_ERRIEN_Msk          (0x1ul << UI2C_PROTIEN_ERRIEN_Pos)                /*!< UI2C_T::PROTIEN: ERRIEN Mask           */
S
S#define UI2C_PROTIEN_ACKIEN_Pos          (6)                                               /*!< UI2C_T::PROTIEN: ACKIEN Position       */
S#define UI2C_PROTIEN_ACKIEN_Msk          (0x1ul << UI2C_PROTIEN_ACKIEN_Pos)                /*!< UI2C_T::PROTIEN: ACKIEN Mask           */
S
S#define UI2C_PROTSTS_TOIF_Pos            (5)                                               /*!< UI2C_T::PROTSTS: TOIF Position         */
S#define UI2C_PROTSTS_TOIF_Msk            (0x1ul << UI2C_PROTSTS_TOIF_Pos)                  /*!< UI2C_T::PROTSTS: TOIF Mask             */
S
S#define UI2C_PROTSTS_ONBUSY_Pos          (6)                                               /*!< UI2C_T::PROTSTS: ONBUSY Position       */
S#define UI2C_PROTSTS_ONBUSY_Msk          (0x1ul << UI2C_PROTSTS_ONBUSY_Pos)                /*!< UI2C_T::PROTSTS: ONBUSY Mask           */
S
S#define UI2C_PROTSTS_STARIF_Pos          (8)                                               /*!< UI2C_T::PROTSTS: STARIF Position       */
S#define UI2C_PROTSTS_STARIF_Msk          (0x1ul << UI2C_PROTSTS_STARIF_Pos)                /*!< UI2C_T::PROTSTS: STARIF Mask           */
S
S#define UI2C_PROTSTS_STORIF_Pos          (9)                                               /*!< UI2C_T::PROTSTS: STORIF Position       */
S#define UI2C_PROTSTS_STORIF_Msk          (0x1ul << UI2C_PROTSTS_STORIF_Pos)                /*!< UI2C_T::PROTSTS: STORIF Mask           */
S
S#define UI2C_PROTSTS_NACKIF_Pos          (10)                                              /*!< UI2C_T::PROTSTS: NACKIF Position       */
S#define UI2C_PROTSTS_NACKIF_Msk          (0x1ul << UI2C_PROTSTS_NACKIF_Pos)                /*!< UI2C_T::PROTSTS: NACKIF Mask           */
S
S#define UI2C_PROTSTS_ARBLOIF_Pos         (11)                                              /*!< UI2C_T::PROTSTS: ARBLOIF Position      */
S#define UI2C_PROTSTS_ARBLOIF_Msk         (0x1ul << UI2C_PROTSTS_ARBLOIF_Pos)               /*!< UI2C_T::PROTSTS: ARBLOIF Mask          */
S
S#define UI2C_PROTSTS_ERRIF_Pos           (12)                                              /*!< UI2C_T::PROTSTS: ERRIF Position        */
S#define UI2C_PROTSTS_ERRIF_Msk           (0x1ul << UI2C_PROTSTS_ERRIF_Pos)                 /*!< UI2C_T::PROTSTS: ERRIF Mask            */
S
S#define UI2C_PROTSTS_ACKIF_Pos           (13)                                              /*!< UI2C_T::PROTSTS: ACKIF Position        */
S#define UI2C_PROTSTS_ACKIF_Msk           (0x1ul << UI2C_PROTSTS_ACKIF_Pos)                 /*!< UI2C_T::PROTSTS: ACKIF Mask            */
S
S#define UI2C_PROTSTS_SLASEL_Pos          (14)                                              /*!< UI2C_T::PROTSTS: SLASEL Position       */
S#define UI2C_PROTSTS_SLASEL_Msk          (0x1ul << UI2C_PROTSTS_SLASEL_Pos)                /*!< UI2C_T::PROTSTS: SLASEL Mask           */
S
S#define UI2C_PROTSTS_SLAREAD_Pos         (15)                                              /*!< UI2C_T::PROTSTS: SLAREAD Position      */
S#define UI2C_PROTSTS_SLAREAD_Msk         (0x1ul << UI2C_PROTSTS_SLAREAD_Pos)               /*!< UI2C_T::PROTSTS: SLAREAD Mask          */
S
S#define UI2C_PROTSTS_WKAKDONE_Pos        (16)                                              /*!< UI2C_T::PROTSTS: WKAKDONE Position     */
S#define UI2C_PROTSTS_WKAKDONE_Msk        (0x1ul << UI2C_PROTSTS_WKAKDONE_Pos)              /*!< UI2C_T::PROTSTS: WKAKDONE Mask         */
S
S#define UI2C_PROTSTS_WRSTSWK_Pos         (17)                                              /*!< UI2C_T::PROTSTS: WRSTSWK Position      */
S#define UI2C_PROTSTS_WRSTSWK_Msk         (0x1ul << UI2C_PROTSTS_WRSTSWK_Pos)               /*!< UI2C_T::PROTSTS: WRSTSWK Mask          */
S
S#define UI2C_PROTSTS_BUSHANG_Pos         (18)                                              /*!< UI2C_T::PROTSTS: BUSHANG Position      */
S#define UI2C_PROTSTS_BUSHANG_Msk         (0x1ul << UI2C_PROTSTS_BUSHANG_Pos)               /*!< UI2C_T::PROTSTS: BUSHANG Mask          */
S
S#define UI2C_PROTSTS_ERRARBLO_Pos        (19)                                              /*!< UI2C_T::PROTSTS: ERRARBLO Position     */
S#define UI2C_PROTSTS_ERRARBLO_Msk        (0x1ul << UI2C_PROTSTS_ERRARBLO_Pos)              /*!< UI2C_T::PROTSTS: ERRARBLO Mask         */
S
S#define UI2C_ADMAT_ADMAT0_Pos            (0)                                               /*!< UI2C_T::ADMAT: ADMAT0 Position         */
S#define UI2C_ADMAT_ADMAT0_Msk            (0x1ul << UI2C_ADMAT_ADMAT0_Pos)                  /*!< UI2C_T::ADMAT: ADMAT0 Mask             */
S
S#define UI2C_ADMAT_ADMAT1_Pos            (1)                                               /*!< UI2C_T::ADMAT: ADMAT1 Position         */
S#define UI2C_ADMAT_ADMAT1_Msk            (0x1ul << UI2C_ADMAT_ADMAT1_Pos)                  /*!< UI2C_T::ADMAT: ADMAT1 Mask             */
S
S#define UI2C_TMCTL_STCTL_Pos             (0)                                               /*!< UI2C_T::TMCTL: STCTL Position          */
S#define UI2C_TMCTL_STCTL_Msk             (0x3ful << UI2C_TMCTL_STCTL_Pos)                  /*!< UI2C_T::TMCTL: STCTL Mask              */
S
S#define UI2C_TMCTL_HTCTL_Pos             (6)                                               /*!< UI2C_T::TMCTL: HTCTL Position          */
S#define UI2C_TMCTL_HTCTL_Msk             (0x3ful << UI2C_TMCTL_HTCTL_Pos)                  /*!< UI2C_T::TMCTL: HTCTL Mask              */
S
S/**@}*/ /* UI2C_CONST */
S/**@}*/ /* end of UI2C register group */
S
S
S/*---------------------- USB Device Controller -------------------------*/
S/**
S    @addtogroup USBD USB Device Controller(USBD)
S    Memory Mapped Structure for USBD Controller
S@{ */
S
S
S
S/**
S  * @brief USBD endpoints register
S  */
Stypedef struct
S{
S    /**
S     * @var USBD_EP_T::BUFSEG
S     * Offset: 0x500/0x510/0x520/0x530/0x540/0x550/0x560/0x570  Endpoint Buffer Segmentation Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[8:3]   |BUFSEG    |Endpoint Buffer Segmentation
S     * |        |          |It is used to indicate the offset address for each endpoint with the USB SRAM starting address The effective starting address of the endpoint is
S     * |        |          |USBD_SRAM address + { BUFSEG[8:3], 3u2019b000}
S     * |        |          |Where the USBD_SRAM address = USBD_BA+0x100h.
S     * |        |          |Refer to the section 6.17.5.76.21.5.7 for the endpoint SRAM structure and its description.
S     * @var USBD_EP_T::MXPLD
S     * Offset: 0x504/0x514/0x524/0x534/0x544/0x554/0x564/0x574  Endpoint Maximal Payload Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[8:0]   |MXPLD     |Maximal Payload
S     * |        |          |Define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token)
S     * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
S     * |        |          |(1) When the register is written by CPU,
S     * |        |          |For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready.
S     * |        |          |For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
S     * |        |          |(2) When the register is read by CPU,
S     * |        |          |For IN token, the value of MXPLD is indicated by the data length be transmitted to host
S     * |        |          |For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
S     * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.
S     * @var USBD_EP_T::CFG
S     * Offset: 0x508/0x518/0x528/0x538/0x548/0x558/0x568/0x578  Endpoint Configuration Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |EPNUM     |Endpoint Number
S     * |        |          |These bits are used to define the endpoint number of the current endpoint
S     * |[4]     |ISOCH     |Isochronous Endpoint
S     * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
S     * |        |          |0 = No Isochronous endpoint.
S     * |        |          |1 = Isochronous endpoint.
S     * |[6:5]   |STATE     |Endpoint STATE
S     * |        |          |00 = Endpoint is Disabled.
S     * |        |          |01 = Out endpoint.
S     * |        |          |10 = IN endpoint.
S     * |        |          |11 = Undefined.
S     * |[7]     |DSQSYNC   |Data Sequence Synchronization
S     * |        |          |0 = DATA0 PID.
S     * |        |          |1 = DATA1 PID.
S     * |        |          |Note: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction
S     * |        |          |hardware will toggle automatically in IN token base on the bit.
S     * |[9]     |CSTALL    |Clear STALL Response
S     * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
S     * |        |          |1 = Clear the device to response STALL handshake in setup stage.
S     * @var USBD_EP_T::CFGP
S     * Offset: 0x50C/0x51C/0x52C/0x53C/0x54C/0x55C/0x56C/0x57C  Endpoint Set Stall and Clear In/Out Ready Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CLRRDY    |Clear Ready
S     * |        |          |When the USBD_MXPLDx register is set by user, it means that the endpoint is ready to transmit or receive data
S     * |        |          |If the user wants to disable this transaction before the transaction start, users can set this bit to 1 to disable it and it is auto clear to 0.
S     * |        |          |For IN token, write u20181u2019 to clear the IN token had ready to transmit the data to USB.
S     * |        |          |For OUT token, write u20181u2019 to clear the OUT token had ready to receive the data from USB.
S     * |        |          |This bit is write 1 only and is always 0 when it is read back.
S     * |[1]     |SSTALL    |Set STALL
S     * |        |          |0 = Disable the device to response STALL.
S     * |        |          |1 = Set the device to respond STALL automatically.
S     */
S    __IO uint32_t BUFSEG;                /*!< [0x0000] Endpoint Buffer Segmentation Register                            */
S    __IO uint32_t MXPLD;                 /*!< [0x0004] Endpoint Maximal Payload Register                                */
S    __IO uint32_t CFG;                   /*!< [0x0008] Endpoint Configuration Register                                  */
S    __IO uint32_t CFGP;                  /*!< [0x000c] Endpoint Set Stall and Clear In/Out Ready Control Register       */
S
S} USBD_EP_T;
S
Stypedef struct
S{
S
S
S    /**
S     * @var USBD_T::INTEN
S     * Offset: 0x00  USB Device Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |BUSIEN    |Bus Event Interrupt Enable Bit
S     * |        |          |0 = BUS Event Interrupt Disabled.
S     * |        |          |1 = BUS Event Interrupt Enabled.
S     * |[1]     |USBIEN    |USB Event Interrupt Enable Bit
S     * |        |          |0 = USB Event Interrupt Disabled.
S     * |        |          |1 = USB Event Interrupt Enabled.
S     * |[2]     |VBDETIEN  |VBUS Detection Interrupt Enable Bit
S     * |        |          |0 = VBUS Detection Interrupt Disabled.
S     * |        |          |1 = VBUS Detection Interrupt Enabled.
S     * |[3]     |WKIDLEIEN |USB Wake-up Idle Interrupt Enable Bit
S     * |        |          |0 = Wake-up Idle Interrupt Disabled.
S     * |        |          |1 = Wake-up Idle Interrupt Enabled.
S     * |[4]     |SOFIEN    |Start of Frame Interrupt Enable Bit
S     * |        |          |0 = SOF Interrupt Disabled.
S     * |        |          |1 = SOF Interrupt Enabled.
S     * |[8]     |WKEN      |Wake-up Function Enable Bit
S     * |        |          |0 = USB Wake-up Function Disabled.
S     * |        |          |1 = USB Wake-up Function Enabled.
S     * |[15]    |INNAKEN   |Active NAK Function and Its Status in IN Token
S     * |        |          |0 = When device responds NAK after receiving IN token, IN NAK status will not be updated to USBD_EPSTS register, so that the USB interrupt event will not be asserted.
S     * |        |          |1 = IN NAK status will be updated to USBD_EPSTS register and the USB interrupt event will be asserted, when the device responds NAK after receiving IN token.
S     * @var USBD_T::INTSTS
S     * Offset: 0x04  USB Device Interrupt Event Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |BUSIF     |BUS Interrupt Status
S     * |        |          |The BUS event means that there is one of the suspense or the resume function in the bus.
S     * |        |          |0 = No BUS event occurred.
S     * |        |          |1 = Bus event occurred; check USBD_ATTR[3:0] and USBD_ATTR[13:12] to know which kind of bus event was occurred, cleared by write 1 to USBD_INTSTS[0].
S     * |[1]     |USBIF     |USB Event Interrupt Status
S     * |        |          |The USB event includes the SETUP Token, IN Token, OUT ACK, ISO IN, or ISO OUT events in the bus.
S     * |        |          |0 = No USB event occurred.
S     * |        |          |1 = USB event occurred, check EPSTS0~5[2:0] to know which kind of USB event was occurred, cleared by write 1 to USBD_INTSTS[1] or EPSTS0~7 and SETUP (USBD_INTSTS[31]).
S     * |[2]     |VBDETIF   |VBUS Detection Interrupt Status
S     * |        |          |0 = There is not attached/detached event in the USB.
S     * |        |          |1 = There is attached/detached event in the USB bus and it is cleared by write 1 to USBD_INTSTS[2].
S     * |[3]     |WKIDLEIF  |No-event-wake-up Interrupt Status
S     * |        |          |0 = WKIDLE event does not occur.
S     * |        |          |1 = No-event-wake-up event occurred, cleared by write 1 to USBD_INTSTS[3].
S     * |[4]     |SOFIF     |Start of Frame Interrupt Status
S     * |        |          |0 = SOF event does not occur.
S     * |        |          |1 = SOF event occurred, cleared by write 1 to USBD_INTSTS[4].
S     * |[16]    |EPEVT0    |Endpoint 0u2019s USB Event Status
S     * |        |          |0 = No event occurred in endpoint 0.
S     * |        |          |1 = USB event occurred on Endpoint 0, check USBD_EPSTS[10:8] to know which kind of USB event was occurred, cleared by write 1 to USBD_INTSTS[16] or USBD_INTSTS[1].
S     * |[17]    |EPEVT1    |Endpoint 1u2019s USB Event Status
S     * |        |          |0 = No event occurred in endpoint 1.
S     * |        |          |1 = USB event occurred on Endpoint 1, check USBD_EPSTS[13:11] to know which kind of USB event was occurred, cleared by write 1 to USBD_INTSTS[17] or USBD_INTSTS[1].
S     * |[18]    |EPEVT2    |Endpoint 2u2019s USB Event Status
S     * |        |          |0 = No event occurred in endpoint 2.
S     * |        |          |1 = USB event occurred on Endpoint 2, check USBD_EPSTS[16:14] to know which kind of USB event was occurred, cleared by write 1 to USBD_INTSTS[18] or USBD_INTSTS[1].
S     * |[19]    |EPEVT3    |Endpoint 3u2019s USB Event Status
S     * |        |          |0 = No event occurred in endpoint 3.
S     * |        |          |1 = USB event occurred on Endpoint 3, check USBD_EPSTS[19:17] to know which kind of USB event was occurred, cleared by write 1 to USBD_INTSTS[19] or USBD_INTSTS[1].
S     * |[20]    |EPEVT4    |Endpoint 4u2019s USB Event Status
S     * |        |          |0 = No event occurred in endpoint 4.
S     * |        |          |1 = USB event occurred on Endpoint 4, check USBD_EPSTS[22:20] to know which kind of USB event was occurred, cleared by write 1 to USBD_INTSTS[20] or USBD_INTSTS[1].
S     * |[21]    |EPEVT5    |Endpoint 5u2019s USB Event Status
S     * |        |          |0 = No event occurred in endpoint 5.
S     * |        |          |1 = USB event occurred on Endpoint 5, check USBD_EPSTS[25:23] to know which kind of USB event was occurred, cleared by write 1 to USBD_INTSTS[21] or USBD_INTSTS[1].
S     * |[22]    |EPEVT6    |Endpoint 6u2019s USB Event Status
S     * |        |          |0 = No event occurred in endpoint 6.
S     * |        |          |1 = USB event occurred on Endpoint 6, check USBD_EPSTS[28:26] to know which kind of USB event was occurred, cleared by write 1 to USBD_INTSTS[22] or USBD_INTSTS[1].
S     * |[23]    |EPEVT7    |Endpoint 7u2019s USB Event Status
S     * |        |          |0 = No event occurred in endpoint 7.
S     * |        |          |1 = USB event occurred on Endpoint 7, check USBD_EPSTS[31:29] to know which kind of USB event was occurred, cleared by write 1 to USBD_INTSTS[23] or USBD_INTSTS[1].
S     * |[31]    |SETUP     |Setup Event Status
S     * |        |          |0 = No Setup event.
S     * |        |          |1 = Setup event occurred, cleared by write 1 to USBD_INTSTS[31].
S     * @var USBD_T::FADDR
S     * Offset: 0x08  USB Device Function Address Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[6:0]   |FADDR     |USB Device Function Address
S     * @var USBD_T::EPSTS
S     * Offset: 0x0C  USB Device Endpoint Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7]     |OV        |Overrun
S     * |        |          |It indicates that the received data is over the maximum payload number or not.
S     * |        |          |0 = No overrun.
S     * |        |          |1 = Out Data is more than the Max Payload in MXPLD register or the Setup Data is more than 8 Bytes.
S     * |[10:8]  |EPSTS0    |Endpoint 0 Status
S     * |        |          |These bits are used to indicate the current status of this endpoint
S     * |        |          |000 = In ACK.
S     * |        |          |001 = In NAK.
S     * |        |          |010 = Out Packet Data0 ACK.
S     * |        |          |110 = Out Packet Data1 ACK.
S     * |        |          |011 = Setup ACK.
S     * |        |          |111 = Isochronous transfer end.
S     * |[13:11] |EPSTS1    |Endpoint 1 Status
S     * |        |          |These bits are used to indicate the current status of this endpoint
S     * |        |          |000 = In ACK.
S     * |        |          |001 = In NAK.
S     * |        |          |010 = Out Packet Data0 ACK.
S     * |        |          |110 = Out Packet Data1 ACK.
S     * |        |          |011 = Setup ACK.
S     * |        |          |111 = Isochronous transfer end.
S     * |[16:14] |EPSTS2    |Endpoint 2 Status
S     * |        |          |These bits are used to indicate the current status of this endpoint
S     * |        |          |000 = In ACK.
S     * |        |          |001 = In NAK.
S     * |        |          |010 = Out Packet Data0 ACK.
S     * |        |          |110 = Out Packet Data1 ACK.
S     * |        |          |011 = Setup ACK.
S     * |        |          |111 = Isochronous transfer end.
S     * |[19:17] |EPSTS3    |Endpoint 3 Status
S     * |        |          |These bits are used to indicate the current status of this endpoint
S     * |        |          |000 = In ACK.
S     * |        |          |001 = In NAK.
S     * |        |          |010 = Out Packet Data0 ACK.
S     * |        |          |110 = Out Packet Data1 ACK.
S     * |        |          |011 = Setup ACK.
S     * |        |          |111 = Isochronous transfer end.
S     * |[22:20] |EPSTS4    |Endpoint 4 Status
S     * |        |          |These bits are used to indicate the current status of this endpoint
S     * |        |          |000 = In ACK.
S     * |        |          |001 = In NAK.
S     * |        |          |010 = Out Packet Data0 ACK.
S     * |        |          |110 = Out Packet Data1 ACK.
S     * |        |          |011 = Setup ACK.
S     * |        |          |111 = Isochronous transfer end.
S     * |[25:23] |EPSTS5    |Endpoint 5 Status
S     * |        |          |These bits are used to indicate the current status of this endpoint
S     * |        |          |000 = In ACK.
S     * |        |          |001 = In NAK.
S     * |        |          |010 = Out Packet Data0 ACK.
S     * |        |          |110 = Out Packet Data1 ACK.
S     * |        |          |011 = Setup ACK.
S     * |        |          |111 = Isochronous transfer end.
S     * |[28:26] |EPSTS6    |Endpoint 6 Status
S     * |        |          |These bits are used to indicate the current status of this endpoint
S     * |        |          |000 = In ACK.
S     * |        |          |001 = In NAK.
S     * |        |          |010 = Out Packet Data0 ACK.
S     * |        |          |110 = Out Packet Data1 ACK.
S     * |        |          |011 = Setup ACK.
S     * |        |          |111 = Isochronous transfer end.
S     * |[31:29] |EPSTS7    |Endpoint 7 Status
S     * |        |          |These bits are used to indicate the current status of this endpoint
S     * |        |          |000 = In ACK.
S     * |        |          |001 = In NAK.
S     * |        |          |010 = Out Packet Data0 ACK.
S     * |        |          |110 = Out Packet Data1 ACK.
S     * |        |          |011 = Setup ACK.
S     * |        |          |111 = Isochronous transfer end.
S     * @var USBD_T::ATTR
S     * Offset: 0x10  USB Device Bus Status and Attribution Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |USBRST    |USB Reset Status
S     * |        |          |0 = Bus no reset.
S     * |        |          |1 = Bus reset when SE0 (single-ended 0) more than 2.5us.
S     * |        |          |Note: This bit is read only.
S     * |[1]     |SUSPEND   |Suspend Status
S     * |        |          |0 = Bus no suspend.
S     * |        |          |1 = Bus idle more than 3ms, either cable is plugged off or host is sleeping.
S     * |        |          |Note: This bit is read only.
S     * |[2]     |RESUME    |Resume Status
S     * |        |          |0 = No bus resume.
S     * |        |          |1 = Resume from suspend.
S     * |        |          |Note: This bit is read only.
S     * |[3]     |TOUT      |Time-out Status
S     * |        |          |0 = No time-out.
S     * |        |          |1 = No Bus response more than 18 bits time.
S     * |        |          |Note: This bit is read only.
S     * |[4]     |PHYEN     |PHY Transceiver Function Enable Bit
S     * |        |          |0 = PHY transceiver function Disabled.
S     * |        |          |1 = PHY transceiver function Enabled.
S     * |[5]     |RWAKEUP   |Remote Wake-up
S     * |        |          |0 = Release the USB bus from K state.
S     * |        |          |1 = Force USB bus to K (USB_D+ low, USB_D-: high) state, used for remote wake-up.
S     * |[7]     |USBEN     |USB Controller Enable Bit
S     * |        |          |0 = USB Controller Disabled.
S     * |        |          |1 = USB Controller Enabled.
S     * |[8]     |DPPUEN    |Pull-up Resistor on USB_DP Enable Bit
S     * |        |          |0 = Pull-up resistor in USB_D+ bus Disabled.
S     * |        |          |1 = Pull-up resistor in USB_D+ bus Active.
S     * |[10]    |BYTEM     |CPU Access USB SRAM Size Mode Selection
S     * |        |          |0 = Word mode: The size of the transfer from CPU to USB SRAM can be Word only.
S     * |        |          |1 = Byte mode: The size of the transfer from CPU to USB SRAM can be Byte only.
S     * |[11]    |LPMACK    |LPM Token Acknowledge Enable
S     * |        |          |The NYET/ACK will be returned only on a successful LPM transaction if no errors in both the EXT token and the LPM token and a valid bLinkState = 0001 (L1) is received, else ERROR and STALL will be returned automatically, respectively.
S     * |        |          |0= the valid LPM Token will be NYET.
S     * |        |          |1= the valid LPM Token will be ACK.
S     * |[12]    |L1SUSPEND |LPM L1 Suspend
S     * |        |          |0 = Bus no L1 state suspend.
S     * |        |          |1 = This bit is set by the hardware when LPM command to enter the L1 state is successfully received and acknowledged.
S     * |        |          |Note: This bit is read only.
S     * |[13]    |L1RESUME  |LPM L1 Resume
S     * |        |          |0 = Bus no LPM L1 state resume.
S     * |        |          |1 = LPM L1 state Resume from LPM L1 state suspend.
S     * |        |          |Note: This bit is read only.
S     * @var USBD_T::VBUSDET
S     * Offset: 0x14  USB Device VBUS Detection Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |VBUSDET   |Device VBUS Detection
S     * |        |          |0 = Controller is not attached to the USB host.
S     * |        |          |1 = Controller is attached to the USB host.
S     * @var USBD_T::STBUFSEG
S     * Offset: 0x18  Setup Token Buffer Segmentation Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[8:3]   |STBUFSEG  |SETUP Token Buffer Segmentation
S     * |        |          |It is used to indicate the offset address for the SETUP token with the USB Device SRAM starting address The effective starting address is
S     * |        |          |USBD_SRAM address + {STBUFSEG[8:3], 3u2019b000}
S     * |        |          |Where the USBD_SRAM address = USBD_BA+0x100h.
S     * |        |          |Note: It is used for SETUP token only.
S     * @var USBD_T::LPMATTR
S     * Offset: 0x88  USB LPM Attribution Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |LPMLINKSTS|LPM Linke State
S     * |        |          |These bits contain the bLinkState received with last ACK LPM Token
S     * |[7:4]   |LPMBESL   |LPM Best Effort Service Latency
S     * |        |          |These bits contain the BESL value received with last ACK LPM Token
S     * |[8]     |LPMRWAKUP |LPM Remote Wakeup
S     * |        |          |This bit contains the bRemoteWake value received with last ACK LPM Token
S     * @var USBD_T::FN
S     * Offset: 0x8C  USB Frame number Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[10:0]  |FN        |Frame Number
S     * |        |          |These bits contain the 11-bits frame number in the last received SOF packet.
S     * @var USBD_T::SE0
S     * Offset: 0x90  USB Device Drive SE0 Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SE0       |Drive Single Ended Zero in USB Bus
S     * |        |          |The Single Ended Zero (SE0) is when both lines (USB_D+ and USB_D-) are being pulled low.
S     * |        |          |0 = Normal operation.
S     * |        |          |1 = Force USB PHY transceiver to drive SE0.
S     */
S
S    __IO uint32_t INTEN;                 /*!< [0x0000] USB Device Interrupt Enable Register                             */
S    __IO uint32_t INTSTS;                /*!< [0x0004] USB Device Interrupt Event Status Register                       */
S    __IO uint32_t FADDR;                 /*!< [0x0008] USB Device Function Address Register                             */
S    __I  uint32_t EPSTS;                 /*!< [0x000c] USB Device Endpoint Status Register                              */
S    __IO uint32_t ATTR;                  /*!< [0x0010] USB Device Bus Status and Attribution Register                   */
S    __I  uint32_t VBUSDET;               /*!< [0x0014] USB Device VBUS Detection Register                               */
S    __IO uint32_t STBUFSEG;              /*!< [0x0018] Setup Token Buffer Segmentation Register                         */
S    __I  uint32_t RESERVE0[27];
S    __I  uint32_t LPMATTR;               /*!< [0x0088] USB LPM Attribution Register                                     */
S    __I  uint32_t FN;                    /*!< [0x008c] USB Frame number Register                                        */
S    __IO uint32_t SE0;                   /*!< [0x0090] USB Device Drive SE0 Control Register                            */
S    __I  uint32_t RESERVE1[283];
S    USBD_EP_T EP[8];                     /*!< [0x0500~0x57C] USB Device Endpoints                                       */
S
S} USBD_T;
S
S/**
S    @addtogroup USBD_CONST USBD Bit Field Definition
S    Constant Definitions for USBD Controller
S@{ */
S
S#define USBD_INTEN_BUSIEN_Pos            (0)                                               /*!< USBD_T::INTEN: BUSIEN Position         */
S#define USBD_INTEN_BUSIEN_Msk            (0x1ul << USBD_INTEN_BUSIEN_Pos)                  /*!< USBD_T::INTEN: BUSIEN Mask             */
S
S#define USBD_INTEN_USBIEN_Pos            (1)                                               /*!< USBD_T::INTEN: USBIEN Position         */
S#define USBD_INTEN_USBIEN_Msk            (0x1ul << USBD_INTEN_USBIEN_Pos)                  /*!< USBD_T::INTEN: USBIEN Mask             */
S
S#define USBD_INTEN_VBDETIEN_Pos          (2)                                               /*!< USBD_T::INTEN: VBDETIEN Position       */
S#define USBD_INTEN_VBDETIEN_Msk          (0x1ul << USBD_INTEN_VBDETIEN_Pos)                /*!< USBD_T::INTEN: VBDETIEN Mask           */
S
S#define USBD_INTEN_WKIDLEIEN_Pos         (3)                                               /*!< USBD_T::INTEN: WKIDLEIEN Position      */
S#define USBD_INTEN_WKIDLEIEN_Msk         (0x1ul << USBD_INTEN_WKIDLEIEN_Pos)               /*!< USBD_T::INTEN: WKIDLEIEN Mask          */
S
S#define USBD_INTEN_SOFIEN_Pos            (4)                                               /*!< USBD_T::INTEN: SOFIEN Position         */
S#define USBD_INTEN_SOFIEN_Msk            (0x1ul << USBD_INTEN_SOFIEN_Pos)                  /*!< USBD_T::INTEN: SOFIEN Mask             */
S
S#define USBD_INTEN_WKEN_Pos              (8)                                               /*!< USBD_T::INTEN: WKEN Position           */
S#define USBD_INTEN_WKEN_Msk              (0x1ul << USBD_INTEN_WKEN_Pos)                    /*!< USBD_T::INTEN: WKEN Mask               */
S
S#define USBD_INTEN_INNAKEN_Pos           (15)                                              /*!< USBD_T::INTEN: INNAKEN Position        */
S#define USBD_INTEN_INNAKEN_Msk           (0x1ul << USBD_INTEN_INNAKEN_Pos)                 /*!< USBD_T::INTEN: INNAKEN Mask            */
S
S#define USBD_INTSTS_BUSIF_Pos            (0)                                               /*!< USBD_T::INTSTS: BUSIF Position         */
S#define USBD_INTSTS_BUSIF_Msk            (0x1ul << USBD_INTSTS_BUSIF_Pos)                  /*!< USBD_T::INTSTS: BUSIF Mask             */
S
S#define USBD_INTSTS_USBIF_Pos            (1)                                               /*!< USBD_T::INTSTS: USBIF Position         */
S#define USBD_INTSTS_USBIF_Msk            (0x1ul << USBD_INTSTS_USBIF_Pos)                  /*!< USBD_T::INTSTS: USBIF Mask             */
S
S#define USBD_INTSTS_VBDETIF_Pos          (2)                                               /*!< USBD_T::INTSTS: VBDETIF Position       */
S#define USBD_INTSTS_VBDETIF_Msk          (0x1ul << USBD_INTSTS_VBDETIF_Pos)                /*!< USBD_T::INTSTS: VBDETIF Mask           */
S
S#define USBD_INTSTS_WKIDLEIF_Pos         (3)                                               /*!< USBD_T::INTSTS: WKIDLEIF Position      */
S#define USBD_INTSTS_WKIDLEIF_Msk         (0x1ul << USBD_INTSTS_WKIDLEIF_Pos)               /*!< USBD_T::INTSTS: WKIDLEIF Mask          */
S
S#define USBD_INTSTS_SOFIF_Pos            (4)                                               /*!< USBD_T::INTSTS: SOFIF Position         */
S#define USBD_INTSTS_SOFIF_Msk            (0x1ul << USBD_INTSTS_SOFIF_Pos)                  /*!< USBD_T::INTSTS: SOFIF Mask             */
S
S#define USBD_INTSTS_EPEVT0_Pos           (16)                                              /*!< USBD_T::INTSTS: EPEVT0 Position        */
S#define USBD_INTSTS_EPEVT0_Msk           (0x1ul << USBD_INTSTS_EPEVT0_Pos)                 /*!< USBD_T::INTSTS: EPEVT0 Mask            */
S
S#define USBD_INTSTS_EPEVT1_Pos           (17)                                              /*!< USBD_T::INTSTS: EPEVT1 Position        */
S#define USBD_INTSTS_EPEVT1_Msk           (0x1ul << USBD_INTSTS_EPEVT1_Pos)                 /*!< USBD_T::INTSTS: EPEVT1 Mask            */
S
S#define USBD_INTSTS_EPEVT2_Pos           (18)                                              /*!< USBD_T::INTSTS: EPEVT2 Position        */
S#define USBD_INTSTS_EPEVT2_Msk           (0x1ul << USBD_INTSTS_EPEVT2_Pos)                 /*!< USBD_T::INTSTS: EPEVT2 Mask            */
S
S#define USBD_INTSTS_EPEVT3_Pos           (19)                                              /*!< USBD_T::INTSTS: EPEVT3 Position        */
S#define USBD_INTSTS_EPEVT3_Msk           (0x1ul << USBD_INTSTS_EPEVT3_Pos)                 /*!< USBD_T::INTSTS: EPEVT3 Mask            */
S
S#define USBD_INTSTS_EPEVT4_Pos           (20)                                              /*!< USBD_T::INTSTS: EPEVT4 Position        */
S#define USBD_INTSTS_EPEVT4_Msk           (0x1ul << USBD_INTSTS_EPEVT4_Pos)                 /*!< USBD_T::INTSTS: EPEVT4 Mask            */
S
S#define USBD_INTSTS_EPEVT5_Pos           (21)                                              /*!< USBD_T::INTSTS: EPEVT5 Position        */
S#define USBD_INTSTS_EPEVT5_Msk           (0x1ul << USBD_INTSTS_EPEVT5_Pos)                 /*!< USBD_T::INTSTS: EPEVT5 Mask            */
S
S#define USBD_INTSTS_EPEVT6_Pos           (22)                                              /*!< USBD_T::INTSTS: EPEVT6 Position        */
S#define USBD_INTSTS_EPEVT6_Msk           (0x1ul << USBD_INTSTS_EPEVT6_Pos)                 /*!< USBD_T::INTSTS: EPEVT6 Mask            */
S
S#define USBD_INTSTS_EPEVT7_Pos           (23)                                              /*!< USBD_T::INTSTS: EPEVT7 Position        */
S#define USBD_INTSTS_EPEVT7_Msk           (0x1ul << USBD_INTSTS_EPEVT7_Pos)                 /*!< USBD_T::INTSTS: EPEVT7 Mask            */
S
S#define USBD_INTSTS_SETUP_Pos            (31)                                              /*!< USBD_T::INTSTS: SETUP Position         */
S#define USBD_INTSTS_SETUP_Msk            (0x1ul << USBD_INTSTS_SETUP_Pos)                  /*!< USBD_T::INTSTS: SETUP Mask             */
S
S#define USBD_FADDR_FADDR_Pos             (0)                                               /*!< USBD_T::FADDR: FADDR Position          */
S#define USBD_FADDR_FADDR_Msk             (0x7ful << USBD_FADDR_FADDR_Pos)                  /*!< USBD_T::FADDR: FADDR Mask              */
S
S#define USBD_EPSTS_OV_Pos                (7)                                               /*!< USBD_T::EPSTS: OV Position             */
S#define USBD_EPSTS_OV_Msk                (0x1ul << USBD_EPSTS_OV_Pos)                      /*!< USBD_T::EPSTS: OV Mask                 */
S
S#define USBD_EPSTS_EPSTS0_Pos            (8)                                               /*!< USBD_T::EPSTS: EPSTS0 Position         */
S#define USBD_EPSTS_EPSTS0_Msk            (0x7ul << USBD_EPSTS_EPSTS0_Pos)                  /*!< USBD_T::EPSTS: EPSTS0 Mask             */
S
S#define USBD_EPSTS_EPSTS1_Pos            (11)                                              /*!< USBD_T::EPSTS: EPSTS1 Position         */
S#define USBD_EPSTS_EPSTS1_Msk            (0x7ul << USBD_EPSTS_EPSTS1_Pos)                  /*!< USBD_T::EPSTS: EPSTS1 Mask             */
S
S#define USBD_EPSTS_EPSTS2_Pos            (14)                                              /*!< USBD_T::EPSTS: EPSTS2 Position         */
S#define USBD_EPSTS_EPSTS2_Msk            (0x7ul << USBD_EPSTS_EPSTS2_Pos)                  /*!< USBD_T::EPSTS: EPSTS2 Mask             */
S
S#define USBD_EPSTS_EPSTS3_Pos            (17)                                              /*!< USBD_T::EPSTS: EPSTS3 Position         */
S#define USBD_EPSTS_EPSTS3_Msk            (0x7ul << USBD_EPSTS_EPSTS3_Pos)                  /*!< USBD_T::EPSTS: EPSTS3 Mask             */
S
S#define USBD_EPSTS_EPSTS4_Pos            (20)                                              /*!< USBD_T::EPSTS: EPSTS4 Position         */
S#define USBD_EPSTS_EPSTS4_Msk            (0x7ul << USBD_EPSTS_EPSTS4_Pos)                  /*!< USBD_T::EPSTS: EPSTS4 Mask             */
S
S#define USBD_EPSTS_EPSTS5_Pos            (23)                                              /*!< USBD_T::EPSTS: EPSTS5 Position         */
S#define USBD_EPSTS_EPSTS5_Msk            (0x7ul << USBD_EPSTS_EPSTS5_Pos)                  /*!< USBD_T::EPSTS: EPSTS5 Mask             */
S
S#define USBD_EPSTS_EPSTS6_Pos            (26)                                              /*!< USBD_T::EPSTS: EPSTS6 Position         */
S#define USBD_EPSTS_EPSTS6_Msk            (0x7ul << USBD_EPSTS_EPSTS6_Pos)                  /*!< USBD_T::EPSTS: EPSTS6 Mask             */
S
S#define USBD_EPSTS_EPSTS7_Pos            (29)                                              /*!< USBD_T::EPSTS: EPSTS7 Position         */
S#define USBD_EPSTS_EPSTS7_Msk            (0x7ul << USBD_EPSTS_EPSTS7_Pos)                  /*!< USBD_T::EPSTS: EPSTS7 Mask             */
S
S#define USBD_ATTR_USBRST_Pos             (0)                                               /*!< USBD_T::ATTR: USBRST Position          */
S#define USBD_ATTR_USBRST_Msk             (0x1ul << USBD_ATTR_USBRST_Pos)                   /*!< USBD_T::ATTR: USBRST Mask              */
S
S#define USBD_ATTR_SUSPEND_Pos            (1)                                               /*!< USBD_T::ATTR: SUSPEND Position         */
S#define USBD_ATTR_SUSPEND_Msk            (0x1ul << USBD_ATTR_SUSPEND_Pos)                  /*!< USBD_T::ATTR: SUSPEND Mask             */
S
S#define USBD_ATTR_RESUME_Pos             (2)                                               /*!< USBD_T::ATTR: RESUME Position          */
S#define USBD_ATTR_RESUME_Msk             (0x1ul << USBD_ATTR_RESUME_Pos)                   /*!< USBD_T::ATTR: RESUME Mask              */
S
S#define USBD_ATTR_TOUT_Pos               (3)                                               /*!< USBD_T::ATTR: TOUT Position            */
S#define USBD_ATTR_TOUT_Msk               (0x1ul << USBD_ATTR_TOUT_Pos)                     /*!< USBD_T::ATTR: TOUT Mask                */
S
S#define USBD_ATTR_PHYEN_Pos              (4)                                               /*!< USBD_T::ATTR: PHYEN Position           */
S#define USBD_ATTR_PHYEN_Msk              (0x1ul << USBD_ATTR_PHYEN_Pos)                    /*!< USBD_T::ATTR: PHYEN Mask               */
S
S#define USBD_ATTR_RWAKEUP_Pos            (5)                                               /*!< USBD_T::ATTR: RWAKEUP Position         */
S#define USBD_ATTR_RWAKEUP_Msk            (0x1ul << USBD_ATTR_RWAKEUP_Pos)                  /*!< USBD_T::ATTR: RWAKEUP Mask             */
S
S#define USBD_ATTR_USBEN_Pos              (7)                                               /*!< USBD_T::ATTR: USBEN Position           */
S#define USBD_ATTR_USBEN_Msk              (0x1ul << USBD_ATTR_USBEN_Pos)                    /*!< USBD_T::ATTR: USBEN Mask               */
S
S#define USBD_ATTR_DPPUEN_Pos             (8)                                               /*!< USBD_T::ATTR: DPPUEN Position          */
S#define USBD_ATTR_DPPUEN_Msk             (0x1ul << USBD_ATTR_DPPUEN_Pos)                   /*!< USBD_T::ATTR: DPPUEN Mask              */
S
S#define USBD_ATTR_BYTEM_Pos              (10)                                              /*!< USBD_T::ATTR: BYTEM Position           */
S#define USBD_ATTR_BYTEM_Msk              (0x1ul << USBD_ATTR_BYTEM_Pos)                    /*!< USBD_T::ATTR: BYTEM Mask               */
S
S#define USBD_ATTR_LPMACK_Pos             (11)                                              /*!< USBD_T::ATTR: LPMACK Position          */
S#define USBD_ATTR_LPMACK_Msk             (0x1ul << USBD_ATTR_LPMACK_Pos)                   /*!< USBD_T::ATTR: LPMACK Mask              */
S
S#define USBD_ATTR_L1SUSPEND_Pos          (12)                                              /*!< USBD_T::ATTR: L1SUSPEND Position       */
S#define USBD_ATTR_L1SUSPEND_Msk          (0x1ul << USBD_ATTR_L1SUSPEND_Pos)                /*!< USBD_T::ATTR: L1SUSPEND Mask           */
S
S#define USBD_ATTR_L1RESUME_Pos           (13)                                              /*!< USBD_T::ATTR: L1RESUME Position        */
S#define USBD_ATTR_L1RESUME_Msk           (0x1ul << USBD_ATTR_L1RESUME_Pos)                 /*!< USBD_T::ATTR: L1RESUME Mask            */
S
S#define USBD_VBUSDET_VBUSDET_Pos         (0)                                               /*!< USBD_T::VBUSDET: VBUSDET Position      */
S#define USBD_VBUSDET_VBUSDET_Msk         (0x1ul << USBD_VBUSDET_VBUSDET_Pos)               /*!< USBD_T::VBUSDET: VBUSDET Mask          */
S
S#define USBD_STBUFSEG_STBUFSEG_Pos       (3)                                               /*!< USBD_T::STBUFSEG: STBUFSEG Position    */
S#define USBD_STBUFSEG_STBUFSEG_Msk       (0x3ful << USBD_STBUFSEG_STBUFSEG_Pos)            /*!< USBD_T::STBUFSEG: STBUFSEG Mask        */
S
S#define USBD_LPMATTR_LPMLINKSTS_Pos      (0)                                               /*!< USBD_T::LPMATTR: LPMLINKSTS Position   */
S#define USBD_LPMATTR_LPMLINKSTS_Msk      (0xful << USBD_LPMATTR_LPMLINKSTS_Pos)            /*!< USBD_T::LPMATTR: LPMLINKSTS Mask       */
S
S#define USBD_LPMATTR_LPMBESL_Pos         (4)                                               /*!< USBD_T::LPMATTR: LPMBESL Position      */
S#define USBD_LPMATTR_LPMBESL_Msk         (0xful << USBD_LPMATTR_LPMBESL_Pos)               /*!< USBD_T::LPMATTR: LPMBESL Mask          */
S
S#define USBD_LPMATTR_LPMRWAKUP_Pos       (8)                                               /*!< USBD_T::LPMATTR: LPMRWAKUP Position    */
S#define USBD_LPMATTR_LPMRWAKUP_Msk       (0x1ul << USBD_LPMATTR_LPMRWAKUP_Pos)             /*!< USBD_T::LPMATTR: LPMRWAKUP Mask        */
S
S#define USBD_FN_FN_Pos                   (0)                                               /*!< USBD_T::FN: FN Position                */
S#define USBD_FN_FN_Msk                   (0x7fful << USBD_FN_FN_Pos)                       /*!< USBD_T::FN: FN Mask                    */
S
S#define USBD_SE0_SE0_Pos                 (0)                                               /*!< USBD_T::SE0: SE0 Position              */
S#define USBD_SE0_SE0_Msk                 (0x1ul << USBD_SE0_SE0_Pos)                       /*!< USBD_T::SE0: SE0 Mask                  */
S
S#define USBD_BUFSEG_BUFSEG_Pos          (3)                                                /*!< USBD_EP_T::BUFSEG: BUFSEG Position     */
S#define USBD_BUFSEG_BUFSEG_Msk          (0x3ful << USBD_BUFSEG_BUFSEG_Pos)                 /*!< USBD_EP_T::BUFSEG: BUFSEG Mask         */
S
S#define USBD_MXPLD_MXPLD_Pos            (0)                                                /*!< USBD_EP_T::MXPLD: MXPLD Position       */
S#define USBD_MXPLD_MXPLD_Msk            (0x1fful << USBD_MXPLD_MXPLD_Pos)                  /*!< USBD_EP_T::MXPLD: MXPLD Mask           */
S
S#define USBD_CFG_EPNUM_Pos              (0)                                                /*!< USBD_EP_T::CFG: EPNUM Position         */
S#define USBD_CFG_EPNUM_Msk              (0xful << USBD_CFG_EPNUM_Pos)                      /*!< USBD_EP_T::CFG: EPNUM Mask             */
S
S#define USBD_CFG_ISOCH_Pos              (4)                                                /*!< USBD_EP_T::CFG: ISOCH Position         */
S#define USBD_CFG_ISOCH_Msk              (0x1ul << USBD_CFG_ISOCH_Pos)                      /*!< USBD_EP_T::CFG: ISOCH Mask             */
S
S#define USBD_CFG_STATE_Pos              (5)                                                /*!< USBD_EP_T::CFG: STATE Position         */
S#define USBD_CFG_STATE_Msk              (0x3ul << USBD_CFG_STATE_Pos)                      /*!< USBD_EP_T::CFG: STATE Mask             */
S
S#define USBD_CFG_DSQSYNC_Pos            (7)                                                /*!< USBD_EP_T::CFG: DSQSYNC Position       */
S#define USBD_CFG_DSQSYNC_Msk            (0x1ul << USBD_CFG_DSQSYNC_Pos)                    /*!< USBD_EP_T::CFG: DSQSYNC Mask           */
S
S#define USBD_CFG_CSTALL_Pos             (9)                                                /*!< USBD_EP_T::CFG: CSTALL Position        */
S#define USBD_CFG_CSTALL_Msk             (0x1ul << USBD_CFG_CSTALL_Pos)                     /*!< USBD_EP_T::CFG: CSTALL Mask            */
S
S#define USBD_CFGP_CLRRDY_Pos            (0)                                                /*!< USBD_EP_T::CFGP: CLRRDY Position       */
S#define USBD_CFGP_CLRRDY_Msk            (0x1ul << USBD_CFGP_CLRRDY_Pos)                    /*!< USBD_EP_T::CFGP: CLRRDY Mask           */
S
S#define USBD_CFGP_SSTALL_Pos            (1)                                                /*!< USBD_EP_T::CFGP: SSTALL Position       */
S#define USBD_CFGP_SSTALL_Msk            (0x1ul << USBD_CFGP_SSTALL_Pos)                    /*!< USBD_EP_T::CFGP: SSTALL Mask           */
S
S
S/**@}*/ /* USBD_CONST */
S/**@}*/ /* end of USBD register group */
S
S
S/*---------------------- SPI Mode of USCI Controller -------------------------*/
S/**
S    @addtogroup USPI SPI Mode of USCI Controller(USPI)
S    Memory Mapped Structure for USPI Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var USPI_T::CTL
S     * Offset: 0x00  USCI Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2:0]   |FUNMODE   |Function Mode
S     * |        |          |This bit field selects the protocol for this USCI controller
S     * |        |          |Selecting a protocol that is not available or a reserved combination disables the USCI
S     * |        |          |When switching between two protocols, the USCI has to be disabled before selecting a new protocol
S     * |        |          |Simultaneously, the USCI will be reset when user write 000 to FUNMODE.
S     * |        |          |000 = The USCI is disabled. All protocol related state machines are set to idle state.
S     * |        |          |001 = The SPI protocol is selected.
S     * |        |          |010 = The UART protocol is selected.
S     * |        |          |100 = The I2C protocol is selected.
S     * |        |          |Note: Other bit combinations are reserved.
S     * @var USPI_T::INTEN
S     * Offset: 0x04  USCI Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |TXSTIEN   |Transmit Start Interrupt Enable Bit
S     * |        |          |This bit enables the interrupt generation in case of a transmit start event.
S     * |        |          |0 = The transmit start interrupt is disabled.
S     * |        |          |1 = The transmit start interrupt is enabled.
S     * |[2]     |TXENDIEN  |Transmit End Interrupt Enable Bit
S     * |        |          |This bit enables the interrupt generation in case of a transmit finish event.
S     * |        |          |0 = The transmit finish interrupt is disabled.
S     * |        |          |1 = The transmit finish interrupt is enabled.
S     * |[3]     |RXSTIEN   |Receive Start Interrupt Enable Bit
S     * |        |          |This bit enables the interrupt generation in case of a receive start event.
S     * |        |          |0 = The receive start interrupt is disabled.
S     * |        |          |1 = The receive start interrupt is enabled.
S     * |[4]     |RXENDIEN  |Receive End Interrupt Enable Bit
S     * |        |          |This bit enables the interrupt generation in case of a receive finish event.
S     * |        |          |0 = The receive end interrupt is disabled.
S     * |        |          |1 = The receive end interrupt is enabled.
S     * @var USPI_T::BRGEN
S     * Offset: 0x08  USCI Baud Rate Generator Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RCLKSEL   |Reference Clock Source Selection
S     * |        |          |This bit selects the source of reference clock (fREF_CLK).
S     * |        |          |0 = Peripheral device clock fPCLK.
S     * |        |          |1 = Reserved.
S     * |[1]     |PTCLKSEL  |Protocol Clock Source Selection
S     * |        |          |This bit selects the source of protocol clock (fPROT_CLK).
S     * |        |          |0 = Reference clock fREF_CLK.
S     * |        |          |1 = fREF_CLK2 (its frequency is half of fREF_CLK).
S     * |[3:2]   |SPCLKSEL  |Sample Clock Source Selection
S     * |        |          |This bit field used for the clock source selection of sample clock (fSAMP_CLK) for the protocol processor.
S     * |        |          |00 = fDIV_CLK.
S     * |        |          |01 = fPROT_CLK.
S     * |        |          |10 = fSCLK.
S     * |        |          |11 = fREF_CLK.
S     * |[4]     |TMCNTEN   |Time Measurement Counter Enable Bit
S     * |        |          |This bit enables the 10-bit timing measurement counter.
S     * |        |          |0 = Time measurement counter is Disabled.
S     * |        |          |1 = Time measurement counter is Enabled.
S     * |[5]     |TMCNTSRC  |Time Measurement Counter Clock Source Selection
S     * |        |          |0 = Time measurement counter with fPROT_CLK.
S     * |        |          |1 = Time measurement counter with fDIV_CLK.
S     * |[25:16] |CLKDIV    |Clock Divider
S     * |        |          |This bit field defines the ratio between the protocol clock frequency fPROT_CLK and the clock divider frequency fDIV_CLK (fDIV_CLK = fPROT_CLK / (CLKDIV+1) ).
S     * |        |          |Note: In UART function, it can be updated by hardware in the 4th falling edge of the input data 0x55 when the auto baud rate function (ABREN(USPI_PROTCTL[6])) is enabled
S     * |        |          |The revised value is the average bit time between bit 5 and bit 6
S     * |        |          |The user can use revised CLKDIV and new BRDETITV (USPI_PROTCTL[24:16]) to calculate the precise baud rate.
S     * @var USPI_T::DATIN0
S     * Offset: 0x10  USCI Input Data Signal Configuration Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SYNCSEL   |Input   Signal Synchronization Selection
S     * |        |          |This bit   selects if the un-synchronized input signal (with optionally inverted) or the   synchronized (and optionally filtered) signal can be used as input for the   data shift unit.
S     * |        |          |0 = The   un-synchronized signal can be taken as input for the data shift unit.
S     * |        |          |1 = The   synchronized signal can be taken as input for the data shift unit.
S     * |        |          |Note: In SPI protocol, we suggest this bit   should be set as 0.
S     * |[2]     |ININV     |Input   Signal Inverse Selection
S     * |        |          |This bit   defines the inverter enable of the input asynchronous signal.
S     * |        |          |0 = The   un-synchronized input signal will not be inverted.
S     * |        |          |1 = The   un-synchronized input signal will be inverted.
S     * |        |          |Note: In SPI protocol, we suggest this bit   should be set as 0.
S     * @var USPI_T::CTLIN0
S     * Offset: 0x20  USCI Input Control Signal Configuration Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SYNCSEL   |Input   Synchronization Signal Selection
S     * |        |          |This bit   selects if the un-synchronized input signal (with optionally inverted) or the   synchronized (and optionally filtered) signal can be used as input for the   data shift unit.
S     * |        |          |0 = The   un-synchronized signal can be taken as input for the data shift unit.
S     * |        |          |1 = The   synchronized signal can be taken as input for the data shift unit.
S     * |        |          |Note: In SPI protocol, we suggest this bit   should be set as 0.
S     * |[2]     |ININV     |Input   Signal Inverse Selection
S     * |        |          |This bit   defines the inverter enable of the input asynchronous signal.
S     * |        |          |0 = The   un-synchronized input signal will not be inverted.
S     * |        |          |1 = The   un-synchronized input signal will be inverted.
S     * @var USPI_T::CLKIN
S     * Offset: 0x28  USCI Input Clock Signal Configuration Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SYNCSEL   |Input   Synchronization Signal Selection
S     * |        |          |This bit   selects if the un-synchronized input signal or the synchronized (and   optionally filtered) signal can be used as input for the data shift unit.
S     * |        |          |0 = The   un-synchronized signal can be taken as input for the data shift unit.
S     * |        |          |1 = The   synchronized signal can be taken as input for the data shift unit.
S     * |        |          |Note: In SPI protocol, we suggest this bit   should be set as 0.
S     * @var USPI_T::LINECTL
S     * Offset: 0x2C  USCI Line Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |LSB       |LSB First Transmission Selection
S     * |        |          |0 = The MSB, which bit of transmit/receive data buffer depends on the setting of DWIDTH, is transmitted/received first.
S     * |        |          |1 = The LSB, the bit 0 of data buffer, will be transmitted/received first.
S     * |[5]     |DATOINV   |Data Output Inverse Selection
S     * |        |          |This bit defines the relation between the internal shift data value and the output data signal of USCIx_DAT0/1 pin.
S     * |        |          |0 = Data output level is not inverted.
S     * |        |          |1 = Data output level is inverted.
S     * |[7]     |CTLOINV   |Control Signal Output Inverse Selection
S     * |        |          |This bit defines the relation between the internal control signal and the output control signal.
S     * |        |          |0 = No effect.
S     * |        |          |1 = The control signal will be inverted before its output.
S     * |        |          |Note: The control signal has different definitions in different protocol
S     * |        |          |In SPI protocol, the control signal means slave select signal
S     * |[11:8]  |DWIDTH    |Word Length of Transmission
S     * |        |          |This bit field defines the data word length (amount of bits) for reception and transmission
S     * |        |          |The data word is always right-aligned in the data buffer
S     * |        |          |USCI support word length from 4 to 16 bits.
S     * |        |          |0x0: The data word contains 16 bits located at bit positions [15:0].
S     * |        |          |0x1: Reserved.
S     * |        |          |0x2: Reserved.
S     * |        |          |0x3: Reserved.
S     * |        |          |0x4: The data word contains 4 bits located at bit positions [3:0].
S     * |        |          |0x5: The data word contains 5 bits located at bit positions [4:0].
S     * |        |          |...
S     * |        |          |0xF: The data word contains 15 bits located at bit positions [14:0].
S     * @var USPI_T::TXDAT
S     * Offset: 0x30  USCI Transmit Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |TXDAT     |Transmit Data
S     * |        |          |Software can use this bit field to write 16-bit transmit data for transmission
S     * |        |          |In order to avoid overwriting the transmit data, user have to check TXEMPTY (USPI_BUFSTS[8]) status before writing transmit data into this bit field.
S     * |[16]    |PORTDIR   |Port Direction Control
S     * |        |          |This bit field is only available while USCI operates in SPI protocol (FUNMODE = 0x1) with half-duplex transfer
S     * |        |          |It is used to define the direction of the data port pin
S     * |        |          |When software writes USPI_TXDAT register, the transmit data and its port direction are settled simultaneously.
S     * |        |          |0 = The data pin is configured as output mode.
S     * |        |          |1 = The data pin is configured as input mode.
S     * @var USPI_T::RXDAT
S     * Offset: 0x34  USCI Receive Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RXDAT     |Received Data
S     * |        |          |This bit field monitors the received data which stored in receive data buffer.
S     * @var USPI_T::BUFCTL
S     * Offset: 0x38  USCI Transmit/Receive Buffer Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[6]     |TXUDRIEN  |Slave Transmit Under-run Interrupt Enable
S     * |        |          |0 = Transmit under-run interrupt Disabled.
S     * |        |          |1 = Transmit under-run interrupt Enabled.
S     * |[7]     |TXCLR     |Clear Transmit Buffer
S     * |        |          |0 = No effect.
S     * |        |          |1 = The transmit buffer is cleared
S     * |        |          |Should only be used while the buffer is not taking part in data traffic.
S     * |        |          |Note: It is cleared automatically after one PCLK cycle.
S     * |[14]    |RXOVIEN   |Receive Buffer Overrun Interrupt Enable Control
S     * |        |          |0 = Receive overrun interrupt Disabled.
S     * |        |          |1 = Receive overrun interrupt Enabled.
S     * |[15]    |RXCLR     |Clear Receive Buffer
S     * |        |          |0 = No effect.
S     * |        |          |1 = The receive buffer is cleared
S     * |        |          |Should only be used while the buffer is not taking part in data traffic.
S     * |        |          |Note: It is cleared automatically after one PCLK cycle.
S     * |[16]    |TXRST     |Transmit Reset
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset the transmit-related counters, state machine, and the content of transmit shift register and data buffer.
S     * |        |          |Note: It is cleared automatically after one PCLK cycle.
S     * |[17]    |RXRST     |Receive Reset
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset the receive-related counters, state machine, and the content of receive shift register and data buffer.
S     * |        |          |Note: It is cleared automatically after one PCLK cycle.
S     * @var USPI_T::BUFSTS
S     * Offset: 0x3C  USCI Transmit/Receive Buffer Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RXEMPTY   |Receive Buffer Empty Indicator
S     * |        |          |0 = Receive buffer is not empty.
S     * |        |          |1 = Receive buffer is empty.
S     * |[1]     |RXFULL    |Receive Buffer Full Indicator
S     * |        |          |0 = Receive buffer is not full.
S     * |        |          |1 = Receive buffer is full.
S     * |[3]     |RXOVIF    |Receive Buffer Overrun Interrupt Status
S     * |        |          |This bit indicates that a receive buffer overrun event has been detected
S     * |        |          |If RXOVIEN (USPI_BUFCTL[14]) is enabled, the corresponding interrupt request is activated
S     * |        |          |It is cleared by software writes 1 to this bit.
S     * |        |          |0 = A receive buffer overrun event has not been detected.
S     * |        |          |1 = A receive buffer overrun event has been detected.
S     * |[8]     |TXEMPTY   |Transmit Buffer Empty Indicator
S     * |        |          |0 = Transmit buffer is not empty.
S     * |        |          |1 = Transmit buffer is empty and available for the next transmission datum.
S     * |[9]     |TXFULL    |Transmit Buffer Full Indicator
S     * |        |          |0 = Transmit buffer is not full.
S     * |        |          |1 = Transmit buffer is full.
S     * |[11]    |TXUDRIF   |Transmit Buffer Under-run Interrupt Status
S     * |        |          |This bit indicates that a transmit buffer under-run event has been detected
S     * |        |          |If enabled by TXUDRIEN (USPI_BUFCTL[6]), the corresponding interrupt request is activated
S     * |        |          |It is cleared by software writes 1 to this bit
S     * |        |          |0 = A transmit buffer under-run event has not been detected.
S     * |        |          |1 = A transmit buffer under-run event has been detected.
S     * @var USPI_T::WKCTL
S     * Offset: 0x54  USCI Wake-up Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WKEN      |Wake-up Enable Bit
S     * |        |          |0 = Wake-up function Disabled.
S     * |        |          |1 = Wake-up function Enabled.
S     * |[1]     |WKADDREN  |Wake-up Address Match Enable Bit
S     * |        |          |0 = The chip is woken up according data toggle.
S     * |        |          |1 = The chip is woken up according address match.
S     * |[2]     |PDBOPT    |Power Down Blocking Option
S     * |        |          |0 = If user attempts to enter Power-down mode by executing WFI while the protocol is in transferring, MCU will stop the transfer and enter Power-down mode immediately.
S     * |        |          |1 = If user attempts to enter Power-down mode by executing WFI while the protocol is in transferring, the on-going transfer will not be stopped and MCU will enter idle mode immediately.
S     * @var USPI_T::WKSTS
S     * Offset: 0x58  USCI Wake-up Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WKF       |Wake-up Flag
S     * |        |          |When chip is woken up from Power-down mode, this bit is set to 1
S     * |        |          |Software can write 1 to clear this bit.
S     * @var USPI_T::PROTCTL
S     * Offset: 0x5C  USCI Protocol Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SLAVE     |Slave Mode Selection
S     * |        |          |0 = Master mode.
S     * |        |          |1 = Slave mode.
S     * |[1]     |SLV3WIRE  |Slave 3-wire Mode Selection (Slave Only)
S     * |        |          |The SPI protocol can work with 3-wire interface (without slave select signal) in Slave mode.
S     * |        |          |0 = 4-wire bi-direction interface.
S     * |        |          |1 = 3-wire bi-direction interface.
S     * |[2]     |SS        |Slave Select Control (Master Only)
S     * |        |          |If AUTOSS bit is cleared, setting this bit to 1 will set the slave select signal to active state, and setting this bit to 0 will set the slave select signal back to inactive state.
S     * |        |          |If the AUTOSS function is enabled (AUTOSS = 1), the setting value of this bit will not affect the current state of slave select signal.
S     * |        |          |Note: In SPI protocol, the internal slave select signal is active high.
S     * |[3]     |AUTOSS    |Automatic Slave Select Function Enable (Master Only)
S     * |        |          |0 = Slave select signal will be controlled by the setting value of SS (USPI_PROTCTL[2]) bit.
S     * |        |          |1 = Slave select signal will be generated automatically
S     * |        |          |The slave select signal will be asserted by the SPI controller when transmit/receive is started, and will be de-asserted after each transmit/receive is finished.
S     * |[7:6]   |SCLKMODE  |Serial Bus Clock Mode
S     * |        |          |This bit field defines the SCLK idle status, data transmit, and data receive edge.
S     * |        |          |MODE0 = The idle state of SPI clock is low level
S     * |        |          |Data is transmitted with falling edge and received with rising edge.
S     * |        |          |MODE1 = The idle state of SPI clock is low level
S     * |        |          |Data is transmitted with rising edge and received with falling edge.
S     * |        |          |MODE2 = The idle state of SPI clock is high level
S     * |        |          |Data is transmitted with rising edge and received with falling edge.
S     * |        |          |MODE3 = The idle state of SPI clock is high level
S     * |        |          |Data is transmitted with falling edge and received with rising edge.
S     * |[11:8]  |SUSPITV   |Suspend Interval (Master Only)
S     * |        |          |This bit field provides the configurable suspend interval between two successive transmit/receive transaction in a transfer
S     * |        |          |The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word and the first clock edge of the following transaction word
S     * |        |          |The default value is 0x3
S     * |        |          |The period of the suspend interval is obtained according to the following equation.
S     * |        |          |(SUSPITV[3:0] + 0.5) * period of SPI_CLK clock cycle
S     * |        |          |Example:
S     * |        |          |SUSPITV = 0x0 u2026. 0.5 SPI_CLK clock cycle.
S     * |        |          |SUSPITV = 0x1 u2026. 1.5 SPI_CLK clock cycle.
S     * |        |          |u2026u2026
S     * |        |          |SUSPITV = 0xE u2026. 14.5 SPI_CLK clock cycle.
S     * |        |          |SUSPITV = 0xF u2026. 15.5 SPI_CLK clock cycle.
S     * |[14:12] |TSMSEL    |Transmit Data Mode Selection
S     * |        |          |This bit field describes how receive and transmit data is shifted in and out.
S     * |        |          |TSMSEL = 000b: Full-duplex SPI.
S     * |        |          |TSMSEL = 100b: Half-duplex SPI.
S     * |        |          |Other values are reserved.
S     * |        |          |Note: Changing the value of this bit field will produce the TXRST and RXRST to clear the TX/RX data buffer automatically.
S     * |[25:16] |SLVTOCNT  |Slave Mode Time-out Period (Slave Only)
S     * |        |          |In Slave mode, this bit field is used for Slave time-out period
S     * |        |          |This bit field indicates how many clock periods (selected by TMCNTSRC, USPI_BRGEN[5]) between the two edges of input SCLK will assert the Slave time-out event
S     * |        |          |Writing 0x0 into this bit field will disable the Slave time-out function.
S     * |        |          |Example: Assume SLVTOCNT is 0x0A and TMCNTSRC (USPI_BRGEN[5]) is 1, it means the time-out event will occur if the state of SPI bus clock pin is not changed more than (10+1) periods of fDIV_CLK.
S     * |[28]    |TXUDRPOL  |Transmit Under-run Data Polarity (for Slave)
S     * |        |          |This bit defines the transmitting data level when no data is available for transferring.
S     * |        |          |0 = The output data level is 0 if TX under-run event occurs.
S     * |        |          |1 = The output data level is 1 if TX under-run event occurs.
S     * |[31]    |PROTEN    |SPI Protocol Enable
S     * |        |          |0 = SPI Protocol Disabled.
S     * |        |          |1 = SPI Protocol Enabled.
S     * @var USPI_T::PROTIEN
S     * Offset: 0x60  USCI Protocol Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SSINAIEN  |Slave Select Inactive Interrupt Enable Control
S     * |        |          |This bit enables/disables the generation of a slave select interrupt if the slave select changes to inactive.
S     * |        |          |0 = Slave select inactive interrupt generation Disabled.
S     * |        |          |1 = Slave select inactive interrupt generation Enabled.
S     * |[1]     |SSACTIEN  |Slave Select Active Interrupt Enable Control
S     * |        |          |This bit enables/disables the generation of a slave select interrupt if the slave select changes to active.
S     * |        |          |0 = Slave select active interrupt generation Disabled.
S     * |        |          |1 = Slave select active interrupt generation Enabled.
S     * |[2]     |SLVTOIEN  |Slave Time-out Interrupt Enable Control
S     * |        |          |In SPI protocol, this bit enables the interrupt generation in case of a Slave time-out event.
S     * |        |          |0 = The Slave time-out interrupt Disabled.
S     * |        |          |1 = The Slave time-out interrupt Enabled.
S     * |[3]     |SLVBEIEN  |Slave Mode Bit Count Error Interrupt Enable Control
S     * |        |          |If data transfer is terminated by slave time-out or slave select inactive event in Slave mode, so that the transmit/receive data bit count does not match the setting of DWIDTH (USPI_LINECTL[11:8])
S     * |        |          |Bit count error event occurs.
S     * |        |          |0 = The Slave mode bit count error interrupt Disabled.
S     * |        |          |1 = The Slave mode bit count error interrupt Enabled.
S     * @var USPI_T::PROTSTS
S     * Offset: 0x64  USCI Protocol Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |TXSTIF    |Transmit Start Interrupt Flag
S     * |        |          |0 = Transmit start event does not occur.
S     * |        |          |1 = Transmit start event occurs.
S     * |        |          |Note: It is cleared by software writes 1 to this bit
S     * |[2]     |TXENDIF   |Transmit End Interrupt Flag
S     * |        |          |0 = Transmit end event does not occur.
S     * |        |          |1 = Transmit end event occurs.
S     * |        |          |Note: It is cleared by software writes 1 to this bit
S     * |[3]     |RXSTIF    |Receive Start Interrupt Flag
S     * |        |          |0 = Receive start event does not occur.
S     * |        |          |1 = Receive start event occurs.
S     * |        |          |Note: It is cleared by software writes 1 to this bit
S     * |[4]     |RXENDIF   |Receive End Interrupt Flag
S     * |        |          |0 = Receive end event does not occur.
S     * |        |          |1 = Receive end event occurs.
S     * |        |          |Note: It is cleared by software writes 1 to this bit
S     * |[5]     |SLVTOIF   |Slave Time-out Interrupt Flag (for Slave Only)
S     * |        |          |0 = Slave time-out event does not occur.
S     * |        |          |1 = Slave time-out event occurs.
S     * |        |          |Note: It is cleared by software writes 1 to this bit
S     * |[6]     |SLVBEIF   |Slave Bit Count Error Interrupt Flag (for Slave Only)
S     * |        |          |0 = Slave bit count error event does not occur.
S     * |        |          |1 = Slave bit count error event occurs.
S     * |        |          |Note: It is cleared by software writes 1 to this bit.
S     * |[8]     |SSINAIF   |Slave Select Inactive Interrupt Flag (for Slave Only)
S     * |        |          |This bit indicates that the internal slave select signal has changed to inactive
S     * |        |          |It is cleared by software writes 1 to this bit
S     * |        |          |0 = The slave select signal has not changed to inactive.
S     * |        |          |1 = The slave select signal has changed to inactive.
S     * |        |          |Note: The internal slave select signal is active high.
S     * |[9]     |SSACTIF   |Slave Select Active Interrupt Flag (for Slave Only)
S     * |        |          |This bit indicates that the internal slave select signal has changed to active
S     * |        |          |It is cleared by software writes one to this bit
S     * |        |          |0 = The slave select signal has not changed to active.
S     * |        |          |1 = The slave select signal has changed to active.
S     * |        |          |Note: The internal slave select signal is active high.
S     * |[16]    |SSLINE    |Slave Select Line Bus Status (Read Only)
S     * |        |          |This bit is only available in Slave mode
S     * |        |          |It used to monitor the current status of the input slave select signal on the bus.
S     * |        |          |0 = The slave select line status is 0.
S     * |        |          |1 = The slave select line status is 1.
S     * |[17]    |BUSY      |Busy Status (Read Only)
S     * |        |          |0 = SPI is in idle state.
S     * |        |          |1 = SPI is in busy state.
S     * |        |          |The following listing are the bus busy conditions:
S     * |        |          |a. USPI_PROTCTL[31] = 1 and the TXEMPTY = 0.
S     * |        |          |b. For SPI Master mode, the TXEMPTY = 1 but the current transaction is not finished yet.
S     * |        |          |c
S     * |        |          |For SPI Slave mode, the USPI_PROTCTL[31] = 1 and there is serial clock input into the SPI core logic when slave select is active.
S     * |        |          |d
S     * |        |          |For SPI Slave mode, the USPI_PROTCTL[31] = 1 and the transmit buffer or transmit shift register is not empty even if the slave select is inactive.
S     * |[18]    |SLVUDR    |Slave Mode Transmit Under-run Status (Read Only)
S     * |        |          |In Slave mode, if there is no available transmit data in buffer while transmit data shift out caused by input serial bus clock, this status flag will be set to 1
S     * |        |          |This bit indicates whether the current shift-out data of word transmission is switched to TXUDRPOL (USPI_PROTCTL[28]) or not.
S     * |        |          |0 = Slave transmit under-run event does not occur.
S     * |        |          |1 = Slave transmit under-run event occurs.
S     */
S    __IO uint32_t CTL;                   /*!< [0x0000] USCI Control Register                                            */
S    __IO uint32_t INTEN;                 /*!< [0x0004] USCI Interrupt Enable Register                                   */
S    __IO uint32_t BRGEN;                 /*!< [0x0008] USCI Baud Rate Generator Register                                */
S    __I  uint32_t RESERVE0[1];
S    __IO uint32_t DATIN0;                /*!< [0x0010] USCI Input Data Signal Configuration Register 0                  */
S    __I  uint32_t RESERVE1[3];
S    __IO uint32_t CTLIN0;                /*!< [0x0020] USCI Input Control Signal Configuration Register 0               */
S    __I  uint32_t RESERVE2[1];
S    __IO uint32_t CLKIN;                 /*!< [0x0028] USCI Input Clock Signal Configuration Register                   */
S    __IO uint32_t LINECTL;               /*!< [0x002c] USCI Line Control Register                                       */
S    __O  uint32_t TXDAT;                 /*!< [0x0030] USCI Transmit Data Register                                      */
S    __I  uint32_t RXDAT;                 /*!< [0x0034] USCI Receive Data Register                                       */
S    __IO uint32_t BUFCTL;                /*!< [0x0038] USCI Transmit/Receive Buffer Control Register                    */
S    __IO uint32_t BUFSTS;                /*!< [0x003c] USCI Transmit/Receive Buffer Status Register                     */
S    __I  uint32_t RESERVE3[5];
S    __IO uint32_t WKCTL;                 /*!< [0x0054] USCI Wake-up Control Register                                    */
S    __IO uint32_t WKSTS;                 /*!< [0x0058] USCI Wake-up Status Register                                     */
S    __IO uint32_t PROTCTL;               /*!< [0x005c] USCI Protocol Control Register                                   */
S    __IO uint32_t PROTIEN;               /*!< [0x0060] USCI Protocol Interrupt Enable Register                          */
S    __IO uint32_t PROTSTS;               /*!< [0x0064] USCI Protocol Status Register                                    */
S
S} USPI_T;
S
S/**
S    @addtogroup USPI_CONST USPI Bit Field Definition
S    Constant Definitions for USPI Controller
S@{ */
S
S#define USPI_CTL_FUNMODE_Pos             (0)                                               /*!< USPI_T::CTL: FUNMODE Position          */
S#define USPI_CTL_FUNMODE_Msk             (0x7ul << USPI_CTL_FUNMODE_Pos)                   /*!< USPI_T::CTL: FUNMODE Mask              */
S
S#define USPI_INTEN_TXSTIEN_Pos           (1)                                               /*!< USPI_T::INTEN: TXSTIEN Position        */
S#define USPI_INTEN_TXSTIEN_Msk           (0x1ul << USPI_INTEN_TXSTIEN_Pos)                 /*!< USPI_T::INTEN: TXSTIEN Mask            */
S
S#define USPI_INTEN_TXENDIEN_Pos          (2)                                               /*!< USPI_T::INTEN: TXENDIEN Position       */
S#define USPI_INTEN_TXENDIEN_Msk          (0x1ul << USPI_INTEN_TXENDIEN_Pos)                /*!< USPI_T::INTEN: TXENDIEN Mask           */
S
S#define USPI_INTEN_RXSTIEN_Pos           (3)                                               /*!< USPI_T::INTEN: RXSTIEN Position        */
S#define USPI_INTEN_RXSTIEN_Msk           (0x1ul << USPI_INTEN_RXSTIEN_Pos)                 /*!< USPI_T::INTEN: RXSTIEN Mask            */
S
S#define USPI_INTEN_RXENDIEN_Pos          (4)                                               /*!< USPI_T::INTEN: RXENDIEN Position       */
S#define USPI_INTEN_RXENDIEN_Msk          (0x1ul << USPI_INTEN_RXENDIEN_Pos)                /*!< USPI_T::INTEN: RXENDIEN Mask           */
S
S#define USPI_BRGEN_RCLKSEL_Pos           (0)                                               /*!< USPI_T::BRGEN: RCLKSEL Position        */
S#define USPI_BRGEN_RCLKSEL_Msk           (0x1ul << USPI_BRGEN_RCLKSEL_Pos)                 /*!< USPI_T::BRGEN: RCLKSEL Mask            */
S
S#define USPI_BRGEN_PTCLKSEL_Pos          (1)                                               /*!< USPI_T::BRGEN: PTCLKSEL Position       */
S#define USPI_BRGEN_PTCLKSEL_Msk          (0x1ul << USPI_BRGEN_PTCLKSEL_Pos)                /*!< USPI_T::BRGEN: PTCLKSEL Mask           */
S
S#define USPI_BRGEN_SPCLKSEL_Pos          (2)                                               /*!< USPI_T::BRGEN: SPCLKSEL Position       */
S#define USPI_BRGEN_SPCLKSEL_Msk          (0x3ul << USPI_BRGEN_SPCLKSEL_Pos)                /*!< USPI_T::BRGEN: SPCLKSEL Mask           */
S
S#define USPI_BRGEN_TMCNTEN_Pos           (4)                                               /*!< USPI_T::BRGEN: TMCNTEN Position        */
S#define USPI_BRGEN_TMCNTEN_Msk           (0x1ul << USPI_BRGEN_TMCNTEN_Pos)                 /*!< USPI_T::BRGEN: TMCNTEN Mask            */
S
S#define USPI_BRGEN_TMCNTSRC_Pos          (5)                                               /*!< USPI_T::BRGEN: TMCNTSRC Position       */
S#define USPI_BRGEN_TMCNTSRC_Msk          (0x1ul << USPI_BRGEN_TMCNTSRC_Pos)                /*!< USPI_T::BRGEN: TMCNTSRC Mask           */
S
S#define USPI_BRGEN_CLKDIV_Pos            (16)                                              /*!< USPI_T::BRGEN: CLKDIV Position         */
S#define USPI_BRGEN_CLKDIV_Msk            (0x3fful << USPI_BRGEN_CLKDIV_Pos)                /*!< USPI_T::BRGEN: CLKDIV Mask             */
S
S#define USPI_DATIN0_SYNCSEL_Pos          (0)                                               /*!< USPI_T::DATIN0: SYNCSEL Position       */
S#define USPI_DATIN0_SYNCSEL_Msk          (0x1ul << USPI_DATIN0_SYNCSEL_Pos)                /*!< USPI_T::DATIN0: SYNCSEL Mask           */
S
S#define USPI_DATIN0_ININV_Pos            (2)                                               /*!< USPI_T::DATIN0: ININV Position         */
S#define USPI_DATIN0_ININV_Msk            (0x1ul << USPI_DATIN0_ININV_Pos)                  /*!< USPI_T::DATIN0: ININV Mask             */
S
S#define USPI_CTLIN0_SYNCSEL_Pos          (0)                                               /*!< USPI_T::CTLIN0: SYNCSEL Position       */
S#define USPI_CTLIN0_SYNCSEL_Msk          (0x1ul << USPI_CTLIN0_SYNCSEL_Pos)                /*!< USPI_T::CTLIN0: SYNCSEL Mask           */
S
S#define USPI_CTLIN0_ININV_Pos            (2)                                               /*!< USPI_T::CTLIN0: ININV Position         */
S#define USPI_CTLIN0_ININV_Msk            (0x1ul << USPI_CTLIN0_ININV_Pos)                  /*!< USPI_T::CTLIN0: ININV Mask             */
S
S#define USPI_CLKIN_SYNCSEL_Pos           (0)                                               /*!< USPI_T::CLKIN: SYNCSEL Position        */
S#define USPI_CLKIN_SYNCSEL_Msk           (0x1ul << USPI_CLKIN_SYNCSEL_Pos)                 /*!< USPI_T::CLKIN: SYNCSEL Mask            */
S
S#define USPI_LINECTL_LSB_Pos             (0)                                               /*!< USPI_T::LINECTL: LSB Position          */
S#define USPI_LINECTL_LSB_Msk             (0x1ul << USPI_LINECTL_LSB_Pos)                   /*!< USPI_T::LINECTL: LSB Mask              */
S
S#define USPI_LINECTL_DATOINV_Pos         (5)                                               /*!< USPI_T::LINECTL: DATOINV Position      */
S#define USPI_LINECTL_DATOINV_Msk         (0x1ul << USPI_LINECTL_DATOINV_Pos)               /*!< USPI_T::LINECTL: DATOINV Mask          */
S
S#define USPI_LINECTL_CTLOINV_Pos         (7)                                               /*!< USPI_T::LINECTL: CTLOINV Position      */
S#define USPI_LINECTL_CTLOINV_Msk         (0x1ul << USPI_LINECTL_CTLOINV_Pos)               /*!< USPI_T::LINECTL: CTLOINV Mask          */
S
S#define USPI_LINECTL_DWIDTH_Pos          (8)                                               /*!< USPI_T::LINECTL: DWIDTH Position       */
S#define USPI_LINECTL_DWIDTH_Msk          (0xful << USPI_LINECTL_DWIDTH_Pos)                /*!< USPI_T::LINECTL: DWIDTH Mask           */
S
S#define USPI_TXDAT_TXDAT_Pos             (0)                                               /*!< USPI_T::TXDAT: TXDAT Position          */
S#define USPI_TXDAT_TXDAT_Msk             (0xfffful << USPI_TXDAT_TXDAT_Pos)                /*!< USPI_T::TXDAT: TXDAT Mask              */
S
S#define USPI_TXDAT_PORTDIR_Pos           (16)                                              /*!< USPI_T::TXDAT: PORTDIR Position        */
S#define USPI_TXDAT_PORTDIR_Msk           (0x1ul << USPI_TXDAT_PORTDIR_Pos)                 /*!< USPI_T::TXDAT: PORTDIR Mask            */
S
S#define USPI_RXDAT_RXDAT_Pos             (0)                                               /*!< USPI_T::RXDAT: RXDAT Position          */
S#define USPI_RXDAT_RXDAT_Msk             (0xfffful << USPI_RXDAT_RXDAT_Pos)                /*!< USPI_T::RXDAT: RXDAT Mask              */
S
S#define USPI_BUFCTL_TXUDRIEN_Pos         (6)                                               /*!< USPI_T::BUFCTL: TXUDRIEN Position      */
S#define USPI_BUFCTL_TXUDRIEN_Msk         (0x1ul << USPI_BUFCTL_TXUDRIEN_Pos)               /*!< USPI_T::BUFCTL: TXUDRIEN Mask          */
S
S#define USPI_BUFCTL_TXCLR_Pos            (7)                                               /*!< USPI_T::BUFCTL: TXCLR Position         */
S#define USPI_BUFCTL_TXCLR_Msk            (0x1ul << USPI_BUFCTL_TXCLR_Pos)                  /*!< USPI_T::BUFCTL: TXCLR Mask             */
S
S#define USPI_BUFCTL_RXOVIEN_Pos          (14)                                              /*!< USPI_T::BUFCTL: RXOVIEN Position       */
S#define USPI_BUFCTL_RXOVIEN_Msk          (0x1ul << USPI_BUFCTL_RXOVIEN_Pos)                /*!< USPI_T::BUFCTL: RXOVIEN Mask           */
S
S#define USPI_BUFCTL_RXCLR_Pos            (15)                                              /*!< USPI_T::BUFCTL: RXCLR Position         */
S#define USPI_BUFCTL_RXCLR_Msk            (0x1ul << USPI_BUFCTL_RXCLR_Pos)                  /*!< USPI_T::BUFCTL: RXCLR Mask             */
S
S#define USPI_BUFCTL_TXRST_Pos            (16)                                              /*!< USPI_T::BUFCTL: TXRST Position         */
S#define USPI_BUFCTL_TXRST_Msk            (0x1ul << USPI_BUFCTL_TXRST_Pos)                  /*!< USPI_T::BUFCTL: TXRST Mask             */
S
S#define USPI_BUFCTL_RXRST_Pos            (17)                                              /*!< USPI_T::BUFCTL: RXRST Position         */
S#define USPI_BUFCTL_RXRST_Msk            (0x1ul << USPI_BUFCTL_RXRST_Pos)                  /*!< USPI_T::BUFCTL: RXRST Mask             */
S
S#define USPI_BUFSTS_RXEMPTY_Pos          (0)                                               /*!< USPI_T::BUFSTS: RXEMPTY Position       */
S#define USPI_BUFSTS_RXEMPTY_Msk          (0x1ul << USPI_BUFSTS_RXEMPTY_Pos)                /*!< USPI_T::BUFSTS: RXEMPTY Mask           */
S
S#define USPI_BUFSTS_RXFULL_Pos           (1)                                               /*!< USPI_T::BUFSTS: RXFULL Position        */
S#define USPI_BUFSTS_RXFULL_Msk           (0x1ul << USPI_BUFSTS_RXFULL_Pos)                 /*!< USPI_T::BUFSTS: RXFULL Mask            */
S
S#define USPI_BUFSTS_RXOVIF_Pos           (3)                                               /*!< USPI_T::BUFSTS: RXOVIF Position        */
S#define USPI_BUFSTS_RXOVIF_Msk           (0x1ul << USPI_BUFSTS_RXOVIF_Pos)                 /*!< USPI_T::BUFSTS: RXOVIF Mask            */
S
S#define USPI_BUFSTS_TXEMPTY_Pos          (8)                                               /*!< USPI_T::BUFSTS: TXEMPTY Position       */
S#define USPI_BUFSTS_TXEMPTY_Msk          (0x1ul << USPI_BUFSTS_TXEMPTY_Pos)                /*!< USPI_T::BUFSTS: TXEMPTY Mask           */
S
S#define USPI_BUFSTS_TXFULL_Pos           (9)                                               /*!< USPI_T::BUFSTS: TXFULL Position        */
S#define USPI_BUFSTS_TXFULL_Msk           (0x1ul << USPI_BUFSTS_TXFULL_Pos)                 /*!< USPI_T::BUFSTS: TXFULL Mask            */
S
S#define USPI_BUFSTS_TXUDRIF_Pos          (11)                                              /*!< USPI_T::BUFSTS: TXUDRIF Position       */
S#define USPI_BUFSTS_TXUDRIF_Msk          (0x1ul << USPI_BUFSTS_TXUDRIF_Pos)                /*!< USPI_T::BUFSTS: TXUDRIF Mask           */
S
S#define USPI_WKCTL_WKEN_Pos              (0)                                               /*!< USPI_T::WKCTL: WKEN Position           */
S#define USPI_WKCTL_WKEN_Msk              (0x1ul << USPI_WKCTL_WKEN_Pos)                    /*!< USPI_T::WKCTL: WKEN Mask               */
S
S#define USPI_WKCTL_WKADDREN_Pos          (1)                                               /*!< USPI_T::WKCTL: WKADDREN Position       */
S#define USPI_WKCTL_WKADDREN_Msk          (0x1ul << USPI_WKCTL_WKADDREN_Pos)                /*!< USPI_T::WKCTL: WKADDREN Mask           */
S
S#define USPI_WKCTL_PDBOPT_Pos            (2)                                               /*!< USPI_T::WKCTL: PDBOPT Position         */
S#define USPI_WKCTL_PDBOPT_Msk            (0x1ul << USPI_WKCTL_PDBOPT_Pos)                  /*!< USPI_T::WKCTL: PDBOPT Mask             */
S
S#define USPI_WKSTS_WKF_Pos               (0)                                               /*!< USPI_T::WKSTS: WKF Position            */
S#define USPI_WKSTS_WKF_Msk               (0x1ul << USPI_WKSTS_WKF_Pos)                     /*!< USPI_T::WKSTS: WKF Mask                */
S
S#define USPI_PROTCTL_SLAVE_Pos           (0)                                               /*!< USPI_T::PROTCTL: SLAVE Position        */
S#define USPI_PROTCTL_SLAVE_Msk           (0x1ul << USPI_PROTCTL_SLAVE_Pos)                 /*!< USPI_T::PROTCTL: SLAVE Mask            */
S
S#define USPI_PROTCTL_SLV3WIRE_Pos        (1)                                               /*!< USPI_T::PROTCTL: SLV3WIRE Position     */
S#define USPI_PROTCTL_SLV3WIRE_Msk        (0x1ul << USPI_PROTCTL_SLV3WIRE_Pos)              /*!< USPI_T::PROTCTL: SLV3WIRE Mask         */
S
S#define USPI_PROTCTL_SS_Pos              (2)                                               /*!< USPI_T::PROTCTL: SS Position           */
S#define USPI_PROTCTL_SS_Msk              (0x1ul << USPI_PROTCTL_SS_Pos)                    /*!< USPI_T::PROTCTL: SS Mask               */
S
S#define USPI_PROTCTL_AUTOSS_Pos          (3)                                               /*!< USPI_T::PROTCTL: AUTOSS Position       */
S#define USPI_PROTCTL_AUTOSS_Msk          (0x1ul << USPI_PROTCTL_AUTOSS_Pos)                /*!< USPI_T::PROTCTL: AUTOSS Mask           */
S
S#define USPI_PROTCTL_SCLKMODE_Pos        (6)                                               /*!< USPI_T::PROTCTL: SCLKMODE Position     */
S#define USPI_PROTCTL_SCLKMODE_Msk        (0x3ul << USPI_PROTCTL_SCLKMODE_Pos)              /*!< USPI_T::PROTCTL: SCLKMODE Mask         */
S
S#define USPI_PROTCTL_SUSPITV_Pos         (8)                                               /*!< USPI_T::PROTCTL: SUSPITV Position      */
S#define USPI_PROTCTL_SUSPITV_Msk         (0xful << USPI_PROTCTL_SUSPITV_Pos)               /*!< USPI_T::PROTCTL: SUSPITV Mask          */
S
S#define USPI_PROTCTL_TSMSEL_Pos          (12)                                              /*!< USPI_T::PROTCTL: TSMSEL Position       */
S#define USPI_PROTCTL_TSMSEL_Msk          (0x7ul << USPI_PROTCTL_TSMSEL_Pos)                /*!< USPI_T::PROTCTL: TSMSEL Mask           */
S
S#define USPI_PROTCTL_SLVTOCNT_Pos        (16)                                              /*!< USPI_T::PROTCTL: SLVTOCNT Position     */
S#define USPI_PROTCTL_SLVTOCNT_Msk        (0x3fful << USPI_PROTCTL_SLVTOCNT_Pos)            /*!< USPI_T::PROTCTL: SLVTOCNT Mask         */
S
S#define USPI_PROTCTL_TXUDRPOL_Pos        (28)                                              /*!< USPI_T::PROTCTL: TXUDRPOL Position     */
S#define USPI_PROTCTL_TXUDRPOL_Msk        (0x1ul << USPI_PROTCTL_TXUDRPOL_Pos)              /*!< USPI_T::PROTCTL: TXUDRPOL Mask         */
S
S#define USPI_PROTCTL_PROTEN_Pos          (31)                                              /*!< USPI_T::PROTCTL: PROTEN Position       */
S#define USPI_PROTCTL_PROTEN_Msk          (0x1ul << USPI_PROTCTL_PROTEN_Pos)                /*!< USPI_T::PROTCTL: PROTEN Mask           */
S
S#define USPI_PROTIEN_SSINAIEN_Pos        (0)                                               /*!< USPI_T::PROTIEN: SSINAIEN Position     */
S#define USPI_PROTIEN_SSINAIEN_Msk        (0x1ul << USPI_PROTIEN_SSINAIEN_Pos)              /*!< USPI_T::PROTIEN: SSINAIEN Mask         */
S
S#define USPI_PROTIEN_SSACTIEN_Pos        (1)                                               /*!< USPI_T::PROTIEN: SSACTIEN Position     */
S#define USPI_PROTIEN_SSACTIEN_Msk        (0x1ul << USPI_PROTIEN_SSACTIEN_Pos)              /*!< USPI_T::PROTIEN: SSACTIEN Mask         */
S
S#define USPI_PROTIEN_SLVTOIEN_Pos        (2)                                               /*!< USPI_T::PROTIEN: SLVTOIEN Position     */
S#define USPI_PROTIEN_SLVTOIEN_Msk        (0x1ul << USPI_PROTIEN_SLVTOIEN_Pos)              /*!< USPI_T::PROTIEN: SLVTOIEN Mask         */
S
S#define USPI_PROTIEN_SLVBEIEN_Pos        (3)                                               /*!< USPI_T::PROTIEN: SLVBEIEN Position     */
S#define USPI_PROTIEN_SLVBEIEN_Msk        (0x1ul << USPI_PROTIEN_SLVBEIEN_Pos)              /*!< USPI_T::PROTIEN: SLVBEIEN Mask         */
S
S#define USPI_PROTSTS_TXSTIF_Pos          (1)                                               /*!< USPI_T::PROTSTS: TXSTIF Position       */
S#define USPI_PROTSTS_TXSTIF_Msk          (0x1ul << USPI_PROTSTS_TXSTIF_Pos)                /*!< USPI_T::PROTSTS: TXSTIF Mask           */
S
S#define USPI_PROTSTS_TXENDIF_Pos         (2)                                               /*!< USPI_T::PROTSTS: TXENDIF Position      */
S#define USPI_PROTSTS_TXENDIF_Msk         (0x1ul << USPI_PROTSTS_TXENDIF_Pos)               /*!< USPI_T::PROTSTS: TXENDIF Mask          */
S
S#define USPI_PROTSTS_RXSTIF_Pos          (3)                                               /*!< USPI_T::PROTSTS: RXSTIF Position       */
S#define USPI_PROTSTS_RXSTIF_Msk          (0x1ul << USPI_PROTSTS_RXSTIF_Pos)                /*!< USPI_T::PROTSTS: RXSTIF Mask           */
S
S#define USPI_PROTSTS_RXENDIF_Pos         (4)                                               /*!< USPI_T::PROTSTS: RXENDIF Position      */
S#define USPI_PROTSTS_RXENDIF_Msk         (0x1ul << USPI_PROTSTS_RXENDIF_Pos)               /*!< USPI_T::PROTSTS: RXENDIF Mask          */
S
S#define USPI_PROTSTS_SLVTOIF_Pos         (5)                                               /*!< USPI_T::PROTSTS: SLVTOIF Position      */
S#define USPI_PROTSTS_SLVTOIF_Msk         (0x1ul << USPI_PROTSTS_SLVTOIF_Pos)               /*!< USPI_T::PROTSTS: SLVTOIF Mask          */
S
S#define USPI_PROTSTS_SLVBEIF_Pos         (6)                                               /*!< USPI_T::PROTSTS: SLVBEIF Position      */
S#define USPI_PROTSTS_SLVBEIF_Msk         (0x1ul << USPI_PROTSTS_SLVBEIF_Pos)               /*!< USPI_T::PROTSTS: SLVBEIF Mask          */
S
S#define USPI_PROTSTS_SSINAIF_Pos         (8)                                               /*!< USPI_T::PROTSTS: SSINAIF Position      */
S#define USPI_PROTSTS_SSINAIF_Msk         (0x1ul << USPI_PROTSTS_SSINAIF_Pos)               /*!< USPI_T::PROTSTS: SSINAIF Mask          */
S
S#define USPI_PROTSTS_SSACTIF_Pos         (9)                                               /*!< USPI_T::PROTSTS: SSACTIF Position      */
S#define USPI_PROTSTS_SSACTIF_Msk         (0x1ul << USPI_PROTSTS_SSACTIF_Pos)               /*!< USPI_T::PROTSTS: SSACTIF Mask          */
S
S#define USPI_PROTSTS_SSLINE_Pos          (16)                                              /*!< USPI_T::PROTSTS: SSLINE Position       */
S#define USPI_PROTSTS_SSLINE_Msk          (0x1ul << USPI_PROTSTS_SSLINE_Pos)                /*!< USPI_T::PROTSTS: SSLINE Mask           */
S
S#define USPI_PROTSTS_BUSY_Pos            (17)                                              /*!< USPI_T::PROTSTS: BUSY Position         */
S#define USPI_PROTSTS_BUSY_Msk            (0x1ul << USPI_PROTSTS_BUSY_Pos)                  /*!< USPI_T::PROTSTS: BUSY Mask             */
S
S#define USPI_PROTSTS_SLVUDR_Pos          (18)                                              /*!< USPI_T::PROTSTS: SLVUDR Position       */
S#define USPI_PROTSTS_SLVUDR_Msk          (0x1ul << USPI_PROTSTS_SLVUDR_Pos)                /*!< USPI_T::PROTSTS: SLVUDR Mask           */
S
S/**@}*/ /* USPI_CONST */
S/**@}*/ /* end of USPI register group */
S
S
S/*---------------------- UART Mode of USCI Controller -------------------------*/
S/**
S    @addtogroup UUART UART Mode of USCI Controller(UUART)
S    Memory Mapped Structure for UUART Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var UUART_T::CTL
S     * Offset: 0x00  USCI Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2:0]   |FUNMODE   |Function Mode
S     * |        |          |This bit field selects the protocol for this USCI controller.
S     * |        |          |Selecting a protocol that is not available or a reserved combination disables the USCI.
S     * |        |          |When switching between two protocols, the USCI has to be disabled before selecting a new protocol.
S     * |        |          |Simultaneously, the USCI will be reset when user write 000 to FUNMODE.
S     * |        |          |000 = The USCI is disabled. All protocol related state machines are set to idle state.
S     * |        |          |001 = The SPI protocol is selected.
S     * |        |          |010 = The UART protocol is selected.
S     * |        |          |100 = The I2C protocol is selected.
S     * |        |          |Note: Other bit combinations are reserved.
S     * @var UUART_T::INTEN
S     * Offset: 0x04  USCI Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |TXSTIEN   |Transmit Start Interrupt Enable Bit
S     * |        |          |This bit enables the interrupt generation in case of a transmit start event.
S     * |        |          |0 = The transmit start interrupt is disabled.
S     * |        |          |1 = The transmit start interrupt is enabled.
S     * |[2]     |TXENDIEN  |Transmit End Interrupt Enable Bit
S     * |        |          |This bit enables the interrupt generation in case of a transmit finish event.
S     * |        |          |0 = The transmit finish interrupt is disabled.
S     * |        |          |1 = The transmit finish interrupt is enabled.
S     * |[3]     |RXSTIEN   |Receive Start Interrupt Enable Bit
S     * |        |          |This bit enables the interrupt generation in case of a receive start event.
S     * |        |          |0 = The receive start interrupt is disabled.
S     * |        |          |1 = The receive start interrupt is enabled.
S     * |[4]     |RXENDIEN  |Receive End Interrupt Enable Bit
S     * |        |          |This bit enables the interrupt generation in case of a receive finish event.
S     * |        |          |0 = The receive end interrupt is disabled.
S     * |        |          |1 = The receive end interrupt is enabled.
S     * @var UUART_T::BRGEN
S     * Offset: 0x08  USCI Baud Rate Generator Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RCLKSEL   |Reference Clock Source Selection
S     * |        |          |This bit selects the source signal of reference clock (fREF_CLK).
S     * |        |          |0 = Peripheral device clock fPCLK.
S     * |        |          |1 = Reserved.
S     * |[1]     |PTCLKSEL  |Protocol Clock Source Selection
S     * |        |          |This bit selects the source signal of protocol clock (fPROT_CLK).
S     * |        |          |0 = Reference clock fREF_CLK.
S     * |        |          |1 = fREF_CLK2 (its frequency is half of fREF_CLK).
S     * |[3:2]   |SPCLKSEL  |Sample Clock Source Selection
S     * |        |          |This bit field used for the clock source selection of a sample clock (fSAMP_CLK) for the protocol processor.
S     * |        |          |00 = fSAMP_CLK = fDIV_CLK.
S     * |        |          |01 = fSAMP_CLK = fPROT_CLK.
S     * |        |          |10 = fSAMP_CLK = fSCLK.
S     * |        |          |11 = fSAMP_CLK = fREF_CLK.
S     * |[4]     |TMCNTEN   |Timing Measurement Counter Enable Bit
S     * |        |          |This bit enables the 10-bit timing measurement counter.
S     * |        |          |0 = Timing measurement counter is Disabled.
S     * |        |          |1 = Timing measurement counter is Enabled.
S     * |[5]     |TMCNTSRC  |Timing Measurement Counter Clock Source Selection
S     * |        |          |0 = Timing measurement counter with fPROT_CLK.
S     * |        |          |1 = Timing measurement counter with fDIV_CLK.
S     * |[9:8]   |PDSCNT    |Pre-divider for Sample Counter
S     * |        |          |This bit field defines the divide ratio of the clock division from sample clock fSAMP_CLK.
S     * |        |          |The divided frequency fPDS_CNT = fSAMP_CLK / (PDSCNT+1).
S     * |[14:10] |DSCNT     |Denominator for Sample Counter
S     * |        |          |This bit field defines the divide ratio of the sample clock fSAMP_CLK.
S     * |        |          |The divided frequency fDS_CNT = fPDS_CNT / (DSCNT+1).
S     * |        |          |Note: The maximum value of DSCNT is 0xF on UART mode and suggest to set over 4 to confirm the receiver data is sampled in right value
S     * |[25:16] |CLKDIV    |Clock Divider
S     * |        |          |This bit field defines the ratio between the protocol clock frequency fPROT_CLK and the clock divider frequency fDIV_CLK (fDIV_CLK = fPROT_CLK / (CLKDIV+1) ).
S     * |        |          |Note: In UART function, it can be updated by hardware in the 4th falling edge of the input data 0x55 when the auto baud rate function (ABREN(UUART_PROTCTL[6])) is enabled.
S     * |        |          |The revised value is the average bit time between bit 5 and bit 6.
S     * |        |          |The user can use revised CLKDIV and new BRDETITV (UUART_PROTCTL[24:16]) to calculate the precise baud rate.
S     * @var UUART_T::DATIN0
S     * Offset: 0x10  USCI Input Data Signal Configuration Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SYNCSEL   |Input Signal Synchronization Selection
S     * |        |          |This bit selects if the un-synchronized input signal (with optionally inverted) or the synchronized (and optionally filtered) signal can be used as input for the data shift unit.
S     * |        |          |0 = The un-synchronized signal can be taken as input for the data shift unit.
S     * |        |          |1 = The synchronized signal can be taken as input for the data shift unit.
S     * |[2]     |ININV     |Input Signal Inverse Selection
S     * |        |          |This bit defines the inverter enable of the input asynchronous signal.
S     * |        |          |0 = The un-synchronized input signal will not be inverted.
S     * |        |          |1 = The un-synchronized input signal will be inverted.
S     * |[4:3]   |EDGEDET   |Input Signal Edge Detection Mode
S     * |        |          |This bit field selects which edge actives the trigger event of input data signal.
S     * |        |          |00 = The trigger event activation is disabled.
S     * |        |          |01 = A rising edge activates the trigger event of input data signal.
S     * |        |          |10 = A falling edge activates the trigger event of input data signal.
S     * |        |          |11 = Both edges activate the trigger event of input data signal.
S     * |        |          |Note: In UART function mode, it is suggested to set this bit field as 10.
S     * @var UUART_T::CTLIN0
S     * Offset: 0x20  USCI Input Control Signal Configuration Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SYNCSEL   |Input Synchronization Signal Selection
S     * |        |          |This bit selects if the un-synchronized input signal (with optionally inverted) or the synchronized (and optionally filtered) signal can be used as input for the data shift unit.
S     * |        |          |0 = The un-synchronized signal can be taken as input for the data shift unit.
S     * |        |          |1 = The synchronized signal can be taken as input for the data shift unit.
S     * |[2]     |ININV     |Input Signal Inverse Selection
S     * |        |          |This bit defines the inverter enable of the input asynchronous signal.
S     * |        |          |0 = The un-synchronized input signal will not be inverted.
S     * |        |          |1 = The un-synchronized input signal will be inverted.
S     * @var UUART_T::CLKIN
S     * Offset: 0x28  USCI Input Clock Signal Configuration Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SYNCSEL   |Input Synchronization Signal Selection
S     * |        |          |This bit selects if the un-synchronized input signal or the synchronized (and optionally filtered) signal can be used as input for the data shift unit.
S     * |        |          |0 = The un-synchronized signal can be taken as input for the data shift unit.
S     * |        |          |1 = The synchronized signal can be taken as input for the data shift unit.
S     * @var UUART_T::LINECTL
S     * Offset: 0x2C  USCI Line Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |LSB       |LSB First Transmission Selection
S     * |        |          |0 = The MSB, which bit of transmit/receive data buffer depends on the setting of DWIDTH, is transmitted/received first.
S     * |        |          |1 = The LSB, the bit 0 of data buffer, will be transmitted/received first.
S     * |[5]     |DATOINV   |Data Output Inverse Selection
S     * |        |          |This bit defines the relation between the internal shift data value and the output data signal of USCIx_DAT1 pin.
S     * |        |          |0 = The value of USCIx_DAT1 is equal to the data shift register.
S     * |        |          |1 = The value of USCIx_DAT1 is the inversion of data shift register.
S     * |[7]     |CTLOINV   |Control Signal Output Inverse Selection
S     * |        |          |This bit defines the relation between the internal control signal and the output control signal.
S     * |        |          |0 = No effect.
S     * |        |          |1 = The control signal will be inverted before its output.
S     * |        |          |Note: In UART protocol, the control signal means nRTS signal.
S     * |[11:8]  |DWIDTH    |Word Length of Transmission
S     * |        |          |This bit field defines the data word length (amount of bits) for reception and transmission.
S     * |        |          |The data word is always right-aligned in the data buffer.
S     * |        |          |USCI support word length from 4 to 16 bits.
S     * |        |          |0x0: The data word contains 16 bits located at bit positions [15:0].
S     * |        |          |0x1: Reserved.
S     * |        |          |0x2: Reserved.
S     * |        |          |0x3: Reserved.
S     * |        |          |0x4: The data word contains 4 bits located at bit positions [3:0].
S     * |        |          |0x5: The data word contains 5 bits located at bit positions [4:0].
S     * |        |          |...
S     * |        |          |0xF: The data word contains 15 bits located at bit positions [14:0].
S     * |        |          |Note: In UART protocol, the length can be configured as 6~13 bits.
S     * @var UUART_T::TXDAT
S     * Offset: 0x30  USCI Transmit Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |TXDAT     |Transmit Data
S     * |        |          |Software can use this bit field to write 16-bit transmit data for transmission.
S     * @var UUART_T::RXDAT
S     * Offset: 0x34  USCI Receive Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RXDAT     |Received Data
S     * |        |          |This bit field monitors the received data which stored in receive data buffer.
S     * |        |          |Note: RXDAT[15:13] indicate the same frame status of BREAK, FRMERR and PARITYERR (UUART_PROTSTS[7:5]).
S     * @var UUART_T::BUFCTL
S     * Offset: 0x38  USCI Transmit/Receive Buffer Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7]     |TXCLR     |Clear Transmit Buffer
S     * |        |          |0 = No effect.
S     * |        |          |1 = The transmit buffer is cleared (filling level is cleared and output pointer is set to input pointer value).
S     * |        |          |Should only be used while the buffer is not taking part in data traffic.
S     * |        |          |Note: It is cleared automatically after one PCLK cycle.
S     * |[14]    |RXOVIEN   |Receive Buffer Overrun Error Interrupt Enable Control
S     * |        |          |0 = Receive overrun interrupt Disabled.
S     * |        |          |1 = Receive overrun interrupt Enabled.
S     * |[15]    |RXCLR     |Clear Receive Buffer
S     * |        |          |0 = No effect.
S     * |        |          |1 = The receive buffer is cleared (filling level is cleared and output pointer is set to input pointer value).
S     * |        |          |Should only be used while the buffer is not taking part in data traffic.
S     * |        |          |Note: It is cleared automatically after one PCLK cycle.
S     * |[16]    |TXRST     |Transmit Reset
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset the transmit-related counters, state machine, and the content of transmit shift register and data buffer.
S     * |        |          |Note: It is cleared automatically after one PCLK cycle.
S     * |[17]    |RXRST     |Receive Reset
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset the receive-related counters, state machine, and the content of receive shift register and data buffer.
S     * |        |          |Note 1: It is cleared automatically after one PCLK cycle.
S     * |        |          |Note 2: It is suggest to check the RXBUSY (UUART_PROTSTS[10]) before this bit will be set to 1.
S     * @var UUART_T::BUFSTS
S     * Offset: 0x3C  USCI Transmit/Receive Buffer Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RXEMPTY   |Receive Buffer Empty Indicator
S     * |        |          |0 = Receive buffer is not empty.
S     * |        |          |1 = Receive buffer is empty.
S     * |[1]     |RXFULL    |Receive Buffer Full Indicator
S     * |        |          |0 = Receive buffer is not full.
S     * |        |          |1 = Receive buffer is full.
S     * |[3]     |RXOVIF    |Receive Buffer Over-run Error Interrupt Status
S     * |        |          |This bit indicates that a receive buffer overrun error event has been detected.
S     * |        |          |If RXOVIEN (UUART_BUFCTL[14]) is enabled, the corresponding interrupt request is activated.
S     * |        |          |It is cleared by software writes 1 to this bit.
S     * |        |          |0 = A receive buffer overrun error event has not been detected.
S     * |        |          |1 = A receive buffer overrun error event has been detected.
S     * |[8]     |TXEMPTY   |Transmit Buffer Empty Indicator
S     * |        |          |0 = Transmit buffer is not empty.
S     * |        |          |1 = Transmit buffer is empty.
S     * |[9]     |TXFULL    |Transmit Buffer Full Indicator
S     * |        |          |0 = Transmit buffer is not full.
S     * |        |          |1 = Transmit buffer is full.
S     * @var UUART_T::WKCTL
S     * Offset: 0x54  USCI Wake-up Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WKEN      |Wake-up Enable Bit
S     * |        |          |0 = Wake-up function Disabled.
S     * |        |          |1 = Wake-up function Enabled.
S     * |[2]     |PDBOPT    |Power Down Blocking Option
S     * |        |          |0 = If user attempts to enter Power-down mode by executing WFI while the protocol is in transferring, MCU will stop the transfer and enter Power-down mode immediately.
S     * |        |          |1 = If user attempts to enter Power-down mode by executing WFI while the protocol is in transferring, the on-going transfer will not be stopped and MCU will enter idle mode immediately.
S     * @var UUART_T::WKSTS
S     * Offset: 0x58  USCI Wake-up Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WKF       |Wake-up Flag
S     * |        |          |When chip is woken up from Power-down mode, this bit is set to 1.
S     * |        |          |Software can write 1 to clear this bit.
S     * @var UUART_T::PROTCTL
S     * Offset: 0x5C  USCI Protocol Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |STOPB     |Stop Bits
S     * |        |          |This bit defines the number of stop bits in an UART frame.
S     * |        |          |0 = The number of stop bits is 1.
S     * |        |          |1 = The number of stop bits is 2.
S     * |[1]     |PARITYEN  |Parity Enable Bit
S     * |        |          |This bit defines the parity bit is enabled in an UART frame.
S     * |        |          |0 = The parity bit Disabled.
S     * |        |          |1 = The parity bit Enabled.
S     * |[2]     |EVENPARITY|Even Parity Enable Bit
S     * |        |          |0 = Odd number of logic 1 is transmitted and checked in each word.
S     * |        |          |1 = Even number of logic 1 is transmitted and checked in each word.
S     * |        |          |Note: This bit has effect only when PARITYEN is set.
S     * |[3]     |RTSAUTOEN |nRTS Auto-flow Control Enable
S     * |        |          |When nRTS auto-flow is enabled, if the receiver buffer is full (RXFULL (UUART_BUFSTS[1] = 1)), the UART will de-assert nRTS signal.
S     * |        |          |0 = nRTS auto-flow control Disabled.
S     * |        |          |1 = nRTS auto-flow control Enabled.
S     * |        |          |Note: This bit has effect only when the RTSAUDIREN is not set.
S     * |[4]     |CTSAUTOEN |nCTS Auto-flow Control Enable Bit
S     * |        |          |When nCTS auto-flow is enabled, the UART will send data to external device when nCTS input assert (UART will not send data to device if nCTS input is dis-asserted).
S     * |        |          |0 = nCTS auto-flow control Disabled.
S     * |        |          |1 = nCTS auto-flow control Enabled.
S     * |[5]     |RTSAUDIREN|nRTS Auto Direction Enable Bit
S     * |        |          |When nRTS auto direction is enabled, if the transmitted bytes in the TX buffer is empty, the UART will reassert nRTS signal.
S     * |        |          |0 = nRTS auto direction control Disabled.
S     * |        |          |1 = nRTS auto direction control Enabled.
S     * |        |          |Note 1: This bit is used for nRTS auto direction control for RS485.
S     * |        |          |Note 2: This bit has effect only when the RTSAUTOEN is not set.
S     * |[6]     |ABREN     |Auto-baud Rate Detect Enable Bit
S     * |        |          |0 = Auto-baud rate detect function Disabled.
S     * |        |          |1 = Auto-baud rate detect function Enabled.
S     * |        |          |Note: When the auto-baud rate detect operation finishes, hardware will clear this bit.
S     * |        |          |The associated interrupt ABRDETIF (USCI_PROTST[9]) will be generated (If ARBIEN (UUART_PROTIEN [1]) is enabled).
S     * |[9]     |DATWKEN   |Data Wake-up Mode Enable Bit
S     * |        |          |0 = Data wake-up mode Disabled.
S     * |        |          |1 = Data wake-up mode Enabled.
S     * |[10]    |CTSWKEN   |nCTS Wake-up Mode Enable Bit
S     * |        |          |0 = nCTS wake-up mode Disabled.
S     * |        |          |1 = nCTS wake-up mode Enabled.
S     * |[14:11] |WAKECNT   |Wake-up Counter
S     * |        |          |These bits field indicate how many clock cycle selected by fPDS_CNT do the slave can get the 1st bit (start bit) when the device is wake-up from Power-down mode.
S     * |[24:16] |BRDETITV  |Baud Rate Detection Interval
S     * |        |          |This bit fields indicate how many clock cycle selected by TMCNTSRC (UUART_BRGEN [5]) does the slave calculates the baud rate in one bits.
S     * |        |          |The order of the bus shall be 1 and 0 step by step (e.g. the input data pattern shall be 0x55).
S     * |        |          |The user can read the value to know the current input baud rate of the bus whenever the ABRDETIF (UUART_PROTCTL[9]) is set.
S     * |        |          |Note: This bit can be cleared to 0 by software writing 1 to the BRDETITV.
S     * |[26]    |STICKEN   |Stick Parity Enable Bit
S     * |        |          |0 = Stick parity Disabled.
S     * |        |          |1 = Stick parity Enabled.
S     * |[29]    |BCEN      |Transmit Break Control Enable Bit
S     * |        |          |0 = Transmit Break Control Disabled.
S     * |        |          |1 = Transmit Break Control Enabled.
S     * |        |          |Note: When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0).
S     * |        |          |This bit acts only on TX line and has no effect on the transmitter logic.
S     * |[31]    |PROTEN    |UART Protocol Enable Bit
S     * |        |          |0 = UART Protocol Disabled.
S     * |        |          |1 = UART Protocol Enabled.
S     * @var UUART_T::PROTIEN
S     * Offset: 0x60  USCI Protocol Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |ABRIEN    |Auto-baud Rate Interrupt Enable Bit
S     * |        |          |0 = Auto-baud rate interrupt Disabled.
S     * |        |          |1 = Auto-baud rate interrupt Enabled.
S     * |[2]     |RLSIEN    |Receive Line Status Interrupt Enable Bit
S     * |        |          |0 = Receive line status interrupt Disabled.
S     * |        |          |1 = Receive line status interrupt Enabled.
S     * |        |          |Note: UUART_PROTSTS[7:5] indicates the current interrupt event for receive line status interrupt.
S     * @var UUART_T::PROTSTS
S     * Offset: 0x64  USCI Protocol Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |TXSTIF    |Transmit Start Interrupt Flag
S     * |        |          |0 = A transmit start interrupt status has not occurred.
S     * |        |          |1 = A transmit start interrupt status has occurred.
S     * |        |          |Note 1: It is cleared by software writing one into this bit.
S     * |        |          |Note 2: Used for user to load next transmit data when there is no data in transmit buffer.
S     * |[2]     |TXENDIF   |Transmit End Interrupt Flag
S     * |        |          |0 = A transmit end interrupt status has not occurred.
S     * |        |          |1 = A transmit end interrupt status has occurred.
S     * |        |          |Note: It is cleared by software writing one into this bit.
S     * |[3]     |RXSTIF    |Receive Start Interrupt Flag
S     * |        |          |0 = A receive start interrupt status has not occurred.
S     * |        |          |1 = A receive start interrupt status has occurred.
S     * |        |          |Note: It is cleared by software writing one into this bit.
S     * |[4]     |RXENDIF   |Receive End Interrupt Flag
S     * |        |          |0 = A receive finish interrupt status has not occurred.
S     * |        |          |1 = A receive finish interrupt status has occurred.
S     * |        |          |Note: It is cleared by software writing one into this bit.
S     * |[5]     |PARITYERR |Parity Error Flag
S     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid parity bit.
S     * |        |          |0 = No parity error is generated.
S     * |        |          |1 = Parity error is generated.
S     * |        |          |Note: This bit can be cleared by write 1 among the BREAK, FRMERR and PARITYERR bits.
S     * |[6]     |FRMERR    |Framing Error Flag
S     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid stop bit (that is, the stop bit following the last data bit or parity bit is detected as logic 0).
S     * |        |          |0 = No framing error is generated.
S     * |        |          |1 = Framing error is generated.
S     * |        |          |Note: This bit can be cleared by write 1 among the BREAK, FRMERR and PARITYERR bits.
S     * |[7]     |BREAK     |Break Flag
S     * |        |          |This bit is set to logic 1 whenever the received data input (RX) is held in the spacing state (logic 0) for longer than a full word transmission time (that is, the total time of "start bit + data bits + parity + stop bits").
S     * |        |          |0 = No Break is generated.
S     * |        |          |1 = Break is generated in the receiver bus.
S     * |        |          |Note: This bit can be cleared by write 1 among the BREAK, FRMERR and PARITYERR bits.
S     * |[9]     |ABRDETIF  |Auto-baud Rate Interrupt Flag
S     * |        |          |This bit is set when auto-baud rate detection is done among the falling edge of the input data.
S     * |        |          |If the ABRIEN (UUART_PROTCTL[6]) is set, the auto-baud rate interrupt will be generated.
S     * |        |          |This bit can be set 4 times when the input data pattern is 0x55 and it is cleared before the next falling edge of the input bus.
S     * |        |          |0 = Auto-baud rate detect function is not done.
S     * |        |          |1 = One Bit auto-baud rate detect function is done.
S     * |        |          |Note: This bit can be cleared by writing 1 to it.
S     * |[10]    |RXBUSY    |RX Bus Status Flag (Read Only)
S     * |        |          |This bit indicates the busy status of the receiver.
S     * |        |          |0 = The receiver is Idle.
S     * |        |          |1 = The receiver is BUSY.
S     * |[11]    |ABERRSTS  |Auto-baud Rate Error Status
S     * |        |          |This bit is set when auto-baud rate detection counter overrun.
S     * |        |          |When the auto-baud rate counter overrun, the user shall revise the CLKDIV (UUART_BRGEN[25:16]) value and enable ABREN (UUART_PROTCTL[6]) to detect the correct baud rate again.
S     * |        |          |0 = Auto-baud rate detect counter is not overrun.
S     * |        |          |1 = Auto-baud rate detect counter is overrun.
S     * |        |          |Note 1: This bit is set at the same time of ABRDETIF.
S     * |        |          |Note 2: This bit can be cleared by writing 1 to ABRDETIF or ABERRSTS.
S     * |[16]    |CTSSYNCLV |nCTS Synchronized Level Status (Read Only)
S     * |        |          |This bit used to indicate the current status of the internal synchronized nCTS signal.
S     * |        |          |0 = The internal synchronized nCTS is low.
S     * |        |          |1 = The internal synchronized nCTS is high.
S     * |[17]    |CTSLV     |nCTS Pin Status (Read Only)
S     * |        |          |This bit used to monitor the current status of nCTS pin input.
S     * |        |          |0 = nCTS pin input is low level voltage logic state.
S     * |        |          |1 = nCTS pin input is high level voltage logic state.
S     */
S    __IO uint32_t CTL;                   /*!< [0x0000] USCI Control Register                                            */
S    __IO uint32_t INTEN;                 /*!< [0x0004] USCI Interrupt Enable Register                                   */
S    __IO uint32_t BRGEN;                 /*!< [0x0008] USCI Baud Rate Generator Register                                */
S    __I  uint32_t RESERVE0[1];
S    __IO uint32_t DATIN0;                /*!< [0x0010] USCI Input Data Signal Configuration Register 0                  */
S    __I  uint32_t RESERVE1[3];
S    __IO uint32_t CTLIN0;                /*!< [0x0020] USCI Input Control Signal Configuration Register 0               */
S    __I  uint32_t RESERVE2[1];
S    __IO uint32_t CLKIN;                 /*!< [0x0028] USCI Input Clock Signal Configuration Register                   */
S    __IO uint32_t LINECTL;               /*!< [0x002c] USCI Line Control Register                                       */
S    __O  uint32_t TXDAT;                 /*!< [0x0030] USCI Transmit Data Register                                      */
S    __I  uint32_t RXDAT;                 /*!< [0x0034] USCI Receive Data Register                                       */
S    __IO uint32_t BUFCTL;                /*!< [0x0038] USCI Transmit/Receive Buffer Control Register                    */
S    __IO uint32_t BUFSTS;                /*!< [0x003c] USCI Transmit/Receive Buffer Status Register                     */
S    __I  uint32_t RESERVE3[5];
S    __IO uint32_t WKCTL;                 /*!< [0x0054] USCI Wake-up Control Register                                    */
S    __IO uint32_t WKSTS;                 /*!< [0x0058] USCI Wake-up Status Register                                     */
S    __IO uint32_t PROTCTL;               /*!< [0x005c] USCI Protocol Control Register                                   */
S    __IO uint32_t PROTIEN;               /*!< [0x0060] USCI Protocol Interrupt Enable Register                          */
S    __IO uint32_t PROTSTS;               /*!< [0x0064] USCI Protocol Status Register                                    */
S
S} UUART_T;
S
S/**
S    @addtogroup UUART_CONST UUART Bit Field Definition
S    Constant Definitions for UUART Controller
S@{ */
S
S#define UUART_CTL_FUNMODE_Pos            (0)                                               /*!< UUART_T::CTL: FUNMODE Position         */
S#define UUART_CTL_FUNMODE_Msk            (0x7ul << UUART_CTL_FUNMODE_Pos)                  /*!< UUART_T::CTL: FUNMODE Mask             */
S
S#define UUART_INTEN_TXSTIEN_Pos          (1)                                               /*!< UUART_T::INTEN: TXSTIEN Position       */
S#define UUART_INTEN_TXSTIEN_Msk          (0x1ul << UUART_INTEN_TXSTIEN_Pos)                /*!< UUART_T::INTEN: TXSTIEN Mask           */
S
S#define UUART_INTEN_TXENDIEN_Pos         (2)                                               /*!< UUART_T::INTEN: TXENDIEN Position      */
S#define UUART_INTEN_TXENDIEN_Msk         (0x1ul << UUART_INTEN_TXENDIEN_Pos)               /*!< UUART_T::INTEN: TXENDIEN Mask          */
S
S#define UUART_INTEN_RXSTIEN_Pos          (3)                                               /*!< UUART_T::INTEN: RXSTIEN Position       */
S#define UUART_INTEN_RXSTIEN_Msk          (0x1ul << UUART_INTEN_RXSTIEN_Pos)                /*!< UUART_T::INTEN: RXSTIEN Mask           */
S
S#define UUART_INTEN_RXENDIEN_Pos         (4)                                               /*!< UUART_T::INTEN: RXENDIEN Position      */
S#define UUART_INTEN_RXENDIEN_Msk         (0x1ul << UUART_INTEN_RXENDIEN_Pos)               /*!< UUART_T::INTEN: RXENDIEN Mask          */
S
S#define UUART_BRGEN_RCLKSEL_Pos          (0)                                               /*!< UUART_T::BRGEN: RCLKSEL Position       */
S#define UUART_BRGEN_RCLKSEL_Msk          (0x1ul << UUART_BRGEN_RCLKSEL_Pos)                /*!< UUART_T::BRGEN: RCLKSEL Mask           */
S
S#define UUART_BRGEN_PTCLKSEL_Pos         (1)                                               /*!< UUART_T::BRGEN: PTCLKSEL Position      */
S#define UUART_BRGEN_PTCLKSEL_Msk         (0x1ul << UUART_BRGEN_PTCLKSEL_Pos)               /*!< UUART_T::BRGEN: PTCLKSEL Mask          */
S
S#define UUART_BRGEN_SPCLKSEL_Pos         (2)                                               /*!< UUART_T::BRGEN: SPCLKSEL Position      */
S#define UUART_BRGEN_SPCLKSEL_Msk         (0x3ul << UUART_BRGEN_SPCLKSEL_Pos)               /*!< UUART_T::BRGEN: SPCLKSEL Mask          */
S
S#define UUART_BRGEN_TMCNTEN_Pos          (4)                                               /*!< UUART_T::BRGEN: TMCNTEN Position       */
S#define UUART_BRGEN_TMCNTEN_Msk          (0x1ul << UUART_BRGEN_TMCNTEN_Pos)                /*!< UUART_T::BRGEN: TMCNTEN Mask           */
S
S#define UUART_BRGEN_TMCNTSRC_Pos         (5)                                               /*!< UUART_T::BRGEN: TMCNTSRC Position      */
S#define UUART_BRGEN_TMCNTSRC_Msk         (0x1ul << UUART_BRGEN_TMCNTSRC_Pos)               /*!< UUART_T::BRGEN: TMCNTSRC Mask          */
S
S#define UUART_BRGEN_PDSCNT_Pos           (8)                                               /*!< UUART_T::BRGEN: PDSCNT Position        */
S#define UUART_BRGEN_PDSCNT_Msk           (0x3ul << UUART_BRGEN_PDSCNT_Pos)                 /*!< UUART_T::BRGEN: PDSCNT Mask            */
S
S#define UUART_BRGEN_DSCNT_Pos            (10)                                              /*!< UUART_T::BRGEN: DSCNT Position         */
S#define UUART_BRGEN_DSCNT_Msk            (0x1ful << UUART_BRGEN_DSCNT_Pos)                 /*!< UUART_T::BRGEN: DSCNT Mask             */
S
S#define UUART_BRGEN_CLKDIV_Pos           (16)                                              /*!< UUART_T::BRGEN: CLKDIV Position        */
S#define UUART_BRGEN_CLKDIV_Msk           (0x3fful << UUART_BRGEN_CLKDIV_Pos)               /*!< UUART_T::BRGEN: CLKDIV Mask            */
S
S#define UUART_DATIN0_SYNCSEL_Pos         (0)                                               /*!< UUART_T::DATIN0: SYNCSEL Position      */
S#define UUART_DATIN0_SYNCSEL_Msk         (0x1ul << UUART_DATIN0_SYNCSEL_Pos)               /*!< UUART_T::DATIN0: SYNCSEL Mask          */
S
S#define UUART_DATIN0_ININV_Pos           (2)                                               /*!< UUART_T::DATIN0: ININV Position        */
S#define UUART_DATIN0_ININV_Msk           (0x1ul << UUART_DATIN0_ININV_Pos)                 /*!< UUART_T::DATIN0: ININV Mask            */
S
S#define UUART_DATIN0_EDGEDET_Pos         (3)                                               /*!< UUART_T::DATIN0: EDGEDET Position      */
S#define UUART_DATIN0_EDGEDET_Msk         (0x3ul << UUART_DATIN0_EDGEDET_Pos)               /*!< UUART_T::DATIN0: EDGEDET Mask          */
S
S#define UUART_CTLIN0_SYNCSEL_Pos         (0)                                               /*!< UUART_T::CTLIN0: SYNCSEL Position      */
S#define UUART_CTLIN0_SYNCSEL_Msk         (0x1ul << UUART_CTLIN0_SYNCSEL_Pos)               /*!< UUART_T::CTLIN0: SYNCSEL Mask          */
S
S#define UUART_CTLIN0_ININV_Pos           (2)                                               /*!< UUART_T::CTLIN0: ININV Position        */
S#define UUART_CTLIN0_ININV_Msk           (0x1ul << UUART_CTLIN0_ININV_Pos)                 /*!< UUART_T::CTLIN0: ININV Mask            */
S
S#define UUART_CLKIN_SYNCSEL_Pos          (0)                                               /*!< UUART_T::CLKIN: SYNCSEL Position       */
S#define UUART_CLKIN_SYNCSEL_Msk          (0x1ul << UUART_CLKIN_SYNCSEL_Pos)                /*!< UUART_T::CLKIN: SYNCSEL Mask           */
S
S#define UUART_LINECTL_LSB_Pos            (0)                                               /*!< UUART_T::LINECTL: LSB Position         */
S#define UUART_LINECTL_LSB_Msk            (0x1ul << UUART_LINECTL_LSB_Pos)                  /*!< UUART_T::LINECTL: LSB Mask             */
S
S#define UUART_LINECTL_DATOINV_Pos        (5)                                               /*!< UUART_T::LINECTL: DATOINV Position     */
S#define UUART_LINECTL_DATOINV_Msk        (0x1ul << UUART_LINECTL_DATOINV_Pos)              /*!< UUART_T::LINECTL: DATOINV Mask         */
S
S#define UUART_LINECTL_CTLOINV_Pos        (7)                                               /*!< UUART_T::LINECTL: CTLOINV Position     */
S#define UUART_LINECTL_CTLOINV_Msk        (0x1ul << UUART_LINECTL_CTLOINV_Pos)              /*!< UUART_T::LINECTL: CTLOINV Mask         */
S
S#define UUART_LINECTL_DWIDTH_Pos         (8)                                               /*!< UUART_T::LINECTL: DWIDTH Position      */
S#define UUART_LINECTL_DWIDTH_Msk         (0xful << UUART_LINECTL_DWIDTH_Pos)               /*!< UUART_T::LINECTL: DWIDTH Mask          */
S
S#define UUART_TXDAT_TXDAT_Pos            (0)                                               /*!< UUART_T::TXDAT: TXDAT Position         */
S#define UUART_TXDAT_TXDAT_Msk            (0xfffful << UUART_TXDAT_TXDAT_Pos)               /*!< UUART_T::TXDAT: TXDAT Mask             */
S
S#define UUART_RXDAT_RXDAT_Pos            (0)                                               /*!< UUART_T::RXDAT: RXDAT Position         */
S#define UUART_RXDAT_RXDAT_Msk            (0xfffful << UUART_RXDAT_RXDAT_Pos)               /*!< UUART_T::RXDAT: RXDAT Mask             */
S
S#define UUART_BUFCTL_TXCLR_Pos           (7)                                               /*!< UUART_T::BUFCTL: TXCLR Position        */
S#define UUART_BUFCTL_TXCLR_Msk           (0x1ul << UUART_BUFCTL_TXCLR_Pos)                 /*!< UUART_T::BUFCTL: TXCLR Mask            */
S
S#define UUART_BUFCTL_RXOVIEN_Pos         (14)                                              /*!< UUART_T::BUFCTL: RXOVIEN Position      */
S#define UUART_BUFCTL_RXOVIEN_Msk         (0x1ul << UUART_BUFCTL_RXOVIEN_Pos)               /*!< UUART_T::BUFCTL: RXOVIEN Mask          */
S
S#define UUART_BUFCTL_RXCLR_Pos           (15)                                              /*!< UUART_T::BUFCTL: RXCLR Position        */
S#define UUART_BUFCTL_RXCLR_Msk           (0x1ul << UUART_BUFCTL_RXCLR_Pos)                 /*!< UUART_T::BUFCTL: RXCLR Mask            */
S
S#define UUART_BUFCTL_TXRST_Pos           (16)                                              /*!< UUART_T::BUFCTL: TXRST Position        */
S#define UUART_BUFCTL_TXRST_Msk           (0x1ul << UUART_BUFCTL_TXRST_Pos)                 /*!< UUART_T::BUFCTL: TXRST Mask            */
S
S#define UUART_BUFCTL_RXRST_Pos           (17)                                              /*!< UUART_T::BUFCTL: RXRST Position        */
S#define UUART_BUFCTL_RXRST_Msk           (0x1ul << UUART_BUFCTL_RXRST_Pos)                 /*!< UUART_T::BUFCTL: RXRST Mask            */
S
S#define UUART_BUFSTS_RXEMPTY_Pos         (0)                                               /*!< UUART_T::BUFSTS: RXEMPTY Position      */
S#define UUART_BUFSTS_RXEMPTY_Msk         (0x1ul << UUART_BUFSTS_RXEMPTY_Pos)               /*!< UUART_T::BUFSTS: RXEMPTY Mask          */
S
S#define UUART_BUFSTS_RXFULL_Pos          (1)                                               /*!< UUART_T::BUFSTS: RXFULL Position       */
S#define UUART_BUFSTS_RXFULL_Msk          (0x1ul << UUART_BUFSTS_RXFULL_Pos)                /*!< UUART_T::BUFSTS: RXFULL Mask           */
S
S#define UUART_BUFSTS_RXOVIF_Pos          (3)                                               /*!< UUART_T::BUFSTS: RXOVIF Position       */
S#define UUART_BUFSTS_RXOVIF_Msk          (0x1ul << UUART_BUFSTS_RXOVIF_Pos)                /*!< UUART_T::BUFSTS: RXOVIF Mask           */
S
S#define UUART_BUFSTS_TXEMPTY_Pos         (8)                                               /*!< UUART_T::BUFSTS: TXEMPTY Position      */
S#define UUART_BUFSTS_TXEMPTY_Msk         (0x1ul << UUART_BUFSTS_TXEMPTY_Pos)               /*!< UUART_T::BUFSTS: TXEMPTY Mask          */
S
S#define UUART_BUFSTS_TXFULL_Pos          (9)                                               /*!< UUART_T::BUFSTS: TXFULL Position       */
S#define UUART_BUFSTS_TXFULL_Msk          (0x1ul << UUART_BUFSTS_TXFULL_Pos)                /*!< UUART_T::BUFSTS: TXFULL Mask           */
S
S#define UUART_WKCTL_WKEN_Pos             (0)                                               /*!< UUART_T::WKCTL: WKEN Position          */
S#define UUART_WKCTL_WKEN_Msk             (0x1ul << UUART_WKCTL_WKEN_Pos)                   /*!< UUART_T::WKCTL: WKEN Mask              */
S
S#define UUART_WKCTL_PDBOPT_Pos           (2)                                               /*!< UUART_T::WKCTL: PDBOPT Position        */
S#define UUART_WKCTL_PDBOPT_Msk           (0x1ul << UUART_WKCTL_PDBOPT_Pos)                 /*!< UUART_T::WKCTL: PDBOPT Mask            */
S
S#define UUART_WKSTS_WKF_Pos              (0)                                               /*!< UUART_T::WKSTS: WKF Position           */
S#define UUART_WKSTS_WKF_Msk              (0x1ul << UUART_WKSTS_WKF_Pos)                    /*!< UUART_T::WKSTS: WKF Mask               */
S
S#define UUART_PROTCTL_STOPB_Pos          (0)                                               /*!< UUART_T::PROTCTL: STOPB Position       */
S#define UUART_PROTCTL_STOPB_Msk          (0x1ul << UUART_PROTCTL_STOPB_Pos)                /*!< UUART_T::PROTCTL: STOPB Mask           */
S
S#define UUART_PROTCTL_PARITYEN_Pos       (1)                                               /*!< UUART_T::PROTCTL: PARITYEN Position    */
S#define UUART_PROTCTL_PARITYEN_Msk       (0x1ul << UUART_PROTCTL_PARITYEN_Pos)             /*!< UUART_T::PROTCTL: PARITYEN Mask        */
S
S#define UUART_PROTCTL_EVENPARITY_Pos     (2)                                               /*!< UUART_T::PROTCTL: EVENPARITY Position  */
S#define UUART_PROTCTL_EVENPARITY_Msk     (0x1ul << UUART_PROTCTL_EVENPARITY_Pos)           /*!< UUART_T::PROTCTL: EVENPARITY Mask      */
S
S#define UUART_PROTCTL_RTSAUTOEN_Pos      (3)                                               /*!< UUART_T::PROTCTL: RTSAUTOEN Position   */
S#define UUART_PROTCTL_RTSAUTOEN_Msk      (0x1ul << UUART_PROTCTL_RTSAUTOEN_Pos)            /*!< UUART_T::PROTCTL: RTSAUTOEN Mask       */
S
S#define UUART_PROTCTL_CTSAUTOEN_Pos      (4)                                               /*!< UUART_T::PROTCTL: CTSAUTOEN Position   */
S#define UUART_PROTCTL_CTSAUTOEN_Msk      (0x1ul << UUART_PROTCTL_CTSAUTOEN_Pos)            /*!< UUART_T::PROTCTL: CTSAUTOEN Mask       */
S
S#define UUART_PROTCTL_RTSAUDIREN_Pos     (5)                                               /*!< UUART_T::PROTCTL: RTSAUDIREN Position  */
S#define UUART_PROTCTL_RTSAUDIREN_Msk     (0x1ul << UUART_PROTCTL_RTSAUDIREN_Pos)           /*!< UUART_T::PROTCTL: RTSAUDIREN Mask      */
S
S#define UUART_PROTCTL_ABREN_Pos          (6)                                               /*!< UUART_T::PROTCTL: ABREN Position       */
S#define UUART_PROTCTL_ABREN_Msk          (0x1ul << UUART_PROTCTL_ABREN_Pos)                /*!< UUART_T::PROTCTL: ABREN Mask           */
S
S#define UUART_PROTCTL_DATWKEN_Pos        (9)                                               /*!< UUART_T::PROTCTL: DATWKEN Position     */
S#define UUART_PROTCTL_DATWKEN_Msk        (0x1ul << UUART_PROTCTL_DATWKEN_Pos)              /*!< UUART_T::PROTCTL: DATWKEN Mask         */
S
S#define UUART_PROTCTL_CTSWKEN_Pos        (10)                                              /*!< UUART_T::PROTCTL: CTSWKEN Position     */
S#define UUART_PROTCTL_CTSWKEN_Msk        (0x1ul << UUART_PROTCTL_CTSWKEN_Pos)              /*!< UUART_T::PROTCTL: CTSWKEN Mask         */
S
S#define UUART_PROTCTL_WAKECNT_Pos        (11)                                              /*!< UUART_T::PROTCTL: WAKECNT Position     */
S#define UUART_PROTCTL_WAKECNT_Msk        (0xful << UUART_PROTCTL_WAKECNT_Pos)              /*!< UUART_T::PROTCTL: WAKECNT Mask         */
S
S#define UUART_PROTCTL_BRDETITV_Pos       (16)                                              /*!< UUART_T::PROTCTL: BRDETITV Position    */
S#define UUART_PROTCTL_BRDETITV_Msk       (0x1fful << UUART_PROTCTL_BRDETITV_Pos)           /*!< UUART_T::PROTCTL: BRDETITV Mask        */
S
S#define UUART_PROTCTL_STICKEN_Pos        (26)                                              /*!< UUART_T::PROTCTL: STICKEN Position     */
S#define UUART_PROTCTL_STICKEN_Msk        (0x1ul << UUART_PROTCTL_STICKEN_Pos)              /*!< UUART_T::PROTCTL: STICKEN Mask         */
S
S#define UUART_PROTCTL_BCEN_Pos           (29)                                              /*!< UUART_T::PROTCTL: BCEN Position        */
S#define UUART_PROTCTL_BCEN_Msk           (0x1ul << UUART_PROTCTL_BCEN_Pos)                 /*!< UUART_T::PROTCTL: BCEN Mask            */
S
S#define UUART_PROTCTL_PROTEN_Pos         (31)                                              /*!< UUART_T::PROTCTL: PROTEN Position      */
S#define UUART_PROTCTL_PROTEN_Msk         (0x1ul << UUART_PROTCTL_PROTEN_Pos)               /*!< UUART_T::PROTCTL: PROTEN Mask          */
S
S#define UUART_PROTIEN_ABRIEN_Pos         (1)                                               /*!< UUART_T::PROTIEN: ABRIEN Position      */
S#define UUART_PROTIEN_ABRIEN_Msk         (0x1ul << UUART_PROTIEN_ABRIEN_Pos)               /*!< UUART_T::PROTIEN: ABRIEN Mask          */
S
S#define UUART_PROTIEN_RLSIEN_Pos         (2)                                               /*!< UUART_T::PROTIEN: RLSIEN Position      */
S#define UUART_PROTIEN_RLSIEN_Msk         (0x1ul << UUART_PROTIEN_RLSIEN_Pos)               /*!< UUART_T::PROTIEN: RLSIEN Mask          */
S
S#define UUART_PROTSTS_TXSTIF_Pos         (1)                                               /*!< UUART_T::PROTSTS: TXSTIF Position      */
S#define UUART_PROTSTS_TXSTIF_Msk         (0x1ul << UUART_PROTSTS_TXSTIF_Pos)               /*!< UUART_T::PROTSTS: TXSTIF Mask          */
S
S#define UUART_PROTSTS_TXENDIF_Pos        (2)                                               /*!< UUART_T::PROTSTS: TXENDIF Position     */
S#define UUART_PROTSTS_TXENDIF_Msk        (0x1ul << UUART_PROTSTS_TXENDIF_Pos)              /*!< UUART_T::PROTSTS: TXENDIF Mask         */
S
S#define UUART_PROTSTS_RXSTIF_Pos         (3)                                               /*!< UUART_T::PROTSTS: RXSTIF Position      */
S#define UUART_PROTSTS_RXSTIF_Msk         (0x1ul << UUART_PROTSTS_RXSTIF_Pos)               /*!< UUART_T::PROTSTS: RXSTIF Mask          */
S
S#define UUART_PROTSTS_RXENDIF_Pos        (4)                                               /*!< UUART_T::PROTSTS: RXENDIF Position     */
S#define UUART_PROTSTS_RXENDIF_Msk        (0x1ul << UUART_PROTSTS_RXENDIF_Pos)              /*!< UUART_T::PROTSTS: RXENDIF Mask         */
S
S#define UUART_PROTSTS_PARITYERR_Pos      (5)                                               /*!< UUART_T::PROTSTS: PARITYERR Position   */
S#define UUART_PROTSTS_PARITYERR_Msk      (0x1ul << UUART_PROTSTS_PARITYERR_Pos)            /*!< UUART_T::PROTSTS: PARITYERR Mask       */
S
S#define UUART_PROTSTS_FRMERR_Pos         (6)                                               /*!< UUART_T::PROTSTS: FRMERR Position      */
S#define UUART_PROTSTS_FRMERR_Msk         (0x1ul << UUART_PROTSTS_FRMERR_Pos)               /*!< UUART_T::PROTSTS: FRMERR Mask          */
S
S#define UUART_PROTSTS_BREAK_Pos          (7)                                               /*!< UUART_T::PROTSTS: BREAK Position       */
S#define UUART_PROTSTS_BREAK_Msk          (0x1ul << UUART_PROTSTS_BREAK_Pos)                /*!< UUART_T::PROTSTS: BREAK Mask           */
S
S#define UUART_PROTSTS_ABRDETIF_Pos       (9)                                               /*!< UUART_T::PROTSTS: ABRDETIF Position    */
S#define UUART_PROTSTS_ABRDETIF_Msk       (0x1ul << UUART_PROTSTS_ABRDETIF_Pos)             /*!< UUART_T::PROTSTS: ABRDETIF Mask        */
S
S#define UUART_PROTSTS_RXBUSY_Pos         (10)                                              /*!< UUART_T::PROTSTS: RXBUSY Position      */
S#define UUART_PROTSTS_RXBUSY_Msk         (0x1ul << UUART_PROTSTS_RXBUSY_Pos)               /*!< UUART_T::PROTSTS: RXBUSY Mask          */
S
S#define UUART_PROTSTS_ABERRSTS_Pos       (11)                                              /*!< UUART_T::PROTSTS: ABERRSTS Position    */
S#define UUART_PROTSTS_ABERRSTS_Msk       (0x1ul << UUART_PROTSTS_ABERRSTS_Pos)             /*!< UUART_T::PROTSTS: ABERRSTS Mask        */
S
S#define UUART_PROTSTS_CTSSYNCLV_Pos      (16)                                              /*!< UUART_T::PROTSTS: CTSSYNCLV Position   */
S#define UUART_PROTSTS_CTSSYNCLV_Msk      (0x1ul << UUART_PROTSTS_CTSSYNCLV_Pos)            /*!< UUART_T::PROTSTS: CTSSYNCLV Mask       */
S
S#define UUART_PROTSTS_CTSLV_Pos          (17)                                              /*!< UUART_T::PROTSTS: CTSLV Position       */
S#define UUART_PROTSTS_CTSLV_Msk          (0x1ul << UUART_PROTSTS_CTSLV_Pos)                /*!< UUART_T::PROTSTS: CTSLV Mask           */
S
S/**@}*/ /* UUART_CONST */
S/**@}*/ /* end of UUART register group */
S
S
S
S/*---------------------- Watch Dog Timer Controller -------------------------*/
S/**
S    @addtogroup WDT Watch Dog Timer Controller(WDT)
S    Memory Mapped Structure for WDT Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var WDT_T::CTL
S     * Offset: 0x00  WDT Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |RSTEN     |WDT Time-out Reset Enable Control (Write Protect)
S     * |        |          |Setting this bit will enable the WDT time-out reset system function If the WDT up counter value has not been cleared after the specific WDT reset delay period expires.
S     * |        |          |0 = WDT time-out reset system function Disabled.
S     * |        |          |1 = WDT time-out reset system function Enabled.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[2]     |RSTF      |WDT Time-out Reset Flag
S     * |        |          |This bit indicates the system has been reset by WDT time-out reset system event or not.
S     * |        |          |0 = WDT time-out reset system event did not occur.
S     * |        |          |1 = WDT time-out reset system event has been occurred.
S     * |        |          |Note: This bit is cleared by writing 1 to it.
S     * |[3]     |IF        |WDT Time-out Interrupt Flag
S     * |        |          |This bit will set to 1 while WDT up counter value reaches the selected WDT time-out interval
S     * |        |          |0 = WDT time-out interrupt event interrupt did not occur.
S     * |        |          |1 = WDT time-out interrupt interrupt event occurred.
S     * |        |          |Note: This bit is cleared by writing 1 to it.
S     * |[4]     |WKEN      |WDT Time-out Wake-up Function Control (Write Protect)
S     * |        |          |If this bit is set to 1, while WDT time-out interrupt flag IF (WDT_CTL[3]) is generated to 1 and interrupt enable bit INTEN (WDT_CTL[6]) is enabled, the WDT time-out interrupt signal will generate a event to trigger CPU wake-up trigger event to chip.
S     * |        |          |0 = Trigger wWake-up trigger event function Disabled if WDT time-out interrupt signal generated.
S     * |        |          |1 = Trigger wWake-up trigger event function Enabled if WDT time-out interrupt signal generated.
S     * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |        |          |Note2: Chip can be woken-up by while WDT time-out interrupt signal generated only if WDT clock source is selected to 10 kHz (LIRC (10 kHz) or LXT (32 kHz).
S     * |[5]     |WKF       |WDT Time-out Wake-up Flag (Write Protect)
S     * |        |          |This bit indicates the WDT time-out event has triggered interruptchip wake-up or not.flag status of WDT
S     * |        |          |0 = WDT does not cause chip wake-up.
S     * |        |          |1 = Chip wake-up from Idle or Power-down mode if when WDT time-out interrupt signal is generated.
S     * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |        |          |Note2: This bit is cleared by writing 1 to it.
S     * |[6]     |INTEN     |WDT Time-out Interrupt Enable Control (Write Protect)
S     * |        |          |If this bit is enabled, when WDT time-out event occurs, the IF (WDT_CTL[3]) will be set to 1 andthe WDT time-out interrupt signal is generated and inform to CPU.
S     * |        |          |0 = WDT time-out interrupt Disabled.
S     * |        |          |1 = WDT time-out interrupt Enabled.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[7]     |WDTEN     |WDT Enable Control (Write Protect)
S     * |        |          |0 = Set WDT counter stopDisabled, and (This action will reset the internal up counter value will be reset also).
S     * |        |          |1 = Set WDT counter start Enabled.
S     * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |        |          |Note2: Perform enable or disable WDTEN bit needs 2 * WDT_CLK period to become active, user can read SYNC (WDT_CTL[30]) to check enabe/disable command is completed or not.
S     * |        |          |Note32: If CWDTEN[2:0] (combined by with Config0[31] and Config0[4:3]) bits is not configure to 0x111, this bit is forced as 1 and user cannot change this bit to 0.
S     * |        |          |Note3: This bit disabled needs 2 * WDT_CLK.
S     * |[10:8]  |TOUTSEL   |WDT Time-out Interval Selection (Write Protect)
S     * |        |          |These three bits select the time-out interval period after for the WDT starts counting.
S     * |        |          |000 = 24 * WDT_CLK.
S     * |        |          |001 = 26 * WDT_CLK.
S     * |        |          |010 = 28 * WDT_CLK.
S     * |        |          |011 = 210 * WDT_CLK.
S     * |        |          |100 = 212 * WDT_CLK.
S     * |        |          |101 = 214 * WDT_CLK.
S     * |        |          |110 = 216 * WDT_CLK.
S     * |        |          |111 = 218 * WDT_CLK.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |[30]    |SYNC      |WDT Enable Control SYNC SYNC Flag Indicator (Read Only)
S     * |        |          |If usDue to synchronization, software er can check execute enable/disable this flag after enable WDTEN (WDT_CTL[7]), this flag can be indicated enable/disable WDTEN function is becomecompleted or not active or not..
S     * |        |          |SYNC delay is
S     * |        |          |0 = Set WDTEN bit is WDT enable control synccompletedhronizing is completion.
S     * |        |          |1 = Set WDTEN bit WDT enable control is synchronizing and not become active yet..
S     * |        |          |Note: Perform enable or disable WDTEN bit
S     * |        |          |This bit enabled needs 2 * WDT_CLK period to become active.
S     * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control (Write Protect)
S     * |        |          |0 = ICE debug mode acknowledgement affects WDT counting.
S     * |        |          |WDT up counter will be held while CPU is held by ICE.
S     * |        |          |1 = ICE debug mode acknowledgement Disabled.
S     * |        |          |WDT up counter will keep going no matter CPU is held by ICE or not.
S     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * @var WDT_T::ALTCTL
S     * Offset: 0x04  WDT Alternative Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |RSTDSEL   |WDT Reset Delay Period Selection (Write Protect)
S     * |        |          |When WDT time-out event happened, user has a time named WDT Reset Delay Period to clear execute WDT counter by setting RSTCNT (WDT_CTL[0]) reset to prevent WDT time-out reset system occurredhappened
S     * |        |          |User can select a suitable setting of RSTDSEL for different application programWDT Reset Delay Period.
S     * |        |          |00 = WDT Reset Delay Period is 1026 * WDT_CLK.
S     * |        |          |01 = WDT Reset Delay Period is 130 * WDT_CLK.
S     * |        |          |10 = WDT Reset Delay Period is 18 * WDT_CLK.
S     * |        |          |11 = WDT Reset Delay Period is 3 * WDT_CLK.
S     * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
S     * |        |          |Note2: This register will be reset to 0 if WDT time-out reset system event occurredhappened.
S     * @var WDT_T::RSTCNT
S     * Offset: 0x08  WDT Reset Counter Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |RSTCNT    |WDT Reset Counter Register
S     * |        |          |Writing 0x00005AA5 to this register field will reset the internal 18-bit WDT up counter value to 0.
S     * |        |          |Note: This WDT_RSTCNT is not write protected, but this RSTCNT (WDT_CTL[0]) is write protected.
S     * |        |          |Note: Perform RSTCNT to reset counter needs 2 * WDT_CLK period to become active.
S     */
S    __IO uint32_t CTL;                   /*!< [0x0000] WDT Control Register                                             */
S    __IO uint32_t ALTCTL;                /*!< [0x0004] WDT Alternative Control Register                                 */
S    __O  uint32_t RSTCNT;                /*!< [0x0008] WDT Reset Counter Register                                       */
S
S} WDT_T;
S
S/**
S    @addtogroup WDT_CONST WDT Bit Field Definition
S    Constant Definitions for WDT Controller
S@{ */
S
S#define WDT_CTL_RSTEN_Pos                (1)                                               /*!< WDT_T::CTL: RSTEN Position             */
S#define WDT_CTL_RSTEN_Msk                (0x1ul << WDT_CTL_RSTEN_Pos)                      /*!< WDT_T::CTL: RSTEN Mask                 */
S
S#define WDT_CTL_RSTF_Pos                 (2)                                               /*!< WDT_T::CTL: RSTF Position              */
S#define WDT_CTL_RSTF_Msk                 (0x1ul << WDT_CTL_RSTF_Pos)                       /*!< WDT_T::CTL: RSTF Mask                  */
S
S#define WDT_CTL_IF_Pos                   (3)                                               /*!< WDT_T::CTL: IF Position                */
S#define WDT_CTL_IF_Msk                   (0x1ul << WDT_CTL_IF_Pos)                         /*!< WDT_T::CTL: IF Mask                    */
S
S#define WDT_CTL_WKEN_Pos                 (4)                                               /*!< WDT_T::CTL: WKEN Position              */
S#define WDT_CTL_WKEN_Msk                 (0x1ul << WDT_CTL_WKEN_Pos)                       /*!< WDT_T::CTL: WKEN Mask                  */
S
S#define WDT_CTL_WKF_Pos                  (5)                                               /*!< WDT_T::CTL: WKF Position               */
S#define WDT_CTL_WKF_Msk                  (0x1ul << WDT_CTL_WKF_Pos)                        /*!< WDT_T::CTL: WKF Mask                   */
S
S#define WDT_CTL_INTEN_Pos                (6)                                               /*!< WDT_T::CTL: INTEN Position             */
S#define WDT_CTL_INTEN_Msk                (0x1ul << WDT_CTL_INTEN_Pos)                      /*!< WDT_T::CTL: INTEN Mask                 */
S
S#define WDT_CTL_WDTEN_Pos                (7)                                               /*!< WDT_T::CTL: WDTEN Position             */
S#define WDT_CTL_WDTEN_Msk                (0x1ul << WDT_CTL_WDTEN_Pos)                      /*!< WDT_T::CTL: WDTEN Mask                 */
S
S#define WDT_CTL_TOUTSEL_Pos              (8)                                               /*!< WDT_T::CTL: TOUTSEL Position           */
S#define WDT_CTL_TOUTSEL_Msk              (0x7ul << WDT_CTL_TOUTSEL_Pos)                    /*!< WDT_T::CTL: TOUTSEL Mask               */
S
S#define WDT_CTL_SYNC_Pos                 (30)                                              /*!< WDT_T::CTL: SYNC Position              */
S#define WDT_CTL_SYNC_Msk                 (0x1ul << WDT_CTL_SYNC_Pos)                       /*!< WDT_T::CTL: SYNC Mask                  */
S
S#define WDT_CTL_ICEDEBUG_Pos             (31)                                              /*!< WDT_T::CTL: ICEDEBUG Position          */
S#define WDT_CTL_ICEDEBUG_Msk             (0x1ul << WDT_CTL_ICEDEBUG_Pos)                   /*!< WDT_T::CTL: ICEDEBUG Mask              */
S
S#define WDT_ALTCTL_RSTDSEL_Pos           (0)                                               /*!< WDT_T::ALTCTL: RSTDSEL Position        */
S#define WDT_ALTCTL_RSTDSEL_Msk           (0x3ul << WDT_ALTCTL_RSTDSEL_Pos)                 /*!< WDT_T::ALTCTL: RSTDSEL Mask            */
S
S#define WDT_RSTCNT_RSTCNT_Pos            (0)                                               /*!< WDT_T::RSTCNT: RSTCNT Position         */
S#define WDT_RSTCNT_RSTCNT_Msk            (0xfffffffful << WDT_RSTCNT_RSTCNT_Pos)           /*!< WDT_T::RSTCNT: RSTCNT Mask             */
S
S
S/**@}*/ /* WDT_CONST */
S/**@}*/ /* end of WDT register group */
S
S
S/*---------------------- Window Watchdog Timer -------------------------*/
S/**
S    @addtogroup WWDT Window Watchdog Timer(WWDT)
S    Memory Mapped Structure for WWDT Controller
S@{ */
S
Stypedef struct
S{
S
S
S    /**
S     * @var WWDT_T::RLDCNT
S     * Offset: 0x00  WWDT Reload Counter Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |RLDCNT    |WWDT Reload Counter Register
S     * |        |          |Writing only 0x00005AA5 to this register will reload the WWDT counter value to 0x3F.
S     * |        |          |Note1: User can only write executeWWDT_RLDCNT register tothe reload WWDT counter value command when current current WWDT counter valueCNTDAT (WWDT_CNT[5:0]) is between 10 and CMPDAT (WWDT_CTL[21:16])
S     * |        |          |If user writes 0x00005AA5 in WWDT_RLDCNT register when current current CNTDATWWDT counter value is larger than CMPDAT, WWDT reset signal system event will be generated immediately.
S     * |        |          |Note2: Execute WWDT counter relaod always needs (WWDT_CLK *3) period to reload CNTDAT to 0x3F and intrenal prescale counter will be reset also.
S     * @var WWDT_T::CTL
S     * Offset: 0x04  WWDT Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WWDTEN    |WWDT Enable Control Bit
S     * |        |          |Set this bit to enable start WWDT counter counting.
S     * |        |          |0 = WWDT counter is stopped.
S     * |        |          |1 = WWDT counter is starting counting.
S     * |[1]     |INTEN     |WWDT Interrupt Enable Control Bit
S     * |        |          |If this bit is enabled, when WWDTIF (WWDT_STATUS[0]) is set to 1, the WWDT counter compare match interrupt signal is generated and inform to CPU.
S     * |        |          |0 = WWDT counter compare match interrupt Disabled.
S     * |        |          |1 = WWDT counter compare match interrupt Enabled.
S     * |[11:8]  |PSCSEL    |WWDT Counter Prescale Period Selection
S     * |        |          |0000 = Pre-scale is 1; Max time-out period is 1 * 64 * WWDT_CLK.
S     * |        |          |0001 = Pre-scale is 2; Max time-out period is 2 * 64 * WWDT_CLK.
S     * |        |          |0010 = Pre-scale is 4; Max time-out period is 4 * 64 * WWDT_CLK.
S     * |        |          |0011 = Pre-scale is 8; Max time-out period is 8 * 64 * WWDT_CLK.
S     * |        |          |0100 = Pre-scale is 16; Max time-out period is 16 * 64 * WWDT_CLK.
S     * |        |          |0101 = Pre-scale is 32; Max time-out period is 32 * 64 * WWDT_CLK.
S     * |        |          |0110 = Pre-scale is 64; Max time-out period is 64 * 64 * WWDT_CLK.
S     * |        |          |0111 = Pre-scale is 128; Max time-out period is 128 * 64 * WWDT_CLK.
S     * |        |          |1000 = Pre-scale is 192; Max time-out period is 192 * 64 * WWDT_CLK.
S     * |        |          |1001 = Pre-scale is 256; Max time-out period is 256 * 64 * WWDT_CLK.
S     * |        |          |1010 = Pre-scale is 384; Max time-out period is 384 * 64 * WWDT_CLK.
S     * |        |          |1011 = Pre-scale is 512; Max time-out period is 512 * 64 * WWDT_CLK.
S     * |        |          |1100 = Pre-scale is 768; Max time-out period is 768 * 64 * WWDT_CLK.
S     * |        |          |1101 = Pre-scale is 1024; Max time-out period is 1024 * 64 * WWDT_CLK.
S     * |        |          |1110 = Pre-scale is 1536; Max time-out period is 1536 * 64 * WWDT_CLK.
S     * |        |          |1111 = Pre-scale is 2048; Max time-out period is 2048 * 64 * WWDT_CLK.
S     * |[21:16] |CMPDAT    |WWDT Window Compare RegisterValue
S     * |        |          |Set this register field to adjust the valid reload window interval when WWDTIF (WWDT_STATUS[0]) is generated..
S     * |        |          |Note: User can only write WWDT_RLDCNT register to reload WWDT counter value when current WWDT CNTDAT (WWDT_CNT[5:]) iscounter value between 10 and CMPDAT
S     * |        |          |If user writes 0x00005AA5 in WWDT_RLDCNT register when current WWDT counter valueCNTDAT is larger than CMPDAT, WWDT reset system event signal will be generated immediately.
S     * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control
S     * |        |          |0 = ICE debug mode acknowledgement effects WWDT counter counting.
S     * |        |          |WWDT down counter will be held while CPU is held by ICE.
S     * |        |          |1 = ICE debug mode acknowledgement Disabled.
S     * |        |          |WWDT down counter will keep going counting no matter CPU is held by ICE or not.
S     * @var WWDT_T::STATUS
S     * Offset: 0x08  WWDT Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WWDTIF    |WWDT Compare Match Interrupt Flag
S     * |        |          |This bit indicates the that current CNTDAT (WWDT_CNT[5:0]) matches the CMPDAT (WWDT_CTL[21:16])interrupt flag status of WWDT while WWDT counter value matches CMPDAT (WWDT_CTL[21:16]).
S     * |        |          |0 = No effect.
S     * |        |          |1 = WWDT WWDT CNTDAT counter value matches the CMPDAT.
S     * |        |          |Note: This bit is cleared by writing 1 to it.
S     * |[1]     |WWDTRF    |WWDT Timer-out Reset System Flag
S     * |        |          |If this bit is set to 1, itThis bit indicates the that system has been reset by WWDT counter time-out reset system event.or not.
S     * |        |          |0 = WWDT time-out reset system event did not occur.
S     * |        |          |1 = WWDT time-out reset system event occurred.
S     * |        |          |Note: This bit is cleared by writing 1 to it.
S     * @var WWDT_T::CNT
S     * Offset: 0x0C  WWDT Counter Value Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |CNTDAT    |WWDT Counter Value
S     * |        |          |CNTDAT will be updated continuously to monitor 6-bit WWDT down counter value.
S     */
S    __O  uint32_t RLDCNT;                /*!< [0x0000] WWDT Reload Counter Register                                     */
S    __IO uint32_t CTL;                   /*!< [0x0004] WWDT Control Register                                            */
S    __IO uint32_t STATUS;                /*!< [0x0008] WWDT Status Register                                             */
S    __I  uint32_t CNT;                   /*!< [0x000c] WWDT Counter Value Register                                      */
S
S} WWDT_T;
S
S/**
S    @addtogroup WWDT_CONST WWDT Bit Field Definition
S    Constant Definitions for WWDT Controller
S@{ */
S
S#define WWDT_RLDCNT_RLDCNT_Pos           (0)                                               /*!< WWDT_T::RLDCNT: RLDCNT Position        */
S#define WWDT_RLDCNT_RLDCNT_Msk           (0xfffffffful << WWDT_RLDCNT_RLDCNT_Pos)          /*!< WWDT_T::RLDCNT: RLDCNT Mask            */
S
S#define WWDT_CTL_WWDTEN_Pos              (0)                                               /*!< WWDT_T::CTL: WWDTEN Position           */
S#define WWDT_CTL_WWDTEN_Msk              (0x1ul << WWDT_CTL_WWDTEN_Pos)                    /*!< WWDT_T::CTL: WWDTEN Mask               */
S
S#define WWDT_CTL_INTEN_Pos               (1)                                               /*!< WWDT_T::CTL: INTEN Position            */
S#define WWDT_CTL_INTEN_Msk               (0x1ul << WWDT_CTL_INTEN_Pos)                     /*!< WWDT_T::CTL: INTEN Mask                */
S
S#define WWDT_CTL_PSCSEL_Pos              (8)                                               /*!< WWDT_T::CTL: PSCSEL Position           */
S#define WWDT_CTL_PSCSEL_Msk              (0xful << WWDT_CTL_PSCSEL_Pos)                    /*!< WWDT_T::CTL: PSCSEL Mask               */
S
S#define WWDT_CTL_CMPDAT_Pos              (16)                                              /*!< WWDT_T::CTL: CMPDAT Position           */
S#define WWDT_CTL_CMPDAT_Msk              (0x3ful << WWDT_CTL_CMPDAT_Pos)                   /*!< WWDT_T::CTL: CMPDAT Mask               */
S
S#define WWDT_CTL_ICEDEBUG_Pos            (31)                                              /*!< WWDT_T::CTL: ICEDEBUG Position         */
S#define WWDT_CTL_ICEDEBUG_Msk            (0x1ul << WWDT_CTL_ICEDEBUG_Pos)                  /*!< WWDT_T::CTL: ICEDEBUG Mask             */
S
S#define WWDT_STATUS_WWDTIF_Pos           (0)                                               /*!< WWDT_T::STATUS: WWDTIF Position        */
S#define WWDT_STATUS_WWDTIF_Msk           (0x1ul << WWDT_STATUS_WWDTIF_Pos)                 /*!< WWDT_T::STATUS: WWDTIF Mask            */
S
S#define WWDT_STATUS_WWDTRF_Pos           (1)                                               /*!< WWDT_T::STATUS: WWDTRF Position        */
S#define WWDT_STATUS_WWDTRF_Msk           (0x1ul << WWDT_STATUS_WWDTRF_Pos)                 /*!< WWDT_T::STATUS: WWDTRF Mask            */
S
S#define WWDT_CNT_CNTDAT_Pos              (0)                                               /*!< WWDT_T::CNT: CNTDAT Position           */
S#define WWDT_CNT_CNTDAT_Msk              (0x3ful << WWDT_CNT_CNTDAT_Pos)                   /*!< WWDT_T::CNT: CNTDAT Mask               */
S
S/**@}*/ /* WWDT_CONST */
S/**@}*/ /* end of WWDT register group */
S
S
S/**@}*/ /* end of REGISTER group */
S
S
S/******************************************************************************/
S/*                         Peripheral memory map                              */
S/******************************************************************************/
S/** @addtogroup PERIPHERAL_BASE Peripheral Memory Base
S  Memory Mapped Structure for Series Peripheral
S  @{
S */
S/* Peripheral and SRAM base address */
S#define FLASH_BASE          ((     uint32_t)0x00000000)
S#define SRAM_BASE           ((     uint32_t)0x20000000)
S#define AHB_BASE            ((     uint32_t)0x50000000)
S#define APB1_BASE           ((     uint32_t)0x40000000)
S#define APB2_BASE           ((     uint32_t)0x40100000)
S
S/* Peripheral memory map */
S#define GPIO_BASE           (AHB_BASE       + 0x4000)                   /*!< GPIO Base Address                                   */
S#define PA_BASE             (GPIO_BASE              )                   /*!< GPIO PA Base Address                                */
S#define PB_BASE             (GPIO_BASE      + 0x0040)                   /*!< GPIO PB Base Address                                */
S#define PC_BASE             (GPIO_BASE      + 0x0080)                   /*!< GPIO PC Base Address                                */
S#define PD_BASE             (GPIO_BASE      + 0x00C0)                   /*!< GPIO PD Base Address                                */
S#define PE_BASE             (GPIO_BASE      + 0x0100)                   /*!< GPIO PE Base Address                                */
S#define PF_BASE             (GPIO_BASE      + 0x0140)                   /*!< GPIO PF Base Address                                */
S#define GPIO_DBCTL_BASE     (GPIO_BASE      + 0x0180)                   /*!< GPIO De-bounce Cycle Control Base Address           */
S#define GPIO_PIN_DATA_BASE  (GPIO_BASE      + 0x0200)                   /*!< GPIO Pin Data Input/Output Control Base Address     */
S
S#define UART0_BASE          (APB1_BASE      + 0x50000)                  /*!< UART0 Base Address                               */
S#define UART1_BASE          (APB2_BASE      + 0x50000)                  /*!< UART1 Base Address                               */
S#define UART2_BASE          (APB2_BASE      + 0x54000)                  /*!< UART2 Base Address                               */
S
S#define TIMER0_BASE         (APB1_BASE      + 0x10000)                  /*!< Timer0 Base Address                              */
S#define TIMER1_BASE         (APB1_BASE      + 0x10100)                  /*!< Timer1 Base Address                              */
S#define TIMER2_BASE         (APB2_BASE      + 0x10000)                  /*!< Timer2 Base Address                              */
S#define TIMER3_BASE         (APB2_BASE      + 0x10100)                  /*!< Timer3 Base Address                              */
S
S#define WDT_BASE            (APB1_BASE      + 0x4000)                   /*!< Watch Dog Timer Base Address                     */
S
S#define WWDT_BASE           (APB1_BASE      + 0x4100)                   /*!< Window Watch Dog Timer Base Address              */
S
S#define SPI0_BASE           (APB1_BASE      + 0x30000)                  /*!< SPI0 Base Address                                */
S#define SPI1_BASE           (APB1_BASE      + 0x34000)                  /*!< SPI1 Base Address                                */
S
S#define I2C0_BASE           (APB1_BASE      + 0x20000)                  /*!< I2C0 Base Address                                */
S#define I2C1_BASE           (APB2_BASE      + 0x20000)                  /*!< I2C1 Base Address                                */
S
S#define RTC_BASE            (APB1_BASE      + 0x08000)                  /*!< RTC Base Address                                 */
S
S#define ADC_BASE            (APB1_BASE      + 0xE0000)                  /*!< ADC Base Address                                 */
S
S#define ACMP01_BASE         (APB1_BASE      + 0xD0000)                  /*!< ACMP01 Base Address                              */
S
S#define CLK_BASE            (AHB_BASE       + 0x00200)                  /*!< System Clock Controller Base Address             */
S
S#define SYS_BASE            (AHB_BASE       + 0x00000)                  /*!< System Global Controller Base Address            */
S
S#define INT_BASE            (AHB_BASE       + 0x00300)                  /*!< Interrupt Source Controller Base Address         */
S
S#define FMC_BASE            (AHB_BASE       + 0x0C000)                  /*!< Flash Memory Controller Base Address             */
S
S#define PWM0_BASE           (APB1_BASE      + 0x40000)                  /*!< PWM0 Base Address                                */
S#define PWM1_BASE           (APB2_BASE      + 0x40000)                  /*!< PWM1 Base Address                                */
S
S#define SC0_BASE            (APB2_BASE      + 0x90000)                  /*!< SC0 Base Address                                 */
S#define SC1_BASE            (APB2_BASE      + 0x94000)                  /*!< SC1 Base Address                                 */
S
S#define EBI_BASE            (AHB_BASE       + 0x10000)                  /*!< EBI Base Address                                 */
S
S#define HDIV_BASE           (AHB_BASE       + 0x14000)                  /*!< HDIV Base Address                                */
S
S#define CRC_BASE            (AHB_BASE       + 0x18000)                  /*!< CRC Base Address                                 */
S
S#define USBD_BASE           (APB1_BASE      + 0x60000)                  /*!< USB Device Base Address                          */
S
S#define PDMA_BASE           (AHB_BASE       + 0x08000)                  /*!< PDMA Base Address                                */
S
S
S#define USCI0_BASE           (APB1_BASE      + 0x70000)
S#define USCI1_BASE           (APB2_BASE      + 0x70000)
S#define USCI2_BASE           (APB1_BASE      + 0x74000)
S
S/**@}*/ /* PERIPHERAL */
S
S/******************************************************************************/
S/*                         Peripheral declaration                             */
S/******************************************************************************/
S
S/** @addtogroup PMODULE Peripheral Pointer
S  The Declaration of Peripheral Pointer
S  @{
S */
S#define PA                  ((GPIO_T *) PA_BASE)                        /*!< GPIO PORTA Configuration Struct                        */
S#define PB                  ((GPIO_T *) PB_BASE)                        /*!< GPIO PORTB Configuration Struct                        */
S#define PC                  ((GPIO_T *) PC_BASE)                        /*!< GPIO PORTC Configuration Struct                        */
S#define PD                  ((GPIO_T *) PD_BASE)                        /*!< GPIO PORTD Configuration Struct                        */
S#define PE                  ((GPIO_T *) PE_BASE)                        /*!< GPIO PORTE Configuration Struct                        */
S#define PF                  ((GPIO_T *) PF_BASE)                        /*!< GPIO PORTF Configuration Struct                        */
S#define GPIO                ((GPIO_DBCTL_T *) GPIO_DBCTL_BASE)          /*!< Interrupt De-bounce Cycle Control Configuration Struct */
S
S#define UART0               ((UART_T *) UART0_BASE)                     /*!< UART0 Configuration Struct                       */
S#define UART1               ((UART_T *) UART1_BASE)                     /*!< UART1 Configuration Struct                       */
S#define UART2               ((UART_T *) UART2_BASE)                     /*!< UART2 Configuration Struct                       */
S
S#define TIMER0              ((TIMER_T *) TIMER0_BASE)                   /*!< TIMER0 Configuration Struct                      */
S#define TIMER1              ((TIMER_T *) TIMER1_BASE)                   /*!< TIMER1 Configuration Struct                      */
S#define TIMER2              ((TIMER_T *) TIMER2_BASE)                   /*!< TIMER2 Configuration Struct                      */
S#define TIMER3              ((TIMER_T *) TIMER3_BASE)                   /*!< TIMER3 Configuration Struct                      */
S
S#define WDT                 ((WDT_T *) WDT_BASE)                        /*!< Watch Dog Timer Configuration Struct             */
S
S#define WWDT                ((WWDT_T *) WWDT_BASE)                      /*!< Window Watch Dog Timer Configuration Struct      */
S
S#define SPI0                ((SPI_T *) SPI0_BASE)                       /*!< SPI0 Configuration Struct                        */
S#define SPI1                ((SPI_T *) SPI1_BASE)                       /*!< SPI1 Configuration Struct                        */
S
S#define I2C0                ((I2C_T *) I2C0_BASE)                       /*!< I2C0 Configuration Struct                        */
S#define I2C1                ((I2C_T *) I2C1_BASE)                       /*!< I2C1 Configuration Struct                        */
S
S#define RTC                 ((RTC_T *) RTC_BASE)                        /*!< RTC Configuration Struct                         */
S
S#define ADC                 ((ADC_T *) ADC_BASE)                        /*!< ADC Configuration Struct                         */
S
S#define ACMP01              ((ACMP_T *) ACMP01_BASE)                    /*!< ACMP01 Configuration Struct                      */
S
S#define CLK                 ((CLK_T *) CLK_BASE)                        /*!< System Clock Controller Configuration Struct     */
S
S#define SYS                 ((SYS_T *) SYS_BASE)                        /*!< System Global Controller Configuration Struct    */
S
S#define SYSINT              ((SYS_INT_T *) INT_BASE)                    /*!< Interrupt Source Controller Configuration Struct */
S
S#define FMC                 ((FMC_T *) FMC_BASE)                        /*!< Flash Memory Controller */
S
S#define PWM0                ((PWM_T *) PWM0_BASE)                       /*!< PWM0 Configuration Struct                        */
S#define PWM1                ((PWM_T *) PWM1_BASE)                       /*!< PWM1 Configuration Struct                        */
S
S#define SC0                 ((SC_T *) SC0_BASE)                         /*!< SC0 Configuration Struct                         */
S#define SC1                 ((SC_T *) SC1_BASE)                         /*!< SC1 Configuration Struct                         */
S
S#define EBI                 ((EBI_T *) EBI_BASE)                        /*!< EBI Configuration Struct                         */
S
S#define HDIV                ((HDIV_T *) HDIV_BASE)                      /*!< HDIV Configuration Struct                        */
S
S#define CRC                 ((CRC_T *) CRC_BASE)                        /*!< CRC Configuration Struct                         */
S
S#define USBD                ((USBD_T *) USBD_BASE)                      /*!< USB Device Configuration Struct                  */
S
S#define PDMA                ((PDMA_T *) PDMA_BASE)                      /*!< PDMA Configuration Struct                        */
S
S#define UI2C0               ((UI2C_T *) USCI0_BASE)                     /*!< UI2C0 Configuration Struct                       */
S#define UI2C1               ((UI2C_T *) USCI1_BASE)                     /*!< UI2C1 Configuration Struct                       */
S#define UI2C2               ((UI2C_T *) USCI2_BASE)                     /*!< UI2C2 Configuration Struct                       */
S
S#define USPI0               ((USPI_T *) USCI0_BASE)                     /*!< USPI0 Configuration Struct                       */
S#define USPI1               ((USPI_T *) USCI1_BASE)                     /*!< USPI1 Configuration Struct                       */
S#define USPI2               ((USPI_T *) USCI2_BASE)                     /*!< USPI2 Configuration Struct                       */
S
S#define UUART0              ((UUART_T *) USCI0_BASE)                    /*!< UUART0 Configuration Struct                      */
S#define UUART1              ((UUART_T *) USCI1_BASE)                    /*!< UUART1 Configuration Struct                      */
S#define UUART2              ((UUART_T *) USCI2_BASE)                    /*!< UUART2 Configuration Struct                      */
S/**@}*/ /* end of group PMODULE */
S
S
S//=============================================================================
Stypedef volatile unsigned char  vu8;
Stypedef volatile unsigned long  vu32;
Stypedef volatile unsigned short vu16;
S#define M8(adr)  (*((vu8  *) (adr)))
S#define M16(adr) (*((vu16 *) (adr)))
S#define M32(adr) (*((vu32 *) (adr)))
S
S#define outpw(port,value)   (*((volatile unsigned int *)(port))=(value))
S#define inpw(port)          ((*((volatile unsigned int *)(port))))
S#define outpb(port,value)   (*((volatile unsigned char *)(port))=(value))
S#define inpb(port)          ((*((volatile unsigned char *)(port))))
S#define outps(port,value)   (*((volatile unsigned short *)(port))=(value))
S#define inps(port)          ((*((volatile unsigned short *)(port))))
S
S#define outp32(port,value)  (*((volatile unsigned int *)(port))=(value))
S#define inp32(port)         ((*((volatile unsigned int *)(port))))
S#define outp8(port,value)   (*((volatile unsigned char *)(port))=(value))
S#define inp8(port)          ((*((volatile unsigned char *)(port))))
S#define outp16(port,value)  (*((volatile unsigned short *)(port))=(value))
S#define inp16(port)         ((*((volatile unsigned short *)(port))))
S
S
S#define E_SUCCESS   0
S#ifndef NULL
S#define NULL        0
S#endif
S
S#define TRUE        1
S#define FALSE       0
S
S#define ENABLE      1
S#define DISABLE     0
S
S/* Bit Mask Definitions */
S#define BIT0    0x00000001
S#define BIT1    0x00000002
S#define BIT2    0x00000004
S#define BIT3    0x00000008
S#define BIT4    0x00000010
S#define BIT5    0x00000020
S#define BIT6    0x00000040
S#define BIT7    0x00000080
S#define BIT8    0x00000100
S#define BIT9    0x00000200
S#define BIT10   0x00000400
S#define BIT11   0x00000800
S#define BIT12   0x00001000
S#define BIT13   0x00002000
S#define BIT14   0x00004000
S#define BIT15   0x00008000
S#define BIT16   0x00010000
S#define BIT17   0x00020000
S#define BIT18   0x00040000
S#define BIT19   0x00080000
S#define BIT20   0x00100000
S#define BIT21   0x00200000
S#define BIT22   0x00400000
S#define BIT23   0x00800000
S#define BIT24   0x01000000
S#define BIT25   0x02000000
S#define BIT26   0x04000000
S#define BIT27   0x08000000
S#define BIT28   0x10000000
S#define BIT29   0x20000000
S#define BIT30   0x40000000
S#define BIT31   0x80000000
S
S
S/* Byte Mask Definitions */
S#define BYTE0_Msk               (0x000000FF)
S#define BYTE1_Msk               (0x0000FF00)
S#define BYTE2_Msk               (0x00FF0000)
S#define BYTE3_Msk               (0xFF000000)
S
S#define _GET_BYTE0(u32Param)    (((u32Param) & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
S#define _GET_BYTE1(u32Param)    (((u32Param) & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
S#define _GET_BYTE2(u32Param)    (((u32Param) & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
S#define _GET_BYTE3(u32Param)    (((u32Param) & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
S
S
S/******************************************************************************/
S/*                         Peripheral header files                            */
S/******************************************************************************/
S#include "sys.h"
S#include "clk.h"
S#include "adc.h"
S#include "ebi.h"
S#include "fmc.h"
S#include "gpio.h"
S#include "i2c.h"
S#include "pwm.h"
S#include "spi.h"
S#include "timer.h"
S#include "timer_pwm.h"
S#include "wdt.h"
S#include "wwdt.h"
S#include "rtc.h"
S#include "uart.h"
S#include "hdiv.h"
S#include "acmp.h"
S#include "crc.h"
S#include "usbd.h"
S#include "pdma.h"
S#include "ebi.h"
S#include "sc.h"
S#include "scuart.h"
S#include "usci_spi.h"
S#include "usci_uart.h"
S#include "usci_i2c.h"
N#endif
N
N/* Copyright (C) 2018 Nuvoton Technology Corp. All rights reserved. */
N
N
N
L 16 "..\lib\StdDriver\inc\fmc.h" 2
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup FMC_Driver FMC Driver
N  @{
N*/
N
N/** @addtogroup FMC_EXPORTED_CONSTANTS FMC Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Global constant definitions                                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ISBEN   0
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Base Address                                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_APROM_BASE          0x00000000UL    /*!< APROM  Base Address         */
N#define FMC_LDROM_BASE          0x00100000UL    /*!< LDROM  Base Address         */
N#define FMC_SPROM_BASE          0x00200000UL    /*!< SPROM  Base Address         */
N#define FMC_CONFIG_BASE         0x00300000UL    /*!< CONFIG Base Address         */
N
N#define FMC_CONFIG0_ADDR        (FMC_CONFIG_BASE)       /*!< CONFIG 0 Address */
N#define FMC_CONFIG1_ADDR        (FMC_CONFIG_BASE + 4)   /*!< CONFIG 1 Address */
N
N
N#define FMC_FLASH_PAGE_SIZE     0x800           /*!< Flash Page Size (2048 Bytes) */
N#define FMC_LDROM_SIZE          0x1000          /*!< LDROM Size (4 kBytes)       */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCTL constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCTL_BS_LDROM     0x2     /*!< ISPCTL setting to select to boot from LDROM */
N#define FMC_ISPCTL_BS_APROM     0x0     /*!< ISPCTL setting to select to boot from APROM */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCMD constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCMD_READ         0x00     /*!< ISP Command: Read Flash               */
N#define FMC_ISPCMD_PROGRAM      0x21     /*!< ISP Command: 32-bit Program Flash     */
N#define FMC_ISPCMD_WRITE_8      0x61     /*!< ISP Command: 64-bit program Flash     */
N#define FMC_ISPCMD_PAGE_ERASE   0x22     /*!< ISP Command: Page Erase Flash         */
N#define FMC_ISPCMD_READ_CID     0x0B     /*!< ISP Command: Read Company ID          */
N#define FMC_ISPCMD_READ_UID     0x04     /*!< ISP Command: Read Unique ID           */
N#define FMC_ISPCMD_READ_DID     0x0C     /*!< ISP Command: Read Device ID           */
N#define FMC_ISPCMD_VECMAP       0x2E     /*!< ISP Command: Set vector mapping       */
N#define FMC_ISPCMD_CHECKSUM     0x0D     /*!< ISP Command: Read Checksum            */
N#define FMC_ISPCMD_CAL_CHECKSUM 0x2D     /*!< ISP Command: Run Check Calculation    */
N#define FMC_ISPCMD_MULTI_PROG   0x27     /*!< ISP Command: Flash Multi-Word Program */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  FTCTL constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_FTCTL_OPTIMIZE_DISABLE      0x00       /*!< Frequency Optimize Mode disable */
N#define FMC_FTCTL_OPTIMIZE_24MHZ        0x01       /*!< Frequency Optimize Mode <= 24Mhz */
N#define FMC_FTCTL_OPTIMIZE_48MHZ        0x02       /*!< Frequency Optimize Mode <= 48Mhz */
N#define FMC_FTCTL_OPTIMIZE_72MHZ        0x05       /*!< Frequency Optimize Mode <= 72Mhz */
N
N/*@}*/ /* end of group FMC_EXPORTED_CONSTANTS */
N
N/** @addtogroup FMC_EXPORTED_FUNCTIONS FMC Exported Functions
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  FMC Macro Definitions                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Enable ISP Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set ISPEN bit of ISPCTL control register to enable ISP function.
N *
N */
N#define FMC_ENABLE_ISP()          (FMC->ISPCTL |=  FMC_ISPCTL_ISPEN_Msk)  /*!< Enable ISP Function  */
N
N/**
N * @brief      Disable ISP Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will clear ISPEN bit of ISPCTL control register to disable ISP function.
N *
N */
N#define FMC_DISABLE_ISP()         (FMC->ISPCTL &= ~FMC_ISPCTL_ISPEN_Msk)  /*!< Disable ISP Function */
N
N/**
N * @brief      Enable LDROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set LDUEN bit of ISPCTL control register to enable LDROM update function.
N *             User needs to set LDUEN bit before they can update LDROM.
N *
N */
N#define FMC_ENABLE_LD_UPDATE()    (FMC->ISPCTL |=  FMC_ISPCTL_LDUEN_Msk)  /*!< Enable LDROM Update Function   */
N
N/**
N * @brief      Disable LDROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set ISPEN bit of ISPCTL control register to disable LDROM update function.
N *
N */
N#define FMC_DISABLE_LD_UPDATE()   (FMC->ISPCTL &= ~FMC_ISPCTL_LDUEN_Msk)  /*!< Disable LDROM Update Function  */
N
N/**
N * @brief      Enable User Configuration Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set CFGUEN bit of ISPCTL control register to enable User Configuration update function.
N *             User needs to set CFGUEN bit before they can update User Configuration area.
N *
N */
N#define FMC_ENABLE_CFG_UPDATE()   (FMC->ISPCTL |=  FMC_ISPCTL_CFGUEN_Msk) /*!< Enable CONFIG Update Function  */
N
N/**
N * @brief      Disable User Configuration Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will clear CFGUEN bit of ISPCTL control register to disable User Configuration update function.
N *
N */
N#define FMC_DISABLE_CFG_UPDATE()  (FMC->ISPCTL &= ~FMC_ISPCTL_CFGUEN_Msk) /*!< Disable CONFIG Update Function */
N
N
N/**
N * @brief      Enable APROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set APUEN bit of ISPCTL control register to enable APROM update function.
N *             User needs to set APUEN bit before they can update APROM in APROM boot mode.
N *
N */
N#define FMC_ENABLE_AP_UPDATE()    (FMC->ISPCTL |=  FMC_ISPCTL_APUEN_Msk)  /*!< Enable APROM Update Function   */
N
N/**
N * @brief      Disable APROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will clear APUEN bit of ISPCTL control register to disable APROM update function.
N *
N */
N#define FMC_DISABLE_AP_UPDATE()   (FMC->ISPCTL &= ~FMC_ISPCTL_APUEN_Msk)  /*!< Disable APROM Update Function  */
N
N/**
N * @brief      Next Booting Selection function
N *
N * @param[in]  x   Booting from APROM(0)/LDROM(1)
N *
N * @return     None
N *
N * @details    This function will set MCU next booting from LDROM/APROM.
N *
N * @note       When use this macro, the Boot Loader booting selection MBS(CONFIG0[5]) must be set.
N *
N */
N#define FMC_SELECT_NEXT_BOOT(x)   (FMC->ISPCTL = (FMC->ISPCTL & ~FMC_ISPCTL_BS_Msk) | ((x) << FMC_ISPCTL_BS_Pos)) /*!< Select Next Booting, x = 0 or 1 */
N
N/**
N * @brief      Get MCU Booting Status
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will get status of chip next booting from LDROM/APROM.
N *
N */
N#define FMC_GET_BOOT_STATUS()     ((FMC->ISPCTL & FMC_ISPCTL_BS_Msk)?1:0) /*!< Get MCU Booting Status */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* inline functions                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Program 32-bit data into specified address of flash
N *
N * @param[in]  u32Addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N * @param[in]  u32Data  32-bit Data to program
N *
N * @return     None
N *
N * @details    To program word data into Flash include APROM, LDROM, Data Flash, and CONFIG.
N *             The corresponding functions in CONFIG are listed in FMC section of Technical Reference Manual.
N *
N */
Nstatic __INLINE void FMC_Write(uint32_t u32Addr, uint32_t u32Data)
Xstatic __inline void FMC_Write(uint32_t u32Addr, uint32_t u32Data)
N{
N    FMC->ISPCMD = FMC_ISPCMD_PROGRAM;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x21;
N    FMC->ISPADDR = u32Addr;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADDR = u32Addr;
N    FMC->ISPDAT = u32Data;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT = u32Data;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;
N#if ISBEN
X#if 0
S    __ISB();
N#endif
N    while(FMC->ISPTRG);
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);
N}
N
N/**
N * @brief      Program 64-bit data into specified address of flash
N *
N * @param[in]  u32Addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N * @param[in]  u32Data0 32-bit Data to program
N * @param[in]  u32Data1 32-bit Data to program
N *
N * @return     None
N *
N * @details    To program two words data into Flash include APROM, LDROM, Data Flash, and CONFIG.
N *             The corresponding functions in CONFIG are listed in FMC section of Technical Reference Manual.
N *
N */
Nstatic __INLINE void FMC_Write8(uint32_t u32Addr, uint32_t u32Data0, uint32_t u32Data1)
Xstatic __inline void FMC_Write8(uint32_t u32Addr, uint32_t u32Data0, uint32_t u32Data1)
N{
N    FMC->ISPCMD = FMC_ISPCMD_WRITE_8;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x61;
N    FMC->ISPADDR = u32Addr;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADDR = u32Addr;
N    FMC->MPDAT0 = u32Data0;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->MPDAT0 = u32Data0;
N    FMC->MPDAT1 = u32Data1;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->MPDAT1 = u32Data1;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;
N#if ISBEN
X#if 0
S    __ISB();
N#endif
N    while(FMC->ISPTRG);
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);
N}
N
N
N/**
N * @brief       Read 32-bit Data from specified address of flash
N *
N * @param[in]   u32Addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N *
N * @return      The data of specified address
N *
N * @details     To read word data from Flash include APROM, LDROM, Data Flash, and CONFIG.
N *
N */
Nstatic __INLINE uint32_t FMC_Read(uint32_t u32Addr)
Xstatic __inline uint32_t FMC_Read(uint32_t u32Addr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x00;
N    FMC->ISPADDR = u32Addr;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADDR = u32Addr;
N    FMC->ISPDAT = 0;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT = 0;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;
N#if ISBEN
X#if 0
S    __ISB();
N#endif
N    while(FMC->ISPTRG);
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N/**
N * @brief      Flash page erase
N *
N * @param[in]  u32Addr  Flash address including APROM, LDROM, Data Flash, and CONFIG
N *
N * @details    To do flash page erase. The target address could be APROM, LDROM, Data Flash, or CONFIG.
N *             The page size is 2048 bytes.
N *
N * @retval      0 Success
N * @retval     -1 Erase failed
N *
N */
Nstatic __INLINE int32_t FMC_Erase(uint32_t u32Addr)
Xstatic __inline int32_t FMC_Erase(uint32_t u32Addr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_PAGE_ERASE;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x22;
N    FMC->ISPADDR = u32Addr;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADDR = u32Addr;
N    if(u32Addr == FMC_SPROM_BASE)
X    if(u32Addr == 0x00200000UL)
N        FMC->ISPDAT = 0x0055AA03;
X        ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT = 0x0055AA03;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;
N#if ISBEN
X#if 0
S    __ISB();
N#endif
N    while(FMC->ISPTRG);
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);
N
N    /* Check ISPFF flag to know whether erase OK or fail. */
N    if(FMC->ISPCTL & FMC_ISPCTL_ISPFF_Msk)
X    if(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCTL & (0x1ul << (6)))
N    {
N        FMC->ISPCTL |= FMC_ISPCTL_ISPFF_Msk;
X        ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCTL |= (0x1ul << (6));
N        return -1;
N    }
N    return 0;
N}
N
N/**
N * @brief       Read Unique ID
N *
N * @param[in]   u8Index  UID index. 0 = UID[31:0], 1 = UID[63:32], 2 = UID[95:64]
N *
N * @return      The 32-bit unique ID data of specified UID index.
N *
N * @details     To read out 96-bit Unique ID.
N *
N */
Nstatic __INLINE uint32_t FMC_ReadUID(uint8_t u8Index)
Xstatic __inline uint32_t FMC_ReadUID(uint8_t u8Index)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_UID;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x04;
N    FMC->ISPADDR = (u8Index << 2);
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADDR = (u8Index << 2);
N    FMC->ISPDAT = 0;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT = 0;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;
N#if ISBEN
X#if 0
S    __ISB();
N#endif
N    while(FMC->ISPTRG);
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N/**
N  * @brief    Read company ID
N  *
N  * @param    None
N  *
N  * @return   The company ID (32-bit)
N  *
N  * @details  The company ID of Nuvoton is fixed to be 0xDA
N  *
N  */
Nstatic __INLINE uint32_t FMC_ReadCID(void)
Xstatic __inline uint32_t FMC_ReadCID(void)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_CID;           /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x0B;            
N    FMC->ISPADDR = 0x0;                          /* Must keep 0x0 when read CID */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADDR = 0x0;                           
N    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;          /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = (0x1ul << (0));           
N#if ISBEN
X#if 0
S    __ISB();
N#endif                                    /* To make sure ISP/CPU be Synchronized */
N    while(FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk) ;  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG & (0x1ul << (0))) ;   
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N/**
N  * @brief    Read product ID
N  *
N  * @param    None
N  *
N  * @return   The product ID (32-bit)
N  *
N  * @details  This function is used to read product ID.
N  *
N  */
Nstatic __INLINE uint32_t FMC_ReadPID(void)
Xstatic __inline uint32_t FMC_ReadPID(void)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_DID;          /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x0C;           
N    FMC->ISPADDR = 0x04;                         /* Must keep 0x4 when read PID */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADDR = 0x04;                          
N    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;         /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = (0x1ul << (0));          
N#if ISBEN
X#if 0
S    __ISB();
N#endif                                     /* To make sure ISP/CPU be Synchronized */
N    while(FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk);  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG & (0x1ul << (0)));   
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N/**
N  * @brief      To read UCID
N  *
N  * @param[in]  u32Index    Index of the UCID to read. u32Index must be 0, 1, 2, or 3.
N  *
N  * @return     The UCID of specified index
N  *
N  * @details    This function is used to read unique chip ID (UCID).
N  *
N  */
Nstatic __INLINE uint32_t FMC_ReadUCID(uint32_t u32Index)
Xstatic __inline uint32_t FMC_ReadUCID(uint32_t u32Index)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_UID;          /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x04;           
N    FMC->ISPADDR = (0x04 * u32Index) + 0x10;     /* The UCID is at offset 0x10 with word alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADDR = (0x04 * u32Index) + 0x10;      
N    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;         /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = (0x1ul << (0));          
N#if ISBEN
X#if 0
S    __ISB();
N#endif                                     /* To make sure ISP/CPU be Synchronized */
N    while(FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk);  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG & (0x1ul << (0)));   
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N/**
N * @brief       Set vector mapping address
N *
N * @param[in]   u32PageAddr  The page address to remap to address 0x0. The address must be page alignment.
N *
N * @return      To set VECMAP to remap specified page address to 0x0.
N *
N * @details     This function is used to set VECMAP to map specified page to vector page (0x0).
N *
N * @note
N *              VECMAP only valid when new IAP function is enabled. (CBS = 10'b or 00'b)
N *
N */
Nstatic __INLINE void FMC_SetVectorPageAddr(uint32_t u32PageAddr)
Xstatic __inline void FMC_SetVectorPageAddr(uint32_t u32PageAddr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_VECMAP; /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x2E;  
N    FMC->ISPADDR = u32PageAddr;       /* The address of specified page which will be map to address 0x0. It must be page alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADDR = u32PageAddr;        
N    FMC->ISPTRG = 0x1;               /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;                
N#if ISBEN
X#if 0
S    __ISB();
N#endif                         /* To make sure ISP/CPU be Synchronized */
N    while(FMC->ISPTRG);              /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);               
N}
N
N/**
N * @brief       Get current vector mapping address.
N *
N * @param       None
N *
N * @return      The current vector mapping address.
N *
N * @details     To get VECMAP value which is the page address for remapping to vector page (0x0).
N *
N * @note
N *              VECMAP only valid when new IAP function is enabled. (CBS = 10'b or 00'b)
N *
N */
Nstatic __INLINE uint32_t FMC_GetVECMAP(void)
Xstatic __inline uint32_t FMC_GetVECMAP(void)
N{
N    return (FMC->ISPSTS & FMC_ISPSTS_VECMAP_Msk);
X    return (((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPSTS & (0x1ffffful << (9)));
N}
N
N/**
N * @brief       Get Flash Checksum
N *
N * @param[in]   u32Addr    Specific flash start address
N * @param[in]   i32Size    Specific a size of Flash area
N *
N * @return      A checksum value of a flash block.
N *
N * @details     To get VECMAP value which is the page address for remapping to vector page (0x0).
N *
N */
Nstatic __INLINE uint32_t FMC_GetCheckSum(uint32_t u32Addr, int32_t i32Size)
Xstatic __inline uint32_t FMC_GetCheckSum(uint32_t u32Addr, int32_t i32Size)
N{
N    FMC->ISPCMD = FMC_ISPCMD_CAL_CHECKSUM;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x2D;
N    FMC->ISPADDR = u32Addr;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADDR = u32Addr;
N    FMC->ISPDAT = i32Size;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT = i32Size;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;
N#if ISBEN
X#if 0
S    __ISB();
N#endif
N    while(FMC->ISPTRG);
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);
N
N    FMC->ISPCMD = FMC_ISPCMD_CHECKSUM;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x0D;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;
N    while(FMC->ISPTRG);
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N/**
N * @brief      Program Multi-Word data into specified address of flash
N *
N * @param[in]  u32Addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N * @param[in]  pu32Buf  A data pointer is point to a data buffer start address;
N *
N * @return     None
N *
N * @details    To program multi-words data into Flash include APROM, LDROM, Data Flash, and CONFIG.
N *             The corresponding functions in CONFIG are listed in FMC section of Technical Reference Manual.
N *
N */
Nstatic __INLINE void FMC_Write256(uint32_t u32Addr, uint32_t *pu32Buf)
Xstatic __inline void FMC_Write256(uint32_t u32Addr, uint32_t *pu32Buf)
N{
N    int32_t i, idx;
N    volatile uint32_t *pu32IspData;
N    //int32_t i32Err;
N
N    //i32Err = 0;
N    idx = 0;
N    FMC->ISPCMD = FMC_ISPCMD_MULTI_PROG;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x27;
N    FMC->ISPADDR = u32Addr;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADDR = u32Addr;
N
Nretrigger:
N
N    //if(i32Err)
N    //    printf("idx=%d  ISPADDR = 0x%08x\n",idx, FMC->ISPADDR);
N
N    FMC->MPDAT0 = pu32Buf[idx + 0];
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->MPDAT0 = pu32Buf[idx + 0];
N    FMC->MPDAT1 = pu32Buf[idx + 1];
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->MPDAT1 = pu32Buf[idx + 1];
N    FMC->MPDAT2 = pu32Buf[idx + 2];
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->MPDAT2 = pu32Buf[idx + 2];
N    FMC->MPDAT3 = pu32Buf[idx + 3];
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->MPDAT3 = pu32Buf[idx + 3];
N
N
N
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;
N
N    pu32IspData = &FMC->MPDAT0;
X    pu32IspData = &((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->MPDAT0;
N    idx += 4;
N
N    for(i = idx; i < 256 / 4; i += 4) // Max data length is 256 bytes (256/4 words)
N    {
N
N        __set_PRIMASK(1); // Mask interrupt to avoid status check coherence error
N        do
N        {
N            if((FMC->MPSTS & FMC_MPSTS_MPBUSY_Msk) == 0)
X            if((((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->MPSTS & (0x1ul << (0))) == 0)
N            {
N                __set_PRIMASK(0);
N                //printf("%d %x\n", i, FMC->MPADDR);
N                FMC->ISPADDR = FMC->MPADDR & (~0xful);
X                ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADDR = ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->MPADDR & (~0xful);
N                idx = (FMC->ISPADDR - u32Addr) / 4;
X                idx = (((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADDR - u32Addr) / 4;
N                //i32Err = -1;
N                goto retrigger;
N            }
N        }
N        while(FMC->MPSTS & (3 << FMC_MPSTS_D0_Pos));
X        while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->MPSTS & (3 << (4)));
N
N        // Update new data for D0
N        pu32IspData[0] = pu32Buf[i  ];
N        pu32IspData[1] = pu32Buf[i + 1];
N
N        do
N        {
N            if((FMC->MPSTS & FMC_MPSTS_MPBUSY_Msk) == 0)
X            if((((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->MPSTS & (0x1ul << (0))) == 0)
N            {
N                __set_PRIMASK(0);
N                //printf("%d %x\n", i, FMC->MPADDR);
N                FMC->ISPADDR = FMC->MPADDR & (~0xful);
X                ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADDR = ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->MPADDR & (~0xful);
N                idx = (FMC->ISPADDR - u32Addr) / 4;
X                idx = (((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADDR - u32Addr) / 4;
N                //i32Err = -1;
N                goto retrigger;
N            }
N        }
N        while(FMC->MPSTS & (3 << FMC_MPSTS_D2_Pos));
X        while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->MPSTS & (3 << (6)));
N
N        // Update new data for D2
N        pu32IspData[2] = pu32Buf[i + 2];
N        pu32IspData[3] = pu32Buf[i + 3];
N        __set_PRIMASK(0);
N    }
N
N    while(FMC->ISPSTS & FMC_ISPSTS_ISPBUSY_Msk);
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPSTS & (0x1ul << (0)));
N}
N
Nvoid FMC_Open(void);
Nvoid FMC_Close(void);
Nvoid FMC_EnableAPUpdate(void);
Nvoid FMC_DisableAPUpdate(void);
Nvoid FMC_EnableConfigUpdate(void);
Nvoid FMC_DisableConfigUpdate(void);
Nvoid FMC_EnableLDUpdate(void);
Nvoid FMC_DisableLDUpdate(void);
Nint32_t FMC_ReadConfig(uint32_t *u32Config, uint32_t u32Count);
Nint32_t FMC_WriteConfig(uint32_t *u32Config, uint32_t u32Count);
Nvoid FMC_SetBootSource(int32_t i32BootSrc);
Nint32_t FMC_GetBootSource(void);
Nuint32_t FMC_ReadDataFlashBaseAddr(void);
Nvoid FMC_EnableFreqOptimizeMode(uint32_t u32Mode);
Nvoid FMC_DisableFreqOptimizeMode(void);
N
N/*@}*/ /* end of group FMC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group FMC_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__FMC_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
N
L 17559 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "gpio.h"
L 1 "..\lib\StdDriver\inc\gpio.h" 1
N/**************************************************************************//**
N * @file     GPIO.h
N * @version  V2.1
N * $Revision: 7 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE series General Purpose I/O (GPIO) driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __GPIO_H__
N#define __GPIO_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup GPIO_Driver GPIO Driver
N  @{
N*/
N
N/** @addtogroup GPIO_EXPORTED_CONSTANTS GPIO Exported Constants
N  @{
N*/
N
N#define GPIO_PIN_MAX            16 /*!< Specify Maximum Pins of Each GPIO Port */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO_MODE Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_MODE_INPUT          0x0UL /*!< Input Mode */
N#define GPIO_MODE_OUTPUT         0x1UL /*!< Output Mode */
N#define GPIO_MODE_OPEN_DRAIN     0x2UL /*!< Open-Drain Mode */
N#define GPIO_MODE_QUASI          0x3UL /*!< Quasi-bidirectional Mode */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO Interrupt Type Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INT_RISING         0x00010000UL /*!< Interrupt enable by Input Rising Edge */
N#define GPIO_INT_FALLING        0x00000001UL /*!< Interrupt enable by Input Falling Edge */
N#define GPIO_INT_BOTH_EDGE      0x00010001UL /*!< Interrupt enable by both Rising Edge and Falling Edge */
N#define GPIO_INT_HIGH           0x01010000UL /*!< Interrupt enable by Level-High */
N#define GPIO_INT_LOW            0x01000001UL /*!< Interrupt enable by Level-Level */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO_INTTYPE Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INTTYPE_EDGE           0UL /*!< GPIO_INTTYPE Setting for Edge Trigger Mode */
N#define GPIO_INTTYPE_LEVEL          1UL /*!< GPIO_INTTYPE Setting for Edge Level Mode */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO_DBCTL Constant Definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_DBCTL_ICLK_ON            0x00000020UL /*!< GPIO_DBCTL setting for all IO pins edge detection circuit is always active after reset */
N#define GPIO_DBCTL_ICLK_OFF           0x00000000UL /*!< GPIO_DBCTL setting for edge detection circuit is active only if IO pin corresponding GPIOx_IEN bit is set to 1 */
N
N#define GPIO_DBCTL_DBCLKSRC_LIRC      0x00000010UL /*!< GPIO_DBCTL setting for de-bounce counter clock source is the internal 10 kHz */
N#define GPIO_DBCTL_DBCLKSRC_HCLK      0x00000000UL /*!< GPIO_DBCTL setting for de-bounce counter clock source is the HCLK */
N
N#define GPIO_DBCTL_DBCLKSEL_1         0x00000000UL /*!< GPIO_DBCTL setting for sampling cycle = 1 clocks */
N#define GPIO_DBCTL_DBCLKSEL_2         0x00000001UL /*!< GPIO_DBCTL setting for sampling cycle = 2 clocks */
N#define GPIO_DBCTL_DBCLKSEL_4         0x00000002UL /*!< GPIO_DBCTL setting for sampling cycle = 4 clocks */
N#define GPIO_DBCTL_DBCLKSEL_8         0x00000003UL /*!< GPIO_DBCTL setting for sampling cycle = 8 clocks */
N#define GPIO_DBCTL_DBCLKSEL_16        0x00000004UL /*!< GPIO_DBCTL setting for sampling cycle = 16 clocks */
N#define GPIO_DBCTL_DBCLKSEL_32        0x00000005UL /*!< GPIO_DBCTL setting for sampling cycle = 32 clocks */
N#define GPIO_DBCTL_DBCLKSEL_64        0x00000006UL /*!< GPIO_DBCTL setting for sampling cycle = 64 clocks */
N#define GPIO_DBCTL_DBCLKSEL_128       0x00000007UL /*!< GPIO_DBCTL setting for sampling cycle = 128 clocks */
N#define GPIO_DBCTL_DBCLKSEL_256       0x00000008UL /*!< GPIO_DBCTL setting for sampling cycle = 256 clocks */
N#define GPIO_DBCTL_DBCLKSEL_512       0x00000009UL /*!< GPIO_DBCTL setting for sampling cycle = 512 clocks */
N#define GPIO_DBCTL_DBCLKSEL_1024      0x0000000AUL /*!< GPIO_DBCTL setting for sampling cycle = 1024 clocks */
N#define GPIO_DBCTL_DBCLKSEL_2048      0x0000000BUL /*!< GPIO_DBCTL setting for sampling cycle = 2048 clocks */
N#define GPIO_DBCTL_DBCLKSEL_4096      0x0000000CUL /*!< GPIO_DBCTL setting for sampling cycle = 4096 clocks */
N#define GPIO_DBCTL_DBCLKSEL_8192      0x0000000DUL /*!< GPIO_DBCTL setting for sampling cycle = 8192 clocks */
N#define GPIO_DBCTL_DBCLKSEL_16384     0x0000000EUL /*!< GPIO_DBCTL setting for sampling cycle = 16384 clocks */
N#define GPIO_DBCTL_DBCLKSEL_32768     0x0000000FUL /*!< GPIO_DBCTL setting for sampling cycle = 32768 clocks */
N
N
N/** Define GPIO Pin Data Input/Output. It could be used to control each I/O pin by pin address mapping.
N *  Example 1:
N *
N *      PA0 = 1;
N *
N *  It is used to set PA.0 to high;
N *
N *  Example 2:
N *
N *      if (PA0)
N *          PA0 = 0;
N *
N *  If PA.0 pin status is high, then set PA.0 data output to low.
N */
N#define GPIO_PIN_DATA(port, pin)    (*((volatile uint32_t *)((GPIO_PIN_DATA_BASE+(0x40*(port))) + ((pin)<<2))))
N#define PA0             GPIO_PIN_DATA(0, 0 ) /*!< Specify PA.0 Pin Data Input/Output */
N#define PA1             GPIO_PIN_DATA(0, 1 ) /*!< Specify PA.1 Pin Data Input/Output */
N#define PA2             GPIO_PIN_DATA(0, 2 ) /*!< Specify PA.2 Pin Data Input/Output */
N#define PA3             GPIO_PIN_DATA(0, 3 ) /*!< Specify PA.3 Pin Data Input/Output */
N#define PA4             GPIO_PIN_DATA(0, 4 ) /*!< Specify PA.4 Pin Data Input/Output */
N#define PA5             GPIO_PIN_DATA(0, 5 ) /*!< Specify PA.5 Pin Data Input/Output */
N#define PA6             GPIO_PIN_DATA(0, 6 ) /*!< Specify PA.6 Pin Data Input/Output */
N#define PA7             GPIO_PIN_DATA(0, 7 ) /*!< Specify PA.7 Pin Data Input/Output */
N#define PA8             GPIO_PIN_DATA(0, 8 ) /*!< Specify PA.8 Pin Data Input/Output */
N#define PA9             GPIO_PIN_DATA(0, 9 ) /*!< Specify PA.9 Pin Data Input/Output */
N#define PA10            GPIO_PIN_DATA(0, 10) /*!< Specify PA.10 Pin Data Input/Output */
N#define PA11            GPIO_PIN_DATA(0, 11) /*!< Specify PA.11 Pin Data Input/Output */
N#define PA12            GPIO_PIN_DATA(0, 12) /*!< Specify PA.12 Pin Data Input/Output */
N#define PA13            GPIO_PIN_DATA(0, 13) /*!< Specify PA.13 Pin Data Input/Output */
N#define PA14            GPIO_PIN_DATA(0, 14) /*!< Specify PA.14 Pin Data Input/Output */
N#define PA15            GPIO_PIN_DATA(0, 15) /*!< Specify PA.15 Pin Data Input/Output */
N#define PB0             GPIO_PIN_DATA(1, 0 ) /*!< Specify PB.0 Pin Data Input/Output */
N#define PB1             GPIO_PIN_DATA(1, 1 ) /*!< Specify PB.1 Pin Data Input/Output */
N#define PB2             GPIO_PIN_DATA(1, 2 ) /*!< Specify PB.2 Pin Data Input/Output */
N#define PB3             GPIO_PIN_DATA(1, 3 ) /*!< Specify PB.3 Pin Data Input/Output */
N#define PB4             GPIO_PIN_DATA(1, 4 ) /*!< Specify PB.4 Pin Data Input/Output */
N#define PB5             GPIO_PIN_DATA(1, 5 ) /*!< Specify PB.5 Pin Data Input/Output */
N#define PB6             GPIO_PIN_DATA(1, 6 ) /*!< Specify PB.6 Pin Data Input/Output */
N#define PB7             GPIO_PIN_DATA(1, 7 ) /*!< Specify PB.7 Pin Data Input/Output */
N#define PB8             GPIO_PIN_DATA(1, 8 ) /*!< Specify PB.8 Pin Data Input/Output */
N#define PB9             GPIO_PIN_DATA(1, 9 ) /*!< Specify PB.9 Pin Data Input/Output */
N#define PB10            GPIO_PIN_DATA(1, 10) /*!< Specify PB.10 Pin Data Input/Output */
N#define PB11            GPIO_PIN_DATA(1, 11) /*!< Specify PB.11 Pin Data Input/Output */
N#define PB12            GPIO_PIN_DATA(1, 12) /*!< Specify PB.12 Pin Data Input/Output */
N#define PB13            GPIO_PIN_DATA(1, 13) /*!< Specify PB.13 Pin Data Input/Output */
N#define PB14            GPIO_PIN_DATA(1, 14) /*!< Specify PB.14 Pin Data Input/Output */
N#define PB15            GPIO_PIN_DATA(1, 15) /*!< Specify PB.15 Pin Data Input/Output */
N#define PC0             GPIO_PIN_DATA(2, 0 ) /*!< Specify PC.0 Pin Data Input/Output */
N#define PC1             GPIO_PIN_DATA(2, 1 ) /*!< Specify PC.1 Pin Data Input/Output */
N#define PC2             GPIO_PIN_DATA(2, 2 ) /*!< Specify PC.2 Pin Data Input/Output */
N#define PC3             GPIO_PIN_DATA(2, 3 ) /*!< Specify PC.3 Pin Data Input/Output */
N#define PC4             GPIO_PIN_DATA(2, 4 ) /*!< Specify PC.4 Pin Data Input/Output */
N#define PC5             GPIO_PIN_DATA(2, 5 ) /*!< Specify PC.5 Pin Data Input/Output */
N#define PC6             GPIO_PIN_DATA(2, 6 ) /*!< Specify PC.6 Pin Data Input/Output */
N#define PC7             GPIO_PIN_DATA(2, 7 ) /*!< Specify PC.7 Pin Data Input/Output */
N#define PC8             GPIO_PIN_DATA(2, 8 ) /*!< Specify PC.8 Pin Data Input/Output */
N#define PC9             GPIO_PIN_DATA(2, 9 ) /*!< Specify PC.9 Pin Data Input/Output */
N#define PC10            GPIO_PIN_DATA(2, 10) /*!< Specify PC.10 Pin Data Input/Output */
N#define PC11            GPIO_PIN_DATA(2, 11) /*!< Specify PC.11 Pin Data Input/Output */
N#define PC12            GPIO_PIN_DATA(2, 12) /*!< Specify PC.12 Pin Data Input/Output */
N#define PC13            GPIO_PIN_DATA(2, 13) /*!< Specify PC.13 Pin Data Input/Output */
N#define PC14            GPIO_PIN_DATA(2, 14) /*!< Specify PC.14 Pin Data Input/Output */
N#define PC15            GPIO_PIN_DATA(2, 15) /*!< Specify PC.15 Pin Data Input/Output */
N#define PD0             GPIO_PIN_DATA(3, 0 ) /*!< Specify PD.0 Pin Data Input/Output */
N#define PD1             GPIO_PIN_DATA(3, 1 ) /*!< Specify PD.1 Pin Data Input/Output */
N#define PD2             GPIO_PIN_DATA(3, 2 ) /*!< Specify PD.2 Pin Data Input/Output */
N#define PD3             GPIO_PIN_DATA(3, 3 ) /*!< Specify PD.3 Pin Data Input/Output */
N#define PD4             GPIO_PIN_DATA(3, 4 ) /*!< Specify PD.4 Pin Data Input/Output */
N#define PD5             GPIO_PIN_DATA(3, 5 ) /*!< Specify PD.5 Pin Data Input/Output */
N#define PD6             GPIO_PIN_DATA(3, 6 ) /*!< Specify PD.6 Pin Data Input/Output */
N#define PD7             GPIO_PIN_DATA(3, 7 ) /*!< Specify PD.7 Pin Data Input/Output */
N#define PD8             GPIO_PIN_DATA(3, 8 ) /*!< Specify PD.8 Pin Data Input/Output */
N#define PD9             GPIO_PIN_DATA(3, 9 ) /*!< Specify PD.9 Pin Data Input/Output */
N#define PD10            GPIO_PIN_DATA(3, 10) /*!< Specify PD.10 Pin Data Input/Output */
N#define PD11            GPIO_PIN_DATA(3, 11) /*!< Specify PD.11 Pin Data Input/Output */
N#define PD12            GPIO_PIN_DATA(3, 12) /*!< Specify PD.12 Pin Data Input/Output */
N#define PD13            GPIO_PIN_DATA(3, 13) /*!< Specify PD.13 Pin Data Input/Output */
N#define PD14            GPIO_PIN_DATA(3, 14) /*!< Specify PD.14 Pin Data Input/Output */
N#define PD15            GPIO_PIN_DATA(3, 15) /*!< Specify PD.15 Pin Data Input/Output */
N#define PE0             GPIO_PIN_DATA(4, 0 ) /*!< Specify PE.0 Pin Data Input/Output */
N#define PE1             GPIO_PIN_DATA(4, 1 ) /*!< Specify PE.1 Pin Data Input/Output */
N#define PE2             GPIO_PIN_DATA(4, 2 ) /*!< Specify PE.2 Pin Data Input/Output */
N#define PE3             GPIO_PIN_DATA(4, 3 ) /*!< Specify PE.3 Pin Data Input/Output */
N#define PE4             GPIO_PIN_DATA(4, 4 ) /*!< Specify PE.4 Pin Data Input/Output */
N#define PE5             GPIO_PIN_DATA(4, 5 ) /*!< Specify PE.5 Pin Data Input/Output */
N#define PE6             GPIO_PIN_DATA(4, 6 ) /*!< Specify PE.6 Pin Data Input/Output */
N#define PE7             GPIO_PIN_DATA(4, 7 ) /*!< Specify PE.7 Pin Data Input/Output */
N#define PE8             GPIO_PIN_DATA(4, 8 ) /*!< Specify PE.8 Pin Data Input/Output */
N#define PE9             GPIO_PIN_DATA(4, 9 ) /*!< Specify PE.9 Pin Data Input/Output */
N#define PE10            GPIO_PIN_DATA(4, 10) /*!< Specify PE.10 Pin Data Input/Output */
N#define PE11            GPIO_PIN_DATA(4, 11) /*!< Specify PE.11 Pin Data Input/Output */
N#define PE12            GPIO_PIN_DATA(4, 12) /*!< Specify PE.12 Pin Data Input/Output */
N#define PE13            GPIO_PIN_DATA(4, 13) /*!< Specify PE.13 Pin Data Input/Output */
N#define PF0             GPIO_PIN_DATA(5, 0 ) /*!< Specify PF.0 Pin Data Input/Output */
N#define PF1             GPIO_PIN_DATA(5, 1 ) /*!< Specify PF.1 Pin Data Input/Output */
N#define PF2             GPIO_PIN_DATA(5, 2 ) /*!< Specify PF.2 Pin Data Input/Output */
N#define PF3             GPIO_PIN_DATA(5, 3 ) /*!< Specify PF.3 Pin Data Input/Output */
N#define PF4             GPIO_PIN_DATA(5, 4 ) /*!< Specify PF.4 Pin Data Input/Output */
N#define PF5             GPIO_PIN_DATA(5, 5 ) /*!< Specify PF.5 Pin Data Input/Output */
N#define PF6             GPIO_PIN_DATA(5, 6 ) /*!< Specify PF.6 Pin Data Input/Output */
N#define PF7             GPIO_PIN_DATA(5, 7 ) /*!< Specify PF.7 Pin Data Input/Output */
N
N/*@}*/ /* end of group GPIO_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup GPIO_EXPORTED_FUNCTIONS GPIO Exported Functions
N  @{
N*/
N
N/**
N * @brief       Clear GPIO Pin Interrupt Flag
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \n
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC and PD. \n
N *                          It could be BIT0 ~ BIT13 for PE. \n
N *                          It could be BIT0 ~ BIT7 for PF.
N *
N * @return      None
N *
N * @details     Clear the interrupt status of specified GPIO pin.
N */
N#define GPIO_CLR_INT_FLAG(port, u32PinMask)         ((port)->INTSRC = (u32PinMask))
N
N/**
N * @brief       Disable Pin De-bounce Function
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \n
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC and PD. \n
N *                          It could be BIT0 ~ BIT13 for PE. \n
N *                          It could be BIT0 ~ BIT7 for PF.
N *
N * @return      None
N *
N * @details     Disable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_DISABLE_DEBOUNCE(port, u32PinMask)     ((port)->DBEN &= ~(u32PinMask))
N
N/**
N * @brief       Enable Pin De-bounce Function
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \n
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC and PD. \n
N *                          It could be BIT0 ~ BIT13 for PE. \n
N *                          It could be BIT0 ~ BIT7 for PF.
N * @return      None
N *
N * @details     Enable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_ENABLE_DEBOUNCE(port, u32PinMask)      ((port)->DBEN |= (u32PinMask))
N
N/**
N * @brief       Disable I/O Digital Input Path
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \n
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC and PD. \n
N *                          It could be BIT0 ~ BIT13 for PE. \n
N *                          It could be BIT0 ~ BIT7 for PF.
N *
N * @return      None
N *
N * @details     Disable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_DISABLE_DIGITAL_PATH(port, u32PinMask) ((port)->DINOFF |= ((u32PinMask)<<16))
N
N/**
N * @brief       Enable I/O Digital Input Path
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \n
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC and PD. \n
N *                          It could be BIT0 ~ BIT13 for PE. \n
N *                          It could be BIT0 ~ BIT7 for PF.
N *
N * @return      None
N *
N * @details     Enable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_ENABLE_DIGITAL_PATH(port, u32PinMask)  ((port)->DINOFF &= ~((u32PinMask)<<16))
N
N/**
N * @brief       Disable I/O DOUT mask
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \n
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC and PD. \n
N *                          It could be BIT0 ~ BIT13 for PE. \n
N *                          It could be BIT0 ~ BIT7 for PF.
N *
N * @return      None
N *
N * @details     Disable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_DISABLE_DOUT_MASK(port, u32PinMask)    ((port)->DATMSK &= ~(u32PinMask))
N
N/**
N * @brief       Enable I/O DOUT mask
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \n
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC and PD. \n
N *                          It could be BIT0 ~ BIT13 for PE. \n
N *                          It could be BIT0 ~ BIT7 for PF.
N *
N * @return      None
N *
N * @details     Enable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_ENABLE_DOUT_MASK(port, u32PinMask) ((port)->DATMSK |= (u32PinMask))
N
N/**
N * @brief       Get GPIO Pin Interrupt Flag
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \n
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC and PD. \n
N *                          It could be BIT0 ~ BIT13 for PE. \n
N *                          It could be BIT0 ~ BIT7 for PF.
N *
N * @retval      0           No interrupt at specified GPIO pin
N * @retval      1           The specified GPIO pin generate an interrupt
N *
N * @details     Get the interrupt status of specified GPIO pin.
N */
N#define GPIO_GET_INT_FLAG(port, u32PinMask)     ((port)->INTSRC & (u32PinMask))
N
N/**
N * @brief       Set De-bounce Sampling Cycle Time
N *
N * @param[in]   u32ClkSrc   The de-bounce counter clock source. It could be GPIO_DBCTL_DBCLKSRC_HCLK or GPIO_DBCTL_DBCLKSRC_LIRC.
N * @param[in]   u32ClkSel   The de-bounce sampling cycle selection. It could be
N *                            - \ref GPIO_DBCTL_DBCLKSEL_1
N *                            - \ref GPIO_DBCTL_DBCLKSEL_2
N *                            - \ref GPIO_DBCTL_DBCLKSEL_4
N *                            - \ref GPIO_DBCTL_DBCLKSEL_8
N *                            - \ref GPIO_DBCTL_DBCLKSEL_16
N *                            - \ref GPIO_DBCTL_DBCLKSEL_32
N *                            - \ref GPIO_DBCTL_DBCLKSEL_64
N *                            - \ref GPIO_DBCTL_DBCLKSEL_128
N *                            - \ref GPIO_DBCTL_DBCLKSEL_256
N *                            - \ref GPIO_DBCTL_DBCLKSEL_512
N *                            - \ref GPIO_DBCTL_DBCLKSEL_1024
N *                            - \ref GPIO_DBCTL_DBCLKSEL_2048
N *                            - \ref GPIO_DBCTL_DBCLKSEL_4096
N *                            - \ref GPIO_DBCTL_DBCLKSEL_8192
N *                            - \ref GPIO_DBCTL_DBCLKSEL_16384
N *                            - \ref GPIO_DBCTL_DBCLKSEL_32768
N *
N * @return      None
N *
N * @details     Set the interrupt de-bounce sampling cycle time based on the debounce counter clock source. \n
N *              Example: _GPIO_SET_DEBOUNCE_TIME(GPIO_DBCTL_DBCLKSRC_LIRC, GPIO_DBCTL_DBCLKSEL_4). \n
N *              It's meaning the De-debounce counter clock source is internal 10 KHz and sampling cycle selection is 4. \n
N *              Then the target de-bounce sampling cycle time is (4)*(1/(10*1000)) s = 4*0.0001 s = 400 us,
N *              and system will sampling interrupt input once per 400 us.
N */
N#define GPIO_SET_DEBOUNCE_TIME(u32ClkSrc, u32ClkSel)    (GPIO->DBCTL = (GPIO_DBCTL_ICLKON_Msk | (u32ClkSrc) | (u32ClkSel)))
N
N/**
N * @brief       Get GPIO Port IN Data
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N *
N * @return      The specified port data
N *
N * @details     Get the PIN register of specified GPIO port.
N */
N#define GPIO_GET_IN_DATA(port)  ((port)->PIN)
N
N/**
N * @brief       Set GPIO Port OUT Data
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32Data     GPIO port data.
N *
N * @return      None
N *
N * @details     Set the Data into specified GPIO port.
N */
N#define GPIO_SET_OUT_DATA(port, u32Data)    ((port)->DOUT = (u32Data))
N
N/**
N * @brief       Toggle Specified GPIO pin
N *
N * @param[in]   u32Pin      Pxy
N *
N * @return      None
N *
N * @details     Toggle the specified GPIO pint.
N */
N#define GPIO_TOGGLE(u32Pin) ((u32Pin) ^= 1)
N
N
N/**
N * @brief       Enable External GPIO interrupt
N *
N * @param[in]   port            GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32Pin          The pin of specified GPIO port. \n
N *                              It could be 0 ~ 15 for PA, PB, PC and PD GPIO port. \n
N *                              It could be 0 ~ 13 for PE GPIO port. \n
N *                              It could be 0 ~ 7 for PF GPIO port.
N * @param[in]   u32IntAttribs   The interrupt attribute of specified GPIO pin. It could be
N *                            - \ref GPIO_INT_RISING
N *                            - \ref GPIO_INT_FALLING
N *                            - \ref GPIO_INT_BOTH_EDGE
N *                            - \ref GPIO_INT_HIGH
N *                            - \ref GPIO_INT_LOW
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_EnableEINT     GPIO_EnableInt
N
N/**
N * @brief       Disable External GPIO interrupt
N *
N * @param[in]   port            GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32Pin          The pin of specified GPIO port. \n
N *                              It could be 0 ~ 15 for PA, PB, PC and PD GPIO port. \n
N *                              It could be 0 ~ 13 for PE GPIO port. \n
N *                              It could be 0 ~ 7 for PF GPIO port.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_DisableEINT    GPIO_DisableInt
N
N
Nvoid GPIO_SetMode(GPIO_T *port, uint32_t u32PinMask, uint32_t u32Mode);
Nvoid GPIO_EnableInt(GPIO_T *port, uint32_t u32Pin, uint32_t u32IntAttribs);
Nvoid GPIO_DisableInt(GPIO_T *port, uint32_t u32Pin);
N
N
N/*@}*/ /* end of group GPIO_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group GPIO_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__GPIO_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17560 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "i2c.h"
L 1 "..\lib\StdDriver\inc\i2c.h" 1
N/**************************************************************************//**
N * @file     i2c.h
N * @version  V3.0
N * $Revision: 9 $
N * $Date: 16/11/11 3:14p $
N * @brief    NUC029xGE series I2C Serial Interface Controller(I2C) driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __I2C_H__
N#define __I2C_H__
N
N#include "NUC029xGE.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup I2C_Driver I2C Driver
N  @{
N*/
N
N/** @addtogroup I2C_EXPORTED_CONSTANTS I2C Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  I2C_CTL constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define I2C_CTL_STA_STO_SI        0x38UL /*!< I2C_CTL setting for I2C control bits. It would set STA, STO and SI bits     */
N#define I2C_CTL_STA_STO_SI_AA     0x3CUL /*!< I2C_CTL setting for I2C control bits. It would set STA, STO, SI and AA bits */
N#define I2C_CTL_STA_SI            0x28UL /*!< I2C_CTL setting for I2C control bits. It would set STA and SI bits          */
N#define I2C_CTL_STA_SI_AA         0x2CUL /*!< I2C_CTL setting for I2C control bits. It would set STA, SI and AA bits      */
N#define I2C_CTL_STO_SI            0x18UL /*!< I2C_CTL setting for I2C control bits. It would set STO and SI bits          */
N#define I2C_CTL_STO_SI_AA         0x1CUL /*!< I2C_CTL setting for I2C control bits. It would set STO, SI and AA bits      */
N#define I2C_CTL_SI                0x08UL /*!< I2C_CTL setting for I2C control bits. It would set SI bit                   */
N#define I2C_CTL_SI_AA             0x0CUL /*!< I2C_CTL setting for I2C control bits. It would set SI and AA bits           */
N#define I2C_CTL_STA               0x20UL /*!< I2C_CTL setting for I2C control bits. It would set STA bit                  */
N#define I2C_CTL_STO               0x10UL /*!< I2C_CTL setting for I2C control bits. It would set STO bit                  */
N#define I2C_CTL_AA                0x04UL /*!< I2C_CTL setting for I2C control bits. It would set AA bit                   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  I2C GCMode constant definitions.                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define I2C_GCMODE_ENABLE           1    /*!< Enable  I2C GC Mode                                                         */
N#define I2C_GCMODE_DISABLE          0    /*!< Disable I2C GC Mode                                                         */
N
N/*@}*/ /* end of group I2C_EXPORTED_CONSTANTS */
N
N/** @addtogroup I2C_EXPORTED_FUNCTIONS I2C Exported Functions
N  @{
N*/
N/**
N *    @brief        The macro is used to set I2C bus condition at One Time
N *
N *    @param[in]    i2c        Specify I2C port
N *    @param[in]    u8Ctrl     A byte writes to I2C control register
N *
N *    @return       None
N *
N *    @details      Set I2C_CTL register to control I2C bus conditions of START, STOP, SI, ACK.
N */
N#define I2C_SET_CONTROL_REG(i2c, u8Ctrl) ((i2c)->CTL = ((i2c)->CTL & ~0x3c) | (u8Ctrl))
N
N/**
N *    @brief        The macro is used to set START condition of I2C Bus
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       None
N *
N *    @details      Set the I2C bus START condition in I2C_CTL register.
N */
N#define I2C_START(i2c)  ((i2c)->CTL = ((i2c)->CTL | I2C_CTL_SI_Msk) | I2C_CTL_STA_Msk)
N
N/**
N *    @brief        The macro is used to set STOP condition of I2C Bus
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       None
N *
N *    @details      Set the I2C bus STOP condition in I2C_CTL register.
N */
N#define I2C_STOP(i2c)   ((i2c)->CTL = ((i2c)->CTL | I2C_CTL_SI_Msk) | I2C_CTL_STO_Msk)
N
N/**
N *    @brief        The macro is used to wait I2C bus status get ready
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       None
N *
N *    @details      When a new status is presented of I2C bus, the SI flag will be set in I2C_CTL register.
N */
N#define I2C_WAIT_READY(i2c)     while(!((i2c)->CTL & I2C_CTL_SI_Msk))
N
N/**
N *    @brief        The macro is used to Read I2C Bus Data Register
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       A byte of I2C data register
N *
N *    @details      I2C controller read data from bus and save it in I2CDAT register.
N */
N#define I2C_GET_DATA(i2c)   ((i2c)->DAT)
N
N/**
N *    @brief        Write a Data to I2C Data Register
N *
N *    @param[in]    i2c         Specify I2C port
N *    @param[in]    u8Data      A byte that writes to data register
N *
N *    @return       None
N *
N *    @details      When write a data to I2C_DAT register, the I2C controller will shift it to I2C bus.
N */
N#define I2C_SET_DATA(i2c, u8Data) ((i2c)->DAT = (u8Data))
N
N/**
N *    @brief        Get I2C Bus status code
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       I2C status code
N *
N *    @details      To get this status code to monitor I2C bus event.
N */
N#define I2C_GET_STATUS(i2c) ((i2c)->STATUS)
N
N/**
N *    @brief        Get Time-out flag from I2C Bus
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @retval       0       I2C Bus time-out is not happened
N *    @retval       1       I2C Bus time-out is happened
N *
N *    @details      When I2C bus occurs time-out event, the time-out flag will be set.
N */
N#define I2C_GET_TIMEOUT_FLAG(i2c)   ( ((i2c)->TOCTL & I2C_TOCTL_TOIF_Msk) == I2C_TOCTL_TOIF_Msk ? 1 : 0 )
N
N/**
N *    @brief        To get wake-up flag from I2C Bus
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @retval       0       Chip is not woken-up from power-down mode
N *    @retval       1       Chip is woken-up from power-down mode
N *
N *    @details      I2C bus occurs wake-up event, wake-up flag will be set.
N */
N#define I2C_GET_WAKEUP_FLAG(i2c) ( ((i2c)->WKSTS & I2C_WKSTS_WKIF_Msk) == I2C_WKSTS_WKIF_Msk ? 1 : 0 )
N
N/**
N *    @brief        To clear wake-up flag
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @return       None
N *
N *    @details      If wake-up flag is set, use this macro to clear it.
N */
N#define I2C_CLEAR_WAKEUP_FLAG(i2c)  ((i2c)->WKSTS = I2C_WKSTS_WKIF_Msk)
N
N/**
N *    @brief        To get wake-up address frame ACK done flag from I2C Bus
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @retval       0       The ACK bit cycle of address match frame is not done
N *    @retval       1       The ACK bit cycle of address match frame is done in power-down
N *
N *    @details      I2C bus occurs wake-up event and address frame ACK is done, this flag will be set.
N *
N *    \hideinitializer
N */
N#define I2C_GET_WAKEUP_DONE(i2c) ( ((i2c)->WKSTS & I2C_WKSTS_WKAKDONE_Msk) == I2C_WKSTS_WKAKDONE_Msk ? 1 : 0 )
N
N/**
N *    @brief        To clear address frame ACK done flag
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @return       None
N *
N *    @details      If wake-up done is set, use this macro to clear it.
N *
N *    \hideinitializer
N */
N#define I2C_CLEAR_WAKEUP_DONE(i2c)  ((i2c)->WKSTS = I2C_WKSTS_WKAKDONE_Msk)
N
N/**
N *    @brief        To get read/write status bit in address wakeup frame
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @retval       0       Write command be record on the address match wakeup frame
N *    @retval       1       Read command be record on the address match wakeup frame.
N *
N *    @details      I2C bus occurs wake-up event and address frame is received, this bit will record read/write status.
N *
N *    \hideinitializer
N*/
N#define I2C_GET_WAKEUP_WR_STATUS(i2c) ( ((i2c)->WKSTS & I2C_WKSTS_WRSTSWK_Msk) == I2C_WKSTS_WRSTSWK_Msk ? 1 : 0 )
N
Nvoid I2C_ClearTimeoutFlag(I2C_T *i2c);
Nvoid I2C_Close(I2C_T *i2c);
Nvoid I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack);
Nvoid I2C_DisableInt(I2C_T *i2c);
Nvoid I2C_EnableInt(I2C_T *i2c);
Nuint32_t I2C_GetBusClockFreq(I2C_T *i2c);
Nuint32_t I2C_GetIntFlag(I2C_T *i2c);
Nuint32_t I2C_GetStatus(I2C_T *i2c);
Nuint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock);
Nuint8_t I2C_GetData(I2C_T *i2c);
Nvoid I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode);
Nvoid I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask);
Nuint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock);
Nvoid I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout);
Nvoid I2C_DisableTimeout(I2C_T *i2c);
Nvoid I2C_EnableWakeup(I2C_T *i2c);
Nvoid I2C_DisableWakeup(I2C_T *i2c);
Nvoid I2C_SetData(I2C_T *i2c, uint8_t u8Data);
Nuint8_t I2C_WriteByte(I2C_T *i2c, uint8_t u8SlaveAddr, const uint8_t data);
Nuint32_t I2C_WriteMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, const uint8_t *data, uint32_t u32wLen);
Nuint8_t I2C_WriteByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, const uint8_t data);
Nuint32_t I2C_WriteMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, const uint8_t *data, uint32_t u32wLen);
Nuint8_t I2C_WriteByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, const uint8_t data);
Nuint32_t I2C_WriteMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, const uint8_t *data, uint32_t u32wLen);
Nuint8_t I2C_ReadByte(I2C_T *i2c, uint8_t u8SlaveAddr);
Nuint32_t I2C_ReadMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t *rdata, uint32_t u32rLen);
Nuint8_t I2C_ReadByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr);
Nuint32_t I2C_ReadMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t *rdata, uint32_t u32rLen);
Nuint8_t I2C_ReadByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr);
Nuint32_t I2C_ReadMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t *rdata, uint32_t u32rLen);
N/*@}*/ /* end of group I2C_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group I2C_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N#endif //__I2C_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17561 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "pwm.h"
L 1 "..\lib\StdDriver\inc\pwm.h" 1
N/**************************************************************************//**
N * @file     pwm.h
N * @version  V3.00
N * $Revision: 5 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE series PWM driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __PWM_H__
N#define __PWM_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup PWM_Driver PWM Driver
N  @{
N*/
N
N/** @addtogroup PWM_EXPORTED_CONSTANTS PWM Exported Constants
N  @{
N*/
N#define PWM_CHANNEL_NUM                          (6)        /*!< PWM channel number */
N#define PWM_CH_0_MASK                            (0x1UL)    /*!< PWM channel 0 mask \hideinitializer */
N#define PWM_CH_1_MASK                            (0x2UL)    /*!< PWM channel 1 mask \hideinitializer */
N#define PWM_CH_2_MASK                            (0x4UL)    /*!< PWM channel 2 mask \hideinitializer */
N#define PWM_CH_3_MASK                            (0x8UL)    /*!< PWM channel 3 mask \hideinitializer */
N#define PWM_CH_4_MASK                            (0x10UL)   /*!< PWM channel 4 mask \hideinitializer */
N#define PWM_CH_5_MASK                            (0x20UL)   /*!< PWM channel 5 mask \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Counter Type Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_UP_COUNTER                           (0UL)      /*!< Up counter type */
N#define PWM_DOWN_COUNTER                         (1UL)      /*!< Down counter type */
N#define PWM_UP_DOWN_COUNTER                      (2UL)      /*!< Up-Down counter type */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Aligned Type Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_EDGE_ALIGNED                         (1UL)      /*!< PWM working in edge aligned type(down count) */
N#define PWM_CENTER_ALIGNED                       (2UL)      /*!< PWM working in center aligned type */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Output Level Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_OUTPUT_NOTHING                       (0UL)      /*!< PWM output nothing */
N#define PWM_OUTPUT_LOW                           (1UL)      /*!< PWM output low */
N#define PWM_OUTPUT_HIGH                          (2UL)      /*!< PWM output high */
N#define PWM_OUTPUT_TOGGLE                        (3UL)      /*!< PWM output toggle */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Synchronous Start Function Control Constant Definitions                                                */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_SSCTL_SSRC_PWM0                      (0UL<<PWM_SSCTL_SSRC_Pos)    /*!< Synchronous start source comes from PWM0 */
N#define PWM_SSCTL_SSRC_PWM1                      (1UL<<PWM_SSCTL_SSRC_Pos)    /*!< Synchronous start source comes from PWM0 */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Trigger Source Select Constant Definitions                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_TRIGGER_ADC_EVEN_ZERO_POINT                     (0UL)     /*!< PWM trigger ADC while counter of even channel matches zero point */
N#define PWM_TRIGGER_ADC_EVEN_PERIOD_POINT                   (1UL)     /*!< PWM trigger ADC while counter of even channel matches period point */
N#define PWM_TRIGGER_ADC_EVEN_ZERO_OR_PERIOD_POINT           (2UL)     /*!< PWM trigger ADC while counter of even channel matches zero or period point */
N#define PWM_TRIGGER_ADC_EVEN_COMPARE_UP_COUNT_POINT         (3UL)     /*!< PWM trigger ADC while counter of even channel matches up count to comparator point */
N#define PWM_TRIGGER_ADC_EVEN_COMPARE_DOWN_COUNT_POINT       (4UL)     /*!< PWM trigger ADC while counter of even channel matches down count to comparator point */
N#define PWM_TRIGGER_ADC_ODD_ZERO_POINT                      (5UL)     /*!< PWM trigger ADC while counter of odd channel matches zero point */
N#define PWM_TRIGGER_ADC_ODD_PERIOD_POINT                    (6UL)     /*!< PWM trigger ADC while counter of odd channel matches period point */
N#define PWM_TRIGGER_ADC_ODD_ZERO_OR_PERIOD_POINT            (7UL)     /*!< PWM trigger ADC while counter of odd channel matches zero or period point */
N#define PWM_TRIGGER_ADC_ODD_COMPARE_UP_COUNT_POINT          (8UL)     /*!< PWM trigger ADC while counter of odd channel matches up count to comparator point */
N#define PWM_TRIGGER_ADC_ODD_COMPARE_DOWN_COUNT_POINT        (9UL)     /*!< PWM trigger ADC while counter of odd channel matches down count to comparator point */
N#define PWM_TRIGGER_ADC_CH_0_FREE_COMPARE_UP_COUNT_POINT    (10UL)    /*!< PWM trigger ADC while counter of channel 0 matches up count to free comparator point */
N#define PWM_TRIGGER_ADC_CH_0_FREE_COMPARE_DOWN_COUNT_POINT  (11UL)    /*!< PWM trigger ADC while counter of channel 0 matches down count to free comparator point */
N#define PWM_TRIGGER_ADC_CH_2_FREE_COMPARE_UP_COUNT_POINT    (12UL)    /*!< PWM trigger ADC while counter of channel 2 matches up count to free comparator point */
N#define PWM_TRIGGER_ADC_CH_2_FREE_COMPARE_DOWN_COUNT_POINT  (13UL)    /*!< PWM trigger ADC while counter of channel 2 matches down count to free comparator point */
N#define PWM_TRIGGER_ADC_CH_4_FREE_COMPARE_UP_COUNT_POINT    (14UL)    /*!< PWM trigger ADC while counter of channel 4 matches up count to free comparator point */
N#define PWM_TRIGGER_ADC_CH_4_FREE_COMPARE_DOWN_COUNT_POINT  (15UL)    /*!< PWM trigger ADC while counter of channel 4 matches down count to free comparator point */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Fail brake Control Constant Definitions                                                                */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_FB_EDGE_ACMP0                        (PWM_BRKCTL0_1_CPO0EBEN_Msk)    /*!< Comparator 0 as edge-detect fault brake source */
N#define PWM_FB_EDGE_ACMP1                        (PWM_BRKCTL0_1_CPO1EBEN_Msk)    /*!< Comparator 1 as edge-detect fault brake source */
N#define PWM_FB_EDGE_BKP0                         (PWM_BRKCTL0_1_BRKP0EEN_Msk)    /*!< BKP0 pin as edge-detect fault brake source */
N#define PWM_FB_EDGE_BKP1                         (PWM_BRKCTL0_1_BRKP1EEN_Msk)    /*!< BKP1 pin as edge-detect fault brake source */
N#define PWM_FB_EDGE_ADCRM                        (PWM_BRKCTL0_1_ADCEBEN_Msk)     /*!< ADC Result Monitor (ADCRM) as edge-detect fault brake source */
N#define PWM_FB_EDGE_SYS_CSS                      (PWM_BRKCTL0_1_SYSEBEN_Msk | PWM_FAILBRK_CSSBRKEN_Msk)    /*!< System fail condition: clock security system detection as edge-detect fault brake source */
N#define PWM_FB_EDGE_SYS_BOD                      (PWM_BRKCTL0_1_SYSEBEN_Msk | PWM_FAILBRK_BODBRKEN_Msk)    /*!< System fail condition: brown-out detection as edge-detect fault brake source */
N#define PWM_FB_EDGE_SYS_COR                      (PWM_BRKCTL0_1_SYSEBEN_Msk | PWM_FAILBRK_CORBRKEN_Msk)    /*!< System fail condition: core lockup detection as edge-detect fault brake source */
N
N#define PWM_FB_LEVEL_ACMP0                       (PWM_BRKCTL0_1_CPO0LBEN_Msk)    /*!< Comparator 0 as level-detect fault brake source */
N#define PWM_FB_LEVEL_ACMP1                       (PWM_BRKCTL0_1_CPO1LBEN_Msk)    /*!< Comparator 1 as level-detect fault brake source */
N#define PWM_FB_LEVEL_BKP0                        (PWM_BRKCTL0_1_BRKP0LEN_Msk)    /*!< BKP0 pin as level-detect fault brake source */
N#define PWM_FB_LEVEL_BKP1                        (PWM_BRKCTL0_1_BRKP1LEN_Msk)    /*!< BKP1 pin as level-detect fault brake source */
N#define PWM_FB_LEVEL_ADCRM                       (PWM_BRKCTL0_1_ADCLBEN_Msk)     /*!< ADC Result Monitor (ADCRM) as level-detect fault brake source */
N#define PWM_FB_LEVEL_SYS_CSS                     (PWM_BRKCTL0_1_SYSLBEN_Msk | PWM_FAILBRK_CSSBRKEN_Msk)    /*!< System fail condition: clock security system detection as level-detect fault brake source */
N#define PWM_FB_LEVEL_SYS_BOD                     (PWM_BRKCTL0_1_SYSLBEN_Msk | PWM_FAILBRK_BODBRKEN_Msk)    /*!< System fail condition: brown-out detection as level-detect fault brake source */
N#define PWM_FB_LEVEL_SYS_COR                     (PWM_BRKCTL0_1_SYSLBEN_Msk | PWM_FAILBRK_CORBRKEN_Msk)    /*!< System fail condition: core lockup detection as level-detect fault brake source */
N
N#define PWM_FB_EDGE                              (0UL)    /*!< edge-detect fault brake */
N#define PWM_FB_LEVEL                             (8UL)    /*!< level-detect fault brake */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Leading Edge Blanking Control Constant Definitions                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_LEBCTL_TRGTYPE_RISING              (0UL<<PWM_LEBCTL_TRGTYPE_Pos)    /*!< PWM Leading Edge Blanking Trigger Type Is Rising Edge \hideinitializer */
N#define PWM_LEBCTL_TRGTYPE_FALLING             (1UL<<PWM_LEBCTL_TRGTYPE_Pos)    /*!< PWM Leading Edge Blanking Trigger Type Is Falling Edge \hideinitializer */
N#define PWM_LEBCTL_TRGTYPE_RISING_OR_FALLING   (2UL<<PWM_LEBCTL_TRGTYPE_Pos)    /*!< PWM Leading Edge Blanking Trigger Type Is Rising or Falling Edge \hideinitializer */
N#define PWM_LEBCTL_SRCEN0                      (PWM_LEBCTL_SRCEN0_Msk)    /*!< PWM Leading Edge Blanking Source From PWMx_CH0 Enable \hideinitializer */
N#define PWM_LEBCTL_SRCEN2                      (PWM_LEBCTL_SRCEN2_Msk)    /*!< PWM Leading Edge Blanking Source From PWMx_CH2 Enable \hideinitializer */
N#define PWM_LEBCTL_SRCEN4                      (PWM_LEBCTL_SRCEN4_Msk)    /*!< PWM Leading Edge Blanking Source From PWMx_CH4 Enable \hideinitializer */
N#define PWM_LEBCTL_SRCEN0_2                    (PWM_LEBCTL_SRCEN0_Msk|PWM_LEBCTL_SRCEN2_Msk)    /*!< PWM Leading Edge Blanking Source From PWMx_CH0 and PWMx_CH2 Enable \hideinitializer */
N#define PWM_LEBCTL_SRCEN0_4                    (PWM_LEBCTL_SRCEN0_Msk|PWM_LEBCTL_SRCEN4_Msk)    /*!< PWM Leading Edge Blanking Source From PWMx_CH0 and PWMx_CH4 Enable \hideinitializer */
N#define PWM_LEBCTL_SRCEN2_4                    (PWM_LEBCTL_SRCEN2_Msk|PWM_LEBCTL_SRCEN4_Msk)    /*!< PWM Leading Edge Blanking Source From PWMx_CH2 and PWMx_CH4 Enable \hideinitializer */
N#define PWM_LEBCTL_SRCEN0_2_4                  (PWM_LEBCTL_SRCEN0_Msk|PWM_LEBCTL_SRCEN2_Msk|PWM_LEBCTL_SRCEN4_Msk)    /*!< PWM Leading Edge Blanking Source From PWMx_CH0, PWMx_CH2 and PWMx_CH4 Enable \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Capture Control Constant Definitions                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_CAPTURE_INT_RISING_LATCH             (1UL)        /*!< PWM capture interrupt if channel has rising transition */
N#define PWM_CAPTURE_INT_FALLING_LATCH            (0x100UL)    /*!< PWM capture interrupt if channel has falling transition */
N
N#define PWM_CAPTURE_PDMA_RISING_LATCH            (0x2UL)      /*!< PWM capture rising latched data transfer by PDMA */
N#define PWM_CAPTURE_PDMA_FALLING_LATCH           (0x4UL)      /*!< PWM capture falling latched data transfer by PDMA */
N#define PWM_CAPTURE_PDMA_RISING_FALLING_LATCH    (0x6UL)      /*!< PWM capture rising and falling latched data transfer by PDMA */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Duty Interrupt Type Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_DUTY_INT_DOWN_COUNT_MATCH_CMP        (PWM_INTEN0_CMPDIEN0_Msk)   /*!< PWM duty interrupt triggered if down count match comparator */
N#define PWM_DUTY_INT_UP_COUNT_MATCH_CMP          (PWM_INTEN0_CMPUIEN0_Msk)   /*!< PWM duty interrupt triggered if up down match comparator */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Interrupt Flag Accumulator Constant Definitions                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_IFA_EVEN_ZERO_POINT                  (0UL)         /*!< PWM counter equal to zero in even channel  \hideinitializer */
N#define PWM_IFA_EVEN_PERIOD_POINT                (1UL)         /*!< PWM counter equal to period in even channel \hideinitializer */
N#define PWM_IFA_EVEN_COMPARE_UP_COUNT_POINT      (2UL)         /*!< PWM counter up count to comparator value in even channel \hideinitializer */
N#define PWM_IFA_EVEN_COMPARE_DOWN_COUNT_POINT    (3UL)         /*!< PWM counter down count to comparator value in even channel \hideinitializer */
N#define PWM_IFA_ODD_ZERO_POINT                   (4UL)         /*!< PWM counter equal to zero in odd channel  \hideinitializer */
N#define PWM_IFA_ODD_PERIOD_POINT                 (5UL)         /*!< PWM counter equal to period in odd channel \hideinitializer */
N#define PWM_IFA_ODD_COMPARE_UP_COUNT_POINT       (6UL)         /*!< PWM counter up count to comparator value in odd channel \hideinitializer */
N#define PWM_IFA_ODD_COMPARE_DOWN_COUNT_POINT     (7UL)         /*!< PWM counter down count to comparator value in odd channel \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Load Mode Constant Definitions                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_LOAD_MODE_IMMEDIATE                  (PWM_CTL0_IMMLDEN0_Msk)    /*!< PWM immediately load mode \hideinitializer */
N#define PWM_LOAD_MODE_WINDOW                     (PWM_CTL0_WINLDEN0_Msk)    /*!< PWM window load mode \hideinitializer */
N#define PWM_LOAD_MODE_CENTER                     (PWM_CTL0_CTRLD0_Msk)      /*!< PWM center load mode \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Synchronize Control Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_SYNC_OUT_FROM_SYNCIN_SWSYNC          (0UL)    /*!< Synchronize source from SYNC_IN or SWSYNC  \hideinitializer */
N#define PWM_SYNC_OUT_FROM_COUNT_TO_ZERO          (1UL)    /*!< Synchronize source from counter equal to 0  \hideinitializer */
N#define PWM_SYNC_OUT_FROM_COUNT_TO_COMPARATOR    (2UL)    /*!< Synchronize source from counter equal to CMPDAT1, CMPDAT3, CMPDAT5 \hideinitializer */
N#define PWM_SYNC_OUT_DISABLE                     (3UL)    /*!< SYNC_OUT will not be generated \hideinitializer */
N#define PWM_PHS_DIR_DECREMENT                    (0UL)    /*!< PWM counter count decrement  \hideinitializer */
N#define PWM_PHS_DIR_INCREMENT                    (1UL)    /*!< PWM counter count increment  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Noise Filter Clock Divide Select Constant Definitions                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_NF_CLK_DIV_1                         (0UL)    /*!< Noise filter clock is HCLK divide by 1 \hideinitializer */
N#define PWM_NF_CLK_DIV_2                         (1UL)    /*!< Noise filter clock is HCLK divide by 2 \hideinitializer */
N#define PWM_NF_CLK_DIV_4                         (2UL)    /*!< Noise filter clock is HCLK divide by 4 \hideinitializer */
N#define PWM_NF_CLK_DIV_8                         (3UL)    /*!< Noise filter clock is HCLK divide by 8 \hideinitializer */
N#define PWM_NF_CLK_DIV_16                        (4UL)    /*!< Noise filter clock is HCLK divide by 16 \hideinitializer */
N#define PWM_NF_CLK_DIV_32                        (5UL)    /*!< Noise filter clock is HCLK divide by 32 \hideinitializer */
N#define PWM_NF_CLK_DIV_64                        (6UL)    /*!< Noise filter clock is HCLK divide by 64 \hideinitializer */
N#define PWM_NF_CLK_DIV_128                       (7UL)    /*!< Noise filter clock is HCLK divide by 128 \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Clock Source Select Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_CLKSRC_PWM_CLK                       (0UL)    /*!< PWM Clock source selects to PWM0_CLK or PWM1_CLK \hideinitializer */
N#define PWM_CLKSRC_TIMER0                        (1UL)    /*!< PWM Clock source selects to TIMER0 overflow \hideinitializer */
N#define PWM_CLKSRC_TIMER1                        (2UL)    /*!< PWM Clock source selects to TIMER1 overflow \hideinitializer */
N#define PWM_CLKSRC_TIMER2                        (3UL)    /*!< PWM Clock source selects to TIMER2 overflow \hideinitializer */
N#define PWM_CLKSRC_TIMER3                        (4UL)    /*!< PWM Clock source selects to TIMER3 overflow \hideinitializer */
N
N
N/*@}*/ /* end of group PWM_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup PWM_EXPORTED_FUNCTIONS PWM Exported Functions
N  @{
N*/
N
N/**
N * @brief This macro enable complementary mode
N * @param[in] pwm The pointer of the specified PWM module
N * @return None
N * @details This macro is used to enable complementary mode of PWM module.
N * \hideinitializer
N */
N#define PWM_ENABLE_COMPLEMENTARY_MODE(pwm) ((pwm)->CTL1 = (pwm)->CTL1 | (0x7ul<<PWM_CTL1_OUTMODE0_Pos))
N
N/**
N * @brief This macro disable complementary mode, and enable independent mode.
N * @param[in] pwm The pointer of the specified PWM module
N * @return None
N * @details This macro is used to disable complementary mode of PWM module.
N * \hideinitializer
N */
N#define PWM_DISABLE_COMPLEMENTARY_MODE(pwm) ((pwm)->CTL1 = (pwm)->CTL1 & ~(0x7ul<<PWM_CTL1_OUTMODE0_Pos))
N
N/**
N * @brief This macro enable group mode
N * @param[in] pwm The pointer of the specified PWM module
N * @return None
N * @details This macro is used to enable group mode of PWM module.
N * \hideinitializer
N */
N#define PWM_ENABLE_GROUP_MODE(pwm) ((pwm)->CTL0 = (pwm)->CTL0 | PWM_CTL0_GROUPEN_Msk)
N
N/**
N * @brief This macro disable group mode
N * @param[in] pwm The pointer of the specified PWM module
N * @return None
N * @details This macro is used to disable group mode of PWM module.
N * \hideinitializer
N */
N#define PWM_DISABLE_GROUP_MODE(pwm) ((pwm)->CTL0 = (pwm)->CTL0 & ~PWM_CTL0_GROUPEN_Msk)
N
N/**
N * @brief Enable timer synchronous start counting function of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @param[in] u32SyncSrc Synchronous start source selection, valid values are:
N *              - \ref PWM_SSCTL_SSRC_PWM0
N *              - \ref PWM_SSCTL_SSRC_PWM1
N * @return None
N * @details This macro is used to enable timer synchronous start counting function of specified channel(s).
N * \hideinitializer
N */
N#define PWM_ENABLE_TIMER_SYNC(pwm, u32ChannelMask, u32SyncSrc) ((pwm)->SSCTL = ((pwm)->SSCTL & ~PWM_SSCTL_SSRC_Msk) | (u32SyncSrc) | (u32ChannelMask))
N
N/**
N * @brief Disable timer synchronous start counting function of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * @details This macro is used to disable timer synchronous start counting function of specified channel(s).
N * \hideinitializer
N */
N#define PWM_DISABLE_TIMER_SYNC(pwm, u32ChannelMask) \
N    do{ \
N        int i;\
N        for(i = 0; i < 6; i++) { \
N            if((u32ChannelMask) & (1 << i)) \
N                (pwm)->SSCTL &= ~(1UL << i); \
N        } \
N    }while(0)
X#define PWM_DISABLE_TIMER_SYNC(pwm, u32ChannelMask)     do{         int i;        for(i = 0; i < 6; i++) {             if((u32ChannelMask) & (1 << i))                 (pwm)->SSCTL &= ~(1UL << i);         }     }while(0)
N
N/**
N * @brief This macro enable PWM counter synchronous start counting function.
N * @param[in] pwm The pointer of the specified PWM module
N * @return None
N * @details This macro is used to make selected PWM0 and PWM1 channel(s) start counting at the same time.
N *          To configure synchronous start counting channel(s) by PWM_ENABLE_TIMER_SYNC() and PWM_DISABLE_TIMER_SYNC().
N * \hideinitializer
N */
N#define PWM_TRIGGER_SYNC_START(pwm) ((pwm)->SSTRG = PWM_SSTRG_CNTSEN_Msk)
N
N/**
N * @brief This macro enable output inverter of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * @details This macro is used to enable output inverter of specified channel(s).
N * \hideinitializer
N */
N#define PWM_ENABLE_OUTPUT_INVERTER(pwm, u32ChannelMask) ((pwm)->POLCTL = (u32ChannelMask))
N
N/**
N * @brief This macro get captured rising data
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @return None
N * @details This macro is used to get captured rising data of specified channel.
N * \hideinitializer
N */
N#define PWM_GET_CAPTURE_RISING_DATA(pwm, u32ChannelNum) (*(__IO uint32_t *) (&((pwm)->RCAPDAT0) + ((u32ChannelNum) << 1)))
N
N/**
N * @brief This macro get captured falling data
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @return None
N * @details This macro is used to get captured falling data of specified channel.
N * \hideinitializer
N */
N#define PWM_GET_CAPTURE_FALLING_DATA(pwm, u32ChannelNum) (*(__IO uint32_t *) (&((pwm)->FCAPDAT0) + ((u32ChannelNum) << 1)))
N
N/**
N * @brief This macro mask output logic to high or low
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @param[in] u32LevelMask Output logic to high or low
N * @return None
N * @details This macro is used to mask output logic to high or low of specified channel(s).
N * @note If u32ChannelMask parameter is 0, then mask function will be disabled.
N * \hideinitializer
N */
N#define PWM_MASK_OUTPUT(pwm, u32ChannelMask, u32LevelMask) \
N    { \
N        (pwm)->MSKEN = (u32ChannelMask); \
N        (pwm)->MSK = (u32LevelMask); \
N    }
X#define PWM_MASK_OUTPUT(pwm, u32ChannelMask, u32LevelMask)     {         (pwm)->MSKEN = (u32ChannelMask);         (pwm)->MSK = (u32LevelMask);     }
N
N/**
N * @brief This macro set the prescaler of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32Prescaler Clock prescaler of specified channel. Valid values are between 0 ~ 0xFFF
N * @return None
N * @details This macro is used to set the prescaler of specified channel.
N * @note Every even channel N, and channel (N + 1) share a prescaler. So if channel 0 prescaler changed, channel 1 will also be affected.
N *       The clock of PWM counter is divided by (u32Prescaler + 1).
N * \hideinitializer
N */
N#define PWM_SET_PRESCALER(pwm, u32ChannelNum, u32Prescaler) (*(__IO uint32_t *) (&((pwm)->CLKPSC0_1) + ((u32ChannelNum) >> 1)) = (u32Prescaler))
N
N/**
N * @brief This macro get the prescaler of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @return Return Clock prescaler of specified channel. Valid values are between 0 ~ 0xFFF
N * @details This macro is used to get the prescaler of specified channel.
N * @note Every even channel N, and channel (N + 1) share a prescaler. So if channel 0 prescaler changed, channel 1 will also be affected.
N *       The clock of PWM counter is divided by (u32Prescaler + 1).
N * \hideinitializer
N */
N#define PWM_GET_PRESCALER(pwm, u32ChannelNum) (*(__IO uint32_t *) (&((pwm)->CLKPSC0_1) + ((u32ChannelNum) >> 1)))
N
N/**
N * @brief This macro set the comparator of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32CMR Comparator of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @details This macro is used to set the comparator of specified channel.
N * @note This new setting will take effect on next PWM period.
N * \hideinitializer
N */
N#define PWM_SET_CMR(pwm, u32ChannelNum, u32CMR) ((pwm)->CMPDAT[(u32ChannelNum)]= (u32CMR))
N
N/**
N * @brief This macro get the comparator of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @return Return the comparator of specified channel. Valid values are between 0~0xFFFF
N * @details This macro is used to get the comparator of specified channel.
N * \hideinitializer
N */
N#define PWM_GET_CMR(pwm, u32ChannelNum) ((pwm)->CMPDAT[(u32ChannelNum)])
N
N/**
N * @brief This macro set the free trigger comparator of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32FTCMR Free trigger comparator of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @details This macro is used to set the free trigger comparator of specified channel.
N * @note This new setting will take effect on next PWM period.
N * \hideinitializer
N */
N#define PWM_SET_FTCMR(pwm, u32ChannelNum, u32FTCMR) (*(__IO uint32_t *) (&((pwm)->FTCMPDAT0_1) + ((u32ChannelNum) >> 1)) = (u32FTCMR))
N
N/**
N * @brief This macro set the period of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32CNR Period of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @details This macro is used to set the period of specified channel.
N * @note This new setting will take effect on next PWM period.
N * @note PWM counter will stop if period length set to 0.
N * \hideinitializer
N */
N#define PWM_SET_CNR(pwm, u32ChannelNum, u32CNR)  ((pwm)->PERIOD[(u32ChannelNum)] = (u32CNR))
N
N/**
N * @brief This macro get the period of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @return Return the period of specified channel. Valid values are between 0~0xFFFF
N * @details This macro is used to get the period of specified channel.
N * \hideinitializer
N */
N#define PWM_GET_CNR(pwm, u32ChannelNum)  ((pwm)->PERIOD[(u32ChannelNum)])
N
N/**
N * @brief This macro set the PWM aligned type
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @param[in] u32AlignedType PWM aligned type, valid values are:
N *              - \ref PWM_EDGE_ALIGNED
N *              - \ref PWM_CENTER_ALIGNED
N * @return None
N * @details This macro is used to set the PWM aligned type of specified channel(s).
N * \hideinitializer
N */
N#define PWM_SET_ALIGNED_TYPE(pwm, u32ChannelMask, u32AlignedType) \
N   do{ \
N        int i; \
N        for(i = 0; i < 6; i++) { \
N            if((u32ChannelMask) & (1 << i)) \
N                (pwm)->CTL1 = (((pwm)->CTL1 & ~(3UL << (i << 1))) | ((u32AlignedType) << (i << 1))); \
N        } \
N    }while(0)
X#define PWM_SET_ALIGNED_TYPE(pwm, u32ChannelMask, u32AlignedType)    do{         int i;         for(i = 0; i < 6; i++) {             if((u32ChannelMask) & (1 << i))                 (pwm)->CTL1 = (((pwm)->CTL1 & ~(3UL << (i << 1))) | ((u32AlignedType) << (i << 1)));         }     }while(0)
N
N/**
N * @brief Set load window of window loading mode for specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * @details This macro is used to set load window of window loading mode for specified channel(s).
N * \hideinitializer
N */
N#define PWM_SET_LOAD_WINDOW(pwm, u32ChannelMask) ((pwm)->LOAD |= (u32ChannelMask))
N
N/**
N * @brief Trigger synchronous event from specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are 0, 2, 4
N *                           Bit 0 represents channel 0, bit 1 represents channel 2 and bit 2 represents channel 4
N * @return None
N * @details This macro is used to trigger synchronous event from specified channel(s).
N * \hideinitializer
N */
N#define PWM_TRIGGER_SYNC(pwm, u32ChannelNum) ((pwm)->SWSYNC |= (1 << ((u32ChannelNum) >> 1)))
N
N/**
N * @brief Clear counter of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * @details This macro is used to clear counter of specified channel(s).
N * \hideinitializer
N */
N#define PWM_CLR_COUNTER(pwm, u32ChannelMask) ((pwm)->CNTCLR |= (u32ChannelMask))
N
N/**
N * @brief Set output level at zero, compare up, period(center) and compare down of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @param[in] u32ZeroLevel output level at zero point, valid values are:
N *              - \ref PWM_OUTPUT_NOTHING
N *              - \ref PWM_OUTPUT_LOW
N *              - \ref PWM_OUTPUT_HIGH
N *              - \ref PWM_OUTPUT_TOGGLE
N * @param[in] u32CmpUpLevel output level at compare up point, valid values are:
N *              - \ref PWM_OUTPUT_NOTHING
N *              - \ref PWM_OUTPUT_LOW
N *              - \ref PWM_OUTPUT_HIGH
N *              - \ref PWM_OUTPUT_TOGGLE
N * @param[in] u32PeriodLevel output level at period(center) point, valid values are:
N *              - \ref PWM_OUTPUT_NOTHING
N *              - \ref PWM_OUTPUT_LOW
N *              - \ref PWM_OUTPUT_HIGH
N *              - \ref PWM_OUTPUT_TOGGLE
N * @param[in] u32CmpDownLevel output level at compare down point, valid values are:
N *              - \ref PWM_OUTPUT_NOTHING
N *              - \ref PWM_OUTPUT_LOW
N *              - \ref PWM_OUTPUT_HIGH
N *              - \ref PWM_OUTPUT_TOGGLE
N * @return None
N * @details This macro is used to Set output level at zero, compare up, period(center) and compare down of specified channel(s).
N * \hideinitializer
N */
N#define PWM_SET_OUTPUT_LEVEL(pwm, u32ChannelMask, u32ZeroLevel, u32CmpUpLevel, u32PeriodLevel, u32CmpDownLevel) \
N   do{ \
N        int i; \
N        for(i = 0; i < 6; i++) { \
N            if((u32ChannelMask) & (1 << i)) { \
N                (pwm)->WGCTL0 = (((pwm)->WGCTL0 & ~(3UL << (i << 1))) | ((u32ZeroLevel) << (i << 1))); \
N                (pwm)->WGCTL0 = (((pwm)->WGCTL0 & ~(3UL << (PWM_WGCTL0_PRDPCTL0_Pos + (i << 1)))) | ((u32PeriodLevel) << (PWM_WGCTL0_PRDPCTL0_Pos + (i << 1)))); \
N                (pwm)->WGCTL1 = (((pwm)->WGCTL1 & ~(3UL << (i << 1))) | ((u32CmpUpLevel) << (i << 1))); \
N                (pwm)->WGCTL1 = (((pwm)->WGCTL1 & ~(3UL << (PWM_WGCTL1_CMPDCTL0_Pos + (i << 1)))) | ((u32CmpDownLevel) << (PWM_WGCTL1_CMPDCTL0_Pos + (i << 1)))); \
N            } \
N        } \
N    }while(0)
X#define PWM_SET_OUTPUT_LEVEL(pwm, u32ChannelMask, u32ZeroLevel, u32CmpUpLevel, u32PeriodLevel, u32CmpDownLevel)    do{         int i;         for(i = 0; i < 6; i++) {             if((u32ChannelMask) & (1 << i)) {                 (pwm)->WGCTL0 = (((pwm)->WGCTL0 & ~(3UL << (i << 1))) | ((u32ZeroLevel) << (i << 1)));                 (pwm)->WGCTL0 = (((pwm)->WGCTL0 & ~(3UL << (PWM_WGCTL0_PRDPCTL0_Pos + (i << 1)))) | ((u32PeriodLevel) << (PWM_WGCTL0_PRDPCTL0_Pos + (i << 1))));                 (pwm)->WGCTL1 = (((pwm)->WGCTL1 & ~(3UL << (i << 1))) | ((u32CmpUpLevel) << (i << 1)));                 (pwm)->WGCTL1 = (((pwm)->WGCTL1 & ~(3UL << (PWM_WGCTL1_CMPDCTL0_Pos + (i << 1)))) | ((u32CmpDownLevel) << (PWM_WGCTL1_CMPDCTL0_Pos + (i << 1))));             }         }     }while(0)
N
N/**
N * @brief Trigger brake event from specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 2 and bit 2 represents channel 4
N * @param[in] u32BrakeType Type of brake trigger. PWM_FB_EDGE of this macro is only supported in M45xD/M45xC.
N *              - \ref PWM_FB_EDGE
N *              - \ref PWM_FB_LEVEL
N * @return None
N * @details This macro is used to trigger brake event from specified channel(s).
N * \hideinitializer
N */
N#define PWM_TRIGGER_BRAKE(pwm, u32ChannelMask, u32BrakeType) ((pwm)->SWBRK |= ((u32ChannelMask) << (u32BrakeType)))
N
N/**
N * @brief Set Dead zone clock source
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32AfterPrescaler Dead zone clock source is from prescaler output. Valid values are TRUE (after prescaler) or FALSE (before prescaler).
N * @return None
N * @details This macro is used to set Dead zone clock source. Every two channels share the same setting.
N * @note The write-protection function should be disabled before using this function.
N * @note This function is only supported in M45xD/M45xC.
N * \hideinitializer
N */
N#define PWM_SET_DEADZONE_CLK_SRC(pwm, u32ChannelNum, u32AfterPrescaler) \
N    (*(__IO uint32_t *) (&((pwm)->DTCTL0_1) + ((u32ChannelNum) >> 1)) = (*(__IO uint32_t *) (&((pwm)->DTCTL0_1) + ((u32ChannelNum) >> 1)) & ~PWM_DTCTL0_1_DTCKSEL_Msk) | \
N    ((u32AfterPrescaler) << PWM_DTCTL0_1_DTCKSEL_Pos))
X#define PWM_SET_DEADZONE_CLK_SRC(pwm, u32ChannelNum, u32AfterPrescaler)     (*(__IO uint32_t *) (&((pwm)->DTCTL0_1) + ((u32ChannelNum) >> 1)) = (*(__IO uint32_t *) (&((pwm)->DTCTL0_1) + ((u32ChannelNum) >> 1)) & ~PWM_DTCTL0_1_DTCKSEL_Msk) |     ((u32AfterPrescaler) << PWM_DTCTL0_1_DTCKSEL_Pos))
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define PWM functions prototype                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
Nuint32_t PWM_ConfigCaptureChannel(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32UnitTimeNsec, uint32_t u32CaptureEdge);
Nuint32_t PWM_ConfigOutputChannel(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Frequency, uint32_t u32DutyCycle);
Nvoid PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nvoid PWM_DisableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nuint32_t PWM_GetADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableFaultBrake(PWM_T *pwm, uint32_t u32ChannelMask, uint32_t u32LevelMask, uint32_t u32BrakeSource);
Nvoid PWM_EnableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnablePDMA(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32RisingFirst, uint32_t u32Mode);
Nvoid PWM_DisablePDMA(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration);
Nvoid PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nvoid PWM_DisableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nvoid PWM_ClearCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nuint32_t PWM_GetCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType);
Nvoid PWM_DisableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource);
Nvoid PWM_DisableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource);
Nvoid PWM_ClearFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource);
Nuint32_t PWM_GetFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource);
Nvoid PWM_EnablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType);
Nvoid PWM_DisablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableZeroInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_DisableZeroInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearZeroIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetZeroIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableAcc(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntFlagCnt, uint32_t u32IntAccSrc);
Nvoid PWM_DisableAcc(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableAccInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_DisableAccInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearAccInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetAccInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearFTDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetFTDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableLoadMode(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32LoadMode);
Nvoid PWM_DisableLoadMode(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32LoadMode);
Nvoid PWM_ConfigSyncPhase(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32SyncSrc, uint32_t u32Direction, uint32_t u32StartPhase);
Nvoid PWM_EnableSyncPhase(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableSyncPhase(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableSyncNoiseFilter(PWM_T *pwm, uint32_t u32ClkCnt, uint32_t u32ClkDivSel);
Nvoid PWM_DisableSyncNoiseFilter(PWM_T *pwm);
Nvoid PWM_EnableSyncPinInverse(PWM_T *pwm);
Nvoid PWM_DisableSyncPinInverse(PWM_T *pwm);
Nvoid PWM_SetClockSource(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32ClkSrcSel);
Nvoid PWM_EnableBrakeNoiseFilter(PWM_T *pwm, uint32_t u32BrakePinNum, uint32_t u32ClkCnt, uint32_t u32ClkDivSel);
Nvoid PWM_DisableBrakeNoiseFilter(PWM_T *pwm, uint32_t u32BrakePinNum);
Nvoid PWM_EnableBrakePinInverse(PWM_T *pwm, uint32_t u32BrakePinNum);
Nvoid PWM_DisableBrakePinInverse(PWM_T *pwm, uint32_t u32BrakePinNum);
Nvoid PWM_SetBrakePinSource(PWM_T *pwm, uint32_t u32BrakePinNum, uint32_t u32SelAnotherModule);
Nvoid PWM_SetLeadingEdgeBlanking(PWM_T *pwm, uint32_t u32TrigSrcSel, uint32_t u32TrigTyp, uint32_t u32BlankingCnt, uint32_t u32BlankingEnable);
Nuint32_t PWM_GetWrapAroundFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearWrapAroundFlag(PWM_T *pwm, uint32_t u32ChannelNum);
N
N/*@}*/ /* end of group PWM_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group PWM_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__PWM_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17562 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "spi.h"
L 1 "..\lib\StdDriver\inc\spi.h" 1
N/******************************************************************************
N * @file     spi.h
N * @version  V3.00
N * $Revision: 5 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE series SPI driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __SPI_H__
N#define __SPI_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup SPI_Driver SPI Driver
N  @{
N*/
N
N/** @addtogroup SPI_EXPORTED_CONSTANTS SPI Exported Constants
N  @{
N*/
N
N#define SPI_MODE_0        (SPI_CTL_TXNEG_Msk)                             /*!< CLKPOL=0; RXNEG=0; TXNEG=1 */
N#define SPI_MODE_1        (SPI_CTL_RXNEG_Msk)                             /*!< CLKPOL=0; RXNEG=1; TXNEG=0 */
N#define SPI_MODE_2        (SPI_CTL_CLKPOL_Msk | SPI_CTL_RXNEG_Msk)        /*!< CLKPOL=1; RXNEG=1; TXNEG=0 */
N#define SPI_MODE_3        (SPI_CTL_CLKPOL_Msk | SPI_CTL_TXNEG_Msk)        /*!< CLKPOL=1; RXNEG=0; TXNEG=1 */
N
N#define SPI_SLAVE         (SPI_CTL_SLAVE_Msk)                             /*!< Set as slave */
N#define SPI_MASTER        (0x0)                                           /*!< Set as master */
N
N#define SPI_SS                (SPI_SSCTL_SS_Msk)                          /*!< Set SS */
N#define SPI_SS_ACTIVE_HIGH    (SPI_SSCTL_SSACTPOL_Msk)                    /*!< SS active high */
N#define SPI_SS_ACTIVE_LOW     (0x0)                                       /*!< SS active low */
N
N/* SPI Interrupt Mask */
N#define SPI_UNIT_INT_MASK                (0x001)                          /*!< Unit transfer interrupt mask */
N#define SPI_SSACT_INT_MASK               (0x002)                          /*!< Slave selection signal active interrupt mask */
N#define SPI_SSINACT_INT_MASK             (0x004)                          /*!< Slave selection signal inactive interrupt mask */
N#define SPI_SLVUR_INT_MASK               (0x008)                          /*!< Slave under run interrupt mask */
N#define SPI_SLVBE_INT_MASK               (0x010)                          /*!< Slave bit count error interrupt mask */
N#define SPI_TXUF_INT_MASK                (0x040)                          /*!< Slave TX underflow interrupt mask */
N#define SPI_FIFO_TXTH_INT_MASK           (0x080)                          /*!< FIFO TX threshold interrupt mask */
N#define SPI_FIFO_RXTH_INT_MASK           (0x100)                          /*!< FIFO RX threshold interrupt mask */
N#define SPI_FIFO_RXOV_INT_MASK           (0x200)                          /*!< FIFO RX overrun interrupt mask */
N#define SPI_FIFO_RXTO_INT_MASK           (0x400)                          /*!< FIFO RX time-out interrupt mask */
N
N/* SPI Status Mask */
N#define SPI_BUSY_MASK                    (0x01)                           /*!< Busy status mask */
N#define SPI_RX_EMPTY_MASK                (0x02)                           /*!< RX empty status mask */
N#define SPI_RX_FULL_MASK                 (0x04)                           /*!< RX full status mask */
N#define SPI_TX_EMPTY_MASK                (0x08)                           /*!< TX empty status mask */
N#define SPI_TX_FULL_MASK                 (0x10)                           /*!< TX full status mask */
N#define SPI_TXRX_RESET_MASK              (0x20)                           /*!< TX or RX reset status mask */
N#define SPI_SPIEN_STS_MASK               (0x40)                           /*!< SPIEN status mask */
N#define SPI_SSLINE_STS_MASK              (0x80)                           /*!< SPIx_SS line status mask */
N
N
N/* SPII2S Data Width */
N#define SPII2S_DATABIT_8           (0 << SPI_I2SCTL_WDWIDTH_Pos)      /*!< SPII2S data width is 8-bit */
N#define SPII2S_DATABIT_16          (1 << SPI_I2SCTL_WDWIDTH_Pos)      /*!< SPII2S data width is 16-bit */
N#define SPII2S_DATABIT_24          (2 << SPI_I2SCTL_WDWIDTH_Pos)      /*!< SPII2S data width is 24-bit */
N#define SPII2S_DATABIT_32          (3 << SPI_I2SCTL_WDWIDTH_Pos)      /*!< SPII2S data width is 32-bit */
N
N/* SPII2S Audio Format */
N#define SPII2S_MONO                SPI_I2SCTL_MONO_Msk                /*!< Monaural channel */
N#define SPII2S_STEREO              0                                  /*!< Stereo channel */
N
N/* SPII2S Data Format */
N#define SPII2S_FORMAT_I2S          (0<<SPI_I2SCTL_FORMAT_Pos)         /*!< I2S data format */
N#define SPII2S_FORMAT_MSB          (1<<SPI_I2SCTL_FORMAT_Pos)         /*!< MSB justified data format */
N#define SPII2S_FORMAT_PCMA         (2<<SPI_I2SCTL_FORMAT_Pos)         /*!< PCM mode A data format */
N#define SPII2S_FORMAT_PCMB         (3<<SPI_I2SCTL_FORMAT_Pos)         /*!< PCM mode B data format */
N
N/* SPII2S Operation mode */
N#define SPII2S_MODE_SLAVE          SPI_I2SCTL_SLAVE_Msk               /*!< As slave mode */
N#define SPII2S_MODE_MASTER         0                                  /*!< As master mode */
N
N/* SPII2S TX FIFO Threshold */
N#define SPII2S_FIFO_TX_LEVEL_WORD_0    0                              /*!< TX threshold is 0 word */
N#define SPII2S_FIFO_TX_LEVEL_WORD_1    (1 << SPI_FIFOCTL_TXTH_Pos)    /*!< TX threshold is 1 word */
N#define SPII2S_FIFO_TX_LEVEL_WORD_2    (2 << SPI_FIFOCTL_TXTH_Pos)    /*!< TX threshold is 2 words */
N#define SPII2S_FIFO_TX_LEVEL_WORD_3    (3 << SPI_FIFOCTL_TXTH_Pos)    /*!< TX threshold is 3 words */
N/* SPII2S RX FIFO Threshold */
N#define SPII2S_FIFO_RX_LEVEL_WORD_1    0                              /*!< RX threshold is 1 word */
N#define SPII2S_FIFO_RX_LEVEL_WORD_2    (1 << SPI_FIFOCTL_RXTH_Pos)    /*!< RX threshold is 2 words */
N#define SPII2S_FIFO_RX_LEVEL_WORD_3    (2 << SPI_FIFOCTL_RXTH_Pos)    /*!< RX threshold is 3 words */
N#define SPII2S_FIFO_RX_LEVEL_WORD_4    (3 << SPI_FIFOCTL_RXTH_Pos)    /*!< RX threshold is 4 words */
N
N/* SPII2S Record Channel */
N#define SPII2S_MONO_RIGHT          0                                  /*!< Record mono right channel */
N#define SPII2S_MONO_LEFT           SPI_I2SCTL_RXLCH_Msk               /*!< Record mono left channel */
N
N/* SPII2S Channel */
N#define SPII2S_RIGHT               0                                  /*!< Select right channel */
N#define SPII2S_LEFT                1                                  /*!< Select left channel */
N
N/* SPII2S Interrupt Mask */
N#define SPII2S_FIFO_TXTH_INT_MASK           (0x01)                          /*!< TX FIFO threshold interrupt mask */
N#define SPII2S_FIFO_RXTH_INT_MASK           (0x02)                          /*!< RX FIFO threshold interrupt mask */
N#define SPII2S_FIFO_RXOV_INT_MASK           (0x04)                          /*!< RX FIFO overrun interrupt mask */
N#define SPII2S_FIFO_RXTO_INT_MASK           (0x08)                          /*!< RX FIFO time-out interrupt mask */
N#define SPII2S_TXUF_INT_MASK                (0x10)                          /*!< TX FIFO underflow interrupt mask */
N#define SPII2S_RIGHT_ZC_INT_MASK            (0x20)                          /*!< Right channel zero cross interrupt mask */
N#define SPII2S_LEFT_ZC_INT_MASK             (0x40)                          /*!< Left channel zero cross interrupt mask */
N
N/*@}*/ /* end of group SPI_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup SPI_EXPORTED_FUNCTIONS SPI Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Clear the unit transfer interrupt flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Write 1 to UNITIF bit of SPI_STATUS register to clear the unit transfer interrupt flag.
N  */
N#define SPI_CLR_UNIT_TRANS_INT_FLAG(spi)   ((spi)->STATUS = SPI_STATUS_UNITIF_Msk)
N
N/**
N  * @brief      Trigger RX PDMA function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set RXPDMAEN bit of SPI_PDMACTL register to enable RX PDMA transfer function.
N  */
N#define SPI_TRIGGER_RX_PDMA(spi)   ((spi)->PDMACTL |= SPI_PDMACTL_RXPDMAEN_Msk)
N
N/**
N  * @brief      Trigger TX PDMA function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set TXPDMAEN bit of SPI_PDMACTL register to enable TX PDMA transfer function.
N  */
N#define SPI_TRIGGER_TX_PDMA(spi)   ((spi)->PDMACTL |= SPI_PDMACTL_TXPDMAEN_Msk)
N
N/**
N  * @brief      Disable RX PDMA transfer.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear RXPDMAEN bit of SPI_PDMACTL register to disable RX PDMA transfer function.
N  */
N#define SPI_DISABLE_RX_PDMA(spi) ( (spi)->PDMACTL &= ~SPI_PDMACTL_RXPDMAEN_Msk )
N
N/**
N  * @brief      Disable TX PDMA transfer.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear TXPDMAEN bit of SPI_PDMACTL register to disable TX PDMA transfer function.
N  */
N#define SPI_DISABLE_TX_PDMA(spi) ( (spi)->PDMACTL &= ~SPI_PDMACTL_TXPDMAEN_Msk )
N
N/**
N  * @brief      Get the count of available data in RX FIFO.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     The count of available data in RX FIFO.
N  * @details    Read RXCNT (SPI_STATUS[27:24]) to get the count of available data in RX FIFO.
N  */
N#define SPI_GET_RX_FIFO_COUNT(spi)   (((spi)->STATUS & SPI_STATUS_RXCNT_Msk) >> SPI_STATUS_RXCNT_Pos)
N
N/**
N  * @brief      Get the RX FIFO empty flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 RX FIFO is not empty.
N  * @retval     1 RX FIFO is empty.
N  * @details    Read RXEMPTY bit of SPI_STATUS register to get the RX FIFO empty flag.
N  */
N#define SPI_GET_RX_FIFO_EMPTY_FLAG(spi)   (((spi)->STATUS & SPI_STATUS_RXEMPTY_Msk)>>SPI_STATUS_RXEMPTY_Pos)
N
N/**
N  * @brief      Get the TX FIFO empty flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 TX FIFO is not empty.
N  * @retval     1 TX FIFO is empty.
N  * @details    Read TXEMPTY bit of SPI_STATUS register to get the TX FIFO empty flag.
N  */
N#define SPI_GET_TX_FIFO_EMPTY_FLAG(spi)   (((spi)->STATUS & SPI_STATUS_TXEMPTY_Msk)>>SPI_STATUS_TXEMPTY_Pos)
N
N/**
N  * @brief      Get the TX FIFO full flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 TX FIFO is not full.
N  * @retval     1 TX FIFO is full.
N  * @details    Read TXFULL bit of SPI_STATUS register to get the TX FIFO full flag.
N  */
N#define SPI_GET_TX_FIFO_FULL_FLAG(spi)   (((spi)->STATUS & SPI_STATUS_TXFULL_Msk)>>SPI_STATUS_TXFULL_Pos)
N
N/**
N  * @brief      Get the datum read from RX register.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     Data in RX register.
N  * @details    Read SPI_RX register to get the received datum.
N  */
N#define SPI_READ_RX(spi)   ((spi)->RX)
N
N/**
N  * @brief      Write datum to TX register.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32TxData The datum which user attempt to transfer through SPI bus.
N  * @return     None.
N  * @details    Write u32TxData to SPI_TX register.
N  */
N#define SPI_WRITE_TX(spi, u32TxData)   ((spi)->TX = (u32TxData))
N
N/**
N  * @brief      Set SPIx_SS pin to high state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIx_SS pin to high state.
N  */
N#define SPI_SET_SS_HIGH(spi)   ((spi)->SSCTL = ((spi)->SSCTL & (~SPI_SSCTL_AUTOSS_Msk)) | (SPI_SSCTL_SSACTPOL_Msk | SPI_SSCTL_SS_Msk))
N
N/**
N  * @brief      Set SPIx_SS pin to low state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIx_SS pin to low state.
N  */
N#define SPI_SET_SS_LOW(spi)   ((spi)->SSCTL = ((spi)->SSCTL & (~(SPI_SSCTL_AUTOSS_Msk | SPI_SSCTL_SSACTPOL_Msk))) | SPI_SSCTL_SS_Msk)
N
N/**
N  * @brief      Enable Byte Reorder function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Enable Byte Reorder function. The suspend interval depends on the setting of SUSPITV (SPI_CTL[7:4]).
N  */
N#define SPI_ENABLE_BYTE_REORDER(spi)   ((spi)->CTL |=  SPI_CTL_REORDER_Msk)
N
N/**
N  * @brief      Disable Byte Reorder function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear REORDER bit field of SPI_CTL register to disable Byte Reorder function.
N  */
N#define SPI_DISABLE_BYTE_REORDER(spi)   ((spi)->CTL &= ~SPI_CTL_REORDER_Msk)
N
N/**
N  * @brief      Set the length of suspend interval.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32SuspCycle Decides the length of suspend interval. It could be 0 ~ 15.
N  * @return     None.
N  * @details    Set the length of suspend interval according to u32SuspCycle.
N  *             The length of suspend interval is ((u32SuspCycle + 0.5) * the length of one SPI bus clock cycle).
N  */
N#define SPI_SET_SUSPEND_CYCLE(spi, u32SuspCycle)   ((spi)->CTL = ((spi)->CTL & ~SPI_CTL_SUSPITV_Msk) | ((u32SuspCycle) << SPI_CTL_SUSPITV_Pos))
N
N/**
N  * @brief      Set the SPI transfer sequence with LSB first.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set LSB bit of SPI_CTL register to set the SPI transfer sequence with LSB first.
N  */
N#define SPI_SET_LSB_FIRST(spi)   ((spi)->CTL |= SPI_CTL_LSB_Msk)
N
N/**
N  * @brief      Set the SPI transfer sequence with MSB first.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear LSB bit of SPI_CTL register to set the SPI transfer sequence with MSB first.
N  */
N#define SPI_SET_MSB_FIRST(spi)   ((spi)->CTL &= ~SPI_CTL_LSB_Msk)
N
N/**
N  * @brief      Set the data width of a SPI transaction.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32Width The bit width of one transaction.
N  * @return     None.
N  * @details    The data width can be 8 ~ 32 bits.
N  */
N#define SPI_SET_DATA_WIDTH(spi, u32Width)   ((spi)->CTL = ((spi)->CTL & ~SPI_CTL_DWIDTH_Msk) | (((u32Width)&0x1F) << SPI_CTL_DWIDTH_Pos))
N
N/**
N  * @brief      Get the SPI busy state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 SPI controller is not busy.
N  * @retval     1 SPI controller is busy.
N  * @details    This macro will return the busy state of SPI controller.
N  */
N#define SPI_IS_BUSY(spi)   ( ((spi)->STATUS & SPI_STATUS_BUSY_Msk)>>SPI_STATUS_BUSY_Pos )
N
N/**
N  * @brief      Enable SPI controller.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set SPIEN (SPI_CTL[0]) to enable SPI controller.
N  */
N#define SPI_ENABLE(spi)   ((spi)->CTL |= SPI_CTL_SPIEN_Msk)
N
N/**
N  * @brief      Disable SPI controller.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear SPIEN (SPI_CTL[0]) to disable SPI controller.
N  */
N#define SPI_DISABLE(spi)   ((spi)->CTL &= ~SPI_CTL_SPIEN_Msk)
N
N
N/**
N  * @brief  Enable zero cross detection function.
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @param[in] u32ChMask The mask for left or right channel. Valid values are:
N  *                    - \ref SPII2S_RIGHT
N  *                    - \ref SPII2S_LEFT
N  * @return None
N  * @details This function will set RZCEN or LZCEN bit of SPI_I2SCTL register to enable zero cross detection function.
N  */
Nstatic __INLINE void SPII2S_ENABLE_TX_ZCD(SPI_T *i2s, uint32_t u32ChMask)
Xstatic __inline void SPII2S_ENABLE_TX_ZCD(SPI_T *i2s, uint32_t u32ChMask)
N{
N    if(u32ChMask == SPII2S_RIGHT)
X    if(u32ChMask == 0)
N        i2s->I2SCTL |= SPI_I2SCTL_RZCEN_Msk;
X        i2s->I2SCTL |= (0x1ul << (16));
N    else
N        i2s->I2SCTL |= SPI_I2SCTL_LZCEN_Msk;
X        i2s->I2SCTL |= (0x1ul << (17));
N}
N
N/**
N  * @brief  Disable zero cross detection function.
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @param[in] u32ChMask The mask for left or right channel. Valid values are:
N  *                    - \ref SPII2S_RIGHT
N  *                    - \ref SPII2S_LEFT
N  * @return None
N  * @details This function will clear RZCEN or LZCEN bit of SPI_I2SCTL register to disable zero cross detection function.
N  */
Nstatic __INLINE void SPII2S_DISABLE_TX_ZCD(SPI_T *i2s, uint32_t u32ChMask)
Xstatic __inline void SPII2S_DISABLE_TX_ZCD(SPI_T *i2s, uint32_t u32ChMask)
N{
N    if(u32ChMask == SPII2S_RIGHT)
X    if(u32ChMask == 0)
N        i2s->I2SCTL &= ~SPI_I2SCTL_RZCEN_Msk;
X        i2s->I2SCTL &= ~(0x1ul << (16));
N    else
N        i2s->I2SCTL &= ~SPI_I2SCTL_LZCEN_Msk;
X        i2s->I2SCTL &= ~(0x1ul << (17));
N}
N
N/**
N  * @brief  Enable SPII2S TX DMA function.
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @return None
N  * @details This macro will set TXPDMAEN bit of SPI_PDMACTL register to transmit data with PDMA.
N  */
N#define SPII2S_ENABLE_TXDMA(i2s)  ( (i2s)->PDMACTL |= SPI_PDMACTL_TXPDMAEN_Msk )
N
N/**
N  * @brief  Disable SPII2S TX DMA function.
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @return None
N  * @details This macro will clear TXPDMAEN bit of SPI_PDMACTL register to disable TX DMA function.
N  */
N#define SPII2S_DISABLE_TXDMA(i2s) ( (i2s)->PDMACTL &= ~SPI_PDMACTL_TXPDMAEN_Msk )
N
N/**
N  * @brief  Enable SPII2S RX DMA function.
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @return None
N  * @details This macro will set RXPDMAEN bit of SPI_PDMACTL register to receive data with PDMA.
N  */
N#define SPII2S_ENABLE_RXDMA(i2s) ( (i2s)->PDMACTL |= SPI_PDMACTL_RXPDMAEN_Msk )
N
N/**
N  * @brief  Disable SPII2S RX DMA function.
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @return None
N  * @details This macro will clear RXPDMAEN bit of SPI_PDMACTL register to disable RX DMA function.
N  */
N#define SPII2S_DISABLE_RXDMA(i2s) ( (i2s)->PDMACTL &= ~SPI_PDMACTL_RXPDMAEN_Msk )
N
N/**
N  * @brief  Enable SPII2S TX function.
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @return None
N  * @details This macro will set TXEN bit of SPI_I2SCTL register to enable SPII2S TX function.
N  */
N#define SPII2S_ENABLE_TX(i2s) ( (i2s)->I2SCTL |= SPI_I2SCTL_TXEN_Msk )
N
N/**
N  * @brief  Disable SPII2S TX function.
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @return None
N  * @details This macro will clear TXEN bit of SPI_I2SCTL register to disable SPII2S TX function.
N  */
N#define SPII2S_DISABLE_TX(i2s) ( (i2s)->I2SCTL &= ~SPI_I2SCTL_TXEN_Msk )
N
N/**
N  * @brief  Enable SPII2S RX function.
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @return None
N  * @details This macro will set RXEN bit of SPI_I2SCTL register to enable SPII2S RX function.
N  */
N#define SPII2S_ENABLE_RX(i2s) ( (i2s)->I2SCTL |= SPI_I2SCTL_RXEN_Msk )
N
N/**
N  * @brief  Disable SPII2S RX function.
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @return None
N  * @details This macro will clear RXEN bit of SPI_I2SCTL register to disable SPII2S RX function.
N  */
N#define SPII2S_DISABLE_RX(i2s) ( (i2s)->I2SCTL &= ~SPI_I2SCTL_RXEN_Msk )
N
N/**
N  * @brief  Enable TX Mute function.
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @return None
N  * @details This macro will set MUTE bit of SPI_I2SCTL register to enable SPII2S TX mute function.
N  */
N#define SPII2S_ENABLE_TX_MUTE(i2s)  ( (i2s)->I2SCTL |= SPI_I2SCTL_MUTE_Msk )
N
N/**
N  * @brief  Disable TX Mute function.
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @return None
N  * @details This macro will clear MUTE bit of SPI_I2SCTL register to disable SPII2S TX mute function.
N  */
N#define SPII2S_DISABLE_TX_MUTE(i2s) ( (i2s)->I2SCTL &= ~SPI_I2SCTL_MUTE_Msk )
N
N/**
N  * @brief  Clear TX FIFO.
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @return None
N  * @details This macro will clear TX FIFO. The internal TX FIFO pointer will be reset to FIFO start point.
N  */
N#define SPII2S_CLR_TX_FIFO(i2s) ( (i2s)->FIFOCTL |= SPI_FIFOCTL_TXFBCLR_Msk )
N
N/**
N  * @brief  Clear RX FIFO.
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @return None
N  * @details This macro will clear RX FIFO. The internal RX FIFO pointer will be reset to FIFO start point.
N  */
N#define SPII2S_CLR_RX_FIFO(i2s) ( (i2s)->FIFOCTL |= SPI_FIFOCTL_RXFBCLR_Msk )
N
N/**
N  * @brief  This function sets the recording source channel when mono mode is used.
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @param[in] u32Ch left or right channel. Valid values are:
N  *                - \ref SPII2S_MONO_LEFT
N  *                - \ref SPII2S_MONO_RIGHT
N  * @return None
N  * @details This function selects the recording source channel of monaural mode.
N  */
Nstatic __INLINE void SPII2S_SET_MONO_RX_CHANNEL(SPI_T *i2s, uint32_t u32Ch)
Xstatic __inline void SPII2S_SET_MONO_RX_CHANNEL(SPI_T *i2s, uint32_t u32Ch)
N{
N    u32Ch == SPII2S_MONO_LEFT ?
X    u32Ch == (0x1ul << (23)) ?
N    (i2s->I2SCTL |= SPI_I2SCTL_RXLCH_Msk) :
X    (i2s->I2SCTL |= (0x1ul << (23))) :
N    (i2s->I2SCTL &= ~SPI_I2SCTL_RXLCH_Msk);
X    (i2s->I2SCTL &= ~(0x1ul << (23)));
N}
N
N/**
N  * @brief  Write data to SPII2S TX FIFO.
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @param[in] u32Data The value written to TX FIFO.
N  * @return None
N  * @details This macro will write a value to TX FIFO.
N  */
N#define SPII2S_WRITE_TX_FIFO(i2s, u32Data)  ( (i2s)->TX = (u32Data) )
N
N/**
N  * @brief  Read RX FIFO.
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @return The value read from RX FIFO.
N  * @details This function will return a value read from RX FIFO.
N  */
N#define SPII2S_READ_RX_FIFO(i2s) ( (i2s)->RX )
N
N/**
N  * @brief  Get the interrupt flag.
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @param[in] u32Mask The mask value for all interrupt flags.
N  * @return The interrupt flags specified by the u32mask parameter.
N  * @details This macro will return the combination interrupt flags of SPI_I2SSTS register. The flags are specified by the u32mask parameter.
N  */
N#define SPII2S_GET_INT_FLAG(i2s, u32Mask) ( (i2s)->I2SSTS & (u32Mask) )
N
N/**
N  * @brief  Clear the interrupt flag.
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @param[in] u32Mask The mask value for all interrupt flags.
N  * @return None
N  * @details This macro will clear the interrupt flags specified by the u32mask parameter.
N  * @note Except TX and RX FIFO threshold interrupt flags, the other interrupt flags can be cleared by writing 1 to itself.
N  */
N#define SPII2S_CLR_INT_FLAG(i2s, u32Mask) ( (i2s)->I2SSTS = (u32Mask) )
N
N/**
N  * @brief  Get transmit FIFO level
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @return TX FIFO level
N  * @details This macro will return the number of available words in TX FIFO.
N  */
N#define SPII2S_GET_TX_FIFO_LEVEL(i2s) ( ((i2s)->I2SSTS & SPI_I2SSTS_TXCNT_Msk) >> SPI_I2SSTS_TXCNT_Pos  )
N
N/**
N  * @brief  Get receive FIFO level
N  * @param[in] i2s The pointer of the specified SPII2S module.
N  * @return RX FIFO level
N  * @details This macro will return the number of available words in RX FIFO.
N  */
N#define SPII2S_GET_RX_FIFO_LEVEL(i2s) ( ((i2s)->I2SSTS & SPI_I2SSTS_RXCNT_Msk) >> SPI_I2SSTS_RXCNT_Pos )
N
N
N
N/* Function prototype declaration */
Nuint32_t SPI_Open(SPI_T *spi, uint32_t u32MasterSlave, uint32_t u32SPIMode, uint32_t u32DataWidth, uint32_t u32BusClock);
Nvoid SPI_Close(SPI_T *spi);
Nvoid SPI_ClearRxFIFO(SPI_T *spi);
Nvoid SPI_ClearTxFIFO(SPI_T *spi);
Nvoid SPI_DisableAutoSS(SPI_T *spi);
Nvoid SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel);
Nuint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock);
Nvoid SPI_SetFIFO(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold);
Nuint32_t SPI_GetBusClock(SPI_T *spi);
Nvoid SPI_EnableInt(SPI_T *spi, uint32_t u32Mask);
Nvoid SPI_DisableInt(SPI_T *spi, uint32_t u32Mask);
Nuint32_t SPI_GetIntFlag(SPI_T *spi, uint32_t u32Mask);
Nvoid SPI_ClearIntFlag(SPI_T *spi, uint32_t u32Mask);
Nuint32_t SPI_GetStatus(SPI_T *spi, uint32_t u32Mask);
N
Nuint32_t SPII2S_Open(SPI_T *i2s, uint32_t u32MasterSlave, uint32_t u32SampleRate, uint32_t u32WordWidth, uint32_t u32Channels, uint32_t u32DataFormat);
Nvoid SPII2S_Close(SPI_T *i2s);
Nvoid SPII2S_EnableInt(SPI_T *i2s, uint32_t u32Mask);
Nvoid SPII2S_DisableInt(SPI_T *i2s, uint32_t u32Mask);
Nuint32_t SPII2S_EnableMCLK(SPI_T *i2s, uint32_t u32BusClock);
Nvoid SPII2S_DisableMCLK(SPI_T *i2s);
Nvoid SPII2S_SetFIFO(SPI_T *i2s, uint32_t u32TxThreshold, uint32_t u32RxThreshold);
N
N
N/*@}*/ /* end of group SPI_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group SPI_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SPI_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17563 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "timer.h"
L 1 "..\lib\StdDriver\inc\timer.h" 1
N/**************************************************************************//**
N * @file     timer.h
N * @version  V3.00
N * $Revision: 8 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE series Timer Controller(Timer) driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __TIMER_H__
N#define __TIMER_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup TIMER_Driver TIMER Driver
N  @{
N*/
N
N/** @addtogroup TIMER_EXPORTED_CONSTANTS TIMER Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  TIMER Operation Mode, External Counter and Capture Mode Constant Definitions                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define TIMER_ONESHOT_MODE                      (0UL << TIMER_CTL_OPMODE_Pos)      /*!< Timer working in one-shot mode */
N#define TIMER_PERIODIC_MODE                     (1UL << TIMER_CTL_OPMODE_Pos)      /*!< Timer working in periodic mode */
N#define TIMER_TOGGLE_MODE                       (2UL << TIMER_CTL_OPMODE_Pos)      /*!< Timer working in toggle-output mode */
N#define TIMER_CONTINUOUS_MODE                   (3UL << TIMER_CTL_OPMODE_Pos)      /*!< Timer working in continuous counting mode */
N#define TIMER_TOUT_PIN_FROM_TX                  (0UL << TIMER_CTL_TGLPINSEL_Pos)   /*!< Timer toggle-output pin is from Tx pin */
N#define TIMER_TOUT_PIN_FROM_TX_EXT              (1UL << TIMER_CTL_TGLPINSEL_Pos)   /*!< Timer toggle-output pin is from Tx_EXT pin */
N
N#define TIMER_COUNTER_EVENT_FALLING             (0UL << TIMER_EXTCTL_CNTPHASE_Pos) /*!< Counter increase on falling edge detection */
N#define TIMER_COUNTER_EVENT_RISING              (1UL << TIMER_EXTCTL_CNTPHASE_Pos) /*!< Counter increase on rising edge detection */
N#define TIMER_CAPTURE_FREE_COUNTING_MODE        (0UL << TIMER_EXTCTL_CAPFUNCS_Pos) /*!< Timer capture event to get timer counter value */
N#define TIMER_CAPTURE_COUNTER_RESET_MODE        (1UL << TIMER_EXTCTL_CAPFUNCS_Pos) /*!< Timer capture event to reset timer counter */
N
N#define TIMER_CAPTURE_EVENT_FALLING             (0UL << TIMER_EXTCTL_CAPEDGE_Pos)  /*!< Falling edge detection to trigger capture event */
N#define TIMER_CAPTURE_EVENT_RISING              (1UL << TIMER_EXTCTL_CAPEDGE_Pos)  /*!< Rising edge detection to trigger capture event */
N#define TIMER_CAPTURE_EVENT_FALLING_RISING      (2UL << TIMER_EXTCTL_CAPEDGE_Pos)  /*!< Both falling and rising edge detection to trigger capture event, and first event at falling edge */
N#define TIMER_CAPTURE_EVENT_RISING_FALLING      (3UL << TIMER_EXTCTL_CAPEDGE_Pos)  /*!< Both rising and falling edge detection to trigger capture event, and first event at rising edge */
N#define TIMER_CAPTURE_EVENT_GET_LOW_PERIOD      (6UL << TIMER_EXTCTL_CAPEDGE_Pos)  /*!< First capture event is at falling edge, follows are at at rising edge */
N#define TIMER_CAPTURE_EVENT_GET_HIGH_PERIOD     (7UL << TIMER_EXTCTL_CAPEDGE_Pos)  /*!< First capture event is at rising edge, follows are at at falling edge */
N
N#define TIMER_TRGSEL_TIMEOUT_EVENT              (0UL << TIMER_TRGCTL_TRGSSEL_Pos) /*!< Select internal trigger source from timer time-out event */
N#define TIMER_TRGSEL_CAPTURE_EVENT              (1UL << TIMER_TRGCTL_TRGSSEL_Pos) /*!< Select internal trigger source from timer capture event */
N#define TIMER_TRG_TO_PWM                        (TIMER_TRGCTL_TRGPWM_Msk)         /*!< Each timer event as PWM counter clock source */
N#define TIMER_TRG_TO_ADC                        (TIMER_TRGCTL_TRGADC_Msk)         /*!< Each timer event to start ADC conversion */
N#define TIMER_TRG_TO_PDMA                       (TIMER_TRGCTL_TRGPDMA_Msk)        /*!< Each timer event to trigger PDMA transfer */
N
N/*@}*/ /* end of group TIMER_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup TIMER_EXPORTED_FUNCTIONS TIMER Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Set Timer Compared Value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  * @param[in]  u32Value    Timer compare value. Valid values are between 2 to 0xFFFFFF.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set timer compared value to adjust timer time-out interval.
N  * @note       1. Never write 0x0 or 0x1 in this field, or the core will run into unknown state. \n
N  *             2. If update timer compared value in continuous counting mode, timer counter value will keep counting continuously. \n
N  *                But if timer is operating at other modes, the timer up counter will restart counting and start from 0.
N  */
N#define TIMER_SET_CMP_VALUE(timer, u32Value)        ((timer)->CMP = (u32Value))
N
N/**
N  * @brief      Set Timer Prescale Value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  * @param[in]  u32Value    Timer prescale value. Valid values are between 0 to 0xFF.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set timer prescale value and timer source clock will be divided by (prescale + 1) \n
N  *             before it is fed into timer.
N  */
N#define TIMER_SET_PRESCALE_VALUE(timer, u32Value)   ((timer)->CTL = ((timer)->CTL & ~TIMER_CTL_PSC_Msk) | (u32Value))
N
N/**
N  * @brief      Check specify Timer Status
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer 24-bit up counter is inactive
N  * @retval     1   Timer 24-bit up counter is active
N  *
N  * @details    This macro is used to check if specify Timer counter is inactive or active.
N  */
N#define TIMER_IS_ACTIVE(timer)                      (((timer)->CTL & TIMER_CTL_ACTSTS_Msk)? 1 : 0)
N
N/**
N  * @brief      Select Toggle-output Pin
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  * @param[in]  u32ToutSel  Toggle-output pin selection, valid values are:
N  *                         - \ref TIMER_TOUT_PIN_FROM_TX
N  *                         - \ref TIMER_TOUT_PIN_FROM_TX_EXT
N  *
N  * @return     None
N  *
N  * @details    This macro is used to select timer toggle-output pin is output on Tx or Tx_EXT pin.
N  */
N#define TIMER_SELECT_TOUT_PIN(timer, u32ToutSel)    ((timer)->CTL = ((timer)->CTL & ~TIMER_CTL_TGLPINSEL_Msk) | (u32ToutSel))
N
N/**
N  * @brief      Start Timer Counting
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to start Timer counting.
N  */
Nstatic __INLINE void TIMER_Start(TIMER_T *timer)
Xstatic __inline void TIMER_Start(TIMER_T *timer)
N{
N    timer->CTL |= TIMER_CTL_CNTEN_Msk;
X    timer->CTL |= (0x1ul << (30));
N}
N
N/**
N  * @brief      Stop Timer Counting
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to stop/suspend Timer counting.
N  */
Nstatic __INLINE void TIMER_Stop(TIMER_T *timer)
Xstatic __inline void TIMER_Stop(TIMER_T *timer)
N{
N    timer->CTL &= ~TIMER_CTL_CNTEN_Msk;
X    timer->CTL &= ~(0x1ul << (30));
N}
N
N/**
N  * @brief      Enable Timer Interrupt Wake-up Function
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the timer interrupt wake-up function and interrupt source could be time-out interrupt, \n
N  *             counter event interrupt or capture trigger interrupt.
N  * @note       To wake the system from Power-down mode, timer clock source must be ether LXT or LIRC.
N  */
Nstatic __INLINE void TIMER_EnableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_EnableWakeup(TIMER_T *timer)
N{
N    timer->CTL |= TIMER_CTL_WKEN_Msk;
X    timer->CTL |= (0x1ul << (23));
N}
N
N/**
N  * @brief      Disable Timer Wake-up Function
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the timer interrupt wake-up function.
N  */
Nstatic __INLINE void TIMER_DisableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_DisableWakeup(TIMER_T *timer)
N{
N    timer->CTL &= ~TIMER_CTL_WKEN_Msk;
X    timer->CTL &= ~(0x1ul << (23));
N}
N
N/**
N  * @brief      Start Timer Capture Function
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to start Timer capture function.
N  */
Nstatic __INLINE void TIMER_StartCapture(TIMER_T *timer)
Xstatic __inline void TIMER_StartCapture(TIMER_T *timer)
N{
N    timer->EXTCTL |= TIMER_EXTCTL_CAPEN_Msk;
X    timer->EXTCTL |= (0x1ul << (3));
N}
N
N/**
N  * @brief      Stop Timer Capture Function
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to stop Timer capture function.
N  */
Nstatic __INLINE void TIMER_StopCapture(TIMER_T *timer)
Xstatic __inline void TIMER_StopCapture(TIMER_T *timer)
N{
N    timer->EXTCTL &= ~TIMER_EXTCTL_CAPEN_Msk;
X    timer->EXTCTL &= ~(0x1ul << (3));
N}
N
N/**
N  * @brief      Enable Capture Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the detect de-bounce function of capture pin.
N  */
Nstatic __INLINE void TIMER_EnableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureDebounce(TIMER_T *timer)
N{
N    timer->EXTCTL |= TIMER_EXTCTL_CAPDBEN_Msk;
X    timer->EXTCTL |= (0x1ul << (6));
N}
N
N/**
N  * @brief      Disable Capture Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the detect de-bounce function of capture pin.
N  */
Nstatic __INLINE void TIMER_DisableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureDebounce(TIMER_T *timer)
N{
N    timer->EXTCTL &= ~TIMER_EXTCTL_CAPDBEN_Msk;
X    timer->EXTCTL &= ~(0x1ul << (6));
N}
N
N/**
N  * @brief      Enable Counter Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the detect de-bounce function of counter pin.
N  */
Nstatic __INLINE void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->EXTCTL |= TIMER_EXTCTL_CNTDBEN_Msk;
X    timer->EXTCTL |= (0x1ul << (7));
N}
N
N/**
N  * @brief      Disable Counter Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the detect de-bounce function of counter pin.
N  */
Nstatic __INLINE void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->EXTCTL &= ~TIMER_EXTCTL_CNTDBEN_Msk;
X    timer->EXTCTL &= ~(0x1ul << (7));
N}
N
N/**
N  * @brief      Enable Timer Time-out Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the timer time-out interrupt function.
N  */
Nstatic __INLINE void TIMER_EnableInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableInt(TIMER_T *timer)
N{
N    timer->CTL |= TIMER_CTL_INTEN_Msk;
X    timer->CTL |= (0x1ul << (29));
N}
N
N/**
N  * @brief      Disable Timer Time-out Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the timer time-out interrupt function.
N  */
Nstatic __INLINE void TIMER_DisableInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableInt(TIMER_T *timer)
N{
N    timer->CTL &= ~TIMER_CTL_INTEN_Msk;
X    timer->CTL &= ~(0x1ul << (29));
N}
N
N/**
N  * @brief      Enable Capture Trigger Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the timer capture trigger interrupt function.
N  */
Nstatic __INLINE void TIMER_EnableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureInt(TIMER_T *timer)
N{
N    timer->EXTCTL |= TIMER_EXTCTL_CAPIEN_Msk;
X    timer->EXTCTL |= (0x1ul << (5));
N}
N
N/**
N  * @brief      Disable Capture Trigger Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the timer capture trigger interrupt function.
N  */
Nstatic __INLINE void TIMER_DisableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureInt(TIMER_T *timer)
N{
N    timer->EXTCTL &= ~TIMER_EXTCTL_CAPIEN_Msk;
X    timer->EXTCTL &= ~(0x1ul << (5));
N}
N
N/**
N  * @brief      Get Timer Time-out Interrupt Flag
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer time-out interrupt did not occur
N  * @retval     1   Timer time-out interrupt occurred
N  *
N  * @details    This function indicates timer time-out interrupt occurred or not.
N  */
Nstatic __INLINE uint32_t TIMER_GetIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetIntFlag(TIMER_T *timer)
N{
N    return ((timer->INTSTS & TIMER_INTSTS_TIF_Msk) ? 1 : 0);
X    return ((timer->INTSTS & (0x1ul << (0))) ? 1 : 0);
N}
N
N/**
N  * @brief      Clear Timer Time-out Interrupt Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function clears timer time-out interrupt flag to 0.
N  */
Nstatic __INLINE void TIMER_ClearIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearIntFlag(TIMER_T *timer)
N{
N    timer->INTSTS = TIMER_INTSTS_TIF_Msk;
X    timer->INTSTS = (0x1ul << (0));
N}
N
N/**
N  * @brief      Get Timer Capture Interrupt Flag
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer capture interrupt did not occur
N  * @retval     1   Timer capture interrupt occurred
N  *
N  * @details    This function indicates timer capture trigger interrupt occurred or not.
N  */
Nstatic __INLINE uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
N{
N    return timer->EINTSTS;
N}
N
N/**
N  * @brief      Clear Timer Capture Interrupt Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function clears timer capture trigger interrupt flag to 0.
N  */
Nstatic __INLINE void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
N{
N    timer->EINTSTS = TIMER_EINTSTS_CAPIF_Msk;
X    timer->EINTSTS = (0x1ul << (0));
N}
N
N/**
N  * @brief      Get Timer Wake-up Flag
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer does not cause CPU wake-up
N  * @retval     1   Timer interrupt event cause CPU wake-up
N  *
N  * @details    This function indicates timer interrupt event has waked up system or not.
N  */
Nstatic __INLINE uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
N{
N    return (timer->INTSTS & TIMER_INTSTS_TWKF_Msk ? 1 : 0);
X    return (timer->INTSTS & (0x1ul << (1)) ? 1 : 0);
N}
N
N/**
N  * @brief      Clear Timer Wake-up Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function clears the timer wake-up system flag to 0.
N  */
Nstatic __INLINE void TIMER_ClearWakeupFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearWakeupFlag(TIMER_T *timer)
N{
N    timer->INTSTS = TIMER_INTSTS_TWKF_Msk;
X    timer->INTSTS = (0x1ul << (1));
N}
N
N/**
N  * @brief      Get Capture value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     24-bit Capture Value
N  *
N  * @details    This function reports the current 24-bit timer capture value.
N  */
Nstatic __INLINE uint32_t TIMER_GetCaptureData(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureData(TIMER_T *timer)
N{
N    return timer->CAP;
N}
N
N/**
N  * @brief      Get Counter value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     24-bit Counter Value
N  *
N  * @details    This function reports the current 24-bit timer counter value.
N  */
Nstatic __INLINE uint32_t TIMER_GetCounter(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCounter(TIMER_T *timer)
N{
N    return timer->CNT;
N}
N
N/**
N  * @brief      Reset Counter
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is usde to reset current counter value and internal prescale counter value.
N  */
Nstatic __INLINE void TIMER_ResetCounter(TIMER_T *timer)
Xstatic __inline void TIMER_ResetCounter(TIMER_T *timer)
N{
N    timer->CNT = 0x0;
N    while(timer->CNT);
N}
N
N
Nuint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq);
Nvoid TIMER_Close(TIMER_T *timer);
Nvoid TIMER_Delay(TIMER_T *timer, uint32_t u32Usec);
Nvoid TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge);
Nvoid TIMER_DisableCapture(TIMER_T *timer);
Nvoid TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge);
Nvoid TIMER_DisableEventCounter(TIMER_T *timer);
Nuint32_t TIMER_GetModuleClock(TIMER_T *timer);
Nvoid TIMER_EnableFreqCounter(TIMER_T *timer, uint32_t u32DropCount, uint32_t u32Timeout, uint32_t u32EnableInt);
Nvoid TIMER_DisableFreqCounter(TIMER_T *timer);
Nvoid TIMER_SetTriggerSource(TIMER_T *timer, uint32_t u32Src);
Nvoid TIMER_SetTriggerTarget(TIMER_T *timer, uint32_t u32Mask);
N
N/*@}*/ /* end of group TIMER_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group TIMER_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__TIMER_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17564 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "timer_pwm.h"
L 1 "..\lib\StdDriver\inc\timer_pwm.h" 1
N/**************************************************************************//**
N * @file     timer.h
N * @version  V3.00
N * $Revision: 9 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE series Timer PWM Controller(Timer PWM) driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __TIMER_PWM_H__
N#define __TIMER_PWM_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup TIMER_PWM_Driver TIMER PWM Driver
N  @{
N*/
N
N/** @addtogroup TIMER_PWM_EXPORTED_CONSTANTS TIMER PWM Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Output Channel Constant Definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define TPWM_CH0                                (BIT0)       /*!< Indicate PWMx_CH0 */
N#define TPWM_CH1                                (BIT1)       /*!< Indicate PWMx_CH1 */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Counter Type Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define TPWM_UP_COUNT                           (0UL)       /*!< Up count type */
N#define TPWM_DOWN_COUNT                         (1UL)       /*!< Down count type */
N#define TPWM_UP_DOWN_COUNT                      (2UL)       /*!< Up-Down count type */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Counter Mode Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define TPWM_AUTO_RELOAD_MODE                   (0UL)       /*!< Auto-reload mode */
N#define TPWM_ONE_SHOT_MODE                      (1UL)       /*!< One-shot mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Output Level Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define TPWM_OUTPUT_TOGGLE                      (0UL)      /*!< Timer PWM output toggle */
N#define TPWM_OUTPUT_NOTHING                     (1UL)      /*!< Timer PWM output nothing */
N#define TPWM_OUTPUT_LOW                         (2UL)      /*!< Timer PWM output low */
N#define TPWM_OUTPUT_HIGH                        (3UL)      /*!< Timer PWM output high */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Trigger ADC Source Select Constant Definitions                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define TPWM_TRIGGER_ADC_AT_ZERO_POINT                      (0UL)     /*!< Timer PWM trigger ADC while counter zero point event occurred */
N#define TPWM_TRIGGER_ADC_AT_PERIOD_POINT                    (1UL)     /*!< Timer PWM trigger ADC while counter period point event occurred */
N#define TPWM_TRIGGER_ADC_AT_ZERO_OR_PERIOD_POINT            (2UL)     /*!< Timer PWM trigger ADC while counter zero or period point event occurred */
N#define TPWM_TRIGGER_ADC_AT_COMPARE_UP_COUNT_POINT          (3UL)     /*!< Timer PWM trigger ADC while counter up count compare point event occurred */
N#define TPWM_TRIGGER_ADC_AT_COMPARE_DOWN_COUNT_POINT        (4UL)     /*!< Timer PWM trigger ADC while counter down count compare point event occurred */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Brake Control Constant Definitions                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define TPWM_BRAKE_SOURCE_EDGE_ACMP0            (TIMER_PWMBRKCTL_CPO0EBEN_Msk) /*!< Comparator 0 as edge-detect fault brake source */
N#define TPWM_BRAKE_SOURCE_EDGE_ACMP1            (TIMER_PWMBRKCTL_CPO1EBEN_Msk) /*!< Comparator 1 as edge-detect fault brake source */
N#define TPWM_BRAKE_SOURCE_EDGE_BKPIN            (TIMER_PWMBRKCTL_BRKPEEN_Msk)  /*!< Brake pin as edge-detect fault brake source */
N#define TPWM_BRAKE_SOURCE_EDGE_SYS_CSS          (TIMER_PWMBRKCTL_SYSEBEN_Msk | (TIMER_PWMFAILBRK_CSSBRKEN_Msk << 16))    /*!< System fail condition: clock security system detection as edge-detect fault brake source */
N#define TPWM_BRAKE_SOURCE_EDGE_SYS_BOD          (TIMER_PWMBRKCTL_SYSEBEN_Msk | (TIMER_PWMFAILBRK_BODBRKEN_Msk << 16))    /*!< System fail condition: brown-out detection as edge-detect fault brake source */
N#define TPWM_BRAKE_SOURCE_EDGE_SYS_COR          (TIMER_PWMBRKCTL_SYSEBEN_Msk | (TIMER_PWMFAILBRK_CORBRKEN_Msk << 16))    /*!< System fail condition: core lockup detection as edge-detect fault brake source */
N
N#define TPWM_BRAKE_SOURCE_LEVEL_ACMP0           (TIMER_PWMBRKCTL_CPO0LBEN_Msk)  /*!< Comparator 0 as level-detect fault brake source */
N#define TPWM_BRAKE_SOURCE_LEVEL_ACMP1           (TIMER_PWMBRKCTL_CPO1LBEN_Msk)  /*!< Comparator 1 as level-detect fault brake source */
N#define TPWM_BRAKE_SOURCE_LEVEL_BKPIN           (TIMER_PWMBRKCTL_BRKPLEN_Msk)   /*!< Brake pin as level-detect fault brake source */
N#define TPWM_BRAKE_SOURCE_LEVEL_SYS_CSS         (TIMER_PWMBRKCTL_SYSLBEN_Msk | (TIMER_PWMFAILBRK_CSSBRKEN_Msk << 16))    /*!< System fail condition: clock security system detection as level-detect fault brake source */
N#define TPWM_BRAKE_SOURCE_LEVEL_SYS_BOD         (TIMER_PWMBRKCTL_SYSLBEN_Msk | (TIMER_PWMFAILBRK_BODBRKEN_Msk << 16))    /*!< System fail condition: brown-out detection as level-detect fault brake source */
N#define TPWM_BRAKE_SOURCE_LEVEL_SYS_COR         (TIMER_PWMBRKCTL_SYSLBEN_Msk | (TIMER_PWMFAILBRK_CORBRKEN_Msk << 16))    /*!< System fail condition: core lockup detection as level-detect fault brake source */
N
N#define TPWM_BRAKE_EDGE                         (TIMER_PWMSWBRK_BRKETRG_Msk)    /*!< Edge-detect fault brake */
N#define TPWM_BRAKE_LEVEL                        (TIMER_PWMSWBRK_BRKLTRG_Msk)    /*!< Level-detect fault brake */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Load Mode Constant Definitions                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define TPWM_LOAD_MODE_PERIOD                   (0UL)                       /*!< Timer PWM period load mode \hideinitializer */
N#define TPWM_LOAD_MODE_IMMEDIATE                (TIMER_PWMCTL_IMMLDEN_Msk)  /*!< Timer PWM immediately load mode \hideinitializer */
N#define TPWM_LOAD_MODE_CENTER                   (TIMER_PWMCTL_CTRLD_Msk)    /*!< Timer PWM center load mode \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Brake Pin De-bounce Clock Source Select Constant Definitions                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define TPWM_BKP_DBCLK_PCLK_DIV_1               (0UL)    /*!< De-bounce clock is PCLK divide by 1 \hideinitializer */
N#define TPWM_BKP_DBCLK_PCLK_DIV_2               (1UL)    /*!< De-bounce clock is PCLK divide by 2 \hideinitializer */
N#define TPWM_BKP_DBCLK_PCLK_DIV_4               (2UL)    /*!< De-bounce clock is PCLK divide by 4 \hideinitializer */
N#define TPWM_BKP_DBCLK_PCLK_DIV_8               (3UL)    /*!< De-bounce clock is PCLK divide by 8 \hideinitializer */
N#define TPWM_BKP_DBCLK_PCLK_DIV_16              (4UL)    /*!< De-bounce clock is PCLK divide by 16 \hideinitializer */
N#define TPWM_BKP_DBCLK_PCLK_DIV_32              (5UL)    /*!< De-bounce clock is PCLK divide by 32 \hideinitializer */
N#define TPWM_BKP_DBCLK_PCLK_DIV_64              (6UL)    /*!< De-bounce clock is PCLK divide by 64 \hideinitializer */
N#define TPWM_BKP_DBCLK_PCLK_DIV_128             (7UL)    /*!< De-bounce clock is PCLK divide by 128 \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Brake Pin Source Select Constant Definitions                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define TPWM_TM_BRAKE0                          (0UL)    /*!< Brake pin source comes from TM_BRAKE0 \hideinitializer */
N#define TPWM_TM_BRAKE1                          (1UL)    /*!< Brake pin source comes from TM_BRAKE1 \hideinitializer */
N#define TPWM_TM_BRAKE2                          (2UL)    /*!< Brake pin source comes from TM_BRAKE2 \hideinitializer */
N#define TPWM_TM_BRAKE3                          (3UL)    /*!< Brake pin source comes from TM_BRAKE3 \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Counter Clock Source Select Constant Definitions                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define TPWM_COUNTER_CLKSRC_TMR_CLK             (0UL)    /*!< Timer PWM Clock source selects to TMR_CLK \hideinitializer */
N#define TPWM_COUNTER_CLKSRC_TIMER0_INT          (1UL)    /*!< Timer PWM Clock source selects to TIMER0 interrupt event \hideinitializer */
N#define TPWM_COUNTER_CLKSRC_TIMER1_INT          (2UL)    /*!< Timer PWM Clock source selects to TIMER1 interrupt event \hideinitializer */
N#define TPWM_COUNTER_CLKSRC_TIMER2_INT          (3UL)    /*!< Timer PWM Clock source selects to TIMER2 interrupt event \hideinitializer */
N#define TPWM_COUNTER_CLKSRC_TIMER3_INT          (4UL)    /*!< Timer PWM Clock source selects to TIMER3 interrupt event \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Counter Synchronous Mode Constant Definitions                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define TPWM_COUNTER_SYNC_DISABLE               (0UL)    /*!< Disable TIMER PWM synchronous function \hideinitializer */
N#define TPWM_COUNTER_SYNC_START_BY_TIMER0       ((0<<TIMER_PWMSCTL_SYNCSRC_Pos) | (1<<TIMER_PWMSCTL_SYNCMODE_Pos))  /*!< PWM counter synchronous start by TIMER0 PWM \hideinitializer */
N#define TPWM_COUNTER_SYNC_CLEAR_BY_TIMER0       ((0<<TIMER_PWMSCTL_SYNCSRC_Pos) | (3<<TIMER_PWMSCTL_SYNCMODE_Pos))  /*!< PWM counter synchronous clear by TIMER0 PWM \hideinitializer */
N#define TPWM_COUNTER_SYNC_START_BY_TIMER2       ((1<<TIMER_PWMSCTL_SYNCSRC_Pos) | (1<<TIMER_PWMSCTL_SYNCMODE_Pos))  /*!< PWM counter synchronous start by TIMER2 PWM \hideinitializer */
N#define TPWM_COUNTER_SYNC_CLEAR_BY_TIMER2       ((1<<TIMER_PWMSCTL_SYNCSRC_Pos) | (3<<TIMER_PWMSCTL_SYNCMODE_Pos))  /*!< PWM counter synchronous clear by TIMER2 PWM \hideinitializer */
N
N/*@}*/ /* end of group TIMER_PWM_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup TIMER_PWM_EXPORTED_FUNCTIONS TIMER PWM Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Enable PWM Counter Mode
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to enable specified Timer channel as PWM counter mode, then timer counter mode is invalid.
N  * @note       All registers about time counter function will be cleard to 0 and timer clock source will be changed to PCLKx automatically after executing this macro.
N  */
N#define TPWM_ENABLE_PWM_MODE(timer)         ((timer)->ALTCTL = (1 << TIMER_ALTCTL_FUNCSEL_Pos))
N
N/**
N  * @brief      Disable PWM Counter Mode
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to disable specified Timer channel as PWM counter mode, then timer counter mode is available.
N  * @note       All registers about PWM counter function will be cleard to 0 after executing this macro.
N  */
N#define TPWM_DISABLE_PWM_MODE(timer)        ((timer)->ALTCTL = (0 << TIMER_ALTCTL_FUNCSEL_Pos))
N
N/**
N  * @brief      Enable Independent Mode
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to enable independent mode of TIMER PWM module and complementary mode will be disabled.
N  */
N#define TPWM_ENABLE_INDEPENDENT_MODE(timer)     ((timer)->PWMCTL &= ~(1 << TIMER_PWMCTL_OUTMODE_Pos))
N
N/**
N  * @brief      Enable Complementary Mode
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to enable complementary mode of Timer PWM module and independent mode will be disabled.
N  */
N#define TPWM_ENABLE_COMPLEMENTARY_MODE(timer)   ((timer)->PWMCTL |= (1 << TIMER_PWMCTL_OUTMODE_Pos))
N
N/**
N  * @brief      Set Counter Type
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  * @param[in]  type        Timer PWM count type, could be one of the following type
N  *                             - \ref TPWM_UP_COUNT
N  *                             - \ref TPWM_DOWN_COUNT
N  *                             - \ref TPWM_UP_DOWN_COUNT
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set Timer PWM counter type.
N  */
N#define TPWM_SET_COUNTER_TYPE(timer, type)      ((timer)->PWMCTL = ((timer)->PWMCTL & ~TIMER_PWMCTL_CNTTYPE_Msk) | (type << TIMER_PWMCTL_CNTTYPE_Pos))
N
N/**
N  * @brief      Start PWM Counter
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to enable PWM generator and start counter counting.
N  */
N#define TPWM_START_COUNTER(timer)               ((timer)->PWMCTL |= TIMER_PWMCTL_CNTEN_Msk)
N
N/**
N  * @brief      Stop PWM Counter
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to stop PWM counter after current period is completed.
N  */
N#define TPWM_STOP_COUNTER(timer)                ((timer)->PWMPERIOD = 0x0)
N
N/**
N  * @brief      Set Counter Clock Prescaler
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @param[in]  prescaler    Clock prescaler of specified channel. Valid values are between 0x0~0xFFF.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set the prescaler of specified TIMER PWM.
N  * @note       If prescaler is 0, then there is no scaling in counter clock source.
N  */
N#define TPWM_SET_PRESCALER(timer, prescaler) ((timer)->PWMCLKPSC = (prescaler))
N
N/**
N  * @brief      Get Counter Clock Prescaler
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     Target prescaler setting, CLKPSC (TIMERx_PWMCLKPSC[11:0])
N  *
N  * @details    Get the prescaler settng, the target counter clock divider is (CLKPSC + 1).
N  */
N#define TPWM_GET_PRESCALER(timer)       ((timer)->PWMCLKPSC)
N
N/**
N  * @brief      Set Couner Period
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @param[in]  period      Period of specified channel. Valid values are between 0x0~0xFFFF.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set the period of specified TIMER PWM.
N  */
N#define TPWM_SET_PERIOD(timer, period)  ((timer)->PWMPERIOD = (period))
N
N/**
N  * @brief      Get Couner Period
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     Target period setting, PERIOD (TIMERx_PWMPERIOD[15:0])
N  *
N  * @details    This macro is used to get the period of specified TIMER PWM.
N  */
N#define TPWM_GET_PERIOD(timer)          ((timer)->PWMPERIOD)
N
N/**
N  * @brief      Set Comparator Value
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @param[in]  cmp     Comparator of specified channel. Valid values are between 0x0~0xFFFF.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set the comparator value of specified TIMER PWM.
N  */
N#define TPWM_SET_CMPDAT(timer, cmp)     ((timer)->PWMCMPDAT = (cmp))
N
N/**
N  * @brief      Get Comparator Value
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     Target comparator setting, CMPDAT (TIMERx_PWMCMPDAT[15:0])
N  *
N  * @details    This macro is used to get the comparator value of specified TIMER PWM.
N  */
N#define TPWM_GET_CMPDAT(timer)          ((timer)->PWMCMPDAT)
N
N/**
N  * @brief      Clear Counter
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear counter of specified TIMER PWM.
N  */
N#define TPWM_CLEAR_COUNTER(timer)       ((timer)->PWMCNTCLR = TIMER_PWMCNTCLR_CNTCLR_Msk)
N
N/**
N  * @brief      Software Trigger Brake Event
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @param[in]  type        Type of brake trigger. Valid values are:
N  *                             - \ref TPWM_BRAKE_EDGE
N  *                             - \ref TPWM_BRAKE_LEVEL
N  *
N  * @return     None
N  *
N  * @details    This macro is used to trigger brake event by writing PWMSWBRK register.
N  */
N#define TPWM_SW_TRIGGER_BRAKE(timer, type)  ((timer)->PWMSWBRK = (type))
N
N/**
N  * @brief      Enable Output Function
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @param[in]  ch          Enable specified channel output function. Valid values are:
N  *                             - \ref TPWM_CH0
N  *                             - \ref TPWM_CH1
N  *
N  * @return     None
N  *
N  * @details    This macro is used to enable output function of specified output pins.
N  * @note       If the corresponding bit in u32ChMask parameter is 0, then output function will be disabled in this channel.
N  */
N#define TPWM_ENABLE_OUTPUT(timer, ch)  ((timer)->PWMPOEN = (ch))
N
N/**
N  * @brief      Set Output Inverse
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @param[in]  ch          Set specified channel output is inversed or not. Valid values are:
N  *                             - \ref TPWM_CH0
N  *                             - \ref TPWM_CH1
N  *
N  * @return     None
N  *
N  * @details    This macro is used to enable output inverse of specified output pins.
N  * @note       If u32ChMask parameter is 0, then output inverse function will be disabled.
N  */
N#define TPWM_SET_OUTPUT_INVERSE(timer, ch)  ((timer)->PWMPOLCTL = (ch))
N
N/**
N  * @brief      Enable Output Function
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @param[in]  ch       Enable specified channel output mask function. Valid values are:
N  *                             - \ref TPWM_CH0
N  *                             - \ref TPWM_CH1
N  *
N  * @param[in]  level    Output to high or low on specified mask channel.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to enable output function of specified output pins.
N  * @note       If u32ChMask parameter is 0, then output mask function will be disabled.
N  */
N#define TPWM_SET_MASK_OUTPUT(timer, ch, level) \
N    { \
N        (timer)->PWMMSKEN = (ch); \
N        (timer)->PWMMSK = (level); \
N    }
X#define TPWM_SET_MASK_OUTPUT(timer, ch, level)     {         (timer)->PWMMSKEN = (ch);         (timer)->PWMMSK = (level);     }
N
N/**
N  * @brief      Set Counter Synchronous Mode
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @param[in]  mode    Synchronous mode. Possible options are:
N  *                         - \ref TPWM_COUNTER_SYNC_DISABLE
N  *                         - \ref TPWM_COUNTER_SYNC_START_BY_TIMER0
N  *                         - \ref TPWM_COUNTER_SYNC_CLEAR_BY_TIMER0
N  *                         - \ref TPWM_COUNTER_SYNC_START_BY_TIMER2
N  *                         - \ref TPWM_COUNTER_SYNC_CLEAR_BY_TIMER2
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set counter synchronous mode of specified Timer PWM module.
N  * @note       Only support all PWM counters are synchronous by TIMER0 PWM or TIMER0~1 PWM counter synchronous by TIMER0 PWM and
N  *             TIMER2~3 PWM counter synchronous by TIMER2 PWM.
N  */
N#define TPWM_SET_COUNTER_SYNC_MODE(timer, mode) ((timer)->PWMSCTL = (mode))
N
N/**
N  * @brief      Trigger Counter Synchronous
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to trigger synchronous event by specified TIMER PWM.
N  * @note       1. This macro is only available for TIMER0 PWM and TIMER2 PWM. \n
N  *             2. STRGEN (PWMSTRG[0]) is write only and always read as 0.
N  */
N#define TPWM_TRIGGER_COUNTER_SYNC(timer)    ((timer)->PWMSTRG = TIMER_PWMSTRG_STRGEN_Msk)
N
N/**
N  * @brief      Enable Zero Event Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to enable the zero event interrupt function.
N  */
N#define TPWM_ENABLE_ZERO_INT(timer)         ((timer)->PWMINTEN0 |= TIMER_PWMINTEN0_ZIEN_Msk)
N
N/**
N  * @brief      Disable Zero Event Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to disable the zero event interrupt function.
N  */
N#define TPWM_DISABLE_ZERO_INT(timer)        ((timer)->PWMINTEN0 &= ~TIMER_PWMINTEN0_ZIEN_Msk)
N
N/**
N  * @brief      Get Zero Event Interrupt Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Zero event interrupt did not occur
N  * @retval     1   Zero event interrupt occurred
N  *
N  * @details    This macro indicates zero event occurred or not.
N  */
N#define TPWM_GET_ZERO_INT_FLAG(timer)       (((timer)->PWMINTSTS0 & TIMER_PWMINTSTS0_ZIF_Msk)? 1 : 0)
N
N/**
N  * @brief      Clear Zero Event Interrupt Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro clears zero event interrupt flag.
N  */
N#define TPWM_CLEAR_ZERO_INT_FLAG(timer)     ((timer)->PWMINTSTS0 = TIMER_PWMINTSTS0_ZIF_Msk)
N
N/**
N  * @brief      Enable Period Event Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to enable the period event interrupt function.
N  */
N#define TPWM_ENABLE_PERIOD_INT(timer)       ((timer)->PWMINTEN0 |= TIMER_PWMINTEN0_PIEN_Msk)
N
N/**
N  * @brief      Disable Period Event Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to disable the period event interrupt function.
N  */
N#define TPWM_DISABLE_PERIOD_INT(timer)      ((timer)->PWMINTEN0 &= ~TIMER_PWMINTEN0_PIEN_Msk)
N
N/**
N  * @brief      Get Period Event Interrupt Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Period event interrupt did not occur
N  * @retval     1   Period event interrupt occurred
N  *
N  * @details    This macro indicates period event occurred or not.
N  */
N#define TPWM_GET_PERIOD_INT_FLAG(timer)     (((timer)->PWMINTSTS0 & TIMER_PWMINTSTS0_PIF_Msk)? 1 : 0)
N
N/**
N  * @brief      Clear Period Event Interrupt Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro clears period event interrupt flag.
N  */
N#define TPWM_CLEAR_PERIOD_INT_FLAG(timer)   ((timer)->PWMINTSTS0 = TIMER_PWMINTSTS0_PIF_Msk)
N
N/**
N  * @brief      Enable Compare Up Event Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to enable the compare up event interrupt function.
N  */
N#define TPWM_ENABLE_CMP_UP_INT(timer)       ((timer)->PWMINTEN0 |= TIMER_PWMINTEN0_CMPUIEN_Msk)
N
N/**
N  * @brief      Disable Compare Up Event Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to disable the compare up event interrupt function.
N  */
N#define TPWM_DISABLE_CMP_UP_INT(timer)      ((timer)->PWMINTEN0 &= ~TIMER_PWMINTEN0_CMPUIEN_Msk)
N
N/**
N  * @brief      Get Compare Up Event Interrupt Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Compare up event interrupt did not occur
N  * @retval     1   Compare up event interrupt occurred
N  *
N  * @details    This macro indicates compare up event occurred or not.
N  */
N#define TPWM_GET_CMP_UP_INT_FLAG(timer)     (((timer)->PWMINTSTS0 & TIMER_PWMINTSTS0_CMPUIF_Msk)? 1 : 0)
N
N/**
N  * @brief      Clear Compare Up Event Interrupt Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro clears compare up event interrupt flag.
N  */
N#define TPWM_CLEAR_CMP_UP_INT_FLAG(timer)   ((timer)->PWMINTSTS0 = TIMER_PWMINTSTS0_CMPUIF_Msk)
N
N/**
N  * @brief      Enable Compare Down Event Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to enable the compare down event interrupt function.
N  */
N#define TPWM_ENABLE_CMP_DOWN_INT(timer)     ((timer)->PWMINTEN0 |= TIMER_PWMINTEN0_CMPDIEN_Msk)
N
N/**
N  * @brief      Disable Compare Down Event Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to disable the compare down event interrupt function.
N  */
N#define TPWM_DISABLE_CMP_DOWN_INT(timer)    ((timer)->PWMINTEN0 &= ~TIMER_PWMINTEN0_CMPDIEN_Msk)
N
N/**
N  * @brief      Get Compare Down Event Interrupt Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Compare down event interrupt did not occur
N  * @retval     1   Compare down event interrupt occurred
N  *
N  * @details    This macro indicates compare down event occurred or not.
N  */
N#define TPWM_GET_CMP_DOWN_INT_FLAG(timer)   (((timer)->PWMINTSTS0 & TIMER_PWMINTSTS0_CMPDIF_Msk)? 1 : 0)
N
N/**
N  * @brief      Clear Compare Down Event Interrupt Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro clears compare down event interrupt flag.
N  */
N#define TPWM_CLEAR_CMP_DOWN_INT_FLAG(timer) ((timer)->PWMINTSTS0 = TIMER_PWMINTSTS0_CMPDIF_Msk)
N
N/**
N  * @brief      Get Counter Reach Maximum Count Status
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer PWM counter never counts to maximum value
N  * @retval     1   Timer PWM counter counts to maximum value, 0xFFFF
N  *
N  * @details    This macro indicates Timer PWM counter has count to 0xFFFF or not.
N  */
N#define TPWM_GET_REACH_MAX_CNT_STATUS(timer)    (((timer)->PWMSTATUS & TIMER_PWMSTATUS_CNTMAXF_Msk)? 1 : 0)
N
N/**
N  * @brief      Clear Counter Reach Maximum Count Status
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro clears reach maximum count status.
N  */
N#define TPWM_CLEAR_REACH_MAX_CNT_STATUS(timer)  ((timer)->PWMSTATUS = TIMER_PWMSTATUS_CNTMAXF_Msk)
N
N/**
N  * @brief      Get Trigger ADC Status
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0       Trigger ADC start conversion is not occur
N  * @retval     1       Specified counter compare event has trigger ADC start conversion
N  *
N  * @details    This macro is used to indicate PWM counter compare event has triggered ADC start conversion.
N  */
N#define TPWM_GET_TRG_ADC_STATUS(timer)          (((timer)->PWMSTATUS & TIMER_PWMSTATUS_ADCTRGF_Msk)? 1 : 0)
N
N/**
N  * @brief      Clear Trigger ADC Status
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear PWM counter compare event trigger ADC status.
N  */
N#define TPWM_CLEAR_TRG_ADC_STATUS(timer)        ((timer)->PWMSTATUS = TIMER_PWMSTATUS_ADCTRGF_Msk)
N
N/**
N  * @brief      Set Brake Event at Brake Pin High or Low-to-High
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set detect brake event when external brake pin at high level or transfer from low to high.
N  * @note       The defailt brake pin detection is high level or from low to high.
N  */
N#define TPWM_SET_BRAKE_PIN_HIGH_DETECT(timer)   ((timer)->PWMBNF &= ~TIMER_PWMBNF_BRKPINV_Msk)
N
N/**
N  * @brief      Set Brake Event at Brake Pin Low or High-to-Low
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set detect brake event when external brake pin at low level or transfer from high to low.
N  */
N#define TPWM_SET_BRAKE_PIN_LOW_DETECT(timer)    ((timer)->PWMBNF |= TIMER_PWMBNF_BRKPINV_Msk)
N
N/**
N  * @brief      Set External Brake Pin Source
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  * @param[in]  pin         The external brake pin source, could be one of following source
N  *                                 - \ref TPWM_TM_BRAKE0
N  *                                 - \ref TPWM_TM_BRAKE1
N  *                                 - \ref TPWM_TM_BRAKE2
N  *                                 - \ref TPWM_TM_BRAKE3
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set detect brake event when external brake pin at high level or transfer from low to high.
N  */
N#define TPWM_SET_BRAKE_PIN_SOURCE(timer, pin)   ((timer)->PWMBNF = ((timer)->PWMBNF & ~TIMER_PWMBNF_BKPINSRC_Msk) | (pin<<TIMER_PWMBNF_BKPINSRC_Pos))
N
N
Nvoid TPWM_SetCounterClockSource(TIMER_T *timer, uint32_t u32CntClkSrc);
Nuint32_t TPWM_ConfigOutputFreqAndDuty(TIMER_T *timer, uint32_t u32Frequency, uint32_t u32DutyCycle);
Nvoid TPWM_EnableDeadTime(TIMER_T *timer, uint32_t u32DTCount);
Nvoid TPWM_EnableDeadTimeWithPrescale(TIMER_T *timer, uint32_t u32DTCount);
Nvoid TPWM_DisableDeadTime(TIMER_T *timer);
Nvoid TPWM_EnableCounter(TIMER_T *timer);
Nvoid TPWM_DisableCounter(TIMER_T *timer);
Nvoid TPWM_EnableTriggerADC(TIMER_T *timer, uint32_t u32Condition);
Nvoid TPWM_DisableTriggerADC(TIMER_T *timer);
Nvoid TPWM_EnableFaultBrake(TIMER_T *timer, uint32_t u32CH0Level, uint32_t u32CH1Level, uint32_t u32BrakeSource);
Nvoid TPWM_EnableFaultBrakeInt(TIMER_T *timer, uint32_t u32IntSource);
Nvoid TPWM_DisableFaultBrakeInt(TIMER_T *timer, uint32_t u32IntSource);
Nuint32_t TPWM_GetFaultBrakeIntFlag(TIMER_T *timer, uint32_t u32IntSource);
Nvoid TPWM_ClearFaultBrakeIntFlag(TIMER_T *timer, uint32_t u32IntSource);
Nvoid TPWM_SetLoadMode(TIMER_T *timer, uint32_t u32LoadMode);
Nvoid TPWM_EnableBrakePinDebounce(TIMER_T *timer, uint32_t u32BrakePinSrc, uint32_t u32DebounceCnt, uint32_t u32ClkSrcSel);
Nvoid TPWM_DisableBrakePinDebounce(TIMER_T *timer);
Nvoid TPWM_EnableBrakePinInverse(TIMER_T *timer);
Nvoid TPWM_DisableBrakePinInverse(TIMER_T *timer);
Nvoid TPWM_SetBrakePinSource(TIMER_T *timer, uint32_t u32BrakePinNum);
N
N/*@}*/ /* end of group TIMER_PWM_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group TIMER_PWM_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__TIMER_PWM_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17565 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "wdt.h"
L 1 "..\lib\StdDriver\inc\wdt.h" 1
N/**************************************************************************//**
N * @file     wdt.h
N * @version  V3.00
N * $Revision: 5 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE series Watchdog Timer(WDT) driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __WDT_H__
N#define __WDT_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup WDT_Driver WDT Driver
N  @{
N*/
N
N/** @addtogroup WDT_EXPORTED_CONSTANTS WDT Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  WDT Time-out Interval Period Constant Definitions                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WDT_TIMEOUT_2POW4           (0UL << WDT_CTL_TOUTSEL_Pos) /*!< Setting WDT time-out interval to 2^4 * WDT clocks */
N#define WDT_TIMEOUT_2POW6           (1UL << WDT_CTL_TOUTSEL_Pos) /*!< Setting WDT time-out interval to 2^6 * WDT clocks */
N#define WDT_TIMEOUT_2POW8           (2UL << WDT_CTL_TOUTSEL_Pos) /*!< Setting WDT time-out interval to 2^8 * WDT clocks */
N#define WDT_TIMEOUT_2POW10          (3UL << WDT_CTL_TOUTSEL_Pos) /*!< Setting WDT time-out interval to 2^10 * WDT clocks */
N#define WDT_TIMEOUT_2POW12          (4UL << WDT_CTL_TOUTSEL_Pos) /*!< Setting WDT time-out interval to 2^12 * WDT clocks */
N#define WDT_TIMEOUT_2POW14          (5UL << WDT_CTL_TOUTSEL_Pos) /*!< Setting WDT time-out interval to 2^14 * WDT clocks */
N#define WDT_TIMEOUT_2POW16          (6UL << WDT_CTL_TOUTSEL_Pos) /*!< Setting WDT time-out interval to 2^16 * WDT clocks */
N#define WDT_TIMEOUT_2POW18          (7UL << WDT_CTL_TOUTSEL_Pos) /*!< Setting WDT time-out interval to 2^18 * WDT clocks */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  WDT  Reset Delay Period Constant Definitions                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WDT_RESET_DELAY_1026CLK     (0UL << WDT_ALTCTL_RSTDSEL_Pos) /*!< Setting WDT reset delay period to 1026 * WDT clocks */
N#define WDT_RESET_DELAY_130CLK      (1UL << WDT_ALTCTL_RSTDSEL_Pos) /*!< Setting WDT reset delay period to 130 * WDT clocks */
N#define WDT_RESET_DELAY_18CLK       (2UL << WDT_ALTCTL_RSTDSEL_Pos) /*!< Setting WDT reset delay period to 18 * WDT clocks */
N#define WDT_RESET_DELAY_3CLK        (3UL << WDT_ALTCTL_RSTDSEL_Pos) /*!< Setting WDT reset delay period to 3 * WDT clocks */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  WDT Free Reset Counter Keyword Constant Definitions                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WDT_RESET_COUNTER_KEYWORD   (0x00005AA5)    /*!< Fill this value to WDT_RSTCNT register to free reset WDT counter */
N
N/*@}*/ /* end of group WDT_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup WDT_EXPORTED_FUNCTIONS WDT Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Clear WDT Reset System Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clears WDT time-out reset system flag.
N  */
N#define WDT_CLEAR_RESET_FLAG()          (WDT->CTL = (WDT->CTL & ~(WDT_CTL_IF_Msk | WDT_CTL_WKF_Msk)) | WDT_CTL_RSTF_Msk)
N
N/**
N  * @brief      Clear WDT Time-out Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clears WDT time-out interrupt flag.
N  */
N#define WDT_CLEAR_TIMEOUT_INT_FLAG()    (WDT->CTL = (WDT->CTL & ~(WDT_CTL_RSTF_Msk | WDT_CTL_WKF_Msk)) | WDT_CTL_IF_Msk)
N
N/**
N  * @brief      Clear WDT Wake-up Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clears WDT time-out wake-up system flag.
N  */
N#define WDT_CLEAR_TIMEOUT_WAKEUP_FLAG() (WDT->CTL = (WDT->CTL & ~(WDT_CTL_RSTF_Msk | WDT_CTL_IF_Msk)) | WDT_CTL_WKF_Msk)
N
N/**
N  * @brief      Get WDT Time-out Reset Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WDT time-out reset system did not occur
N  * @retval     1   WDT time-out reset system occurred
N  *
N  * @details    This macro indicates system has been reset by WDT time-out reset or not.
N  */
N#define WDT_GET_RESET_FLAG()            ((WDT->CTL & WDT_CTL_RSTF_Msk)? 1 : 0)
N
N/**
N  * @brief      Get WDT Time-out Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WDT time-out interrupt did not occur
N  * @retval     1   WDT time-out interrupt occurred
N  *
N  * @details    This macro indicates WDT time-out interrupt occurred or not.
N  */
N#define WDT_GET_TIMEOUT_INT_FLAG()      ((WDT->CTL & WDT_CTL_IF_Msk)? 1 : 0)
N
N/**
N  * @brief      Get WDT Time-out Wake-up Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WDT time-out interrupt does not cause CPU wake-up
N  * @retval     1   WDT time-out interrupt event cause CPU wake-up
N  *
N  * @details    This macro indicates WDT time-out interrupt event has waked up system or not.
N  */
N#define WDT_GET_TIMEOUT_WAKEUP_FLAG()   ((WDT->CTL & WDT_CTL_WKF_Msk)? 1 : 0)
N
N/**
N  * @brief      Reset WDT Counter
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to reset the internal 18-bit WDT up counter value.
N  * @note       If WDT is activated and time-out reset system function is enabled also, user should \n
N  *             reset the 18-bit WDT up counter value to avoid generate WDT time-out reset signal to \n
N  *             reset system before the WDT time-out reset delay period expires.
N  */
N#define WDT_RESET_COUNTER()             (WDT->RSTCNT = WDT_RESET_COUNTER_KEYWORD)
N
N/**
N  * @brief      Stop WDT Counting
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function will stop WDT counting and disable WDT module.
N  */
Nstatic __INLINE void WDT_Close(void)
Xstatic __inline void WDT_Close(void)
N{
N    WDT->CTL = 0;
X    ((WDT_T *) ((( uint32_t)0x40000000) + 0x4000))->CTL = 0;
N    while(WDT->CTL & WDT_CTL_SYNC_Msk); // Wait disable WDTEN bit completed, it needs 2 * WDT_CLK.
X    while(((WDT_T *) ((( uint32_t)0x40000000) + 0x4000))->CTL & (0x1ul << (30))); 
N}
N
N/**
N  * @brief      Enable WDT Time-out Interrupt
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function will enable the WDT time-out interrupt function.
N  */
Nstatic __INLINE void WDT_EnableInt(void)
Xstatic __inline void WDT_EnableInt(void)
N{
N    WDT->CTL |= WDT_CTL_INTEN_Msk;
X    ((WDT_T *) ((( uint32_t)0x40000000) + 0x4000))->CTL |= (0x1ul << (6));
N    while(WDT->CTL & WDT_CTL_SYNC_Msk); // Wait enable WDTEN bit completed, it needs 2 * WDT_CLK.
X    while(((WDT_T *) ((( uint32_t)0x40000000) + 0x4000))->CTL & (0x1ul << (30))); 
N}
N
N/**
N  * @brief      Disable WDT Time-out Interrupt
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function will disable the WDT time-out interrupt function.
N  */
Nstatic __INLINE void WDT_DisableInt(void)
Xstatic __inline void WDT_DisableInt(void)
N{
N    // Do not touch another write 1 clear bits
N    WDT->CTL &= ~(WDT_CTL_INTEN_Msk | WDT_CTL_RSTF_Msk | WDT_CTL_IF_Msk | WDT_CTL_WKF_Msk);
X    ((WDT_T *) ((( uint32_t)0x40000000) + 0x4000))->CTL &= ~((0x1ul << (6)) | (0x1ul << (2)) | (0x1ul << (3)) | (0x1ul << (5)));
N}
N
Nvoid WDT_Open(uint32_t u32TimeoutInterval, uint32_t u32ResetDelay, uint32_t u32EnableReset, uint32_t u32EnableWakeup);
N
N/*@}*/ /* end of group WDT_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group WDT_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__WDT_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17566 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "wwdt.h"
L 1 "..\lib\StdDriver\inc\wwdt.h" 1
N/**************************************************************************//**
N * @file     wwdt.h
N * @version  V3.00
N * $Revision: 4 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE series Window Watchdog Timet(WWDT) driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __WWDT_H__
N#define __WWDT_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup WWDT_Driver WWDT Driver
N  @{
N*/
N
N/** @addtogroup WWDT_EXPORTED_CONSTANTS WWDT Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  WWDT Prescale Period Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WWDT_PRESCALER_1        (0 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 1 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_2        (1 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 2 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_4        (2 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 4 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_8        (3 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 8 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_16       (4 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 16 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_32       (5 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 32 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_64       (6 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 64 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_128      (7 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 128 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_192      (8 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 192 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_256      (9 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 256 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_384      (10 << WWDT_CTL_PSCSEL_Pos) /*!< Select max time-out period to 384 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_512      (11 << WWDT_CTL_PSCSEL_Pos) /*!< Select max time-out period to 512 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_768      (12 << WWDT_CTL_PSCSEL_Pos) /*!< Select max time-out period to 768 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_1024     (13 << WWDT_CTL_PSCSEL_Pos) /*!< Select max time-out period to 1024 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_1536     (14 << WWDT_CTL_PSCSEL_Pos) /*!< Select max time-out period to 1536 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_2048     (15 << WWDT_CTL_PSCSEL_Pos) /*!< Select max time-out period to 2048 * (64*WWDT_CLK) */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  WWDT Reload Counter Keyword Constant Definitions                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WWDT_RELOAD_WORD        (0x00005AA5)                /*!< Fill this value to WWDT_RLDCNT register to reload WWDT counter */
N
N/*@}*/ /* end of group WWDT_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup WWDT_EXPORTED_FUNCTIONS WWDT Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Clear WWDT Reset System Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear WWDT time-out reset system flag.
N  */
N#define WWDT_CLEAR_RESET_FLAG()     (WWDT->STATUS = WWDT_STATUS_WWDTRF_Msk)
N
N/**
N  * @brief      Clear WWDT Compared Match Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear WWDT compared match interrupt flag.
N  */
N#define WWDT_CLEAR_INT_FLAG()       (WWDT->STATUS = WWDT_STATUS_WWDTIF_Msk)
N
N/**
N  * @brief      Get WWDT Reset System Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WWDT time-out reset system did not occur
N  * @retval     1   WWDT time-out reset system occurred
N  *
N  * @details    This macro is used to indicate system has been reset by WWDT time-out reset or not.
N  */
N#define WWDT_GET_RESET_FLAG()       ((WWDT->STATUS & WWDT_STATUS_WWDTRF_Msk)? 1 : 0)
N
N/**
N  * @brief      Get WWDT Compared Match Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WWDT compare match interrupt did not occur
N  * @retval     1   WWDT compare match interrupt occurred
N  *
N  * @details    This macro is used to indicate WWDT counter value matches CMPDAT value or not.
N  */
N#define WWDT_GET_INT_FLAG()         ((WWDT->STATUS & WWDT_STATUS_WWDTIF_Msk)? 1 : 0)
N
N/**
N  * @brief      Get WWDT Counter
N  *
N  * @param      None
N  *
N  * @return     WWDT Counter Value
N  *
N  * @details    This macro reflects the current WWDT counter value.
N  */
N#define WWDT_GET_COUNTER()          (WWDT->CNT)
N
N/**
N  * @brief      Reload WWDT Counter
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to reload the WWDT counter value to 0x3F.
N  * @note       User can only write WWDT_RLDCNT register to reload WWDT counter value when current WWDT counter value \n
N  *             between 0 and CMPDAT value. If user writes WWDT_RLDCNT when current WWDT counter value is larger than CMPDAT, \n
N  *             WWDT reset signal will generate immediately to reset system.
N  */
N#define WWDT_RELOAD_COUNTER()       (WWDT->RLDCNT = WWDT_RELOAD_WORD)
N
Nvoid WWDT_Open(uint32_t u32PreScale, uint32_t u32CmpValue, uint32_t u32EnableInt);
N
N/*@}*/ /* end of group WWDT_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group WWDT_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__WWDT_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17567 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "rtc.h"
L 1 "..\lib\StdDriver\inc\rtc.h" 1
N/**************************************************************************//**
N * @file     rtc.h
N * @version  V3.00
N * $Revision: 7 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE series Real Time Clock(RTC) driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __RTC_H__
N#define __RTC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup RTC_Driver RTC Driver
N  @{
N*/
N
N/** @addtogroup RTC_EXPORTED_CONSTANTS RTC Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  RTC Initial Keyword Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_INIT_KEY            0xA5EB1357UL    /*!< RTC Initiation Key to make RTC leaving reset state */
N#define RTC_WRITE_KEY           0x0000A965UL    /*!< RTC Register Access Enable Key to enable RTC read/write accessible and kept 1024 RTC clock */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  RTC Time Attribute Constant Definitions                                                                */
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_CLOCK_12            0               /*!< RTC as 12-hour time scale with AM and PM indication */
N#define RTC_CLOCK_24            1               /*!< RTC as 24-hour time scale */
N#define RTC_AM                  1               /*!< RTC as AM indication */
N#define RTC_PM                  2               /*!< RTC as PM indication */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  RTC Tick Period Constant Definitions                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_TICK_1_SEC          0x0UL           /*!< RTC time tick period is 1 second */
N#define RTC_TICK_1_2_SEC        0x1UL           /*!< RTC time tick period is 1/2 second */
N#define RTC_TICK_1_4_SEC        0x2UL           /*!< RTC time tick period is 1/4 second */
N#define RTC_TICK_1_8_SEC        0x3UL           /*!< RTC time tick period is 1/8 second */
N#define RTC_TICK_1_16_SEC       0x4UL           /*!< RTC time tick period is 1/16 second */
N#define RTC_TICK_1_32_SEC       0x5UL           /*!< RTC time tick period is 1/32 second */
N#define RTC_TICK_1_64_SEC       0x6UL           /*!< RTC time tick period is 1/64 second */
N#define RTC_TICK_1_128_SEC      0x7UL           /*!< RTC time tick period is 1/128 second */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  RTC Day of Week Constant Definitions                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_SUNDAY              0x0UL           /*!< Day of the Week is Sunday */
N#define RTC_MONDAY              0x1UL           /*!< Day of the Week is Monday */
N#define RTC_TUESDAY             0x2UL           /*!< Day of the Week is Tuesday */
N#define RTC_WEDNESDAY           0x3UL           /*!< Day of the Week is Wednesday */
N#define RTC_THURSDAY            0x4UL           /*!< Day of the Week is Thursday */
N#define RTC_FRIDAY              0x5UL           /*!< Day of the Week is Friday */
N#define RTC_SATURDAY            0x6UL           /*!< Day of the Week is Saturday */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  RTC Miscellaneous Constant Definitions                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_YEAR2000            2000            /*!< RTC Reference for compute year data */
N
N/*@}*/ /* end of group RTC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup RTC_EXPORTED_STRUCTS RTC Exported Structs
N  @{
N*/
N/**
N  * @details    RTC define Time Data Struct
N  */
Ntypedef struct
N{
N    uint32_t u32Year;           /*!< Year value */
N    uint32_t u32Month;          /*!< Month value */
N    uint32_t u32Day;            /*!< Day value */
N    uint32_t u32DayOfWeek;      /*!< Day of week value */
N    uint32_t u32Hour;           /*!< Hour value */
N    uint32_t u32Minute;         /*!< Minute value */
N    uint32_t u32Second;         /*!< Second value */
N    uint32_t u32TimeScale;      /*!< 12-Hour, 24-Hour */
N    uint32_t u32AmPm;           /*!< Only Time Scale select 12-hr used */
N} S_RTC_TIME_DATA_T;
N
N/*@}*/ /* end of group RTC_EXPORTED_STRUCTS */
N
N
N/** @addtogroup RTC_EXPORTED_FUNCTIONS RTC Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Indicate is Leap Year or not
N  *
N  * @param      None
N  *
N  * @retval     0   This year is not a leap year
N  * @retval     1   This year is a leap year
N  *
N  * @details    According to current date, return this year is leap year or not.
N  */
N#define RTC_IS_LEAP_YEAR()              (RTC->LEAPYEAR & RTC_LEAPYEAR_LEAPYEAR_Msk ? 1:0)
N
N/**
N  * @brief      Clear RTC Alarm Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear RTC alarm interrupt flag.
N  */
N#define RTC_CLEAR_ALARM_INT_FLAG()      (RTC->INTSTS = RTC_INTSTS_ALMIF_Msk)
N
N/**
N  * @brief      Clear RTC Tick Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear RTC tick interrupt flag.
N  */
N#define RTC_CLEAR_TICK_INT_FLAG()       (RTC->INTSTS = RTC_INTSTS_TICKIF_Msk)
N
N/**
N  * @brief      Get RTC Alarm Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   RTC alarm interrupt did not occur
N  * @retval     1   RTC alarm interrupt occurred
N  *
N  * @details    This macro indicates RTC alarm interrupt occurred or not.
N  */
N#define RTC_GET_ALARM_INT_FLAG()        ((RTC->INTSTS & RTC_INTSTS_ALMIF_Msk)? 1:0)
N
N/**
N  * @brief      Get RTC Time Tick Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   RTC time tick interrupt did not occur
N  * @retval     1   RTC time tick interrupt occurred
N  *
N  * @details    This macro indicates RTC time tick interrupt occurred or not.
N  */
N#define RTC_GET_TICK_INT_FLAG()         ((RTC->INTSTS & RTC_INTSTS_TICKIF_Msk)? 1:0)
N
N/**
N  * @brief      Enable RTC Tick Wake-up Function
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to enable RTC tick interrupt wake-up function.
N  */
N#define RTC_ENABLE_TICK_WAKEUP()        (RTC->INTEN |= RTC_INTEN_TICKIEN_Msk);
N
N/**
N  * @brief      Disable RTC Tick Wake-up Function
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to disable RTC tick interrupt wake-up function.
N  */
N#define RTC_DISABLE_TICK_WAKEUP()       (RTC->INTEN &= ~RTC_INTEN_TICKIEN_Msk);
N
N/**
N  * @brief      Wait RTC Access Enable
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the maximum RTC read/write accessible time.
N  */
Nstatic __INLINE void RTC_WaitAccessEnable(void)
Xstatic __inline void RTC_WaitAccessEnable(void)
N{
N    /* To wait RWENF bit is cleared and enable RWENF bit (Access Enable bit) again */
N    RTC->RWEN = 0x0; // clear RWENF immediately
X    ((RTC_T *) ((( uint32_t)0x40000000) + 0x08000))->RWEN = 0x0; 
N    while(RTC->RWEN & RTC_RWEN_RWENF_Msk);
X    while(((RTC_T *) ((( uint32_t)0x40000000) + 0x08000))->RWEN & (0x1ul << (16)));
N
N    /* To wait RWENF bit is set and user can access the protected-register of RTC from now on */
N    RTC->RWEN = RTC_WRITE_KEY;
X    ((RTC_T *) ((( uint32_t)0x40000000) + 0x08000))->RWEN = 0x0000A965UL;
N    while((RTC->RWEN & RTC_RWEN_RWENF_Msk) == 0x0);
X    while((((RTC_T *) ((( uint32_t)0x40000000) + 0x08000))->RWEN & (0x1ul << (16))) == 0x0);
N}
N
Nvoid RTC_Open(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_Close(void);
Nvoid RTC_32KCalibration(uint32_t u32FrequencyX100);
Nvoid RTC_GetDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_GetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_SetDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_SetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_SetDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day, uint32_t u32DayOfWeek);
Nvoid RTC_SetTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm);
Nvoid RTC_SetAlarmDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day);
Nvoid RTC_SetAlarmTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm);
Nvoid RTC_SetAlarmDateMask(uint8_t u8IsTenYMsk, uint8_t u8IsYMsk, uint8_t u8IsTenMMsk, uint8_t u8IsMMsk, uint8_t u8IsTenDMsk, uint8_t u8IsDMsk);
Nvoid RTC_SetAlarmTimeMask(uint8_t u8IsTenHMsk, uint8_t u8IsHMsk, uint8_t u8IsTenMMsk, uint8_t u8IsMMsk, uint8_t u8IsTenSMsk, uint8_t u8IsSMsk);
Nuint32_t RTC_GetDayOfWeek(void);
Nvoid RTC_SetTickPeriod(uint32_t u32TickSelection);
Nvoid RTC_EnableInt(uint32_t u32IntFlagMask);
Nvoid RTC_DisableInt(uint32_t u32IntFlagMask);
N
N/*@}*/ /* end of group RTC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group RTC_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__RTC_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17568 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "uart.h"
L 1 "..\lib\StdDriver\inc\uart.h" 1
N/**************************************************************************//**
N * @file     UART.h
N * @version  V3.00
N * $Revision: 8 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE series UART Interface Controller (UART) driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __UART_H__
N#define __UART_H__
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup UART_Driver UART Driver
N  @{
N*/
N
N/** @addtogroup UART_EXPORTED_CONSTANTS UART Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART FIFO size constants definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART0_FIFO_SIZE 16 /*!< UART0 supports separated receive/transmit 16/16 bytes entry FIFO */
N#define UART1_FIFO_SIZE 16 /*!< UART1 supports separated receive/transmit 16/16 bytes entry FIFO */
N#define UART2_FIFO_SIZE 16 /*!< UART2 supports separated receive/transmit 16/16 bytes entry FIFO */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART_FIFO constants definitions                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_FIFO_RFITL_1BYTE      (0x0 << UART_FIFO_RFITL_Pos)   /*!< UART_FIFO setting to set RX FIFO Trigger Level to 1 byte */
N#define UART_FIFO_RFITL_4BYTES     (0x1 << UART_FIFO_RFITL_Pos)   /*!< UART_FIFO setting to set RX FIFO Trigger Level to 4 bytes */
N#define UART_FIFO_RFITL_8BYTES     (0x2 << UART_FIFO_RFITL_Pos)   /*!< UART_FIFO setting to set RX FIFO Trigger Level to 8 bytes */
N#define UART_FIFO_RFITL_14BYTES    (0x3 << UART_FIFO_RFITL_Pos)   /*!< UART_FIFO setting to set RX FIFO Trigger Level to 14 bytes */
N
N#define UART_FIFO_RTSTRGLV_1BYTE      (0x0 << UART_FIFO_RTSTRGLV_Pos)  /*!< UART_FIFO setting to set RTS Trigger Level to 1 byte */
N#define UART_FIFO_RTSTRGLV_4BYTES     (0x1 << UART_FIFO_RTSTRGLV_Pos)  /*!< UART_FIFO setting to set RTS Trigger Level to 4 bytes */
N#define UART_FIFO_RTSTRGLV_8BYTES     (0x2 << UART_FIFO_RTSTRGLV_Pos)  /*!< UART_FIFO setting to set RTS Trigger Level to 8 bytes */
N#define UART_FIFO_RTSTRGLV_14BYTES    (0x3 << UART_FIFO_RTSTRGLV_Pos)  /*!< UART_FIFO setting to set RTS Trigger Level to 14 bytes */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART_LINE constants definitions                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_WORD_LEN_5     (0) /*!< UART_LINE setting to set UART word length to 5 bits */
N#define UART_WORD_LEN_6     (1) /*!< UART_LINE setting to set UART word length to 6 bits */
N#define UART_WORD_LEN_7     (2) /*!< UART_LINE setting to set UART word length to 7 bits */
N#define UART_WORD_LEN_8     (3) /*!< UART_LINE setting to set UART word length to 8 bits */
N
N#define UART_PARITY_NONE    (0x0 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to set UART as no parity   */
N#define UART_PARITY_ODD     (0x1 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to set UART as odd parity  */
N#define UART_PARITY_EVEN    (0x3 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to set UART as even parity */
N#define UART_PARITY_MARK    (0x5 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to keep parity bit as '1'  */
N#define UART_PARITY_SPACE   (0x7 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to keep parity bit as '0'  */
N
N#define UART_STOP_BIT_1     (0x0 << UART_LINE_NSB_Pos) /*!< UART_LINE setting for one stop bit  */
N#define UART_STOP_BIT_1_5   (0x1 << UART_LINE_NSB_Pos) /*!< UART_LINE setting for 1.5 stop bit when 5-bit word length  */
N#define UART_STOP_BIT_2     (0x1 << UART_LINE_NSB_Pos) /*!< UART_LINE setting for two stop bit when 6, 7, 8-bit word length */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART RTS ACTIVE LEVEL constants definitions                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_RTS_IS_LOW_LEV_ACTIVE   (0x1 << UART_MODEM_RTSACTLV_Pos) /*!< Set RTS is Low Level Active */
N#define UART_RTS_IS_HIGH_LEV_ACTIVE  (0x0 << UART_MODEM_RTSACTLV_Pos) /*!< Set RTS is High Level Active */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART_IRDA constants definitions                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_IRDA_TXEN      (0x1 << UART_IRDA_TXEN_Pos) /*!< Set IrDA function Tx mode */
N#define UART_IRDA_RXEN      (0x0 << UART_IRDA_TXEN_Pos) /*!< Set IrDA function Rx mode */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART_FUNCSEL constants definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_FUNCSEL_UART  (0x0 << UART_FUNCSEL_FUNCSEL_Pos) /*!< UART_FUNCSEL setting to set UART Function  (Default) */
N#define UART_FUNCSEL_LIN   (0x1 << UART_FUNCSEL_FUNCSEL_Pos) /*!< UART_FUNCSEL setting to set LIN Function             */
N#define UART_FUNCSEL_IrDA  (0x2 << UART_FUNCSEL_FUNCSEL_Pos) /*!< UART_FUNCSEL setting to set IrDA Function            */
N#define UART_FUNCSEL_RS485 (0x3 << UART_FUNCSEL_FUNCSEL_Pos) /*!< UART_FUNCSEL setting to set RS485 Function           */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART_LINCTL constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_LINCTL_BRKFL(x)    (((x)-1) << UART_LINCTL_BRKFL_Pos)  /*!< UART_LINCTL setting to set LIN Break Field Length, x = 10 ~ 15, default value is 12 */
N#define UART_LINCTL_BSL(x)      (((x)-1) << UART_LINCTL_BSL_Pos)    /*!< UART_LINCTL setting to set LIN Break/Sync Delimiter Length, x = 1 ~ 4 */
N#define UART_LINCTL_HSEL_BREAK             (0x0UL << UART_LINCTL_HSEL_Pos)    /*!< UART_LINCTL setting to set LIN Header Select to break field */
N#define UART_LINCTL_HSEL_BREAK_SYNC        (0x1UL << UART_LINCTL_HSEL_Pos)    /*!< UART_LINCTL setting to set LIN Header Select to break field and sync field */
N#define UART_LINCTL_HSEL_BREAK_SYNC_ID     (0x2UL << UART_LINCTL_HSEL_Pos)    /*!< UART_LINCTL setting to set LIN Header Select to break field, sync field and ID field*/
N#define UART_LINCTL_PID(x)      ((x) << UART_LINCTL_PID_Pos)       /*!< UART_LINCTL setting to set LIN PID value */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART BAUDRATE MODE constants definitions                                                                */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_BAUD_MODE0     (0) /*!< Set UART Baudrate Mode is Mode0 */
N#define UART_BAUD_MODE2     (UART_BAUD_BAUDM1_Msk | UART_BAUD_BAUDM0_Msk) /*!< Set UART Baudrate Mode is Mode2 */
N
N
N
N/*@}*/ /* end of group UART_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup UART_EXPORTED_FUNCTIONS UART Exported Functions
N  @{
N*/
N
N
N/**
N *    @brief        Calculate UART baudrate mode0 divider
N *
N *    @param[in]    u32SrcFreq      UART clock frequency
N *    @param[in]    u32BaudRate     Baudrate of UART module
N *
N *    @return       UART baudrate mode0 divider
N *
N *    @details      This macro calculate UART baudrate mode0 divider.
N */
N#define UART_BAUD_MODE0_DIVIDER(u32SrcFreq, u32BaudRate)    ((((u32SrcFreq) + ((u32BaudRate)*8)) / (u32BaudRate) >> 4)-2)
N
N
N/**
N *    @brief        Calculate UART baudrate mode2 divider
N *
N *    @param[in]    u32SrcFreq      UART clock frequency
N *    @param[in]    u32BaudRate     Baudrate of UART module
N *
N *    @return       UART baudrate mode2 divider
N *
N *    @details      This macro calculate UART baudrate mode2 divider.
N */
N#define UART_BAUD_MODE2_DIVIDER(u32SrcFreq, u32BaudRate)    ((((u32SrcFreq) + ((u32BaudRate)/2)) / (u32BaudRate))-2)
N
N
N/**
N *    @brief        Write UART data
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *    @param[in]    u8Data  Data byte to transmit.
N *
N *    @return       None
N *
N *    @details      This macro write Data to Tx data register.
N */
N#define UART_WRITE(uart, u8Data)    ((uart)->DAT = (u8Data))
N
N
N/**
N *    @brief        Read UART data
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @return       The oldest data byte in RX FIFO.
N *
N *    @details      This macro read Rx data register.
N */
N#define UART_READ(uart)    ((uart)->DAT)
N
N
N/**
N *    @brief        Get Tx empty
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0   Tx FIFO is not empty
N *    @retval       >=1 Tx FIFO is empty
N *
N *    @details      This macro get Transmitter FIFO empty register value.
N */
N#define UART_GET_TX_EMPTY(uart)    ((uart)->FIFOSTS & UART_FIFOSTS_TXEMPTY_Msk)
N
N
N/**
N *    @brief        Get Rx empty
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0   Rx FIFO is not empty
N *    @retval       >=1 Rx FIFO is empty
N *
N *    @details      This macro get Receiver FIFO empty register value.
N */
N#define UART_GET_RX_EMPTY(uart)    ((uart)->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk)
N
N
N/**
N *    @brief        Check specified uart port transmission is over.
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0 Tx transmission is not over
N *    @retval       1 Tx transmission is over
N *
N *    @details      This macro return Transmitter Empty Flag register bit value.
N *                  It indicates if specified uart port transmission is over nor not.
N */
N#define UART_IS_TX_EMPTY(uart)    (((uart)->FIFOSTS & UART_FIFOSTS_TXEMPTYF_Msk) >> UART_FIFOSTS_TXEMPTYF_Pos)
N
N
N/**
N *    @brief        Wait specified uart port transmission is over
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @return       None
N *
N *    @details      This macro wait specified uart port transmission is over.
N */
N#define UART_WAIT_TX_EMPTY(uart)    while(!((((uart)->FIFOSTS) & UART_FIFOSTS_TXEMPTYF_Msk) >> UART_FIFOSTS_TXEMPTYF_Pos))
N
N
N/**
N *    @brief        Check RX is ready or not
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0 The number of bytes in the RX FIFO is less than the RFITL
N *    @retval       1 The number of bytes in the RX FIFO equals or larger than RFITL
N *
N *    @details      This macro check receive data available interrupt flag is set or not.
N */
N#define UART_IS_RX_READY(uart)    (((uart)->INTSTS & UART_INTSTS_RDAIF_Msk)>>UART_INTSTS_RDAIF_Pos)
N
N
N/**
N *    @brief        Check TX FIFO is full or not
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       1 TX FIFO is full
N *    @retval       0 TX FIFO is not full
N *
N *    @details      This macro check TX FIFO is full or not.
N */
N#define UART_IS_TX_FULL(uart)    (((uart)->FIFOSTS & UART_FIFOSTS_TXFULL_Msk)>>UART_FIFOSTS_TXFULL_Pos)
N
N
N/**
N *    @brief        Check RX FIFO is full or not
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       1 RX FIFO is full
N *    @retval       0 RX FIFO is not full
N *
N *    @details      This macro check RX FIFO is full or not.
N */
N#define UART_IS_RX_FULL(uart)    (((uart)->FIFOSTS & UART_FIFOSTS_RXFULL_Msk)>>UART_FIFOSTS_RXFULL_Pos)
N
N
N/**
N *    @brief        Get Tx full register value
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0   Tx FIFO is not full.
N *    @retval       >=1 Tx FIFO is full.
N *
N *    @details      This macro get Tx full register value.
N */
N#define UART_GET_TX_FULL(uart)    ((uart)->FIFOSTS & UART_FIFOSTS_TXFULL_Msk)
N
N
N/**
N *    @brief        Get Rx full register value
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0   Rx FIFO is not full.
N *    @retval       >=1 Rx FIFO is full.
N *
N *    @details      This macro get Rx full register value.
N */
N#define UART_GET_RX_FULL(uart)    ((uart)->FIFOSTS & UART_FIFOSTS_RXFULL_Msk)
N
N
N/**
N *    @brief        Enable specified UART interrupt
N *
N *    @param[in]    uart        The pointer of the specified UART module
N *    @param[in]    u32eIntSel  Interrupt type select
N *                              - \ref UART_INTEN_TXENDIEN_Msk   : Transmitter empty interrupt
N *                              - \ref UART_INTEN_ABRIEN_Msk     : Auto baud rate interrupt
N *                              - \ref UART_INTEN_LINIEN_Msk     : Lin bus interrupt
N *                              - \ref UART_INTEN_WKIEN_Msk      : Wake-up interrupt
N *                              - \ref UART_INTEN_BUFERRIEN_Msk  : Buffer Error interrupt
N *                              - \ref UART_INTEN_RXTOIEN_Msk    : Rx time-out interrupt
N *                              - \ref UART_INTEN_MODEMIEN_Msk   : Modem interrupt
N *                              - \ref UART_INTEN_RLSIEN_Msk     : Rx Line status interrupt
N *                              - \ref UART_INTEN_THREIEN_Msk    : Tx empty interrupt
N *                              - \ref UART_INTEN_RDAIEN_Msk     : Rx ready interrupt
N *
N *    @return       None
N *
N *    @details      This macro enable specified UART interrupt.
N */
N#define UART_ENABLE_INT(uart, u32eIntSel)    ((uart)->INTEN |= (u32eIntSel))
N
N
N/**
N *    @brief        Disable specified UART interrupt
N *
N *    @param[in]    uart        The pointer of the specified UART module
N *    @param[in]    u32eIntSel  Interrupt type select
N *                              - \ref UART_INTEN_TXENDIEN_Msk   : Transmitter Empty Interrupt
N *                              - \ref UART_INTEN_ABRIEN_Msk     : Auto-baud Rate Interrupt
N *                              - \ref UART_INTEN_LINIEN_Msk     : Lin Bus interrupt
N *                              - \ref UART_INTEN_WKIEN_Msk      : Wake-up interrupt
N *                              - \ref UART_INTEN_BUFERRIEN_Msk  : Buffer Error interrupt
N *                              - \ref UART_INTEN_RXTOIEN_Msk    : Rx Time-out Interrupt
N *                              - \ref UART_INTEN_MODEMIEN_Msk   : MODEM Status Interrupt
N *                              - \ref UART_INTEN_RLSIEN_Msk     : Receive Line Status Interrupt
N *                              - \ref UART_INTEN_THREIEN_Msk    : Transmit Holding Register Empty Interrupt
N *                              - \ref UART_INTEN_RDAIEN_Msk     : Receive Data Available Interrupt
N *
N *    @return       None
N *
N *    @details      This macro enable specified UART interrupt.
N */
N#define UART_DISABLE_INT(uart, u32eIntSel)    ((uart)->INTEN &= ~ (u32eIntSel))
N
N
N/**
N *    @brief        Get specified interrupt flag/status
N *
N *    @param[in]    uart            The pointer of the specified UART module
N *    @param[in]    u32eIntTypeFlag Interrupt Type Flag, should be
N *                                  - \ref UART_INTSTS_HWBUFEINT_Msk : PDMA Mode Buffer Error Interrupt Indicator
N *                                  - \ref UART_INTSTS_HWTOINT_Msk   : PDMA Mode Rx Time-out Interrupt Indicator
N *                                  - \ref UART_INTSTS_HWMODINT_Msk  : PDMA Mode MODEM Status Interrupt Indicator
N *                                  - \ref UART_INTSTS_HWRLSINT_Msk  : PDMA Mode Receive Line Status Interrupt Indicator
N *                                  - \ref UART_INTSTS_HWBUFEIF_Msk  : PDMA Mode Buffer Error Interrupt Flag
N *                                  - \ref UART_INTSTS_HWTOIF_Msk    : PDMA Mode Time-out Interrupt Flag
N *                                  - \ref UART_INTSTS_HWMODIF_Msk   : PDMA Mode MODEM Status Interrupt Flag
N *                                  - \ref UART_INTSTS_HWRLSIF_Msk   : PDMA Mode Receive Line Status Flag
N *                                  - \ref UART_INTSTS_ABRINT_Msk    : Auto-baud Rate Interrupt Indicator
N *                                  - \ref UART_INTSTS_TXENDINT_Msk  : Transmitter Empty Interrupt Indicator
N *                                  - \ref UART_INTSTS_LININT_Msk    : LIN Bus Interrupt Indicator
N *                                  - \ref UART_INTSTS_WKINT_Msk     : Wake-up Interrupt Indicator
N *                                  - \ref UART_INTSTS_BUFERRINT_Msk : Buffer Error Interrupt Indicator
N *                                  - \ref UART_INTSTS_RXTOINT_Msk   : Rx Time-out Interrupt Indicator
N *                                  - \ref UART_INTSTS_MODEMINT_Msk  : Modem Status Interrupt Indicator
N *                                  - \ref UART_INTSTS_RLSINT_Msk    : Receive Line Status Interrupt Indicator
N *                                  - \ref UART_INTSTS_THREINT_Msk   : Transmit Holding Register Empty Interrupt Indicator
N *                                  - \ref UART_INTSTS_RDAINT_Msk    : Receive Data Available Interrupt Indicator
N *                                  - \ref UART_INTSTS_TXENDIF_Msk   : Transmitter Empty Interrupt Flag
N *                                  - \ref UART_INTSTS_LINIF_Msk     : LIN Bus Interrupt Flag
N *                                  - \ref UART_INTSTS_WKIF_Msk      : Wake-up Interrupt Flag
N *                                  - \ref UART_INTSTS_BUFERRIF_Msk  : Buffer Error Interrupt Flag
N *                                  - \ref UART_INTSTS_RXTOIF_Msk    : Rx Time-out Interrupt Flag
N *                                  - \ref UART_INTSTS_MODEMIF_Msk   : MODEM Status Interrupt Flag
N *                                  - \ref UART_INTSTS_RLSIF_Msk     : Receive Line Status Interrupt Flag
N *                                  - \ref UART_INTSTS_THREIF_Msk    : Transmit Holding Register Empty Interrupt Flag
N *                                  - \ref UART_INTSTS_RDAIF_Msk     : Receive Data Available Interrupt Flag
N *
N *    @retval       0 The specified interrupt is not happened.
N *                  1 The specified interrupt is happened.
N *
N *    @details      This macro get specified interrupt flag or interrupt indicator status.
N */
N#define UART_GET_INT_FLAG(uart,u32eIntTypeFlag)    (((uart)->INTSTS & (u32eIntTypeFlag))?1:0)
N
N
N/**
N *    @brief        Set RTS pin to low
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @return       None
N *
N *    @details      This macro set RTS pin to low.
N */
N__STATIC_INLINE void UART_CLEAR_RTS(UART_T* uart)
Xstatic __inline void UART_CLEAR_RTS(UART_T* uart)
N{
N    uart->MODEM |= UART_MODEM_RTSACTLV_Msk;
X    uart->MODEM |= (0x1ul << (9));
N    uart->MODEM &= ~UART_MODEM_RTS_Msk;
X    uart->MODEM &= ~(0x1ul << (1));
N}
N
N
N/**
N *    @brief        Set RTS pin to high
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @return       None
N *
N *    @details      This macro set RTS pin to high.
N */
N__STATIC_INLINE void UART_SET_RTS(UART_T* uart)
Xstatic __inline void UART_SET_RTS(UART_T* uart)
N{
N    uart->MODEM |= UART_MODEM_RTSACTLV_Msk | UART_MODEM_RTS_Msk;
X    uart->MODEM |= (0x1ul << (9)) | (0x1ul << (1));
N}
N
N
N/**
N *    @brief        Clear RS-485 Address Byte Detection Flag
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @return       None
N *
N *    @details      This macro clear RS-485 address byte detection flag.
N */
N#define UART_RS485_CLEAR_ADDR_FLAG(uart)    ((uart)->FIFOSTS = UART_FIFOSTS_ADDRDETF_Msk)
N
N
N/**
N *    @brief        Get RS-485 Address Byte Detection Flag
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0 Receiver detects a data that is not an address bit.
N *    @retval       1 Receiver detects a data that is an address bit.
N *
N *    @details      This macro get RS-485 address byte detection flag.
N */
N#define UART_RS485_GET_ADDR_FLAG(uart)    (((uart)->FIFOSTS  & UART_FIFOSTS_ADDRDETF_Msk) >> UART_FIFOSTS_ADDRDETF_Pos)
N
N
N
Nvoid UART_ClearIntFlag(UART_T* uart, uint32_t u32InterruptFlag);
Nvoid UART_Close(UART_T* uart);
Nvoid UART_DisableFlowCtrl(UART_T* uart);
Nvoid UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag);
Nvoid UART_EnableFlowCtrl(UART_T* uart);
Nvoid UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag);
Nvoid UART_Open(UART_T* uart, uint32_t u32baudrate);
Nuint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
Nvoid UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits);
Nvoid UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC);
Nvoid UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction);
Nvoid UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr);
Nvoid UART_SelectLINMode(UART_T* uart, uint32_t u32Mode, uint32_t u32BreakLength);
Nuint32_t UART_Write(UART_T* uart, uint8_t *pu8TxBuf, uint32_t u32WriteBytes);
N
N
N/*@}*/ /* end of group UART_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group UART_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__UART_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
N
L 17569 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "hdiv.h"
L 1 "..\lib\StdDriver\inc\hdiv.h" 1
N/**************************************************************************//**
N * @file     hdiv.h
N * @version  V3.0
N * $Revision: 4 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE series Hardware Divider(HDIV) driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __HDIV_H__
N#define __HDIV_H__
N
N#include "NUC029xGE.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup HDIV_Driver HDIV Driver
N  @{
N*/
N
N/** @addtogroup HDIV_EXPORTED_FUNCTIONS HDIV Exported Functions
N  @{
N*/
N
N/**
N * @brief      Division function to calculate (x/y)
N *
N * @param[in]  x the dividend of the division
N * @param[in]  y the divisor of the division
N *
N * @return     The result of (x/y)
N *
N * @details    This is a division function to calculate x/y
N *
N */
Nstatic __INLINE int32_t HDIV_Div(int32_t x, int16_t y)
Xstatic __inline int32_t HDIV_Div(int32_t x, int16_t y)
N{
N    uint32_t *p32;
N
N    p32 = (uint32_t *)HDIV_BASE;
X    p32 = (uint32_t *)((( uint32_t)0x50000000) + 0x14000);
N    *p32++ = x;
N    *p32++ = y;
N    return *p32;
N}
N
N
N/**
N * @brief      To calculate the remainder of x/y, i.e., the result of x mod y.
N *
N * @param[in]  x the dividend of the division
N * @param[in]  y the divisor of the division
N *
N * @return     The remainder of (x/y)
N *
N * @details    This function is used to calculate the remainder of x/y.
N */
Nstatic __INLINE int16_t HDIV_Mod(int32_t x, int16_t y)
Xstatic __inline int16_t HDIV_Mod(int32_t x, int16_t y)
N{
N    uint32_t *p32;
N
N    p32 = (uint32_t *)HDIV_BASE;
X    p32 = (uint32_t *)((( uint32_t)0x50000000) + 0x14000);
N    *p32++ = x;
N    *p32++ = y;
N    return p32[1];
N}
N
N/*@}*/ /* end of group HDIV_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group HDIV_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__HDIV_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
N
N
L 17570 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "acmp.h"
L 1 "..\lib\StdDriver\inc\acmp.h" 1
N/**************************************************************************//**
N * @file     ACMP.h
N * @version  V0.10
N * $Revision: 5 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE Series ACMP Driver Header File
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __ACMP_H__
N#define __ACMP_H__
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Include related headers                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#include "NUC029xGE.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup ACMP_Driver ACMP Driver
N  @{
N*/
N
N
N/** @addtogroup ACMP_EXPORTED_CONSTANTS ACMP Exported Constants
N  @{
N*/
N
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ACMP_CTL constant definitions                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ACMP_CTL_FILTSEL_OFF         (0UL << 13) /*!< ACMP_CTL setting for filter function disabled. */
N#define ACMP_CTL_FILTSEL_1PCLK       (1UL << 13) /*!< ACMP_CTL setting for 1 PCLK filter count. */
N#define ACMP_CTL_FILTSEL_2PCLK       (2UL << 13) /*!< ACMP_CTL setting for 2 PCLK filter count. */
N#define ACMP_CTL_FILTSEL_4PCLK       (3UL << 13) /*!< ACMP_CTL setting for 4 PCLK filter count. */
N#define ACMP_CTL_FILTSEL_8PCLK       (4UL << 13) /*!< ACMP_CTL setting for 8 PCLK filter count. */
N#define ACMP_CTL_FILTSEL_16PCLK      (5UL << 13) /*!< ACMP_CTL setting for 16 PCLK filter count. */
N#define ACMP_CTL_FILTSEL_32PCLK      (6UL << 13) /*!< ACMP_CTL setting for 32 PCLK filter count. */
N#define ACMP_CTL_FILTSEL_64PCLK      (7UL << 13) /*!< ACMP_CTL setting for 64 PCLK filter count. */
N#define ACMP_CTL_INTPOL_RF           (0UL << 8)  /*!< ACMP_CTL setting for selecting rising edge and falling edge as interrupt condition. */
N#define ACMP_CTL_INTPOL_R            (1UL << 8)  /*!< ACMP_CTL setting for selecting rising edge as interrupt condition. */
N#define ACMP_CTL_INTPOL_F            (2UL << 8)  /*!< ACMP_CTL setting for selecting falling edge as interrupt condition. */
N#define ACMP_CTL_POSSEL_P0           (0UL << 6)  /*!< ACMP_CTL setting for selecting ACMPx_P0 pin as the source of ACMP V+. */
N#define ACMP_CTL_POSSEL_P1           (1UL << 6)  /*!< ACMP_CTL setting for selecting ACMPx_P1 pin as the source of ACMP V+. */
N#define ACMP_CTL_POSSEL_P2           (2UL << 6)  /*!< ACMP_CTL setting for selecting ACMPx_P2 pin as the source of ACMP V+. */
N#define ACMP_CTL_POSSEL_P3           (3UL << 6)  /*!< ACMP_CTL setting for selecting ACMPx_P3 pin as the source of ACMP V+. */
N#define ACMP_CTL_NEGSEL_PIN          (0UL << 4)  /*!< ACMP_CTL setting for selecting the voltage of ACMP negative input pin as the source of ACMP V-. */
N#define ACMP_CTL_NEGSEL_CRV          (1UL << 4)  /*!< ACMP_CTL setting for selecting internal comparator reference voltage as the source of ACMP V-. */
N#define ACMP_CTL_NEGSEL_VBG          (2UL << 4)  /*!< ACMP_CTL setting for selecting internal Band-gap voltage as the source of ACMP V-. */
N#define ACMP_CTL_NEGSEL_DAC          (3UL << 4)  /*!< ACMP_CTL setting for selecting DAC output voltage as the source of ACMP V-. */
N#define ACMP_CTL_HYSTERESIS_ENABLE   (1UL << 2)  /*!< ACMP_CTL setting for enabling the hysteresis function. */
N#define ACMP_CTL_HYSTERESIS_DISABLE  (0UL << 2)  /*!< ACMP_CTL setting for disabling the hysteresis function. */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ACMP_VREF constant definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ACMP_VREF_CRVSSEL_VDDA       (0UL << 6)  /*!< ACMP_VREF setting for selecting analog supply voltage VDDA as the CRV source voltage */
N#define ACMP_VREF_CRVSSEL_INTVREF    (1UL << 6)  /*!< ACMP_VREF setting for selecting internal reference voltage as the CRV source voltage */
N
N
N/*@}*/ /* end of group ACMP_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup ACMP_EXPORTED_FUNCTIONS ACMP Exported Functions
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Macros and functions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N
N/**
N  * @brief This macro is used to enable output inverse function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set ACMPOINV bit of ACMP_CTL register to enable output inverse function.
N  */
N#define ACMP_ENABLE_OUTPUT_INVERSE(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)] |= ACMP_CTL_ACMPOINV_Msk)
N
N/**
N  * @brief This macro is used to disable output inverse function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear ACMPOINV bit of ACMP_CTL register to disable output inverse function.
N  */
N#define ACMP_DISABLE_OUTPUT_INVERSE(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)] &= ~ACMP_CTL_ACMPOINV_Msk)
N
N/**
N  * @brief This macro is used to select ACMP negative input source
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @param[in] u32Src is comparator negative input selection. Including:
N  *                  - \ref ACMP_CTL_NEGSEL_PIN
N  *                  - \ref ACMP_CTL_NEGSEL_CRV
N  *                  - \ref ACMP_CTL_NEGSEL_VBG
N  *                  - \ref ACMP_CTL_NEGSEL_DAC
N  * @return None
N  * @details This macro will set NEGSEL (ACMP_CTL[5:4]) to determine the source of negative input.
N  */
N#define ACMP_SET_NEG_SRC(acmp, u32ChNum, u32Src) ((acmp)->CTL[(u32ChNum)] = ((acmp)->CTL[(u32ChNum)] & ~ACMP_CTL_NEGSEL_Msk) | (u32Src))
N
N/**
N  * @brief This macro is used to enable hysteresis function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set HYSEN bit of ACMP_CTL register to enable hysteresis function.
N  */
N#define ACMP_ENABLE_HYSTERESIS(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)] |= ACMP_CTL_HYSEN_Msk)
N
N/**
N  * @brief This macro is used to disable hysteresis function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear HYSEN bit of ACMP_CTL register to disable hysteresis function.
N  */
N#define ACMP_DISABLE_HYSTERESIS(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)] &= ~ACMP_CTL_HYSEN_Msk)
N
N/**
N  * @brief This macro is used to enable interrupt
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set ACMPIE bit of ACMP_CTL register to enable interrupt function.
N  *          If wake-up function is enabled, the wake-up interrupt will be enabled as well.
N  */
N#define ACMP_ENABLE_INT(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)] |= ACMP_CTL_ACMPIE_Msk)
N
N/**
N  * @brief This macro is used to disable interrupt
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear ACMPIE bit of ACMP_CTL register to disable interrupt function.
N  */
N#define ACMP_DISABLE_INT(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)] &= ~ACMP_CTL_ACMPIE_Msk)
N
N/**
N  * @brief This macro is used to enable ACMP
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set ACMPEN bit of ACMP_CTL register to enable analog comparator.
N  */
N#define ACMP_ENABLE(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)] |= ACMP_CTL_ACMPEN_Msk)
N
N/**
N  * @brief This macro is used to disable ACMP
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear ACMPEN bit of ACMP_CTL register to disable analog comparator.
N  */
N#define ACMP_DISABLE(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)] &= ~ACMP_CTL_ACMPEN_Msk)
N
N/**
N  * @brief This macro is used to get ACMP output value
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return  ACMP output value
N  * @details This macro will return the ACMP output value.
N  */
N#define ACMP_GET_OUTPUT(acmp, u32ChNum) (((acmp)->STATUS & (ACMP_STATUS_ACMPO0_Msk<<((u32ChNum))))?1:0)
N
N/**
N  * @brief This macro is used to get ACMP interrupt flag
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return   ACMP interrupt occurred (1) or not (0)
N  * @details This macro will return the ACMP interrupt flag.
N  */
N#define ACMP_GET_INT_FLAG(acmp, u32ChNum) (((acmp)->STATUS & (ACMP_STATUS_ACMPIF0_Msk<<((u32ChNum))))?1:0)
N
N/**
N  * @brief This macro is used to clear ACMP interrupt flag
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return   None
N  * @details This macro will write 1 to ACMPIFn bit of ACMP_STATUS register to clear interrupt flag.
N  */
N#define ACMP_CLR_INT_FLAG(acmp, u32ChNum) ((acmp)->STATUS = (ACMP_STATUS_ACMPIF0_Msk<<((u32ChNum))))
N
N/**
N  * @brief This macro is used to clear ACMP wake-up interrupt flag
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return   None
N  * @details This macro will write 1 to WKIFn bit of ACMP_STATUS register to clear interrupt flag.
N  */
N#define ACMP_CLR_WAKEUP_INT_FLAG(acmp, u32ChNum) ((acmp)->STATUS = (ACMP_STATUS_WKIF0_Msk<<((u32ChNum))))
N
N/**
N  * @brief This macro is used to enable ACMP wake-up function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set WKEN (ACMP_CTL[16]) to enable ACMP wake-up function.
N  */
N#define ACMP_ENABLE_WAKEUP(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)] |= ACMP_CTL_WKEN_Msk)
N
N/**
N  * @brief This macro is used to disable ACMP wake-up function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear WKEN (ACMP_CTL[16]) to disable ACMP wake-up function.
N  */
N#define ACMP_DISABLE_WAKEUP(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)] &= ~ACMP_CTL_WKEN_Msk)
N
N/**
N  * @brief This macro is used to select ACMP positive input pin
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @param[in] u32Pin Comparator positive pin selection. Including:
N  *                  - \ref ACMP_CTL_POSSEL_P0
N  *                  - \ref ACMP_CTL_POSSEL_P1
N  *                  - \ref ACMP_CTL_POSSEL_P2
N  *                  - \ref ACMP_CTL_POSSEL_P3
N  * @return None
N  * @details This macro will set POSSEL (ACMP_CTL[7:6]) to determine the comparator positive input pin.
N  */
N#define ACMP_SELECT_P(acmp, u32ChNum, u32Pin) ((acmp)->CTL[(u32ChNum)] = ((acmp)->CTL[(u32ChNum)] & ~ACMP_CTL_POSSEL_Msk) | (u32Pin))
N
N/**
N  * @brief This macro is used to enable ACMP filter function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set OUTSEL (ACMP_CTL[12]) to enable output filter function.
N  */
N#define ACMP_ENABLE_FILTER(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)] |= ACMP_CTL_OUTSEL_Msk)
N
N/**
N  * @brief This macro is used to disable ACMP filter function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear OUTSEL (ACMP_CTL[12]) to disable output filter function.
N  */
N#define ACMP_DISABLE_FILTER(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)] &= ~ACMP_CTL_OUTSEL_Msk)
N
N/**
N  * @brief This macro is used to set ACMP filter function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @param[in] u32Cnt is comparator filter count setting.
N  *                  - \ref ACMP_CTL_FILTSEL_OFF
N  *                  - \ref ACMP_CTL_FILTSEL_1PCLK
N  *                  - \ref ACMP_CTL_FILTSEL_2PCLK
N  *                  - \ref ACMP_CTL_FILTSEL_4PCLK
N  *                  - \ref ACMP_CTL_FILTSEL_8PCLK
N  *                  - \ref ACMP_CTL_FILTSEL_16PCLK
N  *                  - \ref ACMP_CTL_FILTSEL_32PCLK
N  *                  - \ref ACMP_CTL_FILTSEL_64PCLK
N  * @return None
N  * @details When ACMP output filter function is enabled, the output sampling count is determined by FILTSEL (ACMP_CTL[15:13]).
N  */
N#define ACMP_SET_FILTER(acmp, u32ChNum, u32Cnt) ((acmp)->CTL[(u32ChNum)] = ((acmp)->CTL[(u32ChNum)] & ~ACMP_CTL_FILTSEL_Msk) | (u32Cnt))
N
N/**
N  * @brief This macro is used to select comparator reference voltage
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32Level  The comparator reference voltage setting.
N  *             The formula is:
N  *                       comparator reference voltage = CRV source voltage x (1/6 + u32Level/24)
N  *             The range of u32Level is 0 ~ 15.
N  * @return   None
N  * @details  When CRV is selected as ACMP negative input source, the CRV level is determined by CRVCTL (ACMP_VREF[3:0]).
N  */
N#define ACMP_CRV_SEL(acmp, u32Level) ((acmp)->VREF = ((acmp)->VREF & ~ACMP_VREF_CRVCTL_Msk) | ((u32Level)<<ACMP_VREF_CRVCTL_Pos))
N
N/**
N  * @brief This macro is used to select the source of CRV
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32Src is the source of CRV. Including:
N  *                  - \ref ACMP_VREF_CRVSSEL_VDDA
N  *                  - \ref ACMP_VREF_CRVSSEL_INTVREF
N  * @return None
N  * @details The source of CRV can be VDDA or internal reference voltage. The internal reference voltage level is determined by SYS_VREFCTL register.
N  */
N#define ACMP_SELECT_CRV_SRC(acmp, u32Src) ((acmp)->VREF = ((acmp)->VREF & ~ACMP_VREF_CRVSSEL_Msk) | (u32Src))
N
N/**
N  * @brief This macro is used to select ACMP interrupt condition
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @param[in] u32Cond Comparator interrupt condition selection. Including:
N  *                  - \ref ACMP_CTL_INTPOL_RF
N  *                  - \ref ACMP_CTL_INTPOL_R
N  *                  - \ref ACMP_CTL_INTPOL_F
N  * @return None
N  * @details The ACMP output interrupt condition can be rising edge, falling edge or any edge.
N  */
N#define ACMP_SELECT_INT_COND(acmp, u32ChNum, u32Cond) ((acmp)->CTL[(u32ChNum)] = ((acmp)->CTL[(u32ChNum)] & ~ACMP_CTL_INTPOL_Msk) | (u32Cond))
N
N
N
N/* Function prototype declaration */
Nvoid ACMP_Open(ACMP_T *, uint32_t u32ChNum, uint32_t u32NegSrc, uint32_t u32HysteresisEn);
Nvoid ACMP_Close(ACMP_T *, uint32_t u32ChNum);
N
N
N
N/*@}*/ /* end of group ACMP_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ACMP_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif //__ACMP_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17571 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "crc.h"
L 1 "..\lib\StdDriver\inc\crc.h" 1
N/**************************************************************************//**
N * @file     crc.h
N * @version  V3.00
N * $Revision: 4 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE series Cyclic Redundancy Check(CRC) driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __CRC_H__
N#define __CRC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup CRC_Driver CRC Driver
N  @{
N*/
N
N/** @addtogroup CRC_EXPORTED_CONSTANTS CRC Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CRC Polynomial Mode Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CRC_CCITT           0x00000000UL            /*!<CRC Polynomial Mode - CCITT */
N#define CRC_8               0x40000000UL            /*!<CRC Polynomial Mode - CRC8 */
N#define CRC_16              0x80000000UL            /*!<CRC Polynomial Mode - CRC16 */
N#define CRC_32              0xC0000000UL            /*!<CRC Polynomial Mode - CRC32 */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Checksum, Write data Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CRC_CHECKSUM_COM    0x08000000UL            /*!<CRC Checksum Complement */
N#define CRC_CHECKSUM_RVS    0x02000000UL            /*!<CRC Checksum Reverse */
N#define CRC_WDATA_COM       0x04000000UL            /*!<CRC Write Data Complement */
N#define CRC_WDATA_RVS       0x01000000UL            /*!<CRC Write Data Reverse */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CPU Write Data Length Constant Definitions                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CRC_CPU_WDATA_8     0x00000000UL            /*!<CRC CPU Write Data length is 8-bit */
N#define CRC_CPU_WDATA_16    0x10000000UL            /*!<CRC CPU Write Data length is 16-bit */
N#define CRC_CPU_WDATA_32    0x20000000UL            /*!<CRC CPU Write Data length is 32-bit */
N
N/*@}*/ /* end of group CRC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup CRC_EXPORTED_FUNCTIONS CRC Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Set CRC Seed Value
N  *
N  * @param[in]  u32Seed     Seed value
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set CRC seed value.
N  *
N  * @note       User must to perform CRC_RST(CRC_CTL[1] CRC Engine Reset) to reload the new seed value
N  *             to CRC controller.
N  */
N#define CRC_SET_SEED(u32Seed)   { CRC->SEED = (u32Seed); CRC->CTL |= CRC_CTL_CHKSINIT_Msk; }
N
N/**
N * @brief       Get CRC Seed Value
N *
N  * @param      None
N *
N * @return      CRC seed value
N *
N * @details     This macro gets the current CRC seed value.
N */
N#define CRC_GET_SEED()          (CRC->SEED)
N
N/**
N * @brief       CRC Write Data
N *
N * @param[in]   u32Data     Write data
N *
N * @return      None
N *
N  * @details    User can write data directly to CRC Write Data Register(CRC_DAT) by this macro to perform CRC operation.
N */
N#define CRC_WRITE_DATA(u32Data)   (CRC->DAT = (u32Data))
N
Nvoid CRC_Open(uint32_t u32Mode, uint32_t u32Attribute, uint32_t u32Seed, uint32_t u32DataLen);
Nuint32_t CRC_GetChecksum(void);
N
N/*@}*/ /* end of group CRC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group CRC_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__CRC_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17572 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "usbd.h"
L 1 "..\lib\StdDriver\inc\usbd.h" 1
N/******************************************************************************
N * @file     usbd.h
N * @brief    M451 series USB driver header file
N * @version  2.0.0
N * @date     10, January, 2014
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N#ifndef __USBD_H__
N#define __USBD_H__
N
N#define SUPPORT_LPM     // define to support LPM
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup USBD_Driver USBD Driver
N  @{
N*/
N
N/** @addtogroup USBD_EXPORTED_STRUCTS USBD Exported Structs
N  @{
N*/
Ntypedef struct s_usbd_info
N{
N    const uint8_t *gu8DevDesc;            /*!< Pointer for USB Device Descriptor          */
N    const uint8_t *gu8ConfigDesc;         /*!< Pointer for USB Configuration Descriptor   */
N    const uint8_t **gu8StringDesc;        /*!< Pointer for USB String Descriptor pointers */
N    const uint8_t **gu8HidReportDesc;     /*!< Pointer for USB HID Report Descriptor      */
N    const uint32_t *gu32HidReportSize;    /*!< Pointer for HID Report descriptor Size */
N    const uint32_t *gu32ConfigHidDescIdx; /*!< Pointer for HID Descriptor start index */
N    const uint8_t *gu8BosDesc;
N} S_USBD_INFO_T;
N
Nextern const S_USBD_INFO_T gsInfo;
N
N/*@}*/ /* end of group USBD_EXPORTED_STRUCTS */
N
N
N
N
N/** @addtogroup USBD_EXPORTED_CONSTANTS USBD Exported Constants
N  @{
N*/
N#define USBD_BUF_BASE   (USBD_BASE+0x100)
N#define USBD_MAX_EP     8
N
N#define EP0     0       /*!< Endpoint 0 */
N#define EP1     1       /*!< Endpoint 1 */
N#define EP2     2       /*!< Endpoint 2 */
N#define EP3     3       /*!< Endpoint 3 */
N#define EP4     4       /*!< Endpoint 4 */
N#define EP5     5       /*!< Endpoint 5 */
N#define EP6     6       /*!< Endpoint 6 */
N#define EP7     7       /*!< Endpoint 7 */
N
N
N/*!<USB Request Type */
N#define REQ_STANDARD        0x00
N#define REQ_CLASS           0x20
N#define REQ_VENDOR          0x40
N
N/*!<USB Standard Request */
N#define GET_STATUS          0x00
N#define CLEAR_FEATURE       0x01
N#define SET_FEATURE         0x03
N#define SET_ADDRESS         0x05
N#define GET_DESCRIPTOR      0x06
N#define SET_DESCRIPTOR      0x07
N#define GET_CONFIGURATION   0x08
N#define SET_CONFIGURATION   0x09
N#define GET_INTERFACE       0x0A
N#define SET_INTERFACE       0x0B
N#define SYNC_FRAME          0x0C
N
N/*!<USB Descriptor Type */
N#define DESC_DEVICE         0x01
N#define DESC_CONFIG         0x02
N#define DESC_STRING         0x03
N#define DESC_INTERFACE      0x04
N#define DESC_ENDPOINT       0x05
N#define DESC_QUALIFIER      0x06
N#define DESC_OTHERSPEED     0x07
N#define DESC_BOS            0x0F
N#define DESC_DEVCAP         0x10
N
N/*!<USB HID Descriptor Type */
N#define DESC_HID            0x21
N#define DESC_HID_RPT        0x22
N
N/*!<USB Descriptor Length */
N#define LEN_DEVICE          18
N#define LEN_CONFIG          9
N#define LEN_INTERFACE       9
N#define LEN_ENDPOINT        7
N#define LEN_HID             9
N#define LEN_CCID            0x36
N#define LEN_BOS             5
N#define LEN_DEVCAP          7
N
N/*!<USB Endpoint Type */
N#define EP_ISO              0x01
N#define EP_BULK             0x02
N#define EP_INT              0x03
N
N#define EP_INPUT            0x80
N#define EP_OUTPUT           0x00
N
N/*!<USB Feature Selector */
N#define FEATURE_DEVICE_REMOTE_WAKEUP    0x01
N#define FEATURE_ENDPOINT_HALT           0x00
N
N/******************************************************************************/
N/*                USB Specific Macros                                         */
N/******************************************************************************/
N
N#define USBD_WAKEUP_EN          USBD_INTEN_WKEN_Msk         /*!< USB Wake-up Enable */
N#define USBD_DRVSE0             USBD_SE0_SE0_Msk            /*!< Drive SE0 */
N
N#define USBD_L1RESUME           USBD_ATTR_L1RESUME_Msk
N#define USBD_L1SUSPEND          USBD_ATTR_L1SUSPEND_Msk
N#define USBD_LPMACK             USBD_ATTR_LPMACK_Msk        /*!< LPM Enable */
N#define USBD_BYTEM              USBD_ATTR_BYTEM_Msk
N#define USBD_DPPU_EN            USBD_ATTR_DPPUEN_Msk        /*!< USB D+ Pull-up Enable */
N#define USBD_USB_EN             USBD_ATTR_USBEN_Msk         /*!< USB Enable */
N#define USBD_RWAKEUP            USBD_ATTR_RWAKEUP_Msk
N#define USBD_PHY_EN             USBD_ATTR_PHYEN_Msk         /*!< PHY Enable */
N
N#define USBD_INT_BUS            USBD_INTEN_BUSIEN_Msk       /*!< USB Bus Event Interrupt */
N#define USBD_INT_USB            USBD_INTEN_USBIEN_Msk       /*!< USB Event Interrupt */
N#define USBD_INT_FLDET          USBD_INTEN_VBDETIEN_Msk     /*!< USB VBUS Detection Interrupt */
N#define USBD_INT_VBDET          USBD_INTEN_VBDETIEN_Msk     /*!< USB VBUS Detection Interrupt */
N#define USBD_INT_WAKEUP_IDLE    (USBD_INTEN_WKIDLEIEN_Msk | USBD_INTEN_WKEN_Msk)    /*!< USB No-Event-Wake-Up Interrupt */
N
N#define USBD_INTSTS_WAKEUP      USBD_INTSTS_WKIDLEIF_Msk    /*!< USB No-Event-Wake-Up Interrupt Status */
N#define USBD_INTSTS_FLDET       USBD_INTSTS_VBDETIF_Msk     /*!< USB Float Detect Interrupt Status */
N#define USBD_INTSTS_VBDET       USBD_INTSTS_VBDETIF_Msk     /*!< USB Float Detect Interrupt Status */
N#define USBD_INTSTS_BUS         USBD_INTSTS_BUSIF_Msk       /*!< USB Bus Event Interrupt Status */
N#define USBD_INTSTS_USB         USBD_INTSTS_USBIF_Msk       /*!< USB Event Interrupt Status */
N#define USBD_INTSTS_SETUP       USBD_INTSTS_SETUP_Msk       /*!< USB Setup Event */
N#define USBD_INTSTS_EP0         USBD_INTSTS_EPEVT0_Msk      /*!< USB Endpoint 0 Event */
N#define USBD_INTSTS_EP1         USBD_INTSTS_EPEVT1_Msk      /*!< USB Endpoint 1 Event */
N#define USBD_INTSTS_EP2         USBD_INTSTS_EPEVT2_Msk      /*!< USB Endpoint 2 Event */
N#define USBD_INTSTS_EP3         USBD_INTSTS_EPEVT3_Msk      /*!< USB Endpoint 3 Event */
N#define USBD_INTSTS_EP4         USBD_INTSTS_EPEVT4_Msk      /*!< USB Endpoint 4 Event */
N#define USBD_INTSTS_EP5         USBD_INTSTS_EPEVT5_Msk      /*!< USB Endpoint 5 Event */
N#define USBD_INTSTS_EP6         USBD_INTSTS_EPEVT6_Msk      /*!< USB Endpoint 6 Event */
N#define USBD_INTSTS_EP7         USBD_INTSTS_EPEVT7_Msk      /*!< USB Endpoint 7 Event */
N
N#define USBD_STATE_USBRST       USBD_ATTR_USBRST_Msk        /*!< USB Bus Reset */
N#define USBD_STATE_SUSPEND      USBD_ATTR_SUSPEND_Msk       /*!< USB Bus Suspend */
N#define USBD_STATE_RESUME       USBD_ATTR_RESUME_Msk        /*!< USB Bus Resume */
N#define USBD_STATE_TIMEOUT      USBD_ATTR_TOUT_Msk          /*!< USB Bus Timeout */
N
N#define USBD_CFGP_SSTALL        USBD_CFGP_SSTALL_Msk        /*!< Set Stall */
N#define USBD_CFGP_CLRRDY        USBD_CFGP_CLRRDY_Msk
N
N#define USBD_CFG_CSTALL         USBD_CFG_CSTALL_Msk         /*!< Clear Stall */
N#define USBD_CFG_EPMODE_DISABLE (0ul << USBD_CFG_STATE_Pos)/*!< Endpoint Disable */
N#define USBD_CFG_EPMODE_OUT     (1ul << USBD_CFG_STATE_Pos)/*!< Out Endpoint */
N#define USBD_CFG_EPMODE_IN      (2ul << USBD_CFG_STATE_Pos)/*!< In Endpoint */
N#define USBD_CFG_TYPE_ISO       (1ul << USBD_CFG_ISOCH_Pos) /*!< Isochronous */
N
N
N
N/*@}*/ /* end of group USBD_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup USBD_EXPORTED_FUNCTIONS USBD Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Compare two input numbers and return maximum one.
N  *
N  * @param[in]  a   First number to be compared.
N  * @param[in]  b   Second number to be compared.
N  *
N  * @return     Maximum value between a and b.
N  *
N  * @details    If a > b, then return a. Otherwise, return b.
N  */
N#define Maximum(a,b)        ((a)>(b) ? (a) : (b))
N
N
N/**
N  * @brief      Compare two input numbers and return minimum one
N  *
N  * @param[in]  a   First number to be compared
N  * @param[in]  b   Second number to be compared
N  *
N  * @return     Minimum value between a and b
N  *
N  * @details    If a < b, then return a. Otherwise, return b.
N  */
N#define Minimum(a,b)        ((a)<(b) ? (a) : (b))
N
N
N/**
N  * @brief    Enable USB
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  To set USB ATTR control register to enable USB and PHY.
N  *
N  */
N#define USBD_ENABLE_USB()           ((uint32_t)(USBD->ATTR |= (USBD_USB_EN|USBD_PHY_EN)))
N
N/**
N  * @brief    Disable USB
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  To set USB ATTR control register to disable USB.
N  *
N  */
N#define USBD_DISABLE_USB()          ((uint32_t)(USBD->ATTR &= ~USBD_USB_EN))
N
N/**
N  * @brief    Enable USB PHY
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  To set USB ATTR control register to enable USB PHY.
N  *
N  */
N#define USBD_ENABLE_PHY()           ((uint32_t)(USBD->ATTR |= USBD_PHY_EN))
N
N/**
N  * @brief    Disable USB PHY
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  To set USB ATTR control register to disable USB PHY.
N  *
N  */
N#define USBD_DISABLE_PHY()          ((uint32_t)(USBD->ATTR &= ~USBD_PHY_EN))
N
N/**
N  * @brief    Enable SE0. Force USB PHY transceiver to drive SE0.
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  Set DRVSE0 bit of USB_DRVSE0 register to enable software-disconnect function. Force USB PHY transceiver to drive SE0 to bus.
N  *
N  */
N#define USBD_SET_SE0()              ((uint32_t)(USBD->SE0 |= USBD_DRVSE0))
N
N/**
N  * @brief    Disable SE0
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  Clear DRVSE0 bit of USB_DRVSE0 register to disable software-disconnect function.
N  *
N  */
N#define USBD_CLR_SE0()              ((uint32_t)(USBD->SE0 &= ~USBD_DRVSE0))
N
N/**
N  * @brief       Set USB device address
N  *
N  * @param[in]   addr The USB device address.
N  *
N  * @return      None
N  *
N  * @details     Write USB device address to USB_FADDR register.
N  *
N  */
N#define USBD_SET_ADDR(addr)         (USBD->FADDR = (addr))
N
N/**
N  * @brief    Get USB device address
N  *
N  * @param    None
N  *
N  * @return   USB device address
N  *
N  * @details  Read USB_FADDR register to get USB device address.
N  *
N  */
N#define USBD_GET_ADDR()             ((uint32_t)(USBD->FADDR))
N
N/**
N  * @brief      Enable USB interrupt function
N  *
N  * @param[in]  intr The combination of the specified interrupt enable bits.
N  *             Each bit corresponds to a interrupt enable bit.
N  *             This parameter decides which interrupts will be enabled.
N  *             (USBD_INT_WAKEUP, USBD_INT_FLDET, USBD_INT_USB, USBD_INT_BUS)
N  *
N  * @return     None
N  *
N  * @details    Enable USB related interrupt functions specified by intr parameter.
N  *
N  */
N#define USBD_ENABLE_INT(intr)       (USBD->INTEN |= (intr))
N
N/**
N  * @brief    Get interrupt status
N  *
N  * @param    None
N  *
N  * @return   The value of USB_INTSTS register
N  *
N  * @details  Return all interrupt flags of USB_INTSTS register.
N  *
N  */
N#define USBD_GET_INT_FLAG()         ((uint32_t)(USBD->INTSTS))
N
N/**
N  * @brief      Clear USB interrupt flag
N  *
N  * @param[in]  flag The combination of the specified interrupt flags.
N  *             Each bit corresponds to a interrupt source.
N  *             This parameter decides which interrupt flags will be cleared.
N  *             (USBD_INTSTS_WAKEUP, USBD_INTSTS_FLDET, USBD_INTSTS_BUS, USBD_INTSTS_USB)
N  *
N  * @return     None
N  *
N  * @details    Clear USB related interrupt flags specified by flag parameter.
N  *
N  */
N#define USBD_CLR_INT_FLAG(flag)     (USBD->INTSTS = (flag))
N
N/**
N  * @brief    Get endpoint status
N  *
N  * @param    None
N  *
N  * @return   The value of USB_EPSTS register.
N  *
N  * @details  Return all endpoint status.
N  *
N  */
N#define USBD_GET_EP_FLAG()          ((uint32_t)(USBD->EPSTS))
N
N/**
N  * @brief    Get USB bus state
N  *
N  * @param    None
N  *
N  * @return   The value of USB_ATTR[3:0].
N  *           Bit 0 indicates USB bus reset status.
N  *           Bit 1 indicates USB bus suspend status.
N  *           Bit 2 indicates USB bus resume status.
N  *           Bit 3 indicates USB bus time-out status.
N  *
N  * @details  Return USB_ATTR[3:0] for USB bus events.
N  *
N  */
N#ifdef SUPPORT_LPM
N#define USBD_GET_BUS_STATE()        ((uint32_t)(USBD->ATTR & 0x300f))
N#else
S#define USBD_GET_BUS_STATE()        ((uint32_t)(USBD->ATTR & 0xf))
N#endif
N/**
N  * @brief    Check cable connection state
N  *
N  * @param    None
N  *
N  * @retval   0 USB cable is not attached.
N  * @retval   1 USB cable is attached.
N  *
N  * @details  Check the connection state by FLDET bit of USB_FLDET register.
N  *
N  */
N#define USBD_IS_ATTACHED()          ((uint32_t)(USBD->VBUSDET & USBD_VBUSDET_VBUSDET_Msk))
N
N/**
N  * @brief      Stop USB transaction of the specified endpoint ID
N  *
N  * @param[in]  ep The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @return     None
N  *
N  * @details    Write 1 to CLRRDY bit of USB_CFGPx register to stop USB transaction of the specified endpoint ID.
N  *
N  */
N#define USBD_STOP_TRANSACTION(ep)   (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFGP + (uint32_t)((ep) << 4))) |= USBD_CFGP_CLRRDY_Msk)
N
N/**
N  * @brief      Set USB DATA1 PID for the specified endpoint ID
N  *
N  * @param[in]  ep The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @return     None
N  *
N  * @details    Set DSQ_SYNC bit of USB_CFGx register to specify the DATA1 PID for the following IN token transaction.
N  *             Base on this setting, hardware will toggle PID between DATA0 and DATA1 automatically for IN token transactions.
N  *
N  */
N#define USBD_SET_DATA1(ep)          (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFG + (uint32_t)((ep) << 4))) |= USBD_CFG_DSQSYNC_Msk)
N
N/**
N  * @brief      Set USB DATA0 PID for the specified endpoint ID
N  *
N  * @param[in]  ep The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @return     None
N  *
N  * @details    Clear DSQ_SYNC bit of USB_CFGx register to specify the DATA0 PID for the following IN token transaction.
N  *             Base on this setting, hardware will toggle PID between DATA0 and DATA1 automatically for IN token transactions.
N  *
N  */
N#define USBD_SET_DATA0(ep)          (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFG + (uint32_t)((ep) << 4))) &= (~USBD_CFG_DSQSYNC_Msk))
N
N/**
N  * @brief      Set USB payload size (IN data)
N  *
N  * @param[in]  ep The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @param[in]  size The transfer length.
N  *
N  * @return     None
N  *
N  * @details    This macro will write the transfer length to USB_MXPLDx register for IN data transaction.
N  *
N  */
N#define USBD_SET_PAYLOAD_LEN(ep, size)  (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].MXPLD + (uint32_t)((ep) << 4))) = (size))
N
N/**
N  * @brief      Get USB payload size (OUT data)
N  *
N  * @param[in]  ep The USB endpoint ID. M451 Series supports 8 endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @return     The value of USB_MXPLDx register.
N  *
N  * @details    Get the data length of OUT data transaction by reading USB_MXPLDx register.
N  *
N  */
N#define USBD_GET_PAYLOAD_LEN(ep)        ((uint32_t)*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].MXPLD + (uint32_t)((ep) << 4))))
N
N/**
N  * @brief      Configure endpoint
N  *
N  * @param[in]  ep The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @param[in]  config The USB configuration.
N  *
N  * @return     None
N  *
N  * @details    This macro will write config parameter to USB_CFGx register of specified endpoint ID.
N  *
N  */
N#define USBD_CONFIG_EP(ep, config)      (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFG + (uint32_t)((ep) << 4))) = (config))
N
N/**
N  * @brief      Set USB endpoint buffer
N  *
N  * @param[in]  ep The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @param[in]  offset The SRAM offset.
N  *
N  * @return     None
N  *
N  * @details    This macro will set the SRAM offset for the specified endpoint ID.
N  *
N  */
N#define USBD_SET_EP_BUF_ADDR(ep, offset)    (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].BUFSEG + (uint32_t)((ep) << 4))) = (offset))
N
N/**
N  * @brief      Get the offset of the specified USB endpoint buffer
N  *
N  * @param[in]  ep The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @return     The offset of the specified endpoint buffer.
N  *
N  * @details    This macro will return the SRAM offset of the specified endpoint ID.
N  *
N  */
N#define USBD_GET_EP_BUF_ADDR(ep)        ((uint32_t)*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].BUFSEG + (uint32_t)((ep) << 4))))
N
N/**
N  * @brief       Set USB endpoint stall state
N  *
N  * @param[in]   ep  The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @return      None
N  *
N  * @details     Set USB endpoint stall state for the specified endpoint ID. Endpoint will respond STALL token automatically.
N  *
N  */
N#define USBD_SET_EP_STALL(ep)        (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFGP + (uint32_t)((ep) << 4))) |= USBD_CFGP_SSTALL_Msk)
N
N/**
N  * @brief       Clear USB endpoint stall state
N  *
N  * @param[in]   ep  The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @return      None
N  *
N  * @details     Clear USB endpoint stall state for the specified endpoint ID. Endpoint will respond ACK/NAK token.
N  */
N#define USBD_CLR_EP_STALL(ep)        (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFGP + (uint32_t)((ep) << 4))) &= ~USBD_CFGP_SSTALL_Msk)
N
N/**
N  * @brief       Get USB endpoint stall state
N  *
N  * @param[in]   ep  The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @retval      0      USB endpoint is not stalled.
N  * @retval      Others USB endpoint is stalled.
N  *
N  * @details     Get USB endpoint stall state of the specified endpoint ID.
N  *
N  */
N#define USBD_GET_EP_STALL(ep)        (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFGP + (uint32_t)((ep) << 4))) & USBD_CFGP_SSTALL_Msk)
N
N/**
N  * @brief      To support byte access between USB SRAM and system SRAM
N  *
N  * @param[in]  dest Destination pointer.
N  *
N  * @param[in]  src  Source pointer.
N  *
N  * @param[in]  size Byte count.
N  *
N  * @return     None
N  *
N  * @details    This function will copy the number of data specified by size and src parameters to the address specified by dest parameter.
N  *
N  */
Nstatic __INLINE void USBD_MemCopy(uint8_t *dest, uint8_t *src, int32_t size)
Xstatic __inline void USBD_MemCopy(uint8_t *dest, uint8_t *src, int32_t size)
N{
N    while(size--) *dest++ = *src++;
N}
N
N
N/**
N  * @brief       Set USB endpoint stall state
N  *
N  * @param[in]   epnum  USB endpoint number
N  *
N  * @return      None
N  *
N  * @details     Set USB endpoint stall state. Endpoint will respond STALL token automatically.
N  *
N  */
Nstatic __INLINE void USBD_SetStall(uint8_t epnum)
Xstatic __inline void USBD_SetStall(uint8_t epnum)
N{
N    uint32_t u32CfgAddr;
N    uint32_t u32Cfg;
N    int i;
N
N    for(i = 0; i < USBD_MAX_EP; i++)
X    for(i = 0; i < 8; i++)
N    {
N        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
X        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) ((( uint32_t)0x40000000) + 0x60000))->EP[0].CFG;  
N        u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X        u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N        if((u32Cfg & 0xf) == epnum)
N        {
N            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFGP; /* USBD_CFGP0 */
X            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) ((( uint32_t)0x40000000) + 0x60000))->EP[0].CFGP;  
N            u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X            u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N            *((__IO uint32_t *)(u32CfgAddr)) = (u32Cfg | USBD_CFGP_SSTALL);
X            *((volatile uint32_t *)(u32CfgAddr)) = (u32Cfg | (0x1ul << (1)));
N            break;
N        }
N    }
N}
N
N/**
N  * @brief       Clear USB endpoint stall state
N  *
N  * @param[in]   epnum  USB endpoint number
N  *
N  * @return      None
N  *
N  * @details     Clear USB endpoint stall state. Endpoint will respond ACK/NAK token.
N  */
Nstatic __INLINE void USBD_ClearStall(uint8_t epnum)
Xstatic __inline void USBD_ClearStall(uint8_t epnum)
N{
N    uint32_t u32CfgAddr;
N    uint32_t u32Cfg;
N    int i;
N
N    for(i = 0; i < USBD_MAX_EP; i++)
X    for(i = 0; i < 8; i++)
N    {
N        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
X        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) ((( uint32_t)0x40000000) + 0x60000))->EP[0].CFG;  
N        u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X        u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N        if((u32Cfg & 0xf) == epnum)
N        {
N            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFGP; /* USBD_CFGP0 */
X            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) ((( uint32_t)0x40000000) + 0x60000))->EP[0].CFGP;  
N            u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X            u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N            *((__IO uint32_t *)(u32CfgAddr)) = (u32Cfg & ~USBD_CFGP_SSTALL);
X            *((volatile uint32_t *)(u32CfgAddr)) = (u32Cfg & ~(0x1ul << (1)));
N            break;
N        }
N    }
N}
N
N/**
N  * @brief       Get USB endpoint stall state
N  *
N  * @param[in]   epnum  USB endpoint number
N  *
N  * @retval      0      USB endpoint is not stalled.
N  * @retval      Others USB endpoint is stalled.
N  *
N  * @details     Get USB endpoint stall state.
N  *
N  */
Nstatic __INLINE uint32_t USBD_GetStall(uint8_t epnum)
Xstatic __inline uint32_t USBD_GetStall(uint8_t epnum)
N{
N    uint32_t u32CfgAddr;
N    uint32_t u32Cfg;
N    int i;
N
N    for(i = 0; i < USBD_MAX_EP; i++)
X    for(i = 0; i < 8; i++)
N    {
N        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
X        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) ((( uint32_t)0x40000000) + 0x60000))->EP[0].CFG;  
N        u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X        u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N        if((u32Cfg & 0xf) == epnum)
N        {
N            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFGP; /* USBD_CFGP0 */
X            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) ((( uint32_t)0x40000000) + 0x60000))->EP[0].CFGP;  
N            break;
N        }
N    }
N
N    return ((*((__IO uint32_t *)(u32CfgAddr))) & USBD_CFGP_SSTALL);
X    return ((*((volatile uint32_t *)(u32CfgAddr))) & (0x1ul << (1)));
N}
N
N
Nextern volatile uint8_t g_usbd_RemoteWakeupEn;
N
N
Ntypedef void (*VENDOR_REQ)(void);           /*!< Functional pointer type definition for Vendor class */
Ntypedef void (*CLASS_REQ)(void);            /*!< Functional pointer type declaration for USB class request callback handler */
Ntypedef void (*SET_INTERFACE_REQ)(void);    /*!< Functional pointer type declaration for USB set interface request callback handler */
Ntypedef void (*SET_CONFIG_CB)(void);       /*!< Functional pointer type declaration for USB set configuration request callback handler */
N
N
N/*--------------------------------------------------------------------*/
Nvoid USBD_Open(const S_USBD_INFO_T *param, CLASS_REQ pfnClassReq, SET_INTERFACE_REQ pfnSetInterface);
Nvoid USBD_Start(void);
Nvoid USBD_GetSetupPacket(uint8_t *buf);
Nvoid USBD_ProcessSetupPacket(void);
Nvoid USBD_StandardRequest(void);
Nvoid USBD_PrepareCtrlIn(uint8_t *pu8Buf, uint32_t u32Size);
Nvoid USBD_CtrlIn(void);
Nvoid USBD_PrepareCtrlOut(uint8_t *pu8Buf, uint32_t u32Size);
Nvoid USBD_CtrlOut(void);
Nvoid USBD_SwReset(void);
Nvoid USBD_SetVendorRequest(VENDOR_REQ pfnVendorReq);
Nvoid USBD_SetConfigCallback(SET_CONFIG_CB pfnSetConfigCallback);
Nvoid USBD_LockEpStall(uint32_t u32EpBitmap);
N
N/*@}*/ /* end of group USBD_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group USBD_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N
N#endif //__USBD_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17573 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "pdma.h"
L 1 "..\lib\StdDriver\inc\pdma.h" 1
N/**************************************************************************//**
N * @file     pdma.h
N * @version  V3.00
N * $Revision: 6 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE series PDMA driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __PDMA_H__
N#define __PDMA_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup PDMA_Driver PDMA Driver
N  @{
N*/
N
N/** @addtogroup PDMA_EXPORTED_CONSTANTS PDMA Exported Constants
N  @{
N*/
N#define PDMA_CH_MAX    5   /*!< Specify Maximum Channels of PDMA  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Operation Mode Constant Definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_OP_STOP        0x00000000UL            /*!<DMA Stop Mode  \hideinitializer */
N#define PDMA_OP_BASIC       0x00000001UL            /*!<DMA Basic Mode  \hideinitializer */
N#define PDMA_OP_SCATTER     0x00000002UL            /*!<DMA Scatter-gather Mode  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Data Width Constant Definitions                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_WIDTH_8        0x00000000UL            /*!<DMA Transfer Width 8-bit  \hideinitializer */
N#define PDMA_WIDTH_16       0x00001000UL            /*!<DMA Transfer Width 16-bit  \hideinitializer */
N#define PDMA_WIDTH_32       0x00002000UL            /*!<DMA Transfer Width 32-bit  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Address Attribute Constant Definitions                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_SAR_INC        0x00000000UL            /*!<DMA SAR increment  \hideinitializer */
N#define PDMA_SAR_FIX        0x00000300UL            /*!<DMA SAR fix address  \hideinitializer */
N#define PDMA_DAR_INC        0x00000000UL            /*!<DMA DAR increment  \hideinitializer */
N#define PDMA_DAR_FIX        0x00000C00UL            /*!<DMA DAR fix address  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Burst Mode Constant Definitions                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_REQ_SINGLE     0x00000004UL            /*!<DMA Single Request  \hideinitializer */
N#define PDMA_REQ_BURST      0x00000000UL            /*!<DMA Burst Request  \hideinitializer */
N
N#define PDMA_BURST_128      0x00000000UL            /*!<DMA Burst 128 Transfers  \hideinitializer */
N#define PDMA_BURST_64       0x00000010UL            /*!<DMA Burst 64 Transfers  \hideinitializer */
N#define PDMA_BURST_32       0x00000020UL            /*!<DMA Burst 32 Transfers  \hideinitializer */
N#define PDMA_BURST_16       0x00000030UL            /*!<DMA Burst 16 Transfers  \hideinitializer */
N#define PDMA_BURST_8        0x00000040UL            /*!<DMA Burst 8 Transfers  \hideinitializer */
N#define PDMA_BURST_4        0x00000050UL            /*!<DMA Burst 4 Transfers  \hideinitializer */
N#define PDMA_BURST_2        0x00000060UL            /*!<DMA Burst 2 Transfers  \hideinitializer */
N#define PDMA_BURST_1        0x00000070UL            /*!<DMA Burst 1 Transfers  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Table Interrupt Disable Constant Definitions                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_TBINTDIS_ENABLE  (0x0UL<<PDMA_DSCT_CTL_TBINTDIS_Pos)  /*!<DMA Table Interrupt Enabled   \hideinitializer */
N#define PDMA_TBINTDIS_DISABLE (0x1UL<<PDMA_DSCT_CTL_TBINTDIS_Pos)  /*!<DMA Table Interrupt Disabled  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Peripheral Transfer Mode Constant Definitions                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_MEM            0x00000000UL            /*!<DMA Connect to Memory  \hideinitializer */
N#define PDMA_USB_TX         0x00000002UL            /*!<DMA Connect to USB TX  \hideinitializer */
N#define PDMA_USB_RX         0x00000003UL            /*!<DMA Connect to USB RX  \hideinitializer */
N#define PDMA_UART0_TX       0x00000004UL            /*!<DMA Connect to UART0 TX  \hideinitializer */
N#define PDMA_UART0_RX       0x00000005UL            /*!<DMA Connect to UART0 RX  \hideinitializer */
N#define PDMA_UART1_TX       0x00000006UL            /*!<DMA Connect to UART1 TX  \hideinitializer */
N#define PDMA_UART1_RX       0x00000007UL            /*!<DMA Connect to UART1 RX  \hideinitializer */
N#define PDMA_UART2_TX       0x00000008UL            /*!<DMA Connect to UART2 TX  \hideinitializer */
N#define PDMA_UART2_RX       0x00000009UL            /*!<DMA Connect to UART2 RX  \hideinitializer */
N#define PDMA_SPI0_TX        0x00000010UL            /*!<DMA Connect to SPI0 TX  \hideinitializer */
N#define PDMA_SPI0_RX        0x00000011UL            /*!<DMA Connect to SPI0 RX  \hideinitializer */
N#define PDMA_SPI1_TX        0x00000012UL            /*!<DMA Connect to SPI1 TX  \hideinitializer */
N#define PDMA_SPI1_RX        0x00000013UL            /*!<DMA Connect to SPI1 RX  \hideinitializer */
N#define PDMA_ADC_RX         0x00000014UL            /*!<DMA Connect to ADC RX  \hideinitializer */
N#define PDMA_PWM0_P1_RX     0x00000015UL            /*!<DMA Connect to PWM0 P1 RX  \hideinitializer */
N#define PDMA_PWM0_P2_RX     0x00000016UL            /*!<DMA Connect to PWM0 P2 RX  \hideinitializer */
N#define PDMA_PWM0_P3_RX     0x00000017UL            /*!<DMA Connect to PWM0 P3 RX  \hideinitializer */
N#define PDMA_PWM1_P1_RX     0x00000018UL            /*!<DMA Connect to PWM1 P1 RX  \hideinitializer */
N#define PDMA_PWM1_P2_RX     0x00000019UL            /*!<DMA Connect to PWM1 P2 RX  \hideinitializer */
N#define PDMA_PWM1_P3_RX     0x0000001AUL            /*!<DMA Connect to PWM1 P3 RX  \hideinitializer */
N#define PDMA_I2C0_TX        0x0000001CUL            /*!<DMA Connect to I2C0 TX  \hideinitializer */
N#define PDMA_I2C0_RX        0x0000001DUL            /*!<DMA Connect to I2C0 RX  \hideinitializer */
N#define PDMA_I2C1_TX        0x0000001EUL            /*!<DMA Connect to I2C1 TX  \hideinitializer */
N#define PDMA_I2C1_RX        0x0000001FUL            /*!<DMA Connect to I2C1 RX  \hideinitializer */
N#define PDMA_TMR0           0x00000020UL            /*!<DMA Connect to TMR0  \hideinitializer */
N#define PDMA_TMR1           0x00000021UL            /*!<DMA Connect to TMR1  \hideinitializer */
N#define PDMA_TMR2           0x00000022UL            /*!<DMA Connect to TMR2  \hideinitializer */
N#define PDMA_TMR3           0x00000023UL            /*!<DMA Connect to TMR3  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Interrupt Type Constant Definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_INT_TRANS_DONE 0x00000000UL            /*!<Transfer Done Interrupt  \hideinitializer */
N#define PDMA_INT_TEMPTY     0x00000001UL            /*!<Table Empty Interrupt  \hideinitializer */
N#define PDMA_INT_TIMEOUT    0x00000002UL            /*!<Timeout Interrupt  \hideinitializer */
N
N
N/*@}*/ /* end of group PDMA_EXPORTED_CONSTANTS */
N
N/** @addtogroup PDMA_EXPORTED_FUNCTIONS PDMA Exported Functions
N  @{
N*/
N
N/**
N * @brief       Get PDMA Interrupt Status
N *
N * @param[in]   None
N *
N * @return      None
N *
N * @details     This macro gets the interrupt status.
N */
N#define PDMA_GET_INT_STATUS() ((uint32_t)(PDMA->INTSTS))
N
N/**
N * @brief       Get Transfer Done Interrupt Status
N *
N * @param[in]   None
N *
N * @return      None
N *
N * @details     Get the transfer done Interrupt status.
N */
N#define PDMA_GET_TD_STS() ((uint32_t)(PDMA->TDSTS))
N
N/**
N * @brief       Clear Transfer Done Interrupt Status
N *
N * @param[in]   u32Mask     The channel mask
N *
N * @return      None
N *
N * @details     Clear the transfer done Interrupt status.
N */
N#define PDMA_CLR_TD_FLAG(u32Mask) ((uint32_t)(PDMA->TDSTS = (u32Mask)))
N
N/**
N * @brief       Get Target Abort Interrupt Status
N *
N * @param[in]   None
N *
N * @return      None
N *
N * @details     Get the target abort Interrupt status.
N */
N#define PDMA_GET_ABORT_STS() ((uint32_t)(PDMA->ABTSTS))
N
N/**
N * @brief       Clear Target Abort Interrupt Status
N *
N * @param[in]   u32Mask     The channel mask
N *
N * @return      None
N *
N * @details     Clear the target abort Interrupt status.
N */
N#define PDMA_CLR_ABORT_FLAG(u32Mask) ((uint32_t)(PDMA->ABTSTS = (u32Mask)))
N
N/**
N * @brief       Get Scatter-Gather Table Empty Interrupt Status
N *
N * @param[in]   None
N *
N * @return      None
N *
N * @details     Get the scatter-gather table empty Interrupt status.
N */
N#define PDMA_GET_EMPTY_STS() ((uint32_t)(PDMA->SCATSTS))
N
N/**
N * @brief       Clear Scatter-Gather Table Empty Interrupt Status
N *
N * @param[in]   u32Mask     The channel mask
N *
N * @return      None
N *
N * @details     Clear the scatter-gather table empty Interrupt status.
N */
N#define PDMA_CLR_EMPTY_FLAG(u32Mask) ((uint32_t)(PDMA->SCATSTS = (u32Mask)))
N
N/**
N * @brief       Clear Timeout Interrupt Status
N *
N * @param[in]   u32Ch     The selected channel
N *
N * @return      None
N *
N * @details     Clear the selected channel timeout interrupt status.
N * @note        This function is only supported in channel 0 and channel 1.
N */
N#define PDMA_CLR_TMOUT_FLAG(u32Ch) ((uint32_t)(PDMA->INTSTS = (1 << ((u32Ch) + 8))))
N
N/**
N * @brief       Check Channel Status
N *
N * @param[in]   u32Ch     The selected channel
N *
N * @retval      0 Idle state
N * @retval      1 Busy state
N *
N * @details     Check the selected channel is busy or not.
N */
N#define PDMA_IS_CH_BUSY(u32Ch) ((uint32_t)(PDMA->TRGSTS & (1 << (u32Ch)))? 1 : 0)
N
N/**
N * @brief       Set Source Address
N *
N * @param[in]   u32Ch     The selected channel
N * @param[in]   u32Addr   The selected address
N *
N * @return      None
N *
N * @details     This macro set the selected channel source address.
N */
N#define PDMA_SET_SRC_ADDR(u32Ch, u32Addr) ((uint32_t)(PDMA->DSCT[(u32Ch)].SA = (u32Addr)))
N
N/**
N * @brief       Set Destination Address
N *
N * @param[in]   u32Ch     The selected channel
N * @param[in]   u32Addr   The selected address
N *
N * @return      None
N *
N * @details     This macro set the selected channel destination address.
N */
N#define PDMA_SET_DST_ADDR(u32Ch, u32Addr) ((uint32_t)(PDMA->DSCT[(u32Ch)].DA = (u32Addr)))
N
N/**
N * @brief       Set Transfer Count
N *
N * @param[in]   u32Ch          The selected channel
N * @param[in]   u32TransCount  Transfer Count
N *
N * @return      None
N *
N * @details     This macro set the selected channel transfer count.
N */
N#define PDMA_SET_TRANS_CNT(u32Ch, u32TransCount) ((uint32_t)(PDMA->DSCT[(u32Ch)].CTL=(PDMA->DSCT[(u32Ch)].CTL&~PDMA_DSCT_CTL_TXCNT_Msk)|((u32TransCount-1) << PDMA_DSCT_CTL_TXCNT_Pos)))
N
N/**
N * @brief       Set Scatter-gather descriptor Address
N *
N * @param[in]   u32Ch     The selected channel
N * @param[in]   u32Addr   The descriptor address
N *
N * @return      None
N *
N * @details     This macro set the selected channel scatter-gather descriptor address.
N */
N#define PDMA_SET_SCATTER_DESC(u32Ch, u32Addr) ((uint32_t)(PDMA->DSCT[(u32Ch)].FIRST = (u32Addr) - (PDMA->SCATBA)))
N
N/**
N * @brief       Pause the channel
N *
N * @param[in]   u32Ch     The selected channel
N *
N * @return      None
N *
N * @details     This macro pause the selected channel.
N */
N#define PDMA_PAUSE(u32Ch) ((uint32_t)(PDMA->PAUSE = (1 << (u32Ch))))
N
N/**
N * @brief       Reset the channel
N *
N * @param[in]   u32Ch     The selected channel
N *
N * @return      None
N *
N * @details     This macro reset the selected channel.
N */
N#define PDMA_RESET(u32Ch) ((uint32_t)(PDMA->RESET = (1 << (u32Ch))))
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define PWM functions prototype                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid PDMA_Open(uint32_t u32Mask);
Nvoid PDMA_Close(void);
Nvoid PDMA_SetTransferCnt(uint32_t u32Ch, uint32_t u32Width, uint32_t u32TransCount);
Nvoid PDMA_SetTransferAddr(uint32_t u32Ch, uint32_t u32SrcAddr, uint32_t u32SrcCtrl, uint32_t u32DstAddr, uint32_t u32DstCtrl);
Nvoid PDMA_SetTransferMode(uint32_t u32Ch, uint32_t u32Peripheral, uint32_t u32ScatterEn, uint32_t u32DescAddr);
Nvoid PDMA_SetBurstType(uint32_t u32Ch, uint32_t u32BurstType, uint32_t u32BurstSize);
Nvoid PDMA_EnableTimeout(uint32_t u32Mask);
Nvoid PDMA_DisableTimeout(uint32_t u32Mask);
Nvoid PDMA_SetTimeOut(uint32_t u32Ch, uint32_t u32OnOff, uint32_t u32TimeOutCnt);
Nvoid PDMA_Trigger(uint32_t u32Ch);
Nvoid PDMA_EnableInt(uint32_t u32Ch, uint32_t u32Mask);
Nvoid PDMA_DisableInt(uint32_t u32Ch, uint32_t u32Mask);
N
N
N/*@}*/ /* end of group PDMA_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group PDMA_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__PDMA_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17574 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "ebi.h"
N#include "sc.h"
L 1 "..\lib\StdDriver\inc\sc.h" 1
N/**************************************************************************//**
N * @file     sc.h
N * @version  V3.00
N * $Revision: 6 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE series Smart Card(SC) driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __SC_H__
N#define __SC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup SC_Driver SC Driver
N  @{
N*/
N
N/** @addtogroup SC_EXPORTED_CONSTANTS SC Exported Constants
N  @{
N*/
N#define SC_INTERFACE_NUM            2                /*!< Smartcard interface numbers */
N#define SC_PIN_STATE_HIGH           1                /*!< Smartcard pin status high   */
N#define SC_PIN_STATE_LOW            0                /*!< Smartcard pin status low    */
N#define SC_PIN_STATE_IGNORE         0xFFFFFFFF       /*!< Ignore pin status           */
N#define SC_CLK_ON                   1                /*!< Smartcard clock on          */
N#define SC_CLK_OFF                  0                /*!< Smartcard clock off         */
N
N#define SC_TMR_MODE_0               (0ul << SC_TMRCTL0_OPMODE_Pos)     /*!< Timer Operation Mode 0, down count                                                      */
N#define SC_TMR_MODE_1               (1ul << SC_TMRCTL0_OPMODE_Pos)     /*!< Timer Operation Mode 1, down count, start after detect start bit                        */
N#define SC_TMR_MODE_2               (2ul << SC_TMRCTL0_OPMODE_Pos)     /*!< Timer Operation Mode 2, down count, start after receive start bit                       */
N#define SC_TMR_MODE_3               (3ul << SC_TMRCTL0_OPMODE_Pos)     /*!< Timer Operation Mode 3, down count, use for activation, only timer 0 support this mode  */
N#define SC_TMR_MODE_4               (4ul << SC_TMRCTL0_OPMODE_Pos)     /*!< Timer Operation Mode 4, down count with reload after timeout                            */
N#define SC_TMR_MODE_5               (5ul << SC_TMRCTL0_OPMODE_Pos)     /*!< Timer Operation Mode 5, down count, start after detect start bit, reload after timeout  */
N#define SC_TMR_MODE_6               (6ul << SC_TMRCTL0_OPMODE_Pos)     /*!< Timer Operation Mode 6, down count, start after receive start bit, reload after timeout */
N#define SC_TMR_MODE_7               (7ul << SC_TMRCTL0_OPMODE_Pos)     /*!< Timer Operation Mode 7, down count, start and reload after detect start bit             */
N#define SC_TMR_MODE_8               (8ul << SC_TMRCTL0_OPMODE_Pos)     /*!< Timer Operation Mode 8, up count                                                        */
N#define SC_TMR_MODE_F               (0xF << SC_TMRCTL0_OPMODE_Pos)     /*!< Timer Operation Mode 15, down count, reload after detect start bit                      */
N
N/*@}*/ /* end of group SC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup SC_EXPORTED_FUNCTIONS SC Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Enable Smartcard Interrupt Function
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  * @param[in]  u32Mask Interrupt mask to be enabled. A combination of
N  *                         - \ref SC_INTEN_ACERRIEN_Msk
N  *                         - \ref SC_INTEN_RXTOIEN_Msk
N  *                         - \ref SC_INTEN_INITIEN_Msk
N  *                         - \ref SC_INTEN_CDIEN_Msk
N  *                         - \ref SC_INTEN_BGTIEN_Msk
N  *                         - \ref SC_INTEN_TMR2IEN_Msk
N  *                         - \ref SC_INTEN_TMR1IEN_Msk
N  *                         - \ref SC_INTEN_TMR0IEN_Msk
N  *                         - \ref SC_INTEN_TERRIEN_Msk
N  *                         - \ref SC_INTEN_TXEIEN_Msk
N  *                         - \ref SC_INTEN_RDAIEN_Msk
N  *
N  * @return     None
N  *
N  * @details    The macro is used to enable Auto-convention error interrupt, Receiver buffer time-out interrupt, Initial end interrupt,
N  *             Card detect interrupt, Block guard time interrupt, Timer2 interrupt, Timer1 interrupt, Timer0 interrupt,
N  *             Transfer error interrupt, Transmit buffer empty interrupt or Receive data reach trigger level interrupt.
N  * \hideinitializer
N  */
N#define SC_ENABLE_INT(sc, u32Mask)      ((sc)->INTEN |= (u32Mask))
N
N/**
N  * @brief      Disable Smartcard Interrupt Function
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  * @param[in]  u32Mask Interrupt mask to be disabled. A combination of
N  *                         - \ref SC_INTEN_ACERRIEN_Msk
N  *                         - \ref SC_INTEN_RXTOIEN_Msk
N  *                         - \ref SC_INTEN_INITIEN_Msk
N  *                         - \ref SC_INTEN_CDIEN_Msk
N  *                         - \ref SC_INTEN_BGTIEN_Msk
N  *                         - \ref SC_INTEN_TMR2IEN_Msk
N  *                         - \ref SC_INTEN_TMR1IEN_Msk
N  *                         - \ref SC_INTEN_TMR0IEN_Msk
N  *                         - \ref SC_INTEN_TERRIEN_Msk
N  *                         - \ref SC_INTEN_TXEIEN_Msk
N  *                         - \ref SC_INTEN_RDAIEN_Msk
N  *
N  * @return     None
N  *
N  * @details    The macro is used to disable Auto-convention error interrupt, Receiver buffer time-out interrupt, Initial end interrupt,
N  *             Card detect interrupt, Block guard time interrupt, Timer2 interrupt, Timer1 interrupt, Timer0 interrupt,
N  *             Transfer error interrupt, Transmit buffer empty interrupt or Receive data reach trigger level interrupt.
N  * \hideinitializer
N  */
N#define SC_DISABLE_INT(sc, u32Mask)     ((sc)->INTEN &= ~(u32Mask))
N
N/**
N  * @brief      Set Smartcard Power Pin State
N  *
N  * @param[in]  sc          The pointer of smartcard module.
N  * @param[in]  u32State    Set pin state of power pin, valid parameters are:
N  *                             - \ref SC_PIN_STATE_HIGH
N  *                             - \ref SC_PIN_STATE_LOW
N  *
N  * @return     None
N  *
N  * @details    User can set PWREN (SC_PINCTL[0]) and PWRINV (SC_PINCTL[11]) to decide SC_PWR pin is in high or low level.
N  * \hideinitializer
N  */
N#define SC_SET_VCC_PIN(sc, u32State) \
N    do {\
N            while((sc)->PINCTL & SC_PINCTL_SYNC_Msk);\
N            if(u32State)\
N                (sc)->PINCTL |= SC_PINCTL_PWREN_Msk;\
N            else\
N                (sc)->PINCTL &= ~SC_PINCTL_PWREN_Msk;\
N    }while(0)
X#define SC_SET_VCC_PIN(sc, u32State)     do {            while((sc)->PINCTL & SC_PINCTL_SYNC_Msk);            if(u32State)                (sc)->PINCTL |= SC_PINCTL_PWREN_Msk;            else                (sc)->PINCTL &= ~SC_PINCTL_PWREN_Msk;    }while(0)
N
N
N/**
N  * @brief      Set Smartcard Clock Status
N  *
N  * @param[in]  sc          The pointer of smartcard module.
N  * @param[in]  u32OnOff    Set clock on or off for selected smartcard module, valid values are:
N  *                             - \ref SC_CLK_ON
N  *                             - \ref SC_CLK_OFF
N  *
N  * @return     None
N  *
N  * @details    User can set CLKKEEP (SC_PINCTL[6]) to decide SC_CLK pin always keeps free running or not.
N  * \hideinitializer
N  */
N#define SC_SET_CLK_PIN(sc, u32OnOff)\
N    do {\
N            while((sc)->PINCTL & SC_PINCTL_SYNC_Msk);\
N            if(u32OnOff)\
N                (sc)->PINCTL |= SC_PINCTL_CLKKEEP_Msk;\
N            else\
N                (sc)->PINCTL &= ~(SC_PINCTL_CLKKEEP_Msk);\
N    }while(0)
X#define SC_SET_CLK_PIN(sc, u32OnOff)    do {            while((sc)->PINCTL & SC_PINCTL_SYNC_Msk);            if(u32OnOff)                (sc)->PINCTL |= SC_PINCTL_CLKKEEP_Msk;            else                (sc)->PINCTL &= ~(SC_PINCTL_CLKKEEP_Msk);    }while(0)
N
N/**
N  * @brief      Set Smartcard I/O Pin State
N  *
N  * @param[in]  sc          The pointer of smartcard module.
N  * @param[in]  u32State    Set pin state of I/O pin, valid parameters are:
N  *                             - \ref SC_PIN_STATE_HIGH
N  *                             - \ref SC_PIN_STATE_LOW
N  *
N  * @return     None
N  *
N  * @details    User can set SCDATA (SC_PINCTL[9]) to decide SC_DATA pin to high or low.
N  * \hideinitializer
N  */
N#define SC_SET_IO_PIN(sc, u32State)\
N    do {\
N            while((sc)->PINCTL & SC_PINCTL_SYNC_Msk);\
N            if(u32State)\
N                (sc)->PINCTL |= SC_PINCTL_SCDATA_Msk;\
N            else\
N                (sc)->PINCTL &= ~SC_PINCTL_SCDATA_Msk;\
N    }while(0)
X#define SC_SET_IO_PIN(sc, u32State)    do {            while((sc)->PINCTL & SC_PINCTL_SYNC_Msk);            if(u32State)                (sc)->PINCTL |= SC_PINCTL_SCDATA_Msk;            else                (sc)->PINCTL &= ~SC_PINCTL_SCDATA_Msk;    }while(0)
N
N/**
N  * @brief      Set Smartcard Reset Pin State
N  *
N  * @param[in]  sc          The pointer of smartcard module.
N  * @param[in]  u32State    Set pin state of reset pin, valid parameters are:
N  *                             - \ref SC_PIN_STATE_HIGH
N  *                             - \ref SC_PIN_STATE_LOW
N  *
N  * @return     None
N  *
N  * @details    User can set SCRST (SC_PINCTL[1]) to decide SC_RST pin to high or low.
N  * \hideinitializer
N  */
N#define SC_SET_RST_PIN(sc, u32State)\
N    do {\
N            while((sc)->PINCTL & SC_PINCTL_SYNC_Msk);\
N            if(u32State)\
N                (sc)->PINCTL |= SC_PINCTL_SCRST_Msk;\
N            else\
N                (sc)->PINCTL &= ~SC_PINCTL_SCRST_Msk;\
N    }while(0)
X#define SC_SET_RST_PIN(sc, u32State)    do {            while((sc)->PINCTL & SC_PINCTL_SYNC_Msk);            if(u32State)                (sc)->PINCTL |= SC_PINCTL_SCRST_Msk;            else                (sc)->PINCTL &= ~SC_PINCTL_SCRST_Msk;    }while(0)
N
N/**
N  * @brief      Read One Byte Data
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  *
N  * @return     One byte read from receive FIFO
N  *
N  * @details    By reading DAT register, the SC will return an 8-bit received data.
N  * \hideinitializer
N  */
N#define SC_READ(sc)             ((char)((sc)->DAT))
N
N/**
N  * @brief      Write One Byte Data
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  * @param[in]  u8Data  Data to write to transmit FIFO.
N  *
N  * @return     None
N  *
N  * @details    By writing data to DAT register, the SC will send out an 8-bit data.
N  * \hideinitializer
N  */
N#define SC_WRITE(sc, u8Data)    ((sc)->DAT = (u8Data))
N
N/**
N  * @brief      Set Smartcard Stop Bit Length
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  * @param[in]  u32Len  Stop bit length, ether 1 or 2.
N  *
N  * @return     None
N  *
N  * @details    Stop bit length must be 1 for T = 1 protocol and 2 for T = 0 protocol.
N  * \hideinitializer
N  */
N#define SC_SET_STOP_BIT_LEN(sc, u32Len) ((sc)->CTL = ((sc)->CTL & ~SC_CTL_NSB_Msk) | (((u32Len) == 1)? SC_CTL_NSB_Msk : 0))
N
N/**
N  * @brief      Set Tx Error Retry Count
N  *
N  * @param[in]  sc          The pointer of smartcard module.
N  * @param[in]  u32Count    The number of Tx error retry count, between 0~8 and 0 means disable Tx error retry function.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable/disable transmitter retry function when parity error has occurred, and set error retry count.
N  * @note       Set error retry count to 0 will disable Tx error retry function.
N  */
N__STATIC_INLINE void SC_SetTxRetry(SC_T *sc, uint32_t u32Count)
Xstatic __inline void SC_SetTxRetry(SC_T *sc, uint32_t u32Count)
N{
N    while((sc)->CTL & SC_CTL_SYNC_Msk);
X    while((sc)->CTL & (0x1ul << (30)));
N
N    if(u32Count == 0)         // Disable Tx error retry
N    {
N        (sc)->CTL &= ~(SC_CTL_TXRTY_Msk | SC_CTL_TXRTYEN_Msk);
X        (sc)->CTL &= ~((0x7ul << (20)) | (0x1ul << (23)));
N    }
N    else
N    {
N        (sc)->CTL = ((sc)->CTL & ~SC_CTL_TXRTY_Msk) | ((u32Count - 1) << SC_CTL_TXRTY_Pos) | SC_CTL_TXRTYEN_Msk;
X        (sc)->CTL = ((sc)->CTL & ~(0x7ul << (20))) | ((u32Count - 1) << (20)) | (0x1ul << (23));
N    }
N}
N
N/**
N  * @brief      Set Rx Error Retry Count
N  *
N  * @param[in]  sc          The pointer of smartcard module.
N  * @param[in]  u32Count    The number of Rx error retry count, between 0~8 and 0 means disable Rx error retry function.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable/disable receiver retry function when parity error has occurred, and set error retry count.
N  * @note       Set error retry count to 0 will disable Rx error retry function.
N  */
N__STATIC_INLINE void  SC_SetRxRetry(SC_T *sc, uint32_t u32Count)
Xstatic __inline void  SC_SetRxRetry(SC_T *sc, uint32_t u32Count)
N{
N    while((sc)->CTL & SC_CTL_SYNC_Msk);
X    while((sc)->CTL & (0x1ul << (30)));
N
N    if(u32Count == 0)         // Disable Rx error retry
N    {
N        (sc)->CTL &= ~(SC_CTL_RXRTY_Msk | SC_CTL_RXRTYEN_Msk);
X        (sc)->CTL &= ~((0x7ul << (16)) | (0x1ul << (19)));
N    }
N    else
N    {
N        (sc)->CTL = ((sc)->CTL & ~SC_CTL_RXRTY_Msk) | ((u32Count - 1) << SC_CTL_RXRTY_Pos) | SC_CTL_RXRTYEN_Msk;
X        (sc)->CTL = ((sc)->CTL & ~(0x7ul << (16))) | ((u32Count - 1) << (16)) | (0x1ul << (19));
N    }
N}
N
N
Nuint32_t SC_IsCardInserted(SC_T *sc);
Nvoid SC_ClearFIFO(SC_T *sc);
Nvoid SC_Close(SC_T *sc);
Nvoid SC_Open(SC_T *sc, uint32_t u32CardDet, uint32_t u32PWR);
Nvoid SC_ResetReader(SC_T *sc);
Nvoid SC_SetBlockGuardTime(SC_T *sc, uint32_t u32BGT);
Nvoid SC_SetCharGuardTime(SC_T *sc, uint32_t u32CGT);
Nvoid SC_StopAllTimer(SC_T *sc);
Nvoid SC_StartTimer(SC_T *sc, uint32_t u32TimerNum, uint32_t u32Mode, uint32_t u32ETUCount);
Nvoid SC_StopTimer(SC_T *sc, uint32_t u32TimerNum);
Nuint32_t SC_GetInterfaceClock(SC_T *sc);
N
N/*@}*/ /* end of group SC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group SC_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SC_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17576 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "scuart.h"
L 1 "..\lib\StdDriver\inc\scuart.h" 1
N/**************************************************************************//**
N * @file     scuart.h
N * @version  V3.00
N * $Revision: 7 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE series Smart Card UART(SCUART) driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __SCUART_H__
N#define __SCUART_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup SCUART_Driver SCUART Driver
N  @{
N*/
N
N/** @addtogroup SCUART_EXPORTED_CONSTANTS SCUART Exported Constants
N  @{
N*/
N#define SCUART_CHAR_LEN_5     (0x3ul << SC_UARTCTL_WLS_Pos)  /*!< Set SCUART word length to 5 bits */
N#define SCUART_CHAR_LEN_6     (0x2ul << SC_UARTCTL_WLS_Pos)  /*!< Set SCUART word length to 6 bits */
N#define SCUART_CHAR_LEN_7     (0x1ul << SC_UARTCTL_WLS_Pos)  /*!< Set SCUART word length to 7 bits */
N#define SCUART_CHAR_LEN_8     (0)                            /*!< Set SCUART word length to 8 bits */
N
N#define SCUART_PARITY_NONE    (SC_UARTCTL_PBOFF_Msk)         /*!< Set SCUART transfer with no parity   */
N#define SCUART_PARITY_ODD     (SC_UARTCTL_OPE_Msk)           /*!< Set SCUART transfer with odd parity  */
N#define SCUART_PARITY_EVEN    (0)                            /*!< Set SCUART transfer with even parity */
N
N#define SCUART_STOP_BIT_1     (SC_CTL_NSB_Msk)               /*!< Set SCUART transfer with one stop bit  */
N#define SCUART_STOP_BIT_2     (0)                            /*!< Set SCUART transfer with two stop bits */
N
N/*@}*/ /* end of group SCUART_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup SCUART_EXPORTED_FUNCTIONS SCUART Exported Functions
N  @{
N*/
N
N/* Tx Macros */
N/**
N  * @brief      Write Data to Tx Data Register
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  * @param[in]  u8Data  Data byte to transmit.
N  *
N  * @return     None
N  *
N  * @details    By writing data to DAT register, the SC will send out an 8-bit data.
N  * \hideinitializer
N  */
N#define SCUART_WRITE(sc, u8Data)    ((sc)-> DAT = (u8Data))
N
N/**
N  * @brief      Get Tx FIFO Empty Flag Status
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  *
N  * @retval     0                       Transmit FIFO is not empty
N  * @retval     SC_STATUS_TXEMPTY_Msk   Transmit FIFO is empty
N  *
N  * @details    When the last byte of Tx buffer has been transferred to Transmitter Shift Register, hardware sets TXEMPTY (SC_STATUS[9]) high.
N  *             It will be cleared when writing data into DAT (SC_DAT[7:0]).
N  * \hideinitializer
N  */
N#define SCUART_GET_TX_EMPTY(sc)     ((sc)->STATUS & SC_STATUS_TXEMPTY_Msk)
N
N/**
N  * @brief      Get Tx FIFO Full Flag Status
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  *
N  * @retval     0                       Transmit FIFO is not full
N  * @retval     SC_STATUS_TXFULL_Msk    Transmit FIFO is full
N  *
N  * @details    TXFULL (SC_STATUS[10]) is set when Tx buffer counts equals to 4, otherwise is cleared by hardware.
N  * \hideinitializer
N  */
N#define SCUART_GET_TX_FULL(sc)      ((sc)->STATUS & SC_STATUS_TXFULL_Msk)
N
N/**
N  * @brief      Wait specified Smartcard port Transmission Complete
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  *
N  * @return     None
N  *
N  * @details    TXACT (SC_STATUS[31]) is cleared automatically when Tx transfer is finished or the last byte transmission has completed.
N  *
N  * @note       This macro blocks until transmit complete.
N  * \hideinitializer
N  */
N#define SCUART_WAIT_TX_EMPTY(sc)    while((sc)->STATUS & SC_STATUS_TXACT_Msk)
N
N/**
N  * @brief      Check Tx FIFO Full Status
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  *
N  * @retval     0       Transmit FIFO is not full
N  * @retval     1       Transmit FIFO is full
N  *
N  * @details    TXFULL (SC_STATUS[10]) indicates Tx buffer full or not.
N  *             This bit is set when Tx buffer counts equals to 4, otherwise is cleared by hardware.
N  * \hideinitializer
N  */
N#define SCUART_IS_TX_FULL(sc)       (((sc)->STATUS & SC_STATUS_TXFULL_Msk)? 1 : 0)
N
N/**
N  * @brief      Check specified smartcard port transmission is over
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  *
N  * @retval     0       Transmit is not complete
N  * @retval     1       Transmit complete
N  */
N#define SCUART_IS_TX_EMPTY(sc) (((sc)->STATUS & SC_STATUS_TXACT_Msk)? 0 : 1)
N
N/**
N  * @brief      Check specified Smartcard port Transmission Status
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  *
N  * @retval     0       Transmit is completed
N  * @retval     1       Transmit is active
N  *
N  * @details    TXACT (SC_STATUS[31]) is set by hardware when Tx transfer is in active and the STOP bit of the last byte has been transmitted.
N  * \hideinitializer
N  */
N#define SCUART_IS_TX_ACTIVE(sc)     (((sc)->STATUS & SC_STATUS_TXACT_Msk)? 1 : 0)
N
N
N/* RX Macros */
N/**
N  * @brief      Read Rx Data Register
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  *
N  * @return     The oldest data byte in RX FIFO
N  *
N  * @details    By reading DAT register, the SC will return an 8-bit received data.
N  * \hideinitializer
N  */
N#define SCUART_READ(sc)         ((sc)->DAT)
N
N/**
N  * @brief      Get Rx FIFO Empty Flag Status
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  *
N  * @retval     0                       Receive FIFO is not empty
N  * @retval     SC_STATUS_RXEMPTY_Msk   Receive FIFO is empty
N  *
N  * @details    When the last byte of Rx buffer has been read by CPU, hardware sets RXEMPTY (SC_STATUS[1]) high.
N  *             It will be cleared when SC receives any new data.
N  * \hideinitializer
N  */
N#define SCUART_GET_RX_EMPTY(sc) ((sc)->STATUS & SC_STATUS_RXEMPTY_Msk)
N
N/**
N  * @brief      Get Rx FIFO Full Flag Status
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  *
N  * @retval     0                       Receive FIFO is not full
N  * @retval     SC_STATUS_TXFULL_Msk    Receive FIFO is full
N  *
N  * @details    RXFULL (SC_STATUS[2]) is set when Rx buffer counts equals to 4, otherwise it is cleared by hardware.
N  * \hideinitializer
N  */
N#define SCUART_GET_RX_FULL(sc)  ((sc)->STATUS & SC_STATUS_RXFULL_Msk)
N
N/**
N  * @brief      Check Rx FIFO Reach FIFO Trigger Level Status
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  *
N  * @retval     0       The number of bytes in Rx FIFO is less than trigger level.
N  * @retval     1       The number of bytes in Rx FIFO equals or larger than trigger level.
N  *
N  * @details    RDAIF (SC_INTSTS[0]) is used for received data reaching trigger level RXTRGLV (SC_CTL[7:6]) interrupt status flag.
N  *
N  * @note       If receive trigger level is \b not 1 byte, this macro return 0 does not necessary indicates there is no data in FIFO.
N  * \hideinitializer
N  */
N#define SCUART_IS_RX_READY(sc)  (((sc)->INTSTS & SC_INTSTS_RDAIF_Msk)? 1 : 0)
N
N/**
N  * @brief      Check Rx FIFO Full Status
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  *
N  * @retval     0       Receive FIFO is not full
N  * @retval     1       Receive FIFO is full
N  *
N  * @details    RXFULLF( SC_STATUS[2]) is set when Rx buffer counts equals to 4, otherwise it is cleared by hardware.
N  * \hideinitializer
N  */
N#define SCUART_IS_RX_FULL(sc)   (((sc)->STATUS & SC_STATUS_RXFULL_Msk)? 1 : 0)
N
N
N/* Interrupt Macros */
N/**
N  * @brief      Enable specified SCUART Interrupt Function
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  * @param[in]  u32Mask Interrupt masks to enable, a combination of following bits.
N  *                         - \ref SC_INTEN_RXTOIEN_Msk
N  *                         - \ref SC_INTEN_TERRIEN_Msk
N  *                         - \ref SC_INTEN_TXEIEN_Msk
N  *                         - \ref SC_INTEN_RDAIEN_Msk
N  *
N  * @return     None
N  *
N  * @details    The macro is used to enable receiver buffer time-out interrupt, transfer error interrupt,
N  *             transmit buffer empty interrupt or receive data reach trigger level interrupt.
N  * \hideinitializer
N  */
N#define SCUART_ENABLE_INT(sc, u32Mask)  ((sc)->INTEN |= (u32Mask))
N
N/**
N  * @brief      Disable specified SCUART Interrupt Function
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  * @param[in]  u32Mask Interrupt masks to disable, a combination of following bits.
N  *                         - \ref SC_INTEN_RXTOIEN_Msk
N  *                         - \ref SC_INTEN_TERRIEN_Msk
N  *                         - \ref SC_INTEN_TXEIEN_Msk
N  *                         - \ref SC_INTEN_RDAIEN_Msk
N  *
N  * @return     None
N  *
N  * @details    The macro is used to disable receiver buffer time-out interrupt, transfer error interrupt,
N  *             transmit buffer empty interrupt or receive data reach trigger level interrupt.
N  * \hideinitializer
N  */
N#define SCUART_DISABLE_INT(sc, u32Mask) ((sc)->INTEN &= ~(u32Mask))
N
N/**
N  * @brief      Get specified SCUART Interrupt Status
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  * @param[in]  u32Type Interrupt status to check, could be one of following value:
N  *                         - \ref SC_INTSTS_RXTOIF_Msk
N  *                         - \ref SC_INTSTS_TERRIF_Msk
N  *                         - \ref SC_INTSTS_TXEIF_Msk
N  *                         - \ref SC_INTSTS_RDAIF_Msk
N  *
N  * @retval     0       Specified interrupt does not happened.
N  * @retval     1       Specified interrupt happened.
N  *
N  * @details    The macro is used to get receiver buffer time-out interrupt status, transfer error interrupt status,
N  *             transmit buffer empty interrupt status or receive data reach interrupt status.
N  * \hideinitializer
N  */
N#define SCUART_GET_INT_FLAG(sc, u32Type)    (((sc)->INTSTS & (u32Type))? 1 : 0)
N
N/**
N  * @brief      Clear specified SCUART Interrupt Flag
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  * @param[in]  u32Type Interrupt flag to clear, could be the combination of following values:
N  *                         - \ref SC_INTSTS_RXTOIF_Msk
N  *                         - \ref SC_INTSTS_TERRIF_Msk
N  *                         - \ref SC_INTSTS_TXEIF_Msk
N  *
N  * @return     None
N  *
N  * @details    The macro is used to clear transfer error interrupt flag.
N  * \hideinitializer
N  */
N#define SCUART_CLR_INT_FLAG(sc, u32Type)    ((sc)->INTSTS = (u32Type))
N
N/**
N  * @brief      Get SCUART Receiver Error Flag Status
N  *
N  * @param[in]  sc  The pointer of smartcard module.
N  *
N  * @retval     SC_STATUS_PEF_Msk   Rx parity error
N  * @retval     SC_STATUS_FEF_Msk   Rx frame error
N  * @retval     SC_STATUS_BEF_Msk   Rx break error
N  *
N  * @details    The macro is used to get receiver parity error status, frame error status or break error status.
N  * \hideinitializer
N  */
N#define SCUART_GET_ERR_FLAG(sc)             ((sc)->STATUS & (SC_STATUS_PEF_Msk | SC_STATUS_FEF_Msk | SC_STATUS_BEF_Msk))
N
N/**
N  * @brief      Clear specified Receiver Error Flag
N  *
N  * @param[in]  sc      The pointer of smartcard module.
N  * @param[in]  u32Mask Receiver error flag to clear, combination following values:
N  *                         - \ref SC_STATUS_PEF_Msk
N  *                         - \ref SC_STATUS_FEF_Msk
N  *                         - \ref SC_STATUS_BEF_Msk
N  *
N  * @return     None
N  *
N  * @details    The macro is used to clear receiver parity error flag, frame error flag or break error flag.
N  * \hideinitializer
N  */
N#define SCUART_CLR_ERR_FLAG(sc, u32Mask)    ((sc)->STATUS = (u32Mask))
N
Nvoid SCUART_Close(SC_T* sc);
Nuint32_t SCUART_Open(SC_T* sc, uint32_t u32Baudrate);
Nuint32_t SCUART_Read(SC_T* sc, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
Nuint32_t SCUART_SetLineConfig(SC_T* sc, uint32_t u32Baudrate, uint32_t u32DataWidth, uint32_t u32Parity, uint32_t u32StopBits);
Nvoid SCUART_SetTimeoutCnt(SC_T* sc, uint32_t u32TOC);
Nvoid SCUART_Write(SC_T* sc, uint8_t *pu8TxBuf, uint32_t u32WriteBytes);
N
N/*@}*/ /* end of group SCUART_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group SCUART_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SCUART_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17577 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "usci_spi.h"
L 1 "..\lib\StdDriver\inc\usci_spi.h" 1
N/****************************************************************************//**
N * @file     usci_spi.h
N * @version  V3.00
N * $Revision: 9 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE series USCI_SPI driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __USCI_SPI_H__
N#define __USCI_SPI_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup USCI_SPI_Driver USCI_SPI Driver
N  @{
N*/
N
N/** @addtogroup USCI_SPI_EXPORTED_CONSTANTS USCI_SPI Exported Constants
N  @{
N*/
N
N#define USPI_MODE_0        (0x0 << USPI_PROTCTL_SCLKMODE_Pos)        /*!< SCLK idle low; data transmit with falling edge and receive with rising edge */
N#define USPI_MODE_1        (0x1 << USPI_PROTCTL_SCLKMODE_Pos)        /*!< SCLK idle low; data transmit with rising edge and receive with falling edge */
N#define USPI_MODE_2        (0x2 << USPI_PROTCTL_SCLKMODE_Pos)        /*!< SCLK idle high; data transmit with rising edge and receive with falling edge */
N#define USPI_MODE_3        (0x3 << USPI_PROTCTL_SCLKMODE_Pos)        /*!< SCLK idle high; data transmit with falling edge and receive with rising edge */
N
N#define USPI_SLAVE         (USPI_PROTCTL_SLAVE_Msk)                  /*!< Set as slave */
N#define USPI_MASTER        (0x0)                                     /*!< Set as master */
N
N#define USPI_SS                (USPI_PROTCTL_SS_Msk)                 /*!< Set SS */
N#define USPI_SS_ACTIVE_HIGH    (0x0)                                 /*!< SS active high */
N#define USPI_SS_ACTIVE_LOW     (USPI_LINECTL_CTLOINV_Msk)            /*!< SS active low */
N
N/* USCI_SPI Interrupt Mask */
N#define USPI_SSINACT_INT_MASK        (0x001)                         /*!< Slave Slave Inactive interrupt mask */
N#define USPI_SSACT_INT_MASK          (0x002)                         /*!< Slave Slave Active interrupt mask */
N#define USPI_SLVTO_INT_MASK          (0x004)                         /*!< Slave Mode Time-out interrupt mask */
N#define USPI_SLVBE_INT_MASK          (0x008)                         /*!< Slave Mode Bit Count Error interrupt mask */
N#define USPI_TXUDR_INT_MASK          (0x010)                         /*!< Slave Transmit Under Run interrupt mask */
N#define USPI_RXOV_INT_MASK           (0x020)                         /*!< Receive Buffer Overrun interrupt mask */
N#define USPI_TXST_INT_MASK           (0x040)                         /*!< Transmit Start interrupt mask */
N#define USPI_TXEND_INT_MASK          (0x080)                         /*!< Transmit End interrupt mask */
N#define USPI_RXST_INT_MASK           (0x100)                         /*!< Receive Start interrupt mask */
N#define USPI_RXEND_INT_MASK          (0x200)                         /*!< Receive End interrupt mask */
N
N/* USCI_SPI Status Mask */
N#define USPI_BUSY_MASK               (0x01)                          /*!< Busy status mask */
N#define USPI_RX_EMPTY_MASK           (0x02)                          /*!< RX empty status mask */
N#define USPI_RX_FULL_MASK            (0x04)                          /*!< RX full status mask */
N#define USPI_TX_EMPTY_MASK           (0x08)                          /*!< TX empty status mask */
N#define USPI_TX_FULL_MASK            (0x10)                          /*!< TX full status mask */
N#define USPI_SSLINE_STS_MASK         (0x20)                          /*!< USCI_SPI_SS line status mask */
N
N/*@}*/ /* end of group USCI_SPI_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup USCI_SPI_EXPORTED_FUNCTIONS USCI_SPI Exported Functions
N  @{
N*/
N
N/**
N  * @brief  Disable slave 3-wire mode.
N  * @param[in]  uspi The pointer of the specified USCI_SPI module.
N  * @return None
N  * \hideinitializer
N  */
N#define USPI_DISABLE_3WIRE_MODE(uspi) ( (uspi)->PROTCTL &= ~USPI_PROTCTL_SLV3WIRE_Msk )
N
N/**
N  * @brief  Enable slave 3-wire mode.
N  * @param[in]  uspi The pointer of the specified USCI_SPI module.
N  * @return None
N  * \hideinitializer
N  */
N#define USPI_ENABLE_3WIRE_MODE(uspi) ( (uspi)->PROTCTL |= USPI_PROTCTL_SLV3WIRE_Msk )
N
N/**
N  * @brief  Get the Rx buffer empty flag.
N  * @param[in]  uspi The pointer of the specified USCI_SPI module.
N  * @return Rx buffer flag
N  * @retval 0: Rx buffer is not empty
N  * @retval 1: Rx buffer is empty
N  * \hideinitializer
N  */
N#define USPI_GET_RX_EMPTY_FLAG(uspi) ( ((uspi)->BUFSTS & USPI_BUFSTS_RXEMPTY_Msk) == USPI_BUFSTS_RXEMPTY_Msk ? 1:0 )
N
N/**
N  * @brief  Get the Tx buffer empty flag.
N  * @param[in]  uspi The pointer of the specified USCI_SPI module.
N  * @return Tx buffer flag
N  * @retval 0: Tx buffer is not empty
N  * @retval 1: Tx buffer is empty
N  * \hideinitializer
N  */
N#define USPI_GET_TX_EMPTY_FLAG(uspi) ( ((uspi)->BUFSTS & USPI_BUFSTS_TXEMPTY_Msk) == USPI_BUFSTS_TXEMPTY_Msk ? 1:0 )
N
N/**
N  * @brief  Get the Tx buffer full flag.
N  * @param[in]  uspi The pointer of the specified USCI_SPI module.
N  * @return Tx buffer flag
N  * @retval 0: Tx buffer is not full
N  * @retval 1: Tx buffer is full
N  * \hideinitializer
N  */
N#define USPI_GET_TX_FULL_FLAG(uspi) ( ((uspi)->BUFSTS & USPI_BUFSTS_TXFULL_Msk) == USPI_BUFSTS_TXFULL_Msk ? 1:0 )
N
N/**
N  * @brief  Get the datum read from RX register.
N  * @param[in]  uspi The pointer of the specified USCI_SPI module.
N  * @return data in Rx register
N  * \hideinitializer
N  */
N#define USPI_READ_RX(uspi) ((uspi)->RXDAT)
N
N/**
N  * @brief  Write datum to TX register.
N  * @param[in]  uspi The pointer of the specified USCI_SPI module.
N  * @param[in]  u32TxData The datum which user attempt to transfer through USCI_SPI bus.
N  * @return None
N  * \hideinitializer
N  */
N#define USPI_WRITE_TX(uspi, u32TxData) ( (uspi)->TXDAT = u32TxData )
N
N/**
N  * @brief      Set USCI_SPI_SS pin to high state.
N  * @param[in]  uspi The pointer of the specified USCI_SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set USCI_SPI_SS pin to high state. Only available in Master mode.
N  * \hideinitializer
N  */
N#define USPI_SET_SS_HIGH(uspi) \
N    do{ \
N        (uspi)->LINECTL |= (USPI_LINECTL_CTLOINV_Msk); \
N        (uspi)->PROTCTL = ((uspi)->PROTCTL & ~(USPI_PROTCTL_AUTOSS_Msk | USPI_PROTCTL_SS_Msk)); \
N    }while(0)
X#define USPI_SET_SS_HIGH(uspi)     do{         (uspi)->LINECTL |= (USPI_LINECTL_CTLOINV_Msk);         (uspi)->PROTCTL = ((uspi)->PROTCTL & ~(USPI_PROTCTL_AUTOSS_Msk | USPI_PROTCTL_SS_Msk));     }while(0)
N
N/**
N  * @brief      Set USCI_SPI_SS pin to low state.
N  * @param[in]  uspi The pointer of the specified USCI_SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set USCI_SPI_SS pin to low state. Only available in Master mode.
N  * \hideinitializer
N  */
N#define USPI_SET_SS_LOW(uspi) \
N    do{ \
N        (uspi)->LINECTL |= (USPI_LINECTL_CTLOINV_Msk); \
N        (uspi)->PROTCTL = (((uspi)->PROTCTL & ~USPI_PROTCTL_AUTOSS_Msk) | USPI_PROTCTL_SS_Msk); \
N    }while(0)
X#define USPI_SET_SS_LOW(uspi)     do{         (uspi)->LINECTL |= (USPI_LINECTL_CTLOINV_Msk);         (uspi)->PROTCTL = (((uspi)->PROTCTL & ~USPI_PROTCTL_AUTOSS_Msk) | USPI_PROTCTL_SS_Msk);     }while(0)
N
N/**
N  * @brief  Set the length of suspend interval.
N  * @param[in]  uspi The pointer of the specified USCI_SPI module.
N  * @param[in]  u32SuspCycle Decide the length of suspend interval.
N  * @return None
N  * \hideinitializer
N  */
N#define USPI_SET_SUSPEND_CYCLE(uspi, u32SuspCycle) ( (uspi)->PROTCTL = ((uspi)->PROTCTL & ~USPI_PROTCTL_SUSPITV_Msk) | (u32SuspCycle << USPI_PROTCTL_SUSPITV_Pos) )
N
N/**
N  * @brief  Set the USCI_SPI transfer sequence with LSB first.
N  * @param[in]  uspi The pointer of the specified USCI_SPI module.
N  * @return None
N  * \hideinitializer
N  */
N#define USPI_SET_LSB_FIRST(uspi) ( (uspi)->LINECTL |= USPI_LINECTL_LSB_Msk )
N
N/**
N  * @brief  Set the USCI_SPI transfer sequence with MSB first.
N  * @param[in]  uspi The pointer of the specified USCI_SPI module.
N  * @return None
N  * \hideinitializer
N  */
N#define USPI_SET_MSB_FIRST(uspi) ( (uspi)->LINECTL &= ~USPI_LINECTL_LSB_Msk )
N
N/**
N  * @brief  Set the data width of a USCI_SPI transaction.
N  * @param[in]  uspi The pointer of the specified USCI_SPI module.
N  * @param[in]  u32Width The data width
N  * @return None
N  * \hideinitializer
N  */
Nstatic __INLINE void USPI_SET_DATA_WIDTH(USPI_T *uspi, uint32_t u32Width)
Xstatic __inline void USPI_SET_DATA_WIDTH(USPI_T *uspi, uint32_t u32Width)
N{
N    if(u32Width == 16)
N        u32Width = 0;
N
N    uspi->LINECTL = (uspi->LINECTL & ~USPI_LINECTL_DWIDTH_Msk) | (u32Width << USPI_LINECTL_DWIDTH_Pos);
X    uspi->LINECTL = (uspi->LINECTL & ~(0xful << (8))) | (u32Width << (8));
N}
N
N/**
N  * @brief  Get the USCI_SPI busy state.
N  * @param[in]  uspi The pointer of the specified USCI_SPI module.
N  * @return USCI_SPI busy status
N  * @retval 0: USCI_SPI module is not busy
N  * @retval 1: USCI_SPI module is busy
N  * \hideinitializer
N  */
N#define USPI_IS_BUSY(uspi) ( ((uspi)->PROTSTS & USPI_PROTSTS_BUSY_Msk) == USPI_PROTSTS_BUSY_Msk ? 1:0 )
N
N/**
N  * @brief Get the USCI_SPI wakeup flag.
N  * @param[in] uspi The pointer of the specified USCI_SPI module.
N  * @return Wakeup status.
N  * @retval 0 Flag is not set.
N  * @retval 1 Flag is set.
N  * \hideinitializer
N  */
N#define USPI_GET_WAKEUP_FLAG(uspi) ( ((uspi)->WKSTS & USPI_WKSTS_WKF_Msk) == USPI_WKSTS_WKF_Msk ? 1:0)
N
N/**
N  * @brief Clear the USCI_SPI wakeup flag.
N  * @param[in] uspi The pointer of the specified USCI_SPI module.
N  * @return None
N  * \hideinitializer
N  */
N#define USPI_CLR_WAKEUP_FLAG(uspi)  ( (uspi)->WKSTS |= USPI_WKSTS_WKF_Msk)
N
N/**
N  * @brief Get protocol interrupt flag/status.
N  * @param[in] uspi The pointer of the specified USCI_SPI module.
N  * @return The interrupt flag/status of protocol status register.
N  * \hideinitializer
N  */
N#define USPI_GET_PROT_STATUS(uspi)    ( (uspi)->PROTSTS)
N
N/**
N  * @brief Clear specified protocol interrupt flag.
N  * @param[in] uspi The pointer of the specified USCI_SPI module.
N  * @param[in] u32IntTypeFlag Interrupt Type Flag, should be
N  *                                  - \ref USPI_PROTSTS_SSACTIF_Msk
N  *                                  - \ref USPI_PROTSTS_SSINAIF_Msk
N  *                                  - \ref USPI_PROTSTS_SLVBEIF_Msk
N  *                                  - \ref USPI_PROTSTS_SLVTOIF_Msk
N  *                                  - \ref USPI_PROTSTS_RXENDIF_Msk
N  *                                  - \ref USPI_PROTSTS_RXSTIF_Msk
N  *                                  - \ref USPI_PROTSTS_TXENDIF_Msk
N  *                                  - \ref USPI_PROTSTS_TXSTIF_Msk
N  * @return None
N  * \hideinitializer
N  */
N#define USPI_CLR_PROT_INT_FLAG(uspi,u32IntTypeFlag)    ( (uspi)->PROTSTS = u32IntTypeFlag)
N
N/**
N  * @brief Get buffer interrupt flag/status.
N  * @param[in] uspi The pointer of the specified USCI_SPI module.
N  * @return The interrupt flag/status of buffer status register.
N  * \hideinitializer
N  */
N#define USPI_GET_BUF_STATUS(uspi)    ( (uspi)->BUFSTS)
N
N/**
N  * @brief Clear specified buffer interrupt flag.
N  * @param[in] uspi The pointer of the specified USCI_SPI module.
N  * @param[in] u32IntTypeFlag Interrupt Type Flag, should be
N  *                                  - \ref USPI_BUFSTS_TXUDRIF_Msk
N  *                                  - \ref USPI_BUFSTS_RXOVIF_Msk
N  * @return None
N  * \hideinitializer
N  */
N#define USPI_CLR_BUF_INT_FLAG(uspi,u32IntTypeFlag)    ( (uspi)->BUFSTS = u32IntTypeFlag)
N
N/**
N  * @brief Enable specified protocol interrupt.
N  * @param[in] uspi The pointer of the specified USCI_SPI module.
N  * @param[in] u32IntSel Interrupt Type, should be
N  *                                  - \ref USPI_PROTIEN_SLVBEIEN_Msk
N  *                                  - \ref USPI_PROTIEN_SLVTOIEN_Msk
N  *                                  - \ref USPI_PROTIEN_SSACTIEN_Msk
N  *                                  - \ref USPI_PROTIEN_SSINAIEN_Msk
N  * @return None
N  * \hideinitializer
N  */
N#define USPI_ENABLE_PROT_INT(uspi, u32IntSel)    ((uspi)->PROTIEN |= (u32IntSel))
N
N/**
N  * @brief Disable specified protocol interrupt.
N  * @param[in] uspi The pointer of the specified USCI_SPI module.
N  * @param[in] u32IntSel Interrupt Type, should be
N  *                                  - \ref USPI_PROTIEN_SLVBEIEN_Msk
N  *                                  - \ref USPI_PROTIEN_SLVTOIEN_Msk
N  *                                  - \ref USPI_PROTIEN_SSACTIEN_Msk
N  *                                  - \ref USPI_PROTIEN_SSINAIEN_Msk
N  * @return None
N  * \hideinitializer
N  */
N#define USPI_DISABLE_PROT_INT(uspi, u32IntSel)    ((uspi)->PROTIEN &= ~ (u32IntSel))
N
N/**
N  * @brief Enable specified buffer interrupt.
N  * @param[in] uspi The pointer of the specified USCI_SPI module.
N  * @param[in] u32IntSel Interrupt Type, should be
N  *                                  - \ref USPI_BUFCTL_RXOVIEN_Msk
N  *                                  - \ref USPI_BUFCTL_TXUDRIEN_Msk
N  * @return None
N  * \hideinitializer
N  */
N#define USPI_ENABLE_BUF_INT(uspi, u32IntSel)    ((uspi)->BUFCTL |= (u32IntSel))
N
N/**
N  * @brief Disable specified buffer interrupt.
N  * @param[in] uspi The pointer of the specified USCI_SPI module.
N  * @param[in] u32IntSel Interrupt Type, should be
N  *                                  - \ref USPI_BUFCTL_RXOVIEN_Msk
N  *                                  - \ref USPI_BUFCTL_TXUDRIEN_Msk
N  * @return None
N  * \hideinitializer
N  */
N#define USPI_DISABLE_BUF_INT(uspi, u32IntSel)    ((uspi)->BUFCTL &= ~ (u32IntSel))
N
N/**
N  * @brief Enable specified transfer interrupt.
N  * @param[in] uspi The pointer of the specified USCI_SPI module.
N  * @param[in] u32IntSel Interrupt Type, should be
N  *                                  - \ref USPI_INTEN_RXENDIEN_Msk
N  *                                  - \ref USPI_INTEN_RXSTIEN_Msk
N  *                                  - \ref USPI_INTEN_TXENDIEN_Msk
N  *                                  - \ref USPI_INTEN_TXSTIEN_Msk
N  * @return None
N  * \hideinitializer
N  */
N#define USPI_ENABLE_TRANS_INT(uspi, u32IntSel)    ((uspi)->INTEN |= (u32IntSel))
N
N/**
N  * @brief Disable specified transfer interrupt.
N  * @param[in] uspi The pointer of the specified USCI_SPI module.
N  * @param[in] u32IntSel Interrupt Type, should be
N  *                                  - \ref USPI_INTEN_RXENDIEN_Msk
N  *                                  - \ref USPI_INTEN_RXSTIEN_Msk
N  *                                  - \ref USPI_INTEN_TXENDIEN_Msk
N  *                                  - \ref USPI_INTEN_TXSTIEN_Msk
N  * @return None
N  * \hideinitializer
N  */
N#define USPI_DISABLE_TRANS_INT(uspi, u32IntSel)    ((uspi)->INTEN &= ~ (u32IntSel))
N
Nuint32_t USPI_Open(USPI_T *uspi, uint32_t u32MasterSlave, uint32_t u32SPIMode,  uint32_t u32DataWidth, uint32_t u32BusClock);
Nvoid USPI_Close(USPI_T *uspi);
Nvoid USPI_ClearRxBuf(USPI_T *uspi);
Nvoid USPI_ClearTxBuf(USPI_T *uspi);
Nvoid USPI_DisableAutoSS(USPI_T *uspi);
Nvoid USPI_EnableAutoSS(USPI_T *uspi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel);
Nuint32_t USPI_SetBusClock(USPI_T *uspi, uint32_t u32BusClock);
Nuint32_t USPI_GetBusClock(USPI_T *uspi);
Nvoid USPI_EnableInt(USPI_T *uspi, uint32_t u32Mask);
Nvoid USPI_DisableInt(USPI_T *uspi, uint32_t u32Mask);
Nuint32_t USPI_GetIntFlag(USPI_T *uspi, uint32_t u32Mask);
Nvoid USPI_ClearIntFlag(USPI_T *uspi, uint32_t u32Mask);
Nuint32_t USPI_GetStatus(USPI_T *uspi, uint32_t u32Mask);
Nvoid USPI_EnableWakeup(USPI_T *uspi);
Nvoid USPI_DisableWakeup(USPI_T *uspi);
N
N
N/*@}*/ /* end of group USCI_SPI_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group USCI_SPI_Driver */
N
N/*@}*/ /* end of group Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__USCI_SPI_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17578 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "usci_uart.h"
L 1 "..\lib\StdDriver\inc\usci_uart.h" 1
N/******************************************************************************
N * @file     usci_uart.h
N * @version  V3.00
N * $Revision: 8 $
N * $Date: 16/10/25 4:25p $
N * @brief    NUC029xGE series USCI UART (UUART) driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __USCI_UART_H__
N#define __USCI_UART_H__
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup USCI_UART_Driver USCI_UART Driver
N  @{
N*/
N
N/** @addtogroup USCI_UART_EXPORTED_CONSTANTS USCI_UART Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UUART_LINECTL constants definitions                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UUART_WORD_LEN_6     (6 << UUART_LINECTL_DWIDTH_Pos) /*!< UUART_LINECTL setting to set UART word length to 6 bits */
N#define UUART_WORD_LEN_7     (7 << UUART_LINECTL_DWIDTH_Pos) /*!< UUART_LINECTL setting to set UART word length to 7 bits */
N#define UUART_WORD_LEN_8     (8 << UUART_LINECTL_DWIDTH_Pos) /*!< UUART_LINECTL setting to set UART word length to 8 bits */
N#define UUART_WORD_LEN_9     (9 << UUART_LINECTL_DWIDTH_Pos) /*!< UUART_LINECTL setting to set UART word length to 9 bits */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UUART_PROTCTL constants definitions                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UUART_PARITY_NONE    (0x0 << UUART_PROTCTL_PARITYEN_Pos)    /*!< UUART_PROTCTL setting to set UART as no parity */
N#define UUART_PARITY_ODD     (0x1 << UUART_PROTCTL_PARITYEN_Pos)    /*!< UUART_PROTCTL setting to set UART as odd parity */
N#define UUART_PARITY_EVEN    (0x3 << UUART_PROTCTL_PARITYEN_Pos)    /*!< UUART_PROTCTL setting to set UART as even parity */
N
N#define UUART_STOP_BIT_1     (0x0) /*!< UUART_PROTCTL setting for one stop bit */
N#define UUART_STOP_BIT_2     (0x1) /*!< UUART_PROTCTL setting for two stop bit */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* USCI UART interrupt mask definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UUART_ABR_INT_MASK      (0x002) /*!< Auto-baud rate interrupt mask */
N#define UUART_RLS_INT_MASK      (0x004) /*!< Receive line status interrupt mask */
N#define UUART_BUF_RXOV_INT_MASK (0x008) /*!< Buffer RX overrun interrupt mask */
N#define UUART_TXST_INT_MASK     (0x010) /*!< TX start interrupt mask */
N#define UUART_TXEND_INT_MASK    (0x020) /*!< Tx end interrupt mask */
N#define UUART_RXST_INT_MASK     (0x040) /*!< RX start interrupt mask */
N#define UUART_RXEND_INT_MASK    (0x080) /*!< RX end interrupt mask */
N
N
N/*@}*/ /* end of group USCI_UART_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup USCI_UART_EXPORTED_FUNCTIONS USCI_UART Exported Functions
N  @{
N*/
N
N
N/**
N *    @brief        Write USCI_UART data
N *
N *    @param[in]    uuart   The pointer of the specified USCI_UART module
N *    @param[in]    u8Data  Data byte to transmit.
N *
N *    @return       None
N *
N *    @details      This macro write Data to Tx data register.
N */
N#define UUART_WRITE(uuart, u8Data)    ((uuart)->TXDAT = (u8Data))
N
N
N/**
N *    @brief        Read USCI_UART data
N *
N *    @param[in]    uuart    The pointer of the specified USCI_UART module
N *
N *    @return       The oldest data byte in RX buffer.
N *
N *    @details      This macro read Rx data register.
N */
N#define UUART_READ(uuart)    ((uuart)->RXDAT)
N
N
N/**
N *    @brief        Get Tx empty
N *
N *    @param[in]    uuart    The pointer of the specified USCI_UART module
N *
N *    @retval       0   Tx buffer is not empty
N *    @retval       >=1 Tx buffer is empty
N *
N *    @details      This macro get Transmitter buffer empty register value.
N */
N#define UUART_GET_TX_EMPTY(uuart)    ((uuart)->BUFSTS & UUART_BUFSTS_TXEMPTY_Msk)
N
N
N/**
N *    @brief        Get Rx empty
N *
N *    @param[in]    uuart    The pointer of the specified USCI_UART module
N *
N *    @retval       0   Rx buffer is not empty
N *    @retval       >=1 Rx buffer is empty
N *
N *    @details      This macro get Receiver buffer empty register value.
N */
N#define UUART_GET_RX_EMPTY(uuart)    ((uuart)->BUFSTS & UUART_BUFSTS_RXEMPTY_Msk)
N
N
N/**
N *    @brief        Check specified usci_uart port transmission is over.
N *
N *    @param[in]    uuart    The pointer of the specified USCI_UART module
N *
N *    @retval       0 Tx transmission is not over
N *    @retval       1 Tx transmission is over
N *
N *    @details      This macro return Transmitter Empty Flag register bit value. \n
N *                  It indicates if specified usci_uart port transmission is over nor not.
N */
N#define UUART_IS_TX_EMPTY(uuart)    (((uuart)->BUFSTS & UUART_BUFSTS_TXEMPTY_Msk) >> UUART_BUFSTS_TXEMPTY_Pos)
N
N
N/**
N *    @brief        Check specified usci_uart port receiver is empty.
N *
N *    @param[in]    uuart    The pointer of the specified USCI_UART module
N *
N *    @retval       0 Rx receiver is not empty
N *    @retval       1 Rx receiver is empty
N *
N *    @details      This macro return Receive Empty Flag register bit value. \n
N *                  It indicates if specified usci_uart port receiver is empty nor not.
N */
N#define UUART_IS_RX_EMPTY(uuart)    (((uuart)->BUFSTS & UUART_BUFSTS_RXEMPTY_Msk) >> UUART_BUFSTS_RXEMPTY_Pos)
N
N
N/**
N *    @brief        Wait specified usci_uart port transmission is over
N *
N *    @param[in]    uuart    The pointer of the specified USCI_UART module
N *
N *    @return       None
N *
N *    @details      This macro wait specified usci_uart port transmission is over.
N */
N#define UUART_WAIT_TX_EMPTY(uuart)    while(!((((uuart)->BUFSTS) & UUART_BUFSTS_TXEMPTY_Msk) >> UUART_BUFSTS_TXEMPTY_Pos))
N
N
N/**
N *    @brief        Check TX buffer is full or not
N *
N *    @param[in]    uuart    The pointer of the specified USCI_UART module
N *
N *    @retval       1 TX buffer is full
N *    @retval       0 TX buffer is not full
N *
N *    @details      This macro check TX buffer is full or not.
N */
N#define UUART_IS_TX_FULL(uuart)    (((uuart)->BUFSTS & UUART_BUFSTS_TXFULL_Msk)>>UUART_BUFSTS_TXFULL_Pos)
N
N
N/**
N *    @brief        Check RX buffer is full or not
N *
N *    @param[in]    uuart    The pointer of the specified USCI_UART module
N *
N *    @retval       1 RX buffer is full
N *    @retval       0 RX buffer is not full
N *
N *    @details      This macro check RX buffer is full or not.
N */
N#define UUART_IS_RX_FULL(uuart)    (((uuart)->BUFSTS & UUART_BUFSTS_RXFULL_Msk)>>UUART_BUFSTS_RXFULL_Pos)
N
N
N/**
N *    @brief        Get Tx full register value
N *
N *    @param[in]    uuart    The pointer of the specified USCI_UART module
N *
N *    @retval       0   Tx buffer is not full.
N *    @retval       >=1 Tx buffer is full.
N *
N *    @details      This macro get Tx full register value.
N */
N#define UUART_GET_TX_FULL(uuart)    ((uuart)->BUFSTS & UUART_BUFSTS_TXFULL_Msk)
N
N
N/**
N *    @brief        Get Rx full register value
N *
N *    @param[in]    uuart    The pointer of the specified USCI_UART module
N *
N *    @retval       0   Rx buffer is not full.
N *    @retval       >=1 Rx buffer is full.
N *
N *    @details      This macro get Rx full register value.
N */
N#define UUART_GET_RX_FULL(uuart)    ((uuart)->BUFSTS & UUART_BUFSTS_RXFULL_Msk)
N
N
N/**
N *    @brief        Enable specified USCI_UART protocol interrupt
N *
N *    @param[in]    uuart      The pointer of the specified USCI_UART module
N *    @param[in]    u32IntSel  Interrupt type select
N *                             - \ref UUART_PROTIEN_RLSIEN_Msk   : Rx Line status interrupt
N *                             - \ref UUART_PROTIEN_ABRIEN_Msk   : Auto-baud rate interrupt
N *
N *    @return       None
N *
N *    @details      This macro enable specified USCI_UART protocol interrupt.
N */
N#define UUART_ENABLE_PROT_INT(uuart, u32IntSel)    ((uuart)->PROTIEN |= (u32IntSel))
N
N
N/**
N *    @brief        Disable specified USCI_UART protocol interrupt
N *
N *    @param[in]    uuart      The pointer of the specified USCI_UART module
N *    @param[in]    u32IntSel  Interrupt type select
N *                             - \ref UUART_PROTIEN_RLSIEN_Msk   : Rx Line status interrupt
N *                             - \ref UUART_PROTIEN_ABRIEN_Msk   : Auto-baud rate interrupt
N *
N *    @return       None
N *
N *    @details      This macro disable specified USCI_UART protocol interrupt.
N */
N#define UUART_DISABLE_PROT_INT(uuart, u32IntSel)    ((uuart)->PROTIEN &= ~(u32IntSel))
N
N
N/**
N *    @brief        Enable specified USCI_UART buffer interrupt
N *
N *    @param[in]    uuart      The pointer of the specified USCI_UART module
N *    @param[in]    u32IntSel  Interrupt type select
N *                             - \ref UUART_BUFCTL_RXOVIEN_Msk     : Receive buffer overrun error interrupt
N *
N *    @return       None
N *
N *    @details      This macro enable specified USCI_UART buffer interrupt.
N */
N#define UUART_ENABLE_BUF_INT(uuart, u32IntSel)    ((uuart)->BUFCTL |= (u32IntSel))
N
N
N/**
N *    @brief        Disable specified USCI_UART buffer interrupt
N *
N *    @param[in]    uuart      The pointer of the specified USCI_UART module
N *    @param[in]    u32IntSel  Interrupt type select
N *                             - \ref UUART_BUFCTL_RXOVIEN_Msk     : Receive buffer overrun error interrupt
N *
N *    @return       None
N *
N *    @details      This macro disable specified USCI_UART buffer interrupt.
N */
N#define UUART_DISABLE_BUF_INT(uuart, u32IntSel)    ((uuart)->BUFCTL &= ~ (u32IntSel))
N
N
N/**
N *    @brief        Enable specified USCI_UART transfer interrupt
N *
N *    @param[in]    uuart      The pointer of the specified USCI_UART module
N *    @param[in]    u32IntSel  Interrupt type select
N *                             - \ref UUART_INTEN_RXENDIEN_Msk  : Receive end interrupt
N *                             - \ref UUART_INTEN_RXSTIEN_Msk   : Receive start interrupt
N *                             - \ref UUART_INTEN_TXENDIEN_Msk  : Transmit end interrupt
N *                             - \ref UUART_INTEN_TXSTIEN_Msk   : Transmit start interrupt
N *
N *    @return       None
N *
N *    @details      This macro enable specified USCI_UART transfer interrupt.
N */
N#define UUART_ENABLE_TRANS_INT(uuart, u32IntSel)    ((uuart)->INTEN |= (u32IntSel))
N
N
N/**
N *    @brief        Disable specified USCI_UART transfer interrupt
N *
N *    @param[in]    uuart      The pointer of the specified USCI_UART module
N *    @param[in]    u32IntSel  Interrupt type select
N *                             - \ref UUART_INTEN_RXENDIEN_Msk  : Receive end interrupt
N *                             - \ref UUART_INTEN_RXSTIEN_Msk   : Receive start interrupt
N *                             - \ref UUART_INTEN_TXENDIEN_Msk  : Transmit end interrupt
N *                             - \ref UUART_INTEN_TXSTIEN_Msk   : Transmit start interrupt
N *
N *    @return       None
N *
N *    @details      This macro disable specified USCI_UART transfer interrupt.
N */
N#define UUART_DISABLE_TRANS_INT(uuart, u32IntSel)    ((uuart)->INTEN &= ~(u32IntSel))
N
N
N/**
N *    @brief        Get protocol interrupt flag/status
N *
N *    @param[in]    uuart        The pointer of the specified USCI_UART module
N *
N *    @return       The interrupt flag/status of protocol status register.
N *
N *    @details      This macro get protocol status register value.
N */
N#define UUART_GET_PROT_STATUS(uuart)    ((uuart)->PROTSTS)
N
N
N/**
N *    @brief        Clear specified protocol interrupt flag
N *
N *    @param[in]    uuart           The pointer of the specified USCI_UART module
N *    @param[in]    u32IntTypeFlag  Interrupt Type Flag, should be
N *                                  - \ref UUART_PROTSTS_ABERRSTS_Msk    : Auto-baud Rate Error Interrupt Indicator
N *                                  - \ref UUART_PROTSTS_ABRDETIF_Msk    : Auto-baud Rate Detected Interrupt Flag
N *                                  - \ref UUART_PROTSTS_BREAK_Msk       : Break Flag
N *                                  - \ref UUART_PROTSTS_FRMERR_Msk      : Framing Error Flag
N *                                  - \ref UUART_PROTSTS_PARITYERR_Msk   : Parity Error Flag
N *                                  - \ref UUART_PROTSTS_RXENDIF_Msk     : Receive End Interrupt Flag
N *                                  - \ref UUART_PROTSTS_RXSTIF_Msk      : Receive Start Interrupt Flag
N *                                  - \ref UUART_PROTSTS_TXENDIF_Msk     : Transmit End Interrupt Flag
N *                                  - \ref UUART_PROTSTS_TXSTIF_Msk      : Transmit Start Interrupt Flag
N *
N *    @return       None
N *
N *    @details      This macro clear specified protocol interrupt flag.
N */
N#define UUART_CLR_PROT_INT_FLAG(uuart,u32IntTypeFlag)    ((uuart)->PROTSTS = (u32IntTypeFlag))
N
N
N/**
N *    @brief        Get transmit/receive buffer interrupt flag/status
N *
N *    @param[in]    uuart        The pointer of the specified USCI_UART module
N *
N *    @return       The interrupt flag/status of buffer status register.
N *
N *    @details      This macro get buffer status register value.
N */
N#define UUART_GET_BUF_STATUS(uuart)    ((uuart)->BUFSTS)
N
N
N/**
N *    @brief        Clear specified buffer interrupt flag
N *
N *    @param[in]    uuart           The pointer of the specified USCI_UART module
N *    @param[in]    u32IntTypeFlag  Interrupt Type Flag, should be
N *                                  - \ref UUART_BUFSTS_RXOVIF_Msk : Receive Buffer Over-run Error  Interrupt Indicator
N *
N *    @return       None
N *
N *    @details      This macro clear specified buffer interrupt flag.
N */
N#define UUART_CLR_BUF_INT_FLAG(uuart,u32IntTypeFlag)    ((uuart)->BUFSTS = (u32IntTypeFlag))
N
N
N/**
N *    @brief        Get wakeup flag
N *
N *    @param[in]    uuart    The pointer of the specified USCI_UART module
N *
N *    @retval       0       Chip did not wake up from power-down mode.
N *    @retval       1       Chip waked up from power-down mode.
N *
N *    @details      This macro get wakeup flag.
N */
N#define UUART_GET_WAKEUP_FLAG(uuart)    ((uuart)->WKSTS & UUART_WKSTS_WKF_Msk ? 1: 0 )
N
N
N/**
N *    @brief        Clear wakeup flag
N *
N *    @param[in]    uuart        The pointer of the specified USCI_UART module
N *
N *    @return       None
N *
N *    @details      This macro clear wakeup flag.
N */
N#define UUART_CLR_WAKEUP_FLAG(uuart)    ((uuart)->WKSTS = UUART_WKSTS_WKF_Msk)
N
N
Nvoid UUART_ClearIntFlag(UUART_T* uuart, uint32_t u32Mask);
Nuint32_t UUART_GetIntFlag(UUART_T* uuart, uint32_t u32Mask);
Nvoid UUART_Close(UUART_T* uuart);
Nvoid UUART_DisableInt(UUART_T*  uuart, uint32_t u32Mask);
Nvoid UUART_EnableInt(UUART_T*  uuart, uint32_t u32Mask);
Nuint32_t UUART_Open(UUART_T* uuart, uint32_t u32baudrate);
Nuint32_t UUART_Read(UUART_T* uuart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
Nuint32_t UUART_SetLine_Config(UUART_T* uuart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t u32stop_bits);
Nuint32_t UUART_Write(UUART_T* uuart, uint8_t *pu8TxBuf, uint32_t u32WriteBytes);
Nvoid UUART_EnableWakeup(UUART_T* uuart, uint32_t u32WakeupMode);
Nvoid UUART_DisableWakeup(UUART_T* uuart);
Nvoid UUART_EnableFlowCtrl(UUART_T* uuart);
Nvoid UUART_DisableFlowCtrl(UUART_T* uuart);
N
N
N/*@}*/ /* end of group USCI_UART_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group USCI_UART_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__USCI_UART_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17579 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#include "usci_i2c.h"
L 1 "..\lib\StdDriver\inc\usci_i2c.h" 1
N/**************************************************************************//**
N * @file     USCI_I2C.h
N * @version  V3.0
N * $Revision: 9 $
N * $Date: 16/11/11 3:14p $
N * @brief    NUC029xGE series USCI I2C(UI2C) driver header file
N *
N * @note
N * Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __USCI_I2C_H__
N#define __USCI_I2C_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup USCI_I2C_Driver USCI_I2C Driver
N  @{
N*/
N
N/** @addtogroup USCI_I2C_EXPORTED_CONSTANTS USCI_I2C Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* USCI_I2C master event definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
Nenum UI2C_MASTER_EVENT
N{
N    MASTER_SEND_ADDRESS = 10,    /*!< Master send address to Slave */
N    MASTER_SEND_H_WR_ADDRESS,    /*!< Master send High address to Slave */
N    MASTER_SEND_H_RD_ADDRESS,    /*!< Master send address to Slave (Read ADDR) */
N    MASTER_SEND_L_ADDRESS,       /*!< Master send Low address to Slave */
N    MASTER_SEND_DATA,            /*!< Master Send Data to Slave */
N    MASTER_SEND_REPEAT_START,    /*!< Master send repeat start to Slave */
N    MASTER_READ_DATA,            /*!< Master Get Data from Slave */
N    MASTER_STOP,                 /*!< Master send stop to Slave */
N    MASTER_SEND_START            /*!< Master send start to Slave */
N};
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* USCI_I2C slave event definitions                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
Nenum UI2C_SLAVE_EVENT
N{
N    SLAVE_ADDRESS_ACK = 100,      /*!< Slave send address ACK */
N    SLAVE_H_WR_ADDRESS_ACK,       /*!< Slave send High address ACK */
N    SLAVE_L_WR_ADDRESS_ACK,       /*!< Slave send Low address ACK */
N    SLAVE_GET_DATA,               /*!< Slave Get Data from Master (Write CMD) */
N    SLAVE_SEND_DATA,              /*!< Slave Send Data to Master (Read CMD) */
N    SLAVE_H_RD_ADDRESS_ACK,       /*!< Slave send High address ACK */
N    SLAVE_L_RD_ADDRESS_ACK        /*!< Slave send Low address ACK */
N};
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  USCI_CTL constant definitions.                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UI2C_CTL_PTRG              0x20UL    /*!< USCI_CTL setting for I2C control bits. It would set PTRG bit */
N#define UI2C_CTL_STA               0x08UL    /*!< USCI_CTL setting for I2C control bits. It would set STA bit */
N#define UI2C_CTL_STO               0x04UL    /*!< USCI_CTL setting for I2C control bits. It would set STO bit */
N#define UI2C_CTL_AA                0x02UL    /*!< USCI_CTL setting for I2C control bits. It would set AA bit  */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  USCI_I2C GCMode constant definitions.                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UI2C_GCMODE_ENABLE         1    /*!< Enable  USCI_I2C GC Mode */
N#define UI2C_GCMODE_DISABLE        0    /*!< Disable USCI_I2C GC Mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  USCI_I2C Wakeup Mode constant definitions.                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UI2C_DATA_TOGGLE_WK        (0x0 << UI2C_WKCTL_WKADDREN_Pos)    /*!< Wakeup according data toggle */
N#define UI2C_ADDR_MATCH_WK         (0x1 << UI2C_WKCTL_WKADDREN_Pos)    /*!< Wakeup according address match */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* USCI_I2C interrupt mask definitions                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UI2C_TO_INT_MASK           (0x001)    /*!< Time-out interrupt mask */
N#define UI2C_STAR_INT_MASK         (0x002)    /*!< Start condition received interrupt mask */
N#define UI2C_STOR_INT_MASK         (0x004)    /*!< Stop condition received interrupt mask */
N#define UI2C_NACK_INT_MASK         (0x008)    /*!< Non-acknowledge interrupt mask */
N#define UI2C_ARBLO_INT_MASK        (0x010)    /*!< Arbitration lost interrupt mask */
N#define UI2C_ERR_INT_MASK          (0x020)    /*!< Error interrupt mask */
N#define UI2C_ACK_INT_MASK          (0x040)    /*!< Acknowledge interrupt mask */
N
N/*@}*/ /* end of group USCI_I2C_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup USCI_I2C_EXPORTED_FUNCTIONS USCI_I2C Exported Functions
N  @{
N*/
N
N/**
N *    @brief        This macro sets the USCI_I2C protocol control register at one time
N *
N *    @param[in]    ui2c      The pointer of the specified USCI_I2C module.
N *    @param[in]    u8Ctrl    Set the register value of USCI_I2C control register.
N *
N *    @return       None
N *
N *    @details      Set UI2C_PROTCTL register to control USCI_I2C bus conditions of START, STOP, SI, ACK.
N */
N#define UI2C_SET_CONTROL_REG(ui2c, u8Ctrl) ((ui2c)->PROTCTL = ((ui2c)->PROTCTL & ~0x2E) | u8Ctrl)
N
N/**
N *    @brief        This macro only set START bit to protocol control register of USCI_I2C module.
N *
N *    @param[in]    ui2c      The pointer of the specified USCI_I2C module.
N *
N *    @return       None
N *
N *    @details      Set the USCI_I2C bus START condition in UI2C_PROTCTL register.
N */
N#define UI2C_START(ui2c) ((ui2c)->PROTCTL = ((ui2c)->PROTCTL & ~UI2C_PROTCTL_PTRG_Msk) | UI2C_PROTCTL_STA_Msk)
N
N/**
N *    @brief        This macro only set STOP bit to the control register of USCI_I2C module
N *
N *    @param[in]    ui2c      The pointer of the specified USCI_I2C module.
N *
N *    @return       None
N *
N *    @details      Set the USCI_I2C bus STOP condition in UI2C_PROTCTL register.
N */
N#define UI2C_STOP(ui2c) ((ui2c)->PROTCTL = ((ui2c)->PROTCTL & ~0x2E) | (UI2C_PROTCTL_PTRG_Msk | UI2C_PROTCTL_STO_Msk))
N
N/**
N *    @brief        This macro returns the data stored in data register of USCI_I2C module
N *
N *    @param[in]    ui2c      The pointer of the specified USCI_I2C module.
N *
N *    @return       Data
N *
N *    @details      Read a byte data value of UI2C_RXDAT register from USCI_I2C bus
N */
N#define UI2C_GET_DATA(ui2c) ((ui2c)->RXDAT)
N
N/**
N *    @brief        This macro writes the data to data register of USCI_I2C module
N *
N *    @param[in]    ui2c     The pointer of the specified USCI_I2C module.
N *    @param[in]    u8Data   The data which will be written to data register of USCI_I2C module.
N *
N *    @return       None
N *
N *    @details      Write a byte data value of UI2C_TXDAT register, then sends address or data to USCI I2C bus
N */
N#define UI2C_SET_DATA(ui2c, u8Data) ((ui2c)->TXDAT = u8Data)
N
N/**
N *    @brief        This macro returns time-out flag
N *
N *    @param[in]    ui2c     The pointer of the specified USCI_I2C module.
N *
N *    @retval       0        USCI_I2C bus time-out is not happened
N *    @retval       1        USCI_I2C bus time-out is happened
N *
N *    @details      USCI_I2C bus occurs time-out event, the time-out flag will be set. If not occurs time-out event, this bit is cleared.
N */
N#define UI2C_GET_TIMEOUT_FLAG(ui2c) (((ui2c)->PROTSTS & UI2C_PROTSTS_TOIF_Msk) == UI2C_PROTSTS_TOIF_Msk ? 1:0)
N
N/**
N *    @brief        This macro returns wake-up flag
N *
N *    @param[in]    ui2c     The pointer of the specified USCI_I2C module.
N *
N *    @retval       0        Chip is not woken-up from power-down mode
N *    @retval       1        Chip is woken-up from power-down mode
N *
N *    @details      USCI_I2C controller wake-up flag will be set when USCI_I2C bus occurs wake-up from deep-sleep.
N */
N#define UI2C_GET_WAKEUP_FLAG(ui2c) (((ui2c)->WKSTS & UI2C_WKSTS_WKF_Msk) == UI2C_WKSTS_WKF_Msk ? 1:0)
N
N/**
N *    @brief        This macro is used to clear USCI_I2C wake-up flag
N *
N *    @param[in]    ui2c     The pointer of the specified USCI_I2C module.
N *
N *    @return       None
N *
N *    @details      If USCI_I2C wake-up flag is set, use this macro to clear it.
N */
N#define UI2C_CLR_WAKEUP_FLAG(ui2c)  ((ui2c)->WKSTS = UI2C_WKSTS_WKF_Msk)
N
N/**
N *    @brief        This macro disables the USCI_I2C 10-bit address mode
N *
N *    @param[in]    ui2c     The pointer of the specified USCI_I2C module.
N *
N *    @return       None
N *
N *    @details      The UI2C_I2C is 7-bit address mode, when disable USCI_I2C 10-bit address match function.
N */
N#define UI2C_DISABLE_10BIT_ADDR_MODE(ui2c)  ((ui2c)->PROTCTL &= ~(UI2C_PROTCTL_ADDR10EN_Msk))
N
N/**
N *    @brief        This macro enables the 10-bit address mode
N *
N *    @param[in]    ui2c     The pointer of the specified USCI_I2C module.
N *
N *    @return       None
N *
N *    @details      To enable USCI_I2C 10-bit address match function.
N */
N#define UI2C_ENABLE_10BIT_ADDR_MODE(ui2c)  ((ui2c)->PROTCTL |= UI2C_PROTCTL_ADDR10EN_Msk)
N
N/**
N *    @brief        This macro gets USCI_I2C protocol interrupt flag or bus status
N *
N *    @param[in]    ui2c     The pointer of the specified USCI_I2C module.
N *
N *    @return       A word data of USCI_I2C_PROTSTS register
N *
N *    @details      Read a word data of USCI_I2C PROTSTS register to get USCI_I2C bus Interrupt flags or status.
N */
N#define UI2C_GET_PROT_STATUS(ui2c)    ((ui2c)->PROTSTS)
N
N/**
N *    @brief        This macro clears specified protocol interrupt flag
N *    @param[in]    ui2c     The pointer of the specified USCI_I2C module.
N *    @param[in]    u32IntTypeFlag Interrupt Type Flag, should be
N *                                  - \ref UI2C_PROTSTS_ACKIF_Msk
N *                                  - \ref UI2C_PROTSTS_ERRIF_Msk
N *                                  - \ref UI2C_PROTSTS_ARBLOIF_Msk
N *                                  - \ref UI2C_PROTSTS_NACKIF_Msk
N *                                  - \ref UI2C_PROTSTS_STORIF_Msk
N *                                  - \ref UI2C_PROTSTS_STARIF_Msk
N *                                  - \ref UI2C_PROTSTS_TOIF_Msk
N *    @return None
N *
N *    @details      To clear interrupt flag when USCI_I2C occurs interrupt and set interrupt flag.
N */
N#define UI2C_CLR_PROT_INT_FLAG(ui2c,u32IntTypeFlag)    ((ui2c)->PROTSTS = u32IntTypeFlag)
N
N/**
N *    @brief        This macro enables specified protocol interrupt
N *    @param[in]    ui2c     The pointer of the specified USCI_I2C module.
N *    @param[in]    u32IntSel Interrupt Type, should be
N *                                  - \ref UI2C_PROTIEN_ACKIEN_Msk
N *                                  - \ref UI2C_PROTIEN_ERRIEN_Msk
N *                                  - \ref UI2C_PROTIEN_ARBLOIEN_Msk
N *                                  - \ref UI2C_PROTIEN_NACKIEN_Msk
N *                                  - \ref UI2C_PROTIEN_STORIEN_Msk
N *                                  - \ref UI2C_PROTIEN_STARIEN_Msk
N *                                  - \ref UI2C_PROTIEN_TOIEN_Msk
N *    @return None
N *
N *    @details      Set specified USCI_I2C protocol interrupt bits to enable interrupt function.
N */
N#define UI2C_ENABLE_PROT_INT(ui2c, u32IntSel)    ((ui2c)->PROTIEN |= (u32IntSel))
N
N/**
N *    @brief        This macro disables specified protocol interrupt
N *    @param[in]    ui2c     The pointer of the specified USCI_I2C module.
N *    @param[in]    u32IntSel Interrupt Type, should be
N *                                  - \ref UI2C_PROTIEN_ACKIEN_Msk
N *                                  - \ref UI2C_PROTIEN_ERRIEN_Msk
N *                                  - \ref UI2C_PROTIEN_ARBLOIEN_Msk
N *                                  - \ref UI2C_PROTIEN_NACKIEN_Msk
N *                                  - \ref UI2C_PROTIEN_STORIEN_Msk
N *                                  - \ref UI2C_PROTIEN_STARIEN_Msk
N *                                  - \ref UI2C_PROTIEN_TOIEN_Msk
N *    @return None
N *
N *    @details      Clear specified USCI_I2C protocol interrupt bits to disable interrupt funtion.
N */
N#define UI2C_DISABLE_PROT_INT(ui2c, u32IntSel)    ((ui2c)->PROTIEN &= ~ (u32IntSel))
N
N
Nuint32_t UI2C_Open(UI2C_T *ui2c, uint32_t u32BusClock);
Nvoid UI2C_Close(UI2C_T *ui2c);
Nvoid UI2C_ClearTimeoutFlag(UI2C_T *ui2c);
Nvoid UI2C_Trigger(UI2C_T *ui2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Ptrg, uint8_t u8Ack);
Nvoid UI2C_DisableInt(UI2C_T *ui2c, uint32_t u32Mask);
Nvoid UI2C_EnableInt(UI2C_T *ui2c, uint32_t u32Mask);
Nuint32_t UI2C_GetBusClockFreq(UI2C_T *ui2c);
Nuint32_t UI2C_SetBusClockFreq(UI2C_T *ui2c, uint32_t u32BusClock);
Nuint32_t UI2C_GetIntFlag(UI2C_T *ui2c, uint32_t u32Mask);
Nvoid UI2C_ClearIntFlag(UI2C_T* ui2c, uint32_t u32Mask);
Nuint32_t UI2C_GetData(UI2C_T *ui2c);
Nvoid UI2C_SetData(UI2C_T *ui2c, uint8_t u8Data);
Nvoid UI2C_SetSlaveAddr(UI2C_T *ui2c, uint8_t u8SlaveNo, uint16_t u16SlaveAddr, uint8_t u8GCMode);
Nvoid UI2C_SetSlaveAddrMask(UI2C_T *ui2c, uint8_t u8SlaveNo, uint16_t u16SlaveAddrMask);
Nvoid UI2C_EnableTimeout(UI2C_T *ui2c, uint32_t u32TimeoutCnt);
Nvoid UI2C_DisableTimeout(UI2C_T *ui2c);
Nvoid UI2C_EnableWakeup(UI2C_T *ui2c, uint8_t u8WakeupMode);
Nvoid UI2C_DisableWakeup(UI2C_T *ui2c);
Nuint8_t UI2C_WriteByte(UI2C_T *ui2c, uint8_t u8SlaveAddr, const uint8_t data);
Nuint32_t UI2C_WriteMultiBytes(UI2C_T *ui2c, uint8_t u8SlaveAddr, const uint8_t *data, uint32_t u32wLen);
Nuint8_t UI2C_WriteByteOneReg(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, const uint8_t data);
Nuint32_t UI2C_WriteMultiBytesOneReg(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, const uint8_t *data, uint32_t u32wLen);
Nuint8_t UI2C_WriteByteTwoRegs(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, const uint8_t data);
Nuint32_t UI2C_WriteMultiBytesTwoRegs(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, const uint8_t *data, uint32_t u32wLen);
Nuint8_t UI2C_ReadByte(UI2C_T *ui2c, uint8_t u8SlaveAddr);
Nuint32_t UI2C_ReadMultiBytes(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint8_t *rdata, uint32_t u32rLen);
Nuint8_t UI2C_ReadByteOneReg(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr);
Nuint32_t UI2C_ReadMultiBytesOneReg(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t *rdata, uint32_t u32rLen);
Nuint8_t UI2C_ReadByteTwoRegs(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr);
Nuint32_t UI2C_ReadMultiBytesTwoRegs(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t *rdata, uint32_t u32rLen);
N/*@}*/ /* end of group USCI_I2C_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group USCI_I2C_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__USCI_I2C_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
L 17580 "..\lib\Device\Nuvoton\NUC029xGE\Include\NUC029xGE.h" 2
N#endif
N
N/* Copyright (C) 2018 Nuvoton Technology Corp. All rights reserved. */
N
N
N
L 12 "..\src\io\io_gpio.c" 2
N#include "tym_gpio.h"
L 1 "..\src\io\include\tym_gpio.h" 1
N/**
N * gpio.h file
N * @author    Aaron.Shao
N * @brief     system gpio
N * @date      2019-Jun.
N *
N * Copyright (c) Tymphany
N */	
N#ifndef __TYM_GPIO_H__
N#define __TYM_GPIO_H__
N
Nvoid TYM_gpio_init(void);
Nvoid TYM_gpio_adc_get(uint32_t adc_channel);
N
Ntypedef enum 
N{
N	ADC_CHANNEL_0 = (0x1),
N	ADC_CHANNEL_1 = (0x1 << 1),
N	ADC_CHANNEL_2 = (0x1 << 2),
N	ADC_CHANNEL_3 = (0x1 << 3),
N	ADC_CHANNEL_4 = (0x1 << 4),
N	ADC_CHANNEL_5 = (0x1 << 5),
N	ADC_CHANNEL_6 = (0x1 << 6),
N	ADC_CHANNEL_7 = (0x1 << 7),  
N	ADC_CHANNEL_8 = (0x1 << 8),
N	ADC_CHANNEL_9 = (0x1 << 9),
N	ADC_CHANNEL_10 = (0x1 << 10),
N	ADC_CHANNEL_11 = (0x1 << 11),
N	ADC_CHANNEL_12 = (0x1 << 12),  //PB.15  ex_bat
N	ADC_CHANNEL_13 = (0x1 << 13),
N	ADC_CHANNEL_14 = (0x1 << 14),
N	ADC_CHANNEL_15 = (0x1 << 15),  //PB.7  in_bat
N	
N}ADC_CHANNEL;
N
N#endif
N
L 13 "..\src\io\io_gpio.c" 2
N#include "tym_global.h"
L 1 "..\src\global\tym_global.h" 1
N/*
N* @file tym_global.h
N* @brief define global variables
N* @author Aaron.Shao
N* @date 25-Jun-2019
N* @copyright Tymphany Ltd.
N*/
N
N#ifndef __GLOBAL_H__
N#define __GLOBAL_H__
N
N#ifdef TYM_GLOBALS
S#define TYM_GLOBALS
N#else
N#define TYM_GLOBALS extern
N#endif
N
N#define TICK_COUNT              (50)   /* 1 second */
N#define TICK_IN_MS              (1000/TICK_COUNT)
N
N#define FM_MAX_STATION_NUM			15
N#define FM_DELAY_TIME				10
N
N
N#define GPIO_HIGH  1
N#define GPIO_LOW   0
N
Ntypedef enum
N{
N    SYS_ERR_NONE       = 0,
N    SYS_ERR_I2C0       = (1 << 1),
N    SYS_ERR_I2C1       = (1 << 2),
N    SYS_ERR_SPI0       = (1 << 3),
N    SYS_ERR_SPI1       = (1 << 4),
N    SYS_ERR_UART0      = (1 << 5),
N    SYS_ERR_UART1      = (1 << 6)
N} sys_err_e;
N
Nextern volatile sys_err_e sys_err;
N
Ntypedef enum
N{
N    MSG_4G_SYS_STATE_IND      = 1,
N    MSG_MCU1_SYS_STATE_IND,
N    MSG_IO_KEY_IND,
N    MSG_IR_KEY_IND,
N
N} eFourG_Msg;
N
Ntypedef enum
N{
N		POWER_ON_MODE,
N		WIFI_MODE, 
N		WIFI_CONNECTED_MODE,
N		WIFI_CONNECTING_MODE,
N		FOURG_MODE,
N		FOURG_CONNECTED_MODE,
N    BT_MODE,
N    BT_CONNECTED_MODE,
N    AUX_MODE,
N    LOUD_SPEAKER_MODE,
N    FM_MODE,
N    SYSTEM_UPDATING,
N    SYS_LOW_POWER,
N    POWER_OFF_MODE,
N    POWER_IDLE_MODE,
N
N} mode_status;
N
N
Ntypedef enum
N{
N	SYS_PLAY_STATE_NONE = 0,
N	SYS_PLAY_STATE_IDLE, 
N	SYS_PLAY_STATE_POWERUP,
N	SYS_PLAY_STATE_REBOOT,
N	SYS_PLAY_STATE_SHUTTING_DOWN,
N	SYS_PLAY_STATE_MW_RADIO,
N	SYS_PLAY_STATE_BT,
N	SYS_PLAY_STATE_FM,
N	SYS_PLAY_STATE_AUX
N
N} SYS_STATE;
N
N
Ntypedef enum
N{
N	NET_TYPE_NONE = 0,
N	NET_TYPE_WIFI,
N	NET_TYPE_4G,
N
N} NET_TYPE;
N
N
N
Ntypedef enum
N{
N	SYS_PLAY_EVENT_NONE = 0,
N	SYS_PLAY_EVENT_POWERING_UP,
N	SYS_PLAY_EVENT_SHUTTING_DOWN,
N	SYS_PLAY_EVENT_INIT_FINISH,
N	SYS_PLAY_EVENT_MODE_SWITCH,
N	SYS_PLAY_EVENT_VOL_UP,
N	SYS_PLAY_EVENT_VOL_DOWN,
N	
N	SYS_PLAY_EVENT_DEFAULT_VOLUME_SET,
N	
N	SYS_PLAY_EVENT_NEXT_SONG,
N	SYS_PLAY_EVENT_PREV_SONG,	
N	SYS_PLAY_EVENT_PLAY_PAUSE,	
N
N	SYS_PLAY_EVENT_MW_RADIO_NEXT_STATION,
N	SYS_PLAY_EVENT_MW_RADIO_PREV_STATION,
N
N	
N	SYS_PLAY_EVENT_EQ_INDOOR_SET,
N	SYS_PLAY_EVENT_EQ_OUTDOOR_SET,
N	SYS_PLAY_EVENT_RADIO_NET_SWITCH,
N	SYS_PLAY_EVENT_RADIO_NET_PAIRING,
N	SYS_PLAY_EVENT_SW_TO_FM_MODE,
N	SYS_PLAY_EVENT_SW_TO_AUX_MODE,
N	SYS_PLAY_EVENT_SW_TO_BT_MODE,
N	SYS_PLAY_EVENT_SW_TO_MW_RADIO_MODE,
N
N	SYS_PLAY_EVENT_TURN_OFF_4G_MOUDLE,
N	SYS_PLAY_EVENT_REBOOT_4G_MOUDLE,
N
N	SYS_PLAY_EVENT_AUTO_SEARCH,
N	SYS_PLAY_EVENT_BT_PAIRING,
N	SYS_PLAY_EVENT_FM_SEEK_UP,
N	SYS_PLAY_EVENT_FM_SEEK_DOWN,
N	SYS_PLAY_EVENT_FM_PREV_STEP,
N	SYS_PLAY_EVENT_FM_NEXT_STEP,
N	SYS_PLAY_EVENT_FM_NEXT_STATION,
N	SYS_PLAY_EVENT_FM_PREV_STATION,
N
N	SYS_PLAY_EVENT_NUM,
N
N
N} SYS_EVENT;
N
N
N
Ntypedef enum
N{
N    MSG_4G_CMD_IND      = 1,
N    MSG_4G_DAT_IND,
N    MSG_MCU1_CMD_IND,
N    MSG_MCU1_DAT_IND,
N
N} eUart_Msg;
N
N
Ntypedef enum
N{
N    EQ_MODE_NONE      = 0,
N    EQ_MODE_INDOOR,
N    EQ_MODE_OUTDOOR,
N
N} EQ_MODE;
N
N
Ntypedef enum
N{
N    PLAY_MODE_NONE      = 0,
N    PLAY_MODE_WIFI,
N    PLAY_MODE_FM,
N    PLAY_MODE_BT,
N    PLAY_MODE_AUX
N
N} PLAY_MODE;
N
Ntypedef enum
N{
N    BAT_LEVEL_5_PERCENT      = 0,  // 5%
N    BAT_LEVEL_10_PERCENT,
N    BAT_LEVEL_20_PERCENT,
N    BAT_LEVEL_30_PERCENT,
N    BAT_LEVEL_40_PERCENT,
N    BAT_LEVEL_50_PERCENT,
N    BAT_LEVEL_60_PERCENT,
N    BAT_LEVEL_70_PERCENT,
N    BAT_LEVEL_80_PERCENT,
N    BAT_LEVEL_90_PERCENT,
N    BAT_LEVEL_100_PERCENT,    
N
N} BATTERY_LEVEL;
N
N
Ntypedef enum
N{
N    CHARGE_STATE_NONE      = 0,  //
N    CHARGE_STATE_ON,
N    CHARGE_STATE_COMPLETE,
N    CHARGE_STATE_NG,
N 
N} CHARGE_STATE;
N
N
N
N
N
N//
N//define key event.
N//
Ntypedef enum _KEY_EVENT
N{
N	IN_KEY_NONE = 0x00,
N	IN_KEY_POWER_SP,
N	IN_KEY_POWER_CP,	
N	IN_KEY_POWER_CPR,	
N	IN_KEY_PAIR_SP,
N	IN_KEY_PAIR_CP,
N	IN_KEY_PAIR_CPR,
N	
N	IN_KEY_FM_MODE_S,
N	IN_KEY_AUX_MODE_S,
N	IN_KEY_MW_RADIO_MODE_S,
N	IN_KEY_BT_MODE_S,
N	IN_KEY_VOL_ADD_S,
N	IN_KEY_VOL_SUB_S,
N	IN_KEY_EQ_INDOOR_S,
N	IN_KEY_EQ_OUTDOOR_S,
N	IN_KEY_EQ_NORNAL_S,
N	IN_KEY_PLAY_S,
N	IN_KEY_NEXT_SONG_S,
N	IN_KEY_PREV_SONG_S,
N	IN_KEY_FM_NEXT_FREQ_S,
N	IN_KEY_FM_PREV_FREQ_S,
N	IN_KEY_AUTO_SEARCH_S,
N	IN_KEY_RADIO_PREV_S,
N	IN_KEY_RADIO_NEXT_S,
N	IN_KEY_RADIO_NET_SWITCH_S,
N	IN_KEY_RADIO_NET_PARIING_S,
N
N	IN_KEY_TURNOFF_4G_MOUDLE,
N	IN_KEY_REBOOT_4G_MOUDLE,
N	IN_KEY_DEFAULT_VOLUME_SET,
N	
N
N	IR_KEY_POWER,
N	IR_KEY_POWER_CP,
N	IR_KEY_MODE,
N	IR_KEY_VOLUME_UP,
N	IR_KEY_VOLUME_UP_CP,
N	IR_KEY_VOLUME_DOWN,
N	IR_KEY_VOLUME_DOWN_CP,
N	IR_KEY_PREV_SONG,
N	IR_KEY_PREV_SONG_CP,
N	IR_KEY_NEXT_SONG,
N	IR_KEY_NEXT_SONG_CP,
N	IR_KEY_PLAY_PAUSE,
N	IR_KEY_PLAY_PAUSE_CP,
N	IR_KEY_PREV_STATION,
N	IR_KEY_NEXT_STATION,
N	IR_KEY_EQ_INDOOR,
N	IR_KEY_EQ_OUTDOOR,
N	IR_KEY_EQ,	
N
N
N	IN_KEY_INIT_FINISH_CMD,
N	
N	
N} KEY_EVENT;
N
N
N
Ntypedef struct _PowerStatus
N{
N	uint8_t PowerBatInStatus;
N	uint8_t PowerBatExStatus;
N	uint8_t PowerAcStatus;
N	uint8_t bat_status;
N	uint8_t bat_value;  //0-3 in bat , 4-7 ex bat
N	uint8_t BatValue;
N	uint8_t NTC_value;
N	
N}sPowerStatus;
N
N
Ntypedef enum
N{
N    FM_STATE_OFF      = 0,
N    FM_STATE_ON,
N    FM_STATE_SEEK_UP,
N    FM_STATE_SEEK_DOWN,
N    FM_STATE_AUTO_SEARCH,
N} FM_STATE;
N
N
Ntypedef struct _POWER_STATE
N{
N
N	uint32_t battery_data;
N	uint32_t ntc_data;
N	BATTERY_LEVEL battery_level;
N	CHARGE_STATE charge_state;
N	uint8_t NTC_level;
N	uint8_t AdapterIn;
N	uint8_t battery_low;
N	uint8_t charge_power_good_pin; // 1 barrery ok, 0 barrery error
N	
N}POWER_STATE;
N
N
N
N
Ntypedef struct _Fm_Data
N{
N	uint32_t Frequency;
N	uint8_t  FmError;
N	uint8_t  FmNeedToStore;
N	uint32_t station_table[FM_MAX_STATION_NUM];
X	uint32_t station_table[15];
N	uint8_t station_num;
N	uint8_t index_station;
N	uint8_t current_station;
N	FM_STATE fmstate;
N}Fm_Data;
N
N
N
Ntypedef struct _SubBoardStatus
N{
N	uint8_t subboard_online;
N	EQ_MODE eq_mode;
N	PLAY_MODE playmode;
N 
N}SubBoardStatus;
N
N
N#define ADC_CHANNEL_NUM_MAX 16
N
Ntypedef struct
N{
N 
N	int16_t ADC_ChannelValue[ADC_CHANNEL_NUM_MAX];
X	int16_t ADC_ChannelValue[16];
N	sPowerStatus g_PowerStatus;
N	uint8_t g_mode_status;
N	uint8_t g_4g_initing;
N	uint8_t power_4g;
N	uint32_t systick;
N	uint8_t key_led_blink;
N	uint8_t shoutting_down;
N	uint8_t	eq_mode;				// in door mode and out door mode
N	uint8_t volume;
N	uint8_t mode_switching;  // during mode switching , need to mute amp
N	uint8_t mute;			 // sys mute flag
N	uint8_t volume_resume;   
N	uint8_t inputmessage;
N	uint8_t fm_delay_time;
N	SYS_STATE state;
N	SYS_EVENT event;
N	NET_TYPE MW_radio_net_type;
N	SubBoardStatus SubBoard;
N	Fm_Data FmData;
N	POWER_STATE PowerState;
N	uint8_t ir_bak_key;
N	
N
N}sGlobalData;
N
Nextern sGlobalData Global_datas;
N
N#define MSG_MAX_LEN						(12)
Nextern uint8_t RxBuff[60];
Nextern uint8_t RxMsgCount_PTE;
N
N
N#define VOLUME_DEFAULT  5
N#define VOLUME_MAX		16
N#define VOLUME_MIN		0
N
N
N
N#endif
L 14 "..\src\io\io_gpio.c" 2
N
N
N/*
N * @brief This function provides the configued MFP registers
N * @param None
N * @return None
N */
Nvoid TYM_gpio_init(void)
N{
N	/* Disable the GPB7 & GPB15 digital input path to avoid the leakage current. */
N
N	GPIO_DISABLE_DIGITAL_PATH(PB,(uint32_t)0x8080);
X	((((GPIO_T *) (((( uint32_t)0x50000000) + 0x4000) + 0x0040)))->DINOFF |= (((uint32_t)0x8080)<<16));
N
N	SYS->GPA_MFPH = 0x00000000;
X	((SYS_T *) ((( uint32_t)0x50000000) + 0x00000))->GPA_MFPH = 0x00000000;
N	SYS->GPA_MFPL = 0x00000000;
X	((SYS_T *) ((( uint32_t)0x50000000) + 0x00000))->GPA_MFPL = 0x00000000;
N	SYS->GPB_MFPH |= SYS_GPB_MFPH_PB15MFP_ADC0_CH12;
X	((SYS_T *) ((( uint32_t)0x50000000) + 0x00000))->GPB_MFPH |= (0x1UL<<(28));
N	SYS->GPB_MFPL |= SYS_GPB_MFPL_PB3MFP_USCI0_DAT1 | SYS_GPB_MFPL_PB2MFP_USCI0_DAT0 | SYS_GPB_MFPL_PB0MFP_UART2_RXD |SYS_GPB_MFPL_PB1MFP_UART2_TXD;  // USIC0 PB2_tx, PB3_rx   to sub board
X	((SYS_T *) ((( uint32_t)0x50000000) + 0x00000))->GPB_MFPL |= (0x8UL<<(12)) | (0x8UL<<(8)) | (0x3UL<<(0)) |(0x3UL<<(4));  
N		
N	SYS->GPC_MFPH = SYS_GPC_MFPH_PC10MFP_I2C1_SDA | SYS_GPC_MFPH_PC9MFP_I2C1_SCL;  //I2C_1  pcm1862
X	((SYS_T *) ((( uint32_t)0x50000000) + 0x00000))->GPC_MFPH = (0x3UL<<(8)) | (0x3UL<<(4));  
N	SYS->GPC_MFPL = 0x00000000;
X	((SYS_T *) ((( uint32_t)0x50000000) + 0x00000))->GPC_MFPL = 0x00000000;
N	SYS->GPD_MFPH = SYS_GPD_MFPH_PD9MFP_UART0_RXD;  // UART_0  PTE
X	((SYS_T *) ((( uint32_t)0x50000000) + 0x00000))->GPD_MFPH = (0x3UL<<(4));  
N	SYS->GPD_MFPL = SYS_GPD_MFPL_PD1MFP_UART0_TXD;
X	((SYS_T *) ((( uint32_t)0x50000000) + 0x00000))->GPD_MFPL = (0x3UL<<(4));
N	SYS->GPE_MFPH = SYS_GPE_MFPH_PE13MFP_I2C0_SDA | SYS_GPE_MFPH_PE12MFP_I2C0_SCL | SYS_GPE_MFPH_PE9MFP_UART1_RXD | SYS_GPE_MFPH_PE8MFP_UART1_TXD; //I2C_0: TSA5825 UART1:4G
X	((SYS_T *) ((( uint32_t)0x50000000) + 0x00000))->GPE_MFPH = (0x4UL<<(20)) | (0x4UL<<(16)) | (0x1UL<<(4)) | (0x1UL<<(0)); 
N	
N	SYS->GPE_MFPL = SYS_GPE_MFPL_PE7MFP_ICE_DAT | SYS_GPE_MFPL_PE6MFP_ICE_CLK;
X	((SYS_T *) ((( uint32_t)0x50000000) + 0x00000))->GPE_MFPL = (0x1UL<<(28)) | (0x1UL<<(24));
N	//SYS->GPE_MFPL = SYS_GPE_MFPL_PE7MFP_GPIO | SYS_GPE_MFPL_PE6MFP_GPIO;
N	
N	return;
N}
N
N
Nvoid TYM_gpio_adc_get(uint32_t adc_channel)
N{
N	uint8_t u8ChannelCount;
N	uint32_t  adc_channel_en;
N	
N	/* Set the ADC operation mode as continuous scan, input mode as single-end and
N	     enable the analog input channel 0, 1, 2 and 3 */
N	ADC_Open(ADC, ADC_ADCR_DIFFEN_SINGLE_END, ADC_ADCR_ADMD_CONTINUOUS, adc_channel);
X	ADC_Open(((ADC_T *) ((( uint32_t)0x40000000) + 0xE0000)), (0UL<<(10)), (3UL<<(2)), adc_channel);
N//	printf("adc channel: 0x%Xul\n",	adc_channel);
N
N	/* Power on ADC module */
N	ADC_POWER_ON(ADC);
X	((((ADC_T *) ((( uint32_t)0x40000000) + 0xE0000)))->ADCR |= (0x1ul << (0)));
N
N	/* Enable the ADC interrupt */
N	ADC_EnableInt(ADC, ADC_ADF_INT);
X	ADC_EnableInt(((ADC_T *) ((( uint32_t)0x40000000) + 0xE0000)), ((0x1ul << (0))));
N//	NVIC_EnableIRQ(ADC_IRQn);
N
N	/* Clear the A/D interrupt flag for safe */
N	ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT);
X	((((ADC_T *) ((( uint32_t)0x40000000) + 0xE0000)))->ADSR0 = (((0x1ul << (0)))));
N
N	/* Start A/D conversion */
N	ADC_START_CONV(ADC);
X	((((ADC_T *) ((( uint32_t)0x40000000) + 0xE0000)))->ADCR |= (0x1ul << (11)));
N#if 1
N	/* Wait conversion done */
N	while(!ADC_GET_INT_FLAG(ADC, ADC_ADF_INT));
X	while(!((((ADC_T *) ((( uint32_t)0x40000000) + 0xE0000)))->ADSR0 & (((0x1ul << (0))))));
N
N	/* Clear the A/D interrupt flag for safe */
N	ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT);
X	((((ADC_T *) ((( uint32_t)0x40000000) + 0xE0000)))->ADSR0 = (((0x1ul << (0)))));
N
N	adc_channel_en = adc_channel;
N	for(u8ChannelCount = 0; u8ChannelCount < ADC_CHANNEL_NUM_MAX; u8ChannelCount++)
X	for(u8ChannelCount = 0; u8ChannelCount < 16; u8ChannelCount++)
N	{
N		if(adc_channel_en & 0x01)
N		{
N			Global_datas.ADC_ChannelValue[u8ChannelCount] = ADC_GET_CONVERSION_DATA(ADC, u8ChannelCount);
X			Global_datas.ADC_ChannelValue[u8ChannelCount] = ((((ADC_T *) ((( uint32_t)0x40000000) + 0xE0000)))->ADDR[(u8ChannelCount)] & (0xfffful << (0)));
N//			printf("adc channel %d: 0x%Xul\n",  u8ChannelCount,Global_datas.ADC_ChannelValue[u8ChannelCount]);
N		}
N		adc_channel_en = adc_channel_en >> 1;		
N	}
N
N	/* Wait conversion done */
N	while(!ADC_GET_INT_FLAG(ADC, ADC_ADF_INT));
X	while(!((((ADC_T *) ((( uint32_t)0x40000000) + 0xE0000)))->ADSR0 & (((0x1ul << (0))))));
N
N	/* Stop A/D conversion */
N	ADC_STOP_CONV(ADC);
X	((((ADC_T *) ((( uint32_t)0x40000000) + 0xE0000)))->ADCR &= ~(0x1ul << (11)));
N
N	adc_channel_en = adc_channel;
N	for(u8ChannelCount = 0; u8ChannelCount < ADC_CHANNEL_NUM_MAX; u8ChannelCount++)
X	for(u8ChannelCount = 0; u8ChannelCount < 16; u8ChannelCount++)
N	{
N		if(adc_channel_en & 0x01)
N		{
N			Global_datas.ADC_ChannelValue[u8ChannelCount] = ADC_GET_CONVERSION_DATA(ADC, u8ChannelCount);
X			Global_datas.ADC_ChannelValue[u8ChannelCount] = ((((ADC_T *) ((( uint32_t)0x40000000) + 0xE0000)))->ADDR[(u8ChannelCount)] & (0xfffful << (0)));
N//			printf("adc channel %d: 0x%Xul\n",  u8ChannelCount,ADC_ChannelValue[u8ChannelCount]);
N		}
N		adc_channel_en = adc_channel_en >> 1;		
N	}
N
N	/* Clear the A/D interrupt flag for safe */
N	ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT);
X	((((ADC_T *) ((( uint32_t)0x40000000) + 0xE0000)))->ADSR0 = (((0x1ul << (0)))));
N	
N	/* Disable the ADC interrupt */
N	ADC_DisableInt(ADC, ADC_ADF_INT);
X	ADC_DisableInt(((ADC_T *) ((( uint32_t)0x40000000) + 0xE0000)), ((0x1ul << (0))));
N    /* Disable External Interrupt */
N//    NVIC_DisableIRQ(ADC_IRQn);
N#endif
N}
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC interrupt handler                                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/*
Nvoid ADC_IRQHandler(void)
N{
N    
N	int32_t  i32ConversionData;
N	ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT);
N	
N    NVIC_DisableIRQ(ADC_IRQn);
N    ADC_GET_INT_FLAG(ADC, ADC_ADF_INT);
N	i32ConversionData = ADC_GET_CONVERSION_DATA(ADC, 12);
N	printf("Conversion result of channel 12: 0x%X \n",  i32ConversionData);
N	i32ConversionData = ADC_GET_CONVERSION_DATA(ADC, 15);
N	printf("Conversion result of channel 15: 0x%X \n",  i32ConversionData);
N    //ADC_CLR_INT_FLAG(ADC, u32Flag);
N}*/
N
N
