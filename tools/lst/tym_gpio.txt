; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\tym_gpio.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\tym_gpio.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\lib\CMSIS\Include -I..\lib\Device\Nuvoton\NUC029xGE\Include -I..\lib\StdDriver\inc -I..\src\core\include -I..\src\driver\include -I..\src\io\include -D__UVISION_VERSION=522 --omf_browse=.\obj\tym_gpio.crf ..\src\io\tym_gpio.c]
                          THUMB

                          AREA ||i.ADC_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  ADC_IRQHandler PROC
;;;112    /*---------------------------------------------------------------------------------------------------------*/
;;;113    void ADC_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;114    {
;;;115        
;;;116    	int32_t  i32ConversionData;
;;;117    	ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT);
000002  480a              LDR      r0,|L1.44|
000004  2101              MOVS     r1,#1
000006  6101              STR      r1,[r0,#0x10]
000008  4a09              LDR      r2,|L1.48|
00000a  0581              LSLS     r1,r0,#22
00000c  6011              STR      r1,[r2,#0]
;;;118    	
;;;119        NVIC_DisableIRQ(ADC_IRQn);
;;;120        ADC_GET_INT_FLAG(ADC, ADC_ADF_INT);
00000e  6900              LDR      r0,[r0,#0x10]
;;;121    	i32ConversionData = ADC_GET_CONVERSION_DATA(ADC, 12);
000010  4c06              LDR      r4,|L1.44|
000012  3c80              SUBS     r4,r4,#0x80
000014  6b20              LDR      r0,[r4,#0x30]
000016  b281              UXTH     r1,r0
;;;122    	printf("Conversion result of channel 12: 0x%X \n",  i32ConversionData);
000018  a006              ADR      r0,|L1.52|
00001a  f7fffffe          BL       __2printf
;;;123    	i32ConversionData = ADC_GET_CONVERSION_DATA(ADC, 15);
00001e  6be0              LDR      r0,[r4,#0x3c]
000020  b281              UXTH     r1,r0
;;;124    	printf("Conversion result of channel 15: 0x%X \n",  i32ConversionData);
000022  a00e              ADR      r0,|L1.92|
000024  f7fffffe          BL       __2printf
;;;125        //ADC_CLR_INT_FLAG(ADC, u32Flag);
;;;126    }
000028  bd10              POP      {r4,pc}
;;;127    
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
                          DCD      0x400e0080
                  |L1.48|
                          DCD      0xe000e180
                  |L1.52|
000034  436f6e76          DCB      "Conversion result of channel 12: 0x%X \n",0
000038  65727369
00003c  6f6e2072
000040  6573756c
000044  74206f66
000048  20636861
00004c  6e6e656c
000050  2031323a
000054  20307825
000058  58200a00
                  |L1.92|
00005c  436f6e76          DCB      "Conversion result of channel 15: 0x%X \n",0
000060  65727369
000064  6f6e2072
000068  6573756c
00006c  74206f66
000070  20636861
000074  6e6e656c
000078  2031353a
00007c  20307825
000080  58200a00

                          AREA ||i.TYM_gpio_adc_get||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  TYM_gpio_adc_get PROC
;;;42     
;;;43     void TYM_gpio_adc_get(uint32_t adc_channel)
000000  b5f1              PUSH     {r0,r4-r7,lr}
;;;44     {
;;;45     	uint8_t u8ChannelCount;
;;;46     	uint32_t  adc_channel_en;
;;;47     	
;;;48     	/* Set the ADC operation mode as continuous scan, input mode as single-end and
;;;49     	     enable the analog input channel 0, 1, 2 and 3 */
;;;50     	ADC_Open(ADC, ADC_ADCR_DIFFEN_SINGLE_END, ADC_ADCR_ADMD_CONTINUOUS, adc_channel);
000002  4d2e              LDR      r5,|L2.188|
000004  220c              MOVS     r2,#0xc
000006  2100              MOVS     r1,#0
000008  4628              MOV      r0,r5
00000a  9b00              LDR      r3,[sp,#0]
00000c  f7fffffe          BL       ADC_Open
;;;51     	printf("adc channel: 0x%Xul\n",	adc_channel);
000010  a02b              ADR      r0,|L2.192|
000012  9900              LDR      r1,[sp,#0]
000014  f7fffffe          BL       __2printf
;;;52     
;;;53     	/* Power on ADC module */
;;;54     	ADC_POWER_ON(ADC);
000018  4c28              LDR      r4,|L2.188|
00001a  3480              ADDS     r4,r4,#0x80
00001c  6820              LDR      r0,[r4,#0]
00001e  2601              MOVS     r6,#1
000020  4330              ORRS     r0,r0,r6
000022  6020              STR      r0,[r4,#0]
;;;55     
;;;56     	/* Enable the ADC interrupt */
;;;57     	ADC_EnableInt(ADC, ADC_ADF_INT);
000024  4631              MOV      r1,r6
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       ADC_EnableInt
;;;58     //	NVIC_EnableIRQ(ADC_IRQn);
;;;59     
;;;60     	/* Clear the A/D interrupt flag for safe */
;;;61     	ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT);
00002c  6126              STR      r6,[r4,#0x10]
;;;62     
;;;63     	/* Start A/D conversion */
;;;64     	ADC_START_CONV(ADC);
00002e  6820              LDR      r0,[r4,#0]
000030  02f1              LSLS     r1,r6,#11
000032  4308              ORRS     r0,r0,r1
000034  6020              STR      r0,[r4,#0]
                  |L2.54|
;;;65     #if 1
;;;66     	/* Wait conversion done */
;;;67     	while(!ADC_GET_INT_FLAG(ADC, ADC_ADF_INT));
000036  6920              LDR      r0,[r4,#0x10]
000038  07c0              LSLS     r0,r0,#31
00003a  d0fc              BEQ      |L2.54|
;;;68     
;;;69     	/* Clear the A/D interrupt flag for safe */
;;;70     	ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT);
00003c  481f              LDR      r0,|L2.188|
00003e  2101              MOVS     r1,#1
000040  3080              ADDS     r0,r0,#0x80
000042  6101              STR      r1,[r0,#0x10]
;;;71     
;;;72     	adc_channel_en = adc_channel;
;;;73     	for(u8ChannelCount = 0; u8ChannelCount < ADC_CHANNEL_NUM_MAX; u8ChannelCount++)
;;;74     	{
;;;75     		if(adc_channel_en & 0x01)
;;;76     		{
;;;77     			ADC_ChannelValue[u8ChannelCount] = ADC_GET_CONVERSION_DATA(ADC, u8ChannelCount);
000044  4f24              LDR      r7,|L2.216|
000046  9e00              LDR      r6,[sp,#0]
000048  2400              MOVS     r4,#0                 ;73
                  |L2.74|
00004a  07f0              LSLS     r0,r6,#31             ;75
00004c  d009              BEQ      |L2.98|
00004e  00a0              LSLS     r0,r4,#2
000050  1940              ADDS     r0,r0,r5
000052  6800              LDR      r0,[r0,#0]
;;;78     			printf("adc channel %d: 0x%Xul\n",  u8ChannelCount,ADC_ChannelValue[u8ChannelCount]);
000054  4621              MOV      r1,r4
000056  b202              SXTH     r2,r0                 ;77
000058  0060              LSLS     r0,r4,#1              ;77
00005a  523a              STRH     r2,[r7,r0]            ;77
00005c  a01f              ADR      r0,|L2.220|
00005e  f7fffffe          BL       __2printf
                  |L2.98|
;;;79     		}
;;;80     		adc_channel_en = adc_channel_en >> 1;		
000062  1c64              ADDS     r4,r4,#1
000064  0876              LSRS     r6,r6,#1
000066  b2e4              UXTB     r4,r4                 ;73
000068  2c10              CMP      r4,#0x10              ;73
00006a  d3ee              BCC      |L2.74|
00006c  4813              LDR      r0,|L2.188|
00006e  3080              ADDS     r0,r0,#0x80           ;54
                  |L2.112|
;;;81     	}
;;;82     
;;;83     	/* Wait conversion done */
;;;84     	while(!ADC_GET_INT_FLAG(ADC, ADC_ADF_INT));
000070  6901              LDR      r1,[r0,#0x10]
000072  07c9              LSLS     r1,r1,#31
000074  d0fc              BEQ      |L2.112|
;;;85     
;;;86     	/* Stop A/D conversion */
;;;87     	ADC_STOP_CONV(ADC);
000076  4811              LDR      r0,|L2.188|
000078  3080              ADDS     r0,r0,#0x80
00007a  6801              LDR      r1,[r0,#0]
00007c  2201              MOVS     r2,#1
00007e  02d2              LSLS     r2,r2,#11
000080  4391              BICS     r1,r1,r2
000082  6001              STR      r1,[r0,#0]
;;;88     
;;;89     	adc_channel_en = adc_channel;
;;;90     	for(u8ChannelCount = 0; u8ChannelCount < ADC_CHANNEL_NUM_MAX; u8ChannelCount++)
000084  9e00              LDR      r6,[sp,#0]
000086  2400              MOVS     r4,#0
                  |L2.136|
;;;91     	{
;;;92     		if(adc_channel_en & 0x01)
000088  07f0              LSLS     r0,r6,#31
00008a  d009              BEQ      |L2.160|
;;;93     		{
;;;94     			ADC_ChannelValue[u8ChannelCount] = ADC_GET_CONVERSION_DATA(ADC, u8ChannelCount);
00008c  00a0              LSLS     r0,r4,#2
00008e  1940              ADDS     r0,r0,r5
000090  6800              LDR      r0,[r0,#0]
;;;95     			printf("adc channel %d: 0x%Xul\n",  u8ChannelCount,ADC_ChannelValue[u8ChannelCount]);
000092  4621              MOV      r1,r4
000094  b202              SXTH     r2,r0                 ;94
000096  0060              LSLS     r0,r4,#1              ;94
000098  523a              STRH     r2,[r7,r0]            ;94
00009a  a010              ADR      r0,|L2.220|
00009c  f7fffffe          BL       __2printf
                  |L2.160|
;;;96     		}
;;;97     		adc_channel_en = adc_channel_en >> 1;		
0000a0  1c64              ADDS     r4,r4,#1
0000a2  0876              LSRS     r6,r6,#1
0000a4  b2e4              UXTB     r4,r4                 ;90
0000a6  2c10              CMP      r4,#0x10              ;90
0000a8  d3ee              BCC      |L2.136|
;;;98     	}
;;;99     
;;;100    	/* Clear the A/D interrupt flag for safe */
;;;101    	ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT);
0000aa  4904              LDR      r1,|L2.188|
0000ac  2001              MOVS     r0,#1
0000ae  3180              ADDS     r1,r1,#0x80
0000b0  6108              STR      r0,[r1,#0x10]
;;;102    	
;;;103    	/* Disable the ADC interrupt */
;;;104    	ADC_DisableInt(ADC, ADC_ADF_INT);
0000b2  4601              MOV      r1,r0
0000b4  4628              MOV      r0,r5
0000b6  f7fffffe          BL       ADC_DisableInt
;;;105        /* Disable External Interrupt */
;;;106    //    NVIC_DisableIRQ(ADC_IRQn);
;;;107    #endif
;;;108    }
0000ba  bdf8              POP      {r3-r7,pc}
;;;109    
                          ENDP

                  |L2.188|
                          DCD      0x400e0000
                  |L2.192|
0000c0  61646320          DCB      "adc channel: 0x%Xul\n",0
0000c4  6368616e
0000c8  6e656c3a
0000cc  20307825
0000d0  58756c0a
0000d4  00      
0000d5  00                DCB      0
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L2.216|
                          DCD      ||.bss||
                  |L2.220|
0000dc  61646320          DCB      "adc channel %d: 0x%Xul\n",0
0000e0  6368616e
0000e4  6e656c20
0000e8  25643a20
0000ec  30782558
0000f0  756c0a00

                          AREA ||i.TYM_gpio_init||, CODE, READONLY, ALIGN=2

                  TYM_gpio_init PROC
;;;21      */
;;;22     void TYM_gpio_init(void)
000000  480d              LDR      r0,|L3.56|
;;;23     {
;;;24     	/* Disable the GPB7 & GPB15 digital input path to avoid the leakage current. */
;;;25     
;;;26     	GPIO_DISABLE_DIGITAL_PATH(PB,(uint32_t)0x8080);
000002  6841              LDR      r1,[r0,#4]
000004  0442              LSLS     r2,r0,#17
000006  4311              ORRS     r1,r1,r2
000008  6041              STR      r1,[r0,#4]
;;;27     
;;;28     	SYS->GPA_MFPH = 0x00000000;
00000a  2100              MOVS     r1,#0
00000c  2005              MOVS     r0,#5
00000e  0700              LSLS     r0,r0,#28
000010  6341              STR      r1,[r0,#0x34]
;;;29     	SYS->GPA_MFPL = 0x00000000;
000012  6301              STR      r1,[r0,#0x30]
;;;30     	SYS->GPB_MFPH = SYS_GPB_MFPH_PB15MFP_ADC0_CH12;
000014  0152              LSLS     r2,r2,#5
000016  63c2              STR      r2,[r0,#0x3c]
;;;31     	SYS->GPB_MFPL = SYS_GPB_MFPL_PB3MFP_USCI0_DAT1 | SYS_GPB_MFPL_PB2MFP_USCI0_DAT0 | SYS_GPB_MFPL_PB1MFP_UART2_TXD | SYS_GPB_MFPL_PB0MFP_UART2_RXD | SYS_GPB_MFPL_PB7MFP_ADC0_CH15;
000018  4a08              LDR      r2,|L3.60|
00001a  6382              STR      r2,[r0,#0x38]
;;;32     	SYS->GPC_MFPH = SYS_GPC_MFPH_PC10MFP_I2C1_SDA | SYS_GPC_MFPH_PC9MFP_I2C1_SCL;
00001c  2233              MOVS     r2,#0x33
00001e  4808              LDR      r0,|L3.64|
000020  0112              LSLS     r2,r2,#4
000022  6042              STR      r2,[r0,#4]
;;;33     	SYS->GPC_MFPL = 0x00000000;
000024  6001              STR      r1,[r0,#0]
;;;34     	SYS->GPD_MFPH = SYS_GPD_MFPH_PD9MFP_UART0_RXD;
000026  2130              MOVS     r1,#0x30
000028  60c1              STR      r1,[r0,#0xc]
;;;35     	SYS->GPD_MFPL = SYS_GPD_MFPL_PD1MFP_UART0_TXD;
00002a  6081              STR      r1,[r0,#8]
;;;36     	SYS->GPE_MFPH = SYS_GPE_MFPH_PE13MFP_I2C0_SDA | SYS_GPE_MFPH_PE12MFP_I2C0_SCL | SYS_GPE_MFPH_PE9MFP_UART1_RXD | SYS_GPE_MFPH_PE8MFP_UART1_TXD;
00002c  4905              LDR      r1,|L3.68|
00002e  6141              STR      r1,[r0,#0x14]
;;;37     	SYS->GPE_MFPL = SYS_GPE_MFPL_PE7MFP_ICE_DAT | SYS_GPE_MFPL_PE6MFP_ICE_CLK;
000030  0609              LSLS     r1,r1,#24
000032  6101              STR      r1,[r0,#0x10]
;;;38     	
;;;39     	return;
;;;40     }
000034  4770              BX       lr
;;;41     
                          ENDP

000036  0000              DCW      0x0000
                  |L3.56|
                          DCD      0x50004040
                  |L3.60|
                          DCD      0x10008833
                  |L3.64|
                          DCD      0x50000040
                  |L3.68|
                          DCD      0x00440011

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  ADC_ChannelValue
                          %        32

;*** Start embedded assembler ***

#line 1 "..\\src\\io\\tym_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_tym_gpio_c_1cfb58e3____REV16|
#line 388 "..\\lib\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_tym_gpio_c_1cfb58e3____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_tym_gpio_c_1cfb58e3____REVSH|
#line 402
|__asm___10_tym_gpio_c_1cfb58e3____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
