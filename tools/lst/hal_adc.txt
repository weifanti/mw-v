; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\hal_adc.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\hal_adc.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\lib\CMSIS\Include -I..\lib\Device\Nuvoton\NUC029xGE\Include -I..\lib\StdDriver\inc -I..\src\core\include -I..\src\driver\include -I..\src\io\include -I..\src\global -I..\src\server\include -I..\src\driver\audio -D__UVISION_VERSION=522 --omf_browse=.\obj\hal_adc.crf ..\src\driver\hal_adc.c]
                          THUMB

                          AREA ||i.ADC_FunctionTest||, CODE, READONLY, ALIGN=2

                  ADC_FunctionTest PROC
;;;81     
;;;82     void ADC_FunctionTest()
000000  b5f8              PUSH     {r3-r7,lr}
;;;83     {
;;;84     	static uint8_t  u8Option = 0;
;;;85         int32_t  i32ConversionData;
;;;86     
;;;87         u8Option++;
000002  4c2b              LDR      r4,|L1.176|
000004  2600              MOVS     r6,#0
000006  7820              LDRB     r0,[r4,#0]  ; u8Option
000008  1c40              ADDS     r0,r0,#1
00000a  b2c0              UXTB     r0,r0
00000c  7020              STRB     r0,[r4,#0]
;;;88     
;;;89     	if(u8Option == 2) u8Option = 0;
00000e  2802              CMP      r0,#2
000010  d100              BNE      |L1.20|
000012  7026              STRB     r6,[r4,#0]
                  |L1.20|
;;;90     
;;;91         /* Enable ADC converter */
;;;92         ADC_POWER_ON(ADC);
000014  4d27              LDR      r5,|L1.180|
000016  6828              LDR      r0,[r5,#0]
000018  2701              MOVS     r7,#1
00001a  4338              ORRS     r0,r0,r7
00001c  6028              STR      r0,[r5,#0]
;;;93     
;;;94        // while(1)
;;;95         {
;;;96     
;;;97             if(u8Option)  // BAT_LEVEL
00001e  7821              LDRB     r1,[r4,#0]  ; u8Option
000020  2900              CMP      r1,#0
000022  d022              BEQ      |L1.106|
;;;98             {
;;;99                 /* Set input mode as single-end, Single mode, and select channel 15 */
;;;100                ADC_Open(ADC, ADC_ADCR_DIFFEN_SINGLE_END, ADC_ADCR_ADMD_SINGLE, BIT15);
000024  4823              LDR      r0,|L1.180|
000026  2200              MOVS     r2,#0
000028  03fb              LSLS     r3,r7,#15
00002a  4611              MOV      r1,r2
00002c  3880              SUBS     r0,r0,#0x80
00002e  f7fffffe          BL       ADC_Open
;;;101    
;;;102                /* Clear the A/D interrupt flag for safe */
;;;103                ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT);
000032  612f              STR      r7,[r5,#0x10]
;;;104    
;;;105                /* Enable the sample module interrupt */
;;;106                //ADC_ENABLE_INT(ADC, ADC_ADF_INT);  /* Enable sample module A/D interrupt. */
;;;107                
;;;108    			ADC_EnableInt(ADC, ADC_ADF_INT);
000034  481f              LDR      r0,|L1.180|
000036  2101              MOVS     r1,#1
000038  3880              SUBS     r0,r0,#0x80
00003a  f7fffffe          BL       ADC_EnableInt
00003e  481e              LDR      r0,|L1.184|
000040  05a9              LSLS     r1,r5,#22
000042  6001              STR      r1,[r0,#0]
;;;109                NVIC_EnableIRQ(ADC_IRQn);
;;;110    
;;;111                /* Reset the ADC interrupt indicator and trigger sample module 0 to start A/D conversion */
;;;112                g_u32AdcIntFlag = 0;
000044  60a6              STR      r6,[r4,#8]  ; g_u32AdcIntFlag
;;;113                ADC_START_CONV(ADC);
000046  6828              LDR      r0,[r5,#0]
000048  1489              ASRS     r1,r1,#18
00004a  4308              ORRS     r0,r0,r1
00004c  6028              STR      r0,[r5,#0]
                  |L1.78|
;;;114    
;;;115                /* Wait ADC interrupt (g_u32AdcIntFlag will be set at IRQ_Handler function) */
;;;116                while(g_u32AdcIntFlag == 0);
00004e  68a0              LDR      r0,[r4,#8]  ; g_u32AdcIntFlag
000050  2800              CMP      r0,#0
000052  d0fc              BEQ      |L1.78|
;;;117    
;;;118                /* Disable the sample module interrupt */
;;;119                //ADC_DISABLE_INT(ADC, ADC_ADF_INT);
;;;120    			
;;;121    			ADC_DisableInt(ADC, ADC_ADF_INT);
000054  4c17              LDR      r4,|L1.180|
000056  2101              MOVS     r1,#1
000058  3c80              SUBS     r4,r4,#0x80
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       ADC_DisableInt
;;;122    
;;;123                /* Get the conversion result of ADC channel 15 */
;;;124                i32ConversionData = ADC_GET_CONVERSION_DATA(ADC, 15);
000060  6be0              LDR      r0,[r4,#0x3c]
000062  b280              UXTH     r0,r0
;;;125    			bat_value_get(i32ConversionData);
000064  f7fffffe          BL       bat_value_get
;;;126                //printf("Conversion result of channel 2: 0x%X (%d)\n\n", i32ConversionData, i32ConversionData);
;;;127            }
;;;128            else  // NTC LEVLE
;;;129            {
;;;130    		   /* Set input mode as single-end, Single mode, and select channel 14 */
;;;131    		   ADC_Open(ADC, ADC_ADCR_DIFFEN_SINGLE_END, ADC_ADCR_ADMD_SINGLE, BIT14);
;;;132    		   
;;;133    		   /* Clear the A/D interrupt flag for safe */
;;;134    		   ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT);
;;;135    		   
;;;136    		   /* Enable the sample module interrupt */
;;;137    		   //ADC_ENABLE_INT(ADC, ADC_ADF_INT);	/* Enable sample module A/D interrupt. */
;;;138    		   
;;;139    		   ADC_EnableInt(ADC, ADC_ADF_INT);
;;;140    		   NVIC_EnableIRQ(ADC_IRQn);
;;;141    		   
;;;142    		   /* Reset the ADC interrupt indicator and trigger sample module 0 to start A/D conversion */
;;;143    		   g_u32AdcIntFlag = 0;
;;;144    		   ADC_START_CONV(ADC);
;;;145    		   
;;;146    		   /* Wait ADC interrupt (g_u32AdcIntFlag will be set at IRQ_Handler function) */
;;;147    		   while(g_u32AdcIntFlag == 0);
;;;148    		   
;;;149    		   /* Disable the sample module interrupt */
;;;150    		   //ADC_DISABLE_INT(ADC, ADC_ADF_INT);
;;;151    		   
;;;152    		   ADC_DisableInt(ADC, ADC_ADF_INT);
;;;153    		   
;;;154    		   /* Get the conversion result of ADC channel 14 */
;;;155    		   i32ConversionData = ADC_GET_CONVERSION_DATA(ADC, 14);
;;;156    
;;;157               // printf("Conversion result of channel pair 1: 0x%X (%d)\n\n", i32ConversionData, i32ConversionData);
;;;158    		   //ntc_value_get(i32ConversionData);
;;;159            }
;;;160        }
;;;161    }
000068  bdf8              POP      {r3-r7,pc}
                  |L1.106|
00006a  4812              LDR      r0,|L1.180|
00006c  2301              MOVS     r3,#1                 ;131
00006e  2200              MOVS     r2,#0                 ;131
000070  039b              LSLS     r3,r3,#14             ;131
000072  4611              MOV      r1,r2                 ;131
000074  3880              SUBS     r0,r0,#0x80           ;131
000076  f7fffffe          BL       ADC_Open
00007a  612f              STR      r7,[r5,#0x10]         ;134
00007c  480d              LDR      r0,|L1.180|
00007e  2101              MOVS     r1,#1                 ;139
000080  3880              SUBS     r0,r0,#0x80           ;139
000082  f7fffffe          BL       ADC_EnableInt
000086  2001              MOVS     r0,#1                 ;139
000088  490b              LDR      r1,|L1.184|
00008a  0740              LSLS     r0,r0,#29             ;139
00008c  6008              STR      r0,[r1,#0]            ;139
00008e  60a6              STR      r6,[r4,#8]            ;143  ; g_u32AdcIntFlag
000090  6829              LDR      r1,[r5,#0]            ;144
000092  1480              ASRS     r0,r0,#18             ;144
000094  4301              ORRS     r1,r1,r0              ;144
000096  6029              STR      r1,[r5,#0]            ;144
                  |L1.152|
000098  68a0              LDR      r0,[r4,#8]            ;147  ; g_u32AdcIntFlag
00009a  2800              CMP      r0,#0                 ;147
00009c  d0fc              BEQ      |L1.152|
00009e  4c05              LDR      r4,|L1.180|
0000a0  2101              MOVS     r1,#1                 ;152
0000a2  3c80              SUBS     r4,r4,#0x80           ;152
0000a4  4620              MOV      r0,r4                 ;152
0000a6  f7fffffe          BL       ADC_DisableInt
0000aa  6ba0              LDR      r0,[r4,#0x38]         ;155
0000ac  bdf8              POP      {r3-r7,pc}
;;;162    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L1.176|
                          DCD      ||.data||
                  |L1.180|
                          DCD      0x400e0080
                  |L1.184|
                          DCD      0xe000e100

                          AREA ||i.ADC_IRQHandler||, CODE, READONLY, ALIGN=2

                  ADC_IRQHandler PROC
;;;72     
;;;73     void ADC_IRQHandler(void)
000000  4902              LDR      r1,|L2.12|
;;;74     {
;;;75         g_u32AdcIntFlag = 1;
000002  2001              MOVS     r0,#1
000004  6088              STR      r0,[r1,#8]  ; g_u32AdcIntFlag
;;;76         ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT); /* Clear the A/D interrupt flag */
000006  4902              LDR      r1,|L2.16|
000008  6108              STR      r0,[r1,#0x10]
;;;77     }
00000a  4770              BX       lr
;;;78     
                          ENDP

                  |L2.12|
                          DCD      ||.data||
                  |L2.16|
                          DCD      0x400e0080

                          AREA ||i.Mic1Check||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  Mic1Check PROC
;;;163    
;;;164    void Mic1Check(void)
000000  b570              PUSH     {r4-r6,lr}
;;;165    {
;;;166        int32_t  i32ConversionData;
;;;167    	static uint8_t adc1_step = 0;
;;;168    
;;;169    	adc1_step++;
000002  4915              LDR      r1,|L3.88|
000004  7848              LDRB     r0,[r1,#1]  ; adc1_step
000006  1c40              ADDS     r0,r0,#1
000008  b2c0              UXTB     r0,r0
00000a  7048              STRB     r0,[r1,#1]
;;;170    	
;;;171    	if(adc1_step > 4) adc1_step = 0;
00000c  2804              CMP      r0,#4
00000e  d901              BLS      |L3.20|
000010  2000              MOVS     r0,#0
000012  7048              STRB     r0,[r1,#1]
                  |L3.20|
;;;172    
;;;173    	switch(adc1_step)
000014  0601              LSLS     r1,r0,#24
;;;174    	{
;;;175    		case 0:
;;;176    			
;;;177                ADC_Open(ADC, ADC_ADCR_DIFFEN_SINGLE_END, ADC_ADCR_ADMD_SINGLE, BIT15);
000016  4811              LDR      r0,|L3.92|
;;;178    
;;;179    			ADC_START_CONV(ADC);
000018  4c11              LDR      r4,|L3.96|
00001a  4d12              LDR      r5,|L3.100|
00001c  0e09              LSRS     r1,r1,#24             ;173
00001e  d00b              BEQ      |L3.56|
000020  2901              CMP      r1,#1                 ;173
000022  d00c              BEQ      |L3.62|
000024  2902              CMP      r1,#2                 ;173
000026  d00c              BEQ      |L3.66|
000028  2903              CMP      r1,#3                 ;173
00002a  d104              BNE      |L3.54|
;;;180    
;;;181    		break;
;;;182    
;;;183    		case 1:
;;;184    
;;;185    		i32ConversionData = ADC_GET_CONVERSION_DATA(ADC, 15);
;;;186    		
;;;187    		printf("CHAN15 VALUE: %d\n", i32ConversionData);
;;;188    
;;;189    		break;
;;;190    
;;;191    
;;;192    		case 2:
;;;193    
;;;194    		ADC_Open(ADC, ADC_ADCR_DIFFEN_SINGLE_END, ADC_ADCR_ADMD_SINGLE, BIT14);
;;;195    		ADC_START_CONV(ADC);
;;;196    		break;
;;;197    
;;;198    	    case 3:
;;;199    
;;;200    		i32ConversionData = ADC_GET_CONVERSION_DATA(ADC, 14);
00002c  6b80              LDR      r0,[r0,#0x38]
                  |L3.46|
00002e  b281              UXTH     r1,r0
;;;201    		
;;;202    		printf("CHAN15 VALUE: %d\n", i32ConversionData);
000030  a00d              ADR      r0,|L3.104|
000032  f7fffffe          BL       __2printf
                  |L3.54|
;;;203    		
;;;204    		break;
;;;205    
;;;206    		default:break;
;;;207    	
;;;208    	}
;;;209    	
;;;210    }
000036  bd70              POP      {r4-r6,pc}
                  |L3.56|
000038  2301              MOVS     r3,#1                 ;177
00003a  03db              LSLS     r3,r3,#15             ;177
00003c  e003              B        |L3.70|
                  |L3.62|
00003e  6bc0              LDR      r0,[r0,#0x3c]         ;185
000040  e7f5              B        |L3.46|
                  |L3.66|
000042  2301              MOVS     r3,#1                 ;194
000044  039b              LSLS     r3,r3,#14             ;194
                  |L3.70|
000046  2200              MOVS     r2,#0                 ;194
000048  4611              MOV      r1,r2                 ;194
00004a  f7fffffe          BL       ADC_Open
00004e  6820              LDR      r0,[r4,#0]            ;195
000050  4328              ORRS     r0,r0,r5              ;195
000052  6020              STR      r0,[r4,#0]            ;195
000054  bd70              POP      {r4-r6,pc}
;;;211    
                          ENDP

000056  0000              DCW      0x0000
                  |L3.88|
                          DCD      ||.data||
                  |L3.92|
                          DCD      0x400e0000
                  |L3.96|
                          DCD      0x400e0080
                  |L3.100|
                          DCD      0x00000800
                  |L3.104|
000068  4348414e          DCB      "CHAN15 VALUE: %d\n",0
00006c  31352056
000070  414c5545
000074  3a202564
000078  0a00    
00007a  00                DCB      0
00007b  00                DCB      0

                          AREA ||i.bat_value_get||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  bat_value_get PROC
;;;215    
;;;216    void bat_value_get(uint32_t dat)
000000  b570              PUSH     {r4-r6,lr}
;;;217    {
;;;218    	static uint8_t index = 0;
;;;219    	static uint8_t flag = 0;
;;;220    	uint32_t num = 0;
;;;221    	uint8_t temp = 0;
;;;222    	uint8_t current_step = 0;
;;;223    	uint8_t prev_step = 0;
;;;224    
;;;225    	prev_step = Global_datas.PowerState.battery_level;
;;;226    	index++;
000002  4d1c              LDR      r5,|L4.116|
000004  2200              MOVS     r2,#0                 ;220
000006  78ab              LDRB     r3,[r5,#2]  ; index
000008  4c19              LDR      r4,|L4.112|
00000a  1c5b              ADDS     r3,r3,#1
00000c  b2db              UXTB     r3,r3
00000e  4611              MOV      r1,r2                 ;221
000010  70ab              STRB     r3,[r5,#2]
;;;227    	
;;;228    	if(index > 8) 
000012  2b08              CMP      r3,#8
000014  d903              BLS      |L4.30|
;;;229    	{
;;;230    		index = 0;
000016  2300              MOVS     r3,#0
000018  70ab              STRB     r3,[r5,#2]
;;;231    		flag = 1;
00001a  2301              MOVS     r3,#1
00001c  70eb              STRB     r3,[r5,#3]
                  |L4.30|
;;;232    	}
;;;233    	bat_buf[index] = dat;
00001e  78ab              LDRB     r3,[r5,#2]  ; index
000020  009e              LSLS     r6,r3,#2
000022  4b15              LDR      r3,|L4.120|
000024  5198              STR      r0,[r3,r6]
;;;234    
;;;235    	if(flag)
000026  78e8              LDRB     r0,[r5,#3]  ; flag
000028  2800              CMP      r0,#0
00002a  d01f              BEQ      |L4.108|
                  |L4.44|
;;;236    	{
;;;237    		for(temp = 0; temp < 8; temp++)
;;;238    		{
;;;239    			num += bat_buf[temp];
00002c  0088              LSLS     r0,r1,#2
00002e  5818              LDR      r0,[r3,r0]
000030  1c49              ADDS     r1,r1,#1
000032  1882              ADDS     r2,r0,r2
000034  b2c9              UXTB     r1,r1                 ;237
000036  2908              CMP      r1,#8                 ;237
000038  d3f8              BCC      |L4.44|
;;;240    		}
;;;241    
;;;242    		num  = num >> 3;
00003a  08d1              LSRS     r1,r2,#3
;;;243    
;;;244    		for(current_step = 0; current_step < 11; current_step++)
;;;245    		{
;;;246    			if(num < batlevel_table[current_step]) 
00003c  4a0d              LDR      r2,|L4.116|
00003e  2000              MOVS     r0,#0                 ;244
000040  320c              ADDS     r2,r2,#0xc
                  |L4.66|
000042  0083              LSLS     r3,r0,#2
000044  58d3              LDR      r3,[r2,r3]
000046  428b              CMP      r3,r1
000048  d803              BHI      |L4.82|
00004a  1c40              ADDS     r0,r0,#1
00004c  b2c0              UXTB     r0,r0                 ;244
00004e  280b              CMP      r0,#0xb               ;244
000050  d3f7              BCC      |L4.66|
                  |L4.82|
;;;247    			{
;;;248    			   // Global_datas.PowerState.battery_level = current_step;
;;;249    				break;
;;;250    			}
;;;251    		}
;;;252    
;;;253    		if(current_step > 0) current_step = current_step -1;
000052  2800              CMP      r0,#0
000054  d001              BEQ      |L4.90|
000056  1e40              SUBS     r0,r0,#1
000058  b2c0              UXTB     r0,r0
                  |L4.90|
;;;254    
;;;255    		Global_datas.PowerState.battery_level = current_step;
00005a  7420              STRB     r0,[r4,#0x10]
;;;256    		Global_datas.PowerState.battery_data = num;
;;;257    		
;;;258    
;;;259    	//	if(((current_step  == (prev_step + 1)) && (num < batlevel_table[prev_step] + 20)) || ((temp  == (Global_datas.PowerState.battery_level - 1)) && (num > batlevel_table[temp] - 20)))
;;;260    	//	{
;;;261    	//			current_step = prev_step;
;;;262    	//	}
;;;263    
;;;264    		printf("sample_bat_data: %d\n", Global_datas.PowerState.battery_data);
00005c  a007              ADR      r0,|L4.124|
00005e  60a1              STR      r1,[r4,#8]  ; Global_datas
000060  f7fffffe          BL       __2printf
;;;265    		printf("sample_batlevel: %d\n", Global_datas.PowerState.battery_level);
000064  7c21              LDRB     r1,[r4,#0x10]  ; Global_datas
000066  a00b              ADR      r0,|L4.148|
000068  f7fffffe          BL       __2printf
                  |L4.108|
;;;266    		
;;;267    	}
;;;268    
;;;269    }
00006c  bd70              POP      {r4-r6,pc}
;;;270    
                          ENDP

00006e  0000              DCW      0x0000
                  |L4.112|
                          DCD      Global_datas+0x80
                  |L4.116|
                          DCD      ||.data||
                  |L4.120|
                          DCD      ||.bss||
                  |L4.124|
00007c  73616d70          DCB      "sample_bat_data: %d\n",0
000080  6c655f62
000084  61745f64
000088  6174613a
00008c  2025640a
000090  00      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0
                  |L4.148|
000094  73616d70          DCB      "sample_batlevel: %d\n",0
000098  6c655f62
00009c  61746c65
0000a0  76656c3a
0000a4  2025640a
0000a8  00      
0000a9  00                DCB      0
0000aa  00                DCB      0
0000ab  00                DCB      0

                          AREA ||i.hal_adc_init||, CODE, READONLY, ALIGN=2

                  hal_adc_init PROC
;;;43     
;;;44     void hal_adc_init(void)    // PB6 -> ADC CH6; PB7 -> ADC CH7;
000000  b510              PUSH     {r4,lr}
;;;45     {
;;;46         /* Enable ADC module clock */
;;;47         CLK_EnableModuleClock(ADC_MODULE);		
000002  4c17              LDR      r4,|L5.96|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;48     	
;;;49     		//  /* ADC clock source is PCLK1, set divider to 1 */
;;;50         //   CLK_SetModuleClock(ADC_MODULE, CLK_CLKSEL2_ADCSEL_PCLK1, CLK_CLKDIV0_ADC(1));
;;;51     
;;;52       
;;;53         /* ADC clock source is 22.1184MHz, set divider to 7, ADC clock is 22.1184/7 MHz */
;;;54         CLK_SetModuleClock(ADC_MODULE, CLK_CLKSEL1_ADCSEL_HIRC, CLK_CLKDIV0_ADC(7));
00000a  2203              MOVS     r2,#3
00000c  0452              LSLS     r2,r2,#17
00000e  210c              MOVS     r1,#0xc
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       CLK_SetModuleClock
;;;55     
;;;56         /* Set PB.2 - PB.3 to input mode */
;;;57         GPIO_SetMode(PB, BIT6, GPIO_MODE_INPUT);
000016  4c13              LDR      r4,|L5.100|
000018  2200              MOVS     r2,#0
00001a  2140              MOVS     r1,#0x40
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       GPIO_SetMode
;;;58         GPIO_SetMode(PB, BIT7, GPIO_MODE_INPUT);
000022  2200              MOVS     r2,#0
000024  2180              MOVS     r1,#0x80
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       GPIO_SetMode
;;;59     
;;;60     	/* Configure the GPB6-,GPB7 ADC analog input pins */
;;;61         SYS->GPB_MFPL &= ~(SYS_GPB_MFPL_PB6MFP_Msk | SYS_GPB_MFPL_PB7MFP_Msk);
00002c  2005              MOVS     r0,#5
00002e  0700              LSLS     r0,r0,#28
000030  6b81              LDR      r1,[r0,#0x38]
000032  0209              LSLS     r1,r1,#8
000034  0a09              LSRS     r1,r1,#8
000036  6381              STR      r1,[r0,#0x38]
;;;62         SYS->GPB_MFPL |= SYS_GPB_MFPL_PB6MFP_ADC0_CH14 | SYS_GPB_MFPL_PB7MFP_ADC0_CH15 ;
000038  6b81              LDR      r1,[r0,#0x38]
00003a  2211              MOVS     r2,#0x11
00003c  0612              LSLS     r2,r2,#24
00003e  4311              ORRS     r1,r1,r2
000040  6381              STR      r1,[r0,#0x38]
;;;63     	
;;;64         /* Disable the PB.6 - PB.7 digital input path to avoid the leakage current. */
;;;65         GPIO_DISABLE_DIGITAL_PATH(PB, BIT6);	
000042  6860              LDR      r0,[r4,#4]
000044  2101              MOVS     r1,#1
000046  0589              LSLS     r1,r1,#22
000048  4308              ORRS     r0,r0,r1
00004a  6060              STR      r0,[r4,#4]
;;;66         GPIO_DISABLE_DIGITAL_PATH(PB, BIT7);	
00004c  6860              LDR      r0,[r4,#4]
00004e  0049              LSLS     r1,r1,#1
000050  4308              ORRS     r0,r0,r1
000052  6060              STR      r0,[r4,#4]
;;;67     	
;;;68     	ADC_POWER_ON(ADC);
000054  4804              LDR      r0,|L5.104|
000056  6801              LDR      r1,[r0,#0]
000058  2201              MOVS     r2,#1
00005a  4311              ORRS     r1,r1,r2
00005c  6001              STR      r1,[r0,#0]
;;;69     }
00005e  bd10              POP      {r4,pc}
;;;70     
                          ENDP

                  |L5.96|
                          DCD      0x5623fe1c
                  |L5.100|
                          DCD      0x50004040
                  |L5.104|
                          DCD      0x400e0080

                          AREA ||i.ntc_value_get||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  ntc_value_get PROC
;;;271    
;;;272    void ntc_value_get(uint32_t dat)
000000  b570              PUSH     {r4-r6,lr}
;;;273    {
;;;274    	static uint8_t index_ntc = 0;
;;;275    	static uint8_t flag_ntc = 0;
;;;276    	uint32_t num_ntc = 0;
;;;277    	uint8_t temp_ntc = 0;
;;;278    
;;;279    	index_ntc++;
000002  4c11              LDR      r4,|L6.72|
000004  2200              MOVS     r2,#0                 ;276
000006  7923              LDRB     r3,[r4,#4]  ; index_ntc
000008  4611              MOV      r1,r2                 ;277
00000a  1c5b              ADDS     r3,r3,#1
00000c  b2db              UXTB     r3,r3
00000e  7123              STRB     r3,[r4,#4]
;;;280    	if(index_ntc > 8) 
000010  2b08              CMP      r3,#8
000012  d903              BLS      |L6.28|
;;;281    	{
;;;282    		index_ntc = 0;
000014  2300              MOVS     r3,#0
000016  7123              STRB     r3,[r4,#4]
;;;283    		flag_ntc = 1;
000018  2301              MOVS     r3,#1
00001a  7163              STRB     r3,[r4,#5]
                  |L6.28|
;;;284    	}
;;;285    	ntc_buf[index_ntc] = dat;
00001c  7923              LDRB     r3,[r4,#4]  ; index_ntc
00001e  009d              LSLS     r5,r3,#2
000020  4b0a              LDR      r3,|L6.76|
000022  5158              STR      r0,[r3,r5]
;;;286    
;;;287    	if(flag_ntc)
000024  7960              LDRB     r0,[r4,#5]  ; flag_ntc
000026  2800              CMP      r0,#0
000028  d00d              BEQ      |L6.70|
                  |L6.42|
;;;288    	{
;;;289    		for(temp_ntc = 0; temp_ntc < 8; temp_ntc++)
;;;290    		{
;;;291    			num_ntc += ntc_buf[temp_ntc];
00002a  0088              LSLS     r0,r1,#2
00002c  5818              LDR      r0,[r3,r0]
00002e  1c49              ADDS     r1,r1,#1
000030  1882              ADDS     r2,r0,r2
000032  b2c9              UXTB     r1,r1                 ;289
000034  2908              CMP      r1,#8                 ;289
000036  d3f8              BCC      |L6.42|
;;;292    		}
;;;293    
;;;294    		num_ntc  = num_ntc >> 3;
000038  08d4              LSRS     r4,r2,#3
;;;295    
;;;296    		printf("sample_ntclevel: %d\n", num_ntc);
00003a  4621              MOV      r1,r4
00003c  a004              ADR      r0,|L6.80|
00003e  f7fffffe          BL       __2printf
;;;297    		Global_datas.PowerState.ntc_data = num_ntc;
000042  4809              LDR      r0,|L6.104|
000044  60c4              STR      r4,[r0,#0xc]  ; Global_datas
                  |L6.70|
;;;298    		
;;;299    	}
;;;300    
;;;301    }
000046  bd70              POP      {r4-r6,pc}
;;;302    
                          ENDP

                  |L6.72|
                          DCD      ||.data||
                  |L6.76|
                          DCD      ||.bss||+0x40
                  |L6.80|
000050  73616d70          DCB      "sample_ntclevel: %d\n",0
000054  6c655f6e
000058  74636c65
00005c  76656c3a
000060  2025640a
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0
                  |L6.104|
                          DCD      Global_datas+0x80

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  bat_buf
                          %        64
                  ntc_buf
                          %        64

                          AREA ||.data||, DATA, ALIGN=2

                  u8Option
000000  00                DCB      0x00
                  adc1_step
000001  00                DCB      0x00
                  index
000002  00                DCB      0x00
                  flag
000003  00                DCB      0x00
                  index_ntc
000004  00                DCB      0x00
                  flag_ntc
000005  000000            DCB      0x00,0x00,0x00
                  g_u32AdcIntFlag
                          DCD      0x00000000
                  batlevel_table
                          DCD      0x0000071e
                          DCD      0x00000784
                          DCD      0x00000804
                          DCD      0x00000848
                          DCD      0x00000894
                          DCD      0x000008ab
                          DCD      0x000008ec
                          DCD      0x00000923
                          DCD      0x00000966
                          DCD      0x00000999
                          DCD      0x00000a05

                          AREA ||area_number.11||, DATA, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.data||
                  MicValueTable
                          DCD      0x0000003c
                          %        60

;*** Start embedded assembler ***

#line 1 "..\\src\\driver\\hal_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_hal_adc_c_5a377792____REV16|
#line 388 "..\\lib\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_hal_adc_c_5a377792____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_hal_adc_c_5a377792____REVSH|
#line 402
|__asm___9_hal_adc_c_5a377792____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
